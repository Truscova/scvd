{
  "doc_id": "trailofbits_2025-01-bacon-labs-bunniv2-securityreview",
  "source_pdf": "2025-01-bacon-labs-bunniv2-securityreview.pdf",
  "source_mtime": "2025-11-01T12:04:44+00:00",
  "extracted_at": "2025-11-19T09:10:03.614383+00:00",
  "extractor_version": "poc-0.4",
  "repositories": [
    {
      "url": "https://github.com/timeless-fi/bunni-v2",
      "org": "timeless-fi",
      "repo": "bunni-v2",
      "commit": null,
      "evidence": {
        "page": 8,
        "snippet": "Repository <https://github.com/timeless-fi/bunni-v2>"
      }
    },
    {
      "url": "https://github.com/Bunniapp/biddog",
      "org": "Bunniapp",
      "repo": "biddog",
      "commit": null,
      "evidence": {
        "page": 8,
        "snippet": "Repository <https://github.com/Bunniapp/biddog>"
      }
    },
    {
      "url": "https://github.com/Uniswap/v4-periphery",
      "org": "Uniswap",
      "repo": "v4-periphery",
      "commit": null,
      "evidence": {
        "page": 9,
        "snippet": "- **Oracle.** We reviewed the Oracle implementation against the Uniswap v3 implementation and against the [proposed](https://blog.uniswap.org/uniswap-v4-truncated-oracle-hook) truncated oracle [implem..."
      }
    },
    {
      "url": "https://github.com/timeless-fi/bunni-v2",
      "org": "timeless-fi",
      "repo": "bunni-v2",
      "commit": "7faae4718eecda1b33dc3abd894431ed2d16c929",
      "evidence": {
        "page": 22,
        "snippet": "*Figure 1.1: The permit function ([src/base/ERC20.sol#L291–L355](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/base/ERC20.sol#L291-L355))*"
      }
    },
    {
      "url": "https://github.com/Bunniapp/biddog",
      "org": "Bunniapp",
      "repo": "biddog",
      "commit": "95f4270ad4447e96044973580afda9176730e7c8",
      "evidence": {
        "page": 25,
        "snippet": "*Figure 3.1: A snippet of the withdrawNextBid function ([src/AmAmm.sol#L273–L276](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L273-L276))*"
      }
    },
    {
      "url": "https://github.com/Uniswap/v4-core",
      "org": "Uniswap",
      "repo": "v4-core",
      "commit": "9293e5ab1deed87e03c176d8af94b1af19eb3900",
      "evidence": {
        "page": 30,
        "snippet": "*Figure 5.2: The body of the getSqrtPriceTarget function in the Uniswap v4 SwapMath contract, showing the high bits of the values being cleared before being used ([src/libraries/SwapMath.sol#L20–L37](..."
      }
    },
    {
      "url": "https://github.com/flood-protocol/flood-contracts",
      "org": "flood-protocol",
      "repo": "flood-contracts",
      "commit": "c9891965b29f8e32ed00d9b98356a0833f806e18",
      "evidence": {
        "page": 31,
        "snippet": "*Figure 6.1: One of the fulfillOrder functions ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/..."
      }
    },
    {
      "url": "https://github.com/crytic/slither",
      "org": "crytic",
      "repo": "slither",
      "commit": null,
      "evidence": {
        "page": 49,
        "snippet": "Long term, use the Slither static [analyzer](https://github.com/crytic/slither) to catch common issues such as this one. Consider integrating a Slither scan into the project's CI pipeline, pre-commit ..."
      }
    },
    {
      "url": "https://github.com/crytic/medusa",
      "org": "crytic",
      "repo": "medusa",
      "commit": null,
      "evidence": {
        "page": 71,
        "snippet": "We used [Medusa,](https://github.com/crytic/medusa) maintained by Trail of Bits. Medusa is used in conjunction with a test harness: a special contract that sits in front of the system under test and i..."
      }
    },
    {
      "url": "https://github.com/timeless-fi/bunni-v2",
      "org": "timeless-fi",
      "repo": "bunni-v2",
      "commit": "fbbe3747416df15450663bda817e0eeded4cc3b5",
      "evidence": {
        "page": 86,
        "snippet": "Resolved in PR [#66](https://github.com/timeless-fi/bunni-v2/pull/66), [PR](https://github.com/Bunniapp/biddog/pull/3) #3, PR [#75](https://github.com/timeless-fi/bunni-v2/pull/75), and commit [fbbe37..."
      }
    },
    {
      "url": "https://github.com/Uniswap/v4-core",
      "org": "Uniswap",
      "repo": "v4-core",
      "commit": "c8173143cf1e6f1c6c7b682a3563b263f149255f",
      "evidence": {
        "page": 86,
        "snippet": "Resolved in PR [#69](https://github.com/timeless-fi/bunni-v2/pull/69). The SwapMath and SqrtPriceMath library contracts have been updated to use a more recent version of these libraries, taken from Un..."
      }
    },
    {
      "url": "https://github.com/timeless-fi/bunni-v2",
      "org": "timeless-fi",
      "repo": "bunni-v2",
      "commit": "f3e8a381932647f445149399fbf8cea69b6edfd0",
      "evidence": {
        "page": 88,
        "snippet": "Undetermined in PR [#81,](https://github.com/timeless-fi/bunni-v2/pull/81) PR [#76,](https://github.com/timeless-fi/bunni-v2/pull/76) and PR [#82.](https://github.com/timeless-fi/bunni-v2/pull/82) The..."
      }
    },
    {
      "url": "https://github.com/trailofbits/publications",
      "org": "trailofbits",
      "repo": "publications",
      "commit": null,
      "evidence": {
        "page": 91,
        "snippet": "We maintain an exhaustive list of publications at [https://github.com/trailofbits/publications,](https://github.com/trailofbits/publications) with links to papers, presentations, public audit reports,..."
      }
    }
  ],
  "report_schema": [
    {
      "key": "Severity",
      "meaning": "How serious the impact of this finding is.",
      "expected_values": "Informational / Low / Medium / High"
    },
    {
      "key": "Difficulty",
      "meaning": "How hard it is to exploit this issue.",
      "expected_values": "Low / Medium / High"
    },
    {
      "key": "Type",
      "meaning": "The category or type of security finding.",
      "expected_values": "Access Controls / Data Validation / Logic Error"
    },
    {
      "key": "Finding ID",
      "meaning": "A unique identifier for the specific finding within the report.",
      "expected_values": "String describing a unique identifier"
    },
    {
      "key": "Target",
      "meaning": "The part of the contract or codebase where the issue is located.",
      "expected_values": "Path to affected file / contract"
    }
  ],
  "vulnerability_sections": [
    {
      "index": 1,
      "page_start": 21,
      "heading": "1. BunniToken permit cannot be revoked Severity: **Informational** Difficulty: **Medium** Type: Access Controls Finding ID: TOB-BUNNI-1 Target: src/BunniToken.sol",
      "markdown": "# 1. BunniToken permit cannot be revoked Severity: **Informational** Difficulty: **Medium** Type: Access Controls Finding ID: TOB-BUNNI-1 Target: src/BunniToken.sol\n\n#### Description\n\nThe BunniToken contract does not implement a way for permit signatures to be revoked, resulting in these signatures being valid until the deadline.\n\nThe BunniToken contract inherits the permit function from the ERC20 contract, allowing users to sign a payload in order to allow another user or contract to spend their tokens.\n\n```\nfunction permit(address owner, address spender, uint256 value, uint256 deadline,\nuint8 v, bytes32 r, bytes32 s)\n public\n virtual\n{\n bytes32 nameHash = _constantNameHash();\n // We simply calculate it on-the-fly to allow for cases where the `name` may\nchange.\n if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n /// @solidity memory-safe-assembly\n assembly {\n // Revert if the block timestamp is greater than `deadline`.\n if gt(timestamp(), deadline) {\n mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n revert(0x1c, 0x04)\n }\n let m := mload(0x40) // Grab the free memory pointer.\n // Clean the upper 96 bits.\n owner := shr(96, shl(96, owner))\n spender := shr(96, shl(96, spender))\n // Compute the nonce slot and load its value.\n mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n mstore(0x00, owner)\n let nonceSlot := keccak256(0x0c, 0x20)\n let nonceValue := sload(nonceSlot)\n // Prepare the domain separator.\n mstore(m, _DOMAIN_TYPEHASH)\n mstore(add(m, 0x20), nameHash)\n mstore(add(m, 0x40), _VERSION_HASH)\n```\n\n\n```\n mstore(add(m, 0x60), chainid())\n mstore(add(m, 0x80), address())\n mstore(0x2e, keccak256(m, 0xa0))\n // Prepare the struct hash.\n mstore(m, _PERMIT_TYPEHASH)\n mstore(add(m, 0x20), owner)\n mstore(add(m, 0x40), spender)\n mstore(add(m, 0x60), value)\n mstore(add(m, 0x80), nonceValue)\n mstore(add(m, 0xa0), deadline)\n mstore(0x4e, keccak256(m, 0xc0))\n // Prepare the ecrecover calldata.\n mstore(0x00, keccak256(0x2c, 0x42))\n mstore(0x20, and(0xff, v))\n mstore(0x40, r)\n mstore(0x60, s)\n let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n // If the ecrecover fails, the returndatasize will be 0x00,\n // `owner` will be checked if it equals the hash at 0x00,\n // which evaluates to false (i.e. 0), and we will revert.\n // If the ecrecover succeeds, the returndatasize will be 0x20,\n // `owner` will be compared against the returned address at 0x20.\n if iszero(eq(mload(returndatasize()), owner)) {\n mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n revert(0x1c, 0x04)\n }\n // Increment and store the updated nonce.\n sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n // Compute the allowance slot and store the value.\n // The `owner` is already at slot 0x20.\n mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n sstore(keccak256(0x2c, 0x34), value)\n // Emit the {Approval} event.\n log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n mstore(0x40, m) // Restore the free memory pointer.\n mstore(0x60, 0) // Restore the zero pointer.\n }\n}\n```\n\n*Figure 1.1: The permit function ([src/base/ERC20.sol#L291–L355](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/base/ERC20.sol#L291-L355))*\n\nHowever, once a user signs a payload and sends it to another user, they have no way of revoking this signature. Since only one nonce is valid until it is consumed, this would prevent the original user from submitting permit signatures with a different nonce. They could still generate a new signature using the same nonce; however, the user with whom they shared the original signature could execute their transaction first in order to prevent it from being invalidated.\n\n## Recommendations\n\nAdd an external function that allows msg.sender to increase their nonce in order to invalidate an already signed payload.\n",
      "finding_id": null,
      "markdown_raw": "# <span id=\"page-21-1\"></span>1. BunniToken permit cannot be revoked Severity: **Informational** Difficulty: **Medium** Type: Access Controls Finding ID: TOB-BUNNI-1 Target: src/BunniToken.sol\n\n#### Description\n\nThe BunniToken contract does not implement a way for permit signatures to be revoked, resulting in these signatures being valid until the deadline.\n\nThe BunniToken contract inherits the permit function from the ERC20 contract, allowing users to sign a payload in order to allow another user or contract to spend their tokens.\n\n```\nfunction permit(address owner, address spender, uint256 value, uint256 deadline,\nuint8 v, bytes32 r, bytes32 s)\n public\n virtual\n{\n bytes32 nameHash = _constantNameHash();\n // We simply calculate it on-the-fly to allow for cases where the `name` may\nchange.\n if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n /// @solidity memory-safe-assembly\n assembly {\n // Revert if the block timestamp is greater than `deadline`.\n if gt(timestamp(), deadline) {\n mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n revert(0x1c, 0x04)\n }\n let m := mload(0x40) // Grab the free memory pointer.\n // Clean the upper 96 bits.\n owner := shr(96, shl(96, owner))\n spender := shr(96, shl(96, spender))\n // Compute the nonce slot and load its value.\n mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n mstore(0x00, owner)\n let nonceSlot := keccak256(0x0c, 0x20)\n let nonceValue := sload(nonceSlot)\n // Prepare the domain separator.\n mstore(m, _DOMAIN_TYPEHASH)\n mstore(add(m, 0x20), nameHash)\n mstore(add(m, 0x40), _VERSION_HASH)\n```\n\n{22}------------------------------------------------\n\n```\n mstore(add(m, 0x60), chainid())\n mstore(add(m, 0x80), address())\n mstore(0x2e, keccak256(m, 0xa0))\n // Prepare the struct hash.\n mstore(m, _PERMIT_TYPEHASH)\n mstore(add(m, 0x20), owner)\n mstore(add(m, 0x40), spender)\n mstore(add(m, 0x60), value)\n mstore(add(m, 0x80), nonceValue)\n mstore(add(m, 0xa0), deadline)\n mstore(0x4e, keccak256(m, 0xc0))\n // Prepare the ecrecover calldata.\n mstore(0x00, keccak256(0x2c, 0x42))\n mstore(0x20, and(0xff, v))\n mstore(0x40, r)\n mstore(0x60, s)\n let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n // If the ecrecover fails, the returndatasize will be 0x00,\n // `owner` will be checked if it equals the hash at 0x00,\n // which evaluates to false (i.e. 0), and we will revert.\n // If the ecrecover succeeds, the returndatasize will be 0x20,\n // `owner` will be compared against the returned address at 0x20.\n if iszero(eq(mload(returndatasize()), owner)) {\n mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n revert(0x1c, 0x04)\n }\n // Increment and store the updated nonce.\n sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n // Compute the allowance slot and store the value.\n // The `owner` is already at slot 0x20.\n mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n sstore(keccak256(0x2c, 0x34), value)\n // Emit the {Approval} event.\n log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n mstore(0x40, m) // Restore the free memory pointer.\n mstore(0x60, 0) // Restore the zero pointer.\n }\n}\n```\n\n*Figure 1.1: The permit function ([src/base/ERC20.sol#L291–L355](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/base/ERC20.sol#L291-L355))*\n\nHowever, once a user signs a payload and sends it to another user, they have no way of revoking this signature. Since only one nonce is valid until it is consumed, this would prevent the original user from submitting permit signatures with a different nonce. They could still generate a new signature using the same nonce; however, the user with whom they shared the original signature could execute their transaction first in order to prevent it from being invalidated.\n\n## Recommendations\n\nAdd an external function that allows msg.sender to increase their nonce in order to invalidate an already signed payload.\n\n![](_page_22_Picture_5.jpeg)\n\n{23}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe BunniToken contract does not implement a way for permit signatures to be revoked, resulting in these signatures being valid until the deadline.\n\nThe BunniToken contract inherits the permit function from the ERC20 contract, allowing users to sign a payload in order to allow another user or contract to spend their tokens.\n\n```\nfunction permit(address owner, address spender, uint256 value, uint256 deadline,\nuint8 v, bytes32 r, bytes32 s)\n public\n virtual\n{\n bytes32 nameHash = _constantNameHash();\n // We simply calculate it on-the-fly to allow for cases where the `name` may\nchange.\n if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n /// @solidity memory-safe-assembly\n assembly {\n // Revert if the block timestamp is greater than `deadline`.\n if gt(timestamp(), deadline) {\n mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n revert(0x1c, 0x04)\n }\n let m := mload(0x40) // Grab the free memory pointer.\n // Clean the upper 96 bits.\n owner := shr(96, shl(96, owner))\n spender := shr(96, shl(96, spender))\n // Compute the nonce slot and load its value.\n mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n mstore(0x00, owner)\n let nonceSlot := keccak256(0x0c, 0x20)\n let nonceValue := sload(nonceSlot)\n // Prepare the domain separator.\n mstore(m, _DOMAIN_TYPEHASH)\n mstore(add(m, 0x20), nameHash)\n mstore(add(m, 0x40), _VERSION_HASH)\n```\n\n\n```\n mstore(add(m, 0x60), chainid())\n mstore(add(m, 0x80), address())\n mstore(0x2e, keccak256(m, 0xa0))\n // Prepare the struct hash.\n mstore(m, _PERMIT_TYPEHASH)\n mstore(add(m, 0x20), owner)\n mstore(add(m, 0x40), spender)\n mstore(add(m, 0x60), value)\n mstore(add(m, 0x80), nonceValue)\n mstore(add(m, 0xa0), deadline)\n mstore(0x4e, keccak256(m, 0xc0))\n // Prepare the ecrecover calldata.\n mstore(0x00, keccak256(0x2c, 0x42))\n mstore(0x20, and(0xff, v))\n mstore(0x40, r)\n mstore(0x60, s)\n let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n // If the ecrecover fails, the returndatasize will be 0x00,\n // `owner` will be checked if it equals the hash at 0x00,\n // which evaluates to false (i.e. 0), and we will revert.\n // If the ecrecover succeeds, the returndatasize will be 0x20,\n // `owner` will be compared against the returned address at 0x20.\n if iszero(eq(mload(returndatasize()), owner)) {\n mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n revert(0x1c, 0x04)\n }\n // Increment and store the updated nonce.\n sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n // Compute the allowance slot and store the value.\n // The `owner` is already at slot 0x20.\n mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n sstore(keccak256(0x2c, 0x34), value)\n // Emit the {Approval} event.\n log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n mstore(0x40, m) // Restore the free memory pointer.\n mstore(0x60, 0) // Restore the zero pointer.\n }\n}\n```\n\n*Figure 1.1: The permit function ([src/base/ERC20.sol#L291–L355](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/base/ERC20.sol#L291-L355))*\n\nHowever, once a user signs a payload and sends it to another user, they have no way of revoking this signature. Since only one nonce is valid until it is consumed, this would prevent the original user from submitting permit signatures with a different nonce. They could still generate a new signature using the same nonce; however, the user with whom they shared the original signature could execute their transaction first in order to prevent it from being invalidated.\n",
        "impact": null,
        "recommendation": "## Recommendations\n\nAdd an external function that allows msg.sender to increase their nonce in order to invalidate an already signed payload.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe BunniToken contract does not implement a way for permit signatures to be revoked, resulting in these signatures being valid until the deadline.\n\nThe BunniToken contract inherits the permit function from the ERC20 contract, allowing users to sign a payload in order to allow another user or contract to spend their tokens.\n\n```\nfunction permit(address owner, address spender, uint256 value, uint256 deadline,\nuint8 v, bytes32 r, bytes32 s)\n public\n virtual\n{\n bytes32 nameHash = _constantNameHash();\n // We simply calculate it on-the-fly to allow for cases where the `name` may\nchange.\n if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n /// @solidity memory-safe-assembly\n assembly {\n // Revert if the block timestamp is greater than `deadline`.\n if gt(timestamp(), deadline) {\n mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n revert(0x1c, 0x04)\n }\n let m := mload(0x40) // Grab the free memory pointer.\n // Clean the upper 96 bits.\n owner := shr(96, shl(96, owner))\n spender := shr(96, shl(96, spender))\n // Compute the nonce slot and load its value.\n mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n mstore(0x00, owner)\n let nonceSlot := keccak256(0x0c, 0x20)\n let nonceValue := sload(nonceSlot)\n // Prepare the domain separator.\n mstore(m, _DOMAIN_TYPEHASH)\n mstore(add(m, 0x20), nameHash)\n mstore(add(m, 0x40), _VERSION_HASH)\n```\n\n\n```\n mstore(add(m, 0x60), chainid())\n mstore(add(m, 0x80), address())\n mstore(0x2e, keccak256(m, 0xa0))\n // Prepare the struct hash.\n mstore(m, _PERMIT_TYPEHASH)\n mstore(add(m, 0x20), owner)\n mstore(add(m, 0x40), spender)\n mstore(add(m, 0x60), value)\n mstore(add(m, 0x80), nonceValue)\n mstore(add(m, 0xa0), deadline)\n mstore(0x4e, keccak256(m, 0xc0))\n // Prepare the ecrecover calldata.\n mstore(0x00, keccak256(0x2c, 0x42))\n mstore(0x20, and(0xff, v))\n mstore(0x40, r)\n mstore(0x60, s)\n let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n // If the ecrecover fails, the returndatasize will be 0x00,\n // `owner` will be checked if it equals the hash at 0x00,\n // which evaluates to false (i.e. 0), and we will revert.\n // If the ecrecover succeeds, the returndatasize will be 0x20,\n // `owner` will be compared against the returned address at 0x20.\n if iszero(eq(mload(returndatasize()), owner)) {\n mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n revert(0x1c, 0x04)\n }\n // Increment and store the updated nonce.\n sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n // Compute the allowance slot and store the value.\n // The `owner` is already at slot 0x20.\n mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n sstore(keccak256(0x2c, 0x34), value)\n // Emit the {Approval} event.\n log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n mstore(0x40, m) // Restore the free memory pointer.\n mstore(0x60, 0) // Restore the zero pointer.\n }\n}\n```\n\n*Figure 1.1: The permit function ([src/base/ERC20.sol#L291–L355](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/base/ERC20.sol#L291-L355))*\n\nHowever, once a user signs a payload and sends it to another user, they have no way of revoking this signature. Since only one nonce is valid until it is consumed, this would prevent the original user from submitting permit signatures with a different nonce. They could still generate a new signature using the same nonce; however, the user with whom they shared the original signature could execute their transaction first in order to prevent it from being invalidated.\n",
      "markdown_body": "#### Description\n\nThe BunniToken contract does not implement a way for permit signatures to be revoked, resulting in these signatures being valid until the deadline.\n\nThe BunniToken contract inherits the permit function from the ERC20 contract, allowing users to sign a payload in order to allow another user or contract to spend their tokens.\n\n```\nfunction permit(address owner, address spender, uint256 value, uint256 deadline,\nuint8 v, bytes32 r, bytes32 s)\n public\n virtual\n{\n bytes32 nameHash = _constantNameHash();\n // We simply calculate it on-the-fly to allow for cases where the `name` may\nchange.\n if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n /// @solidity memory-safe-assembly\n assembly {\n // Revert if the block timestamp is greater than `deadline`.\n if gt(timestamp(), deadline) {\n mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n revert(0x1c, 0x04)\n }\n let m := mload(0x40) // Grab the free memory pointer.\n // Clean the upper 96 bits.\n owner := shr(96, shl(96, owner))\n spender := shr(96, shl(96, spender))\n // Compute the nonce slot and load its value.\n mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n mstore(0x00, owner)\n let nonceSlot := keccak256(0x0c, 0x20)\n let nonceValue := sload(nonceSlot)\n // Prepare the domain separator.\n mstore(m, _DOMAIN_TYPEHASH)\n mstore(add(m, 0x20), nameHash)\n mstore(add(m, 0x40), _VERSION_HASH)\n```\n\n\n```\n mstore(add(m, 0x60), chainid())\n mstore(add(m, 0x80), address())\n mstore(0x2e, keccak256(m, 0xa0))\n // Prepare the struct hash.\n mstore(m, _PERMIT_TYPEHASH)\n mstore(add(m, 0x20), owner)\n mstore(add(m, 0x40), spender)\n mstore(add(m, 0x60), value)\n mstore(add(m, 0x80), nonceValue)\n mstore(add(m, 0xa0), deadline)\n mstore(0x4e, keccak256(m, 0xc0))\n // Prepare the ecrecover calldata.\n mstore(0x00, keccak256(0x2c, 0x42))\n mstore(0x20, and(0xff, v))\n mstore(0x40, r)\n mstore(0x60, s)\n let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n // If the ecrecover fails, the returndatasize will be 0x00,\n // `owner` will be checked if it equals the hash at 0x00,\n // which evaluates to false (i.e. 0), and we will revert.\n // If the ecrecover succeeds, the returndatasize will be 0x20,\n // `owner` will be compared against the returned address at 0x20.\n if iszero(eq(mload(returndatasize()), owner)) {\n mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n revert(0x1c, 0x04)\n }\n // Increment and store the updated nonce.\n sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n // Compute the allowance slot and store the value.\n // The `owner` is already at slot 0x20.\n mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n sstore(keccak256(0x2c, 0x34), value)\n // Emit the {Approval} event.\n log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n mstore(0x40, m) // Restore the free memory pointer.\n mstore(0x60, 0) // Restore the zero pointer.\n }\n}\n```\n\n*Figure 1.1: The permit function ([src/base/ERC20.sol#L291–L355](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/base/ERC20.sol#L291-L355))*\n\nHowever, once a user signs a payload and sends it to another user, they have no way of revoking this signature. Since only one nonce is valid until it is consumed, this would prevent the original user from submitting permit signatures with a different nonce. They could still generate a new signature using the same nonce; however, the user with whom they shared the original signature could execute their transaction first in order to prevent it from being invalidated.\n\n## Recommendations\n\nAdd an external function that allows msg.sender to increase their nonce in order to invalidate an already signed payload.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Medium",
        "Type": "Access Controls",
        "Finding ID": "TOB-BUNNI-1",
        "Target": "src/BunniToken.sol"
      },
      "heading_cleaned": "BunniToken permit cannot be revoked"
    },
    {
      "index": 2,
      "page_start": 23,
      "heading": "2. Token approvals to ERC-4626 vaults are never revoked",
      "markdown": "# 2. Token approvals to ERC-4626 vaults are never revoked\n\n| Severity: Informational                                | Diffi culty: Medium     |\n|-----------------------------------------------------------|-------------------------------|\n| Type: Access Controls                               | Finding ID: TOB-BUNNI-2 |\n| Target: src/BunniHub.sol, src/lib/BunniHubLogic.sol |                               |\n\n#### Description\n\nThe BunniHub contract can approve an arbitrary ERC-4626 vault to handle its tokens when calling the deposit function of the vault; however, these approvals are never revoked.\n\nThe BunniHub contract can give approvals to spend a certain amount of its tokens to an ERC-4626 vault in order to deposit these tokens into the vault. For instance, this is done when updating the reserves during a liquidity deposit (figure 2.1) or when a pool does not have a sufficient amount of output tokens (figure 2.2).\n\n```\n// ...\n// do vault deposit\naddress(token).safeApproveWithRetry(address(vault), amount);\nreserveChange = vault.deposit(amount, address(this));\nreserveChangeInUnderlying = vault.previewRedeem(reserveChange);\n// ...\n```\n\n*Figure 2.1: The \\_depositVaultReserve function ([src/lib/BunniHubLogic.sol#L665–L668](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L665-L668))*\n\n```\n// ...\nfunction _updateVaultReserveViaClaimTokens(int256 rawBalanceChange, Currency\ncurrency, ERC4626 vault)\n internal\n returns (int256 reserveChange, int256 actualRawBalanceChange)\n{\n // ...\n address(token).safeApproveWithRetry(address(vault), absAmount);\n reserveChange = vault.deposit(absAmount, address(this)).toInt256();\n // ...\n```\n\n*Figure 2.2: The \\_updateVaultReserveViaClaimTokens function ([src/BunniHub.sol#L432–L433](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L432-L433))*\n\nHowever, since the vault implementation could be malicious, the deposit function is not guaranteed to perform the operation correctly and consume the token approvals. While the balance updates should prevent the tokens from being stolen, there could be a vulnerability in some other piece of the codebase that would allow this to be abused.\n\n\n#### Recommendations\n\nShort term, reset the approvals to zero after the call to the deposit function.\n\nLong term, clearly identify the trust assumptions of external components. Use these assumptions to evaluate all the asset and token interactions (transfer and approval) and their safeguards against malicious actors.\n",
      "finding_id": null,
      "markdown_raw": "# <span id=\"page-23-0\"></span>2. Token approvals to ERC-4626 vaults are never revoked\n\n| Severity:<br>Informational                                | Diffi<br>culty:<br>Medium     |\n|-----------------------------------------------------------|-------------------------------|\n| Type:<br>Access<br>Controls                               | Finding<br>ID:<br>TOB-BUNNI-2 |\n| Target:<br>src/BunniHub.sol,<br>src/lib/BunniHubLogic.sol |                               |\n\n#### Description\n\nThe BunniHub contract can approve an arbitrary ERC-4626 vault to handle its tokens when calling the deposit function of the vault; however, these approvals are never revoked.\n\nThe BunniHub contract can give approvals to spend a certain amount of its tokens to an ERC-4626 vault in order to deposit these tokens into the vault. For instance, this is done when updating the reserves during a liquidity deposit (figure 2.1) or when a pool does not have a sufficient amount of output tokens (figure 2.2).\n\n```\n// ...\n// do vault deposit\naddress(token).safeApproveWithRetry(address(vault), amount);\nreserveChange = vault.deposit(amount, address(this));\nreserveChangeInUnderlying = vault.previewRedeem(reserveChange);\n// ...\n```\n\n*Figure 2.1: The \\_depositVaultReserve function ([src/lib/BunniHubLogic.sol#L665–L668](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L665-L668))*\n\n```\n// ...\nfunction _updateVaultReserveViaClaimTokens(int256 rawBalanceChange, Currency\ncurrency, ERC4626 vault)\n internal\n returns (int256 reserveChange, int256 actualRawBalanceChange)\n{\n // ...\n address(token).safeApproveWithRetry(address(vault), absAmount);\n reserveChange = vault.deposit(absAmount, address(this)).toInt256();\n // ...\n```\n\n*Figure 2.2: The \\_updateVaultReserveViaClaimTokens function ([src/BunniHub.sol#L432–L433](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L432-L433))*\n\nHowever, since the vault implementation could be malicious, the deposit function is not guaranteed to perform the operation correctly and consume the token approvals. While the balance updates should prevent the tokens from being stolen, there could be a vulnerability in some other piece of the codebase that would allow this to be abused.\n\n{24}------------------------------------------------\n\n#### Recommendations\n\nShort term, reset the approvals to zero after the call to the deposit function.\n\nLong term, clearly identify the trust assumptions of external components. Use these assumptions to evaluate all the asset and token interactions (transfer and approval) and their safeguards against malicious actors.\n\n![](_page_24_Picture_3.jpeg)\n\n{25}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe BunniHub contract can approve an arbitrary ERC-4626 vault to handle its tokens when calling the deposit function of the vault; however, these approvals are never revoked.\n\nThe BunniHub contract can give approvals to spend a certain amount of its tokens to an ERC-4626 vault in order to deposit these tokens into the vault. For instance, this is done when updating the reserves during a liquidity deposit (figure 2.1) or when a pool does not have a sufficient amount of output tokens (figure 2.2).\n\n```\n// ...\n// do vault deposit\naddress(token).safeApproveWithRetry(address(vault), amount);\nreserveChange = vault.deposit(amount, address(this));\nreserveChangeInUnderlying = vault.previewRedeem(reserveChange);\n// ...\n```\n\n*Figure 2.1: The \\_depositVaultReserve function ([src/lib/BunniHubLogic.sol#L665–L668](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L665-L668))*\n\n```\n// ...\nfunction _updateVaultReserveViaClaimTokens(int256 rawBalanceChange, Currency\ncurrency, ERC4626 vault)\n internal\n returns (int256 reserveChange, int256 actualRawBalanceChange)\n{\n // ...\n address(token).safeApproveWithRetry(address(vault), absAmount);\n reserveChange = vault.deposit(absAmount, address(this)).toInt256();\n // ...\n```\n\n*Figure 2.2: The \\_updateVaultReserveViaClaimTokens function ([src/BunniHub.sol#L432–L433](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L432-L433))*\n\nHowever, since the vault implementation could be malicious, the deposit function is not guaranteed to perform the operation correctly and consume the token approvals. While the balance updates should prevent the tokens from being stolen, there could be a vulnerability in some other piece of the codebase that would allow this to be abused.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, reset the approvals to zero after the call to the deposit function.\n\nLong term, clearly identify the trust assumptions of external components. Use these assumptions to evaluate all the asset and token interactions (transfer and approval) and their safeguards against malicious actors.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe BunniHub contract can approve an arbitrary ERC-4626 vault to handle its tokens when calling the deposit function of the vault; however, these approvals are never revoked.\n\nThe BunniHub contract can give approvals to spend a certain amount of its tokens to an ERC-4626 vault in order to deposit these tokens into the vault. For instance, this is done when updating the reserves during a liquidity deposit (figure 2.1) or when a pool does not have a sufficient amount of output tokens (figure 2.2).\n\n```\n// ...\n// do vault deposit\naddress(token).safeApproveWithRetry(address(vault), amount);\nreserveChange = vault.deposit(amount, address(this));\nreserveChangeInUnderlying = vault.previewRedeem(reserveChange);\n// ...\n```\n\n*Figure 2.1: The \\_depositVaultReserve function ([src/lib/BunniHubLogic.sol#L665–L668](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L665-L668))*\n\n```\n// ...\nfunction _updateVaultReserveViaClaimTokens(int256 rawBalanceChange, Currency\ncurrency, ERC4626 vault)\n internal\n returns (int256 reserveChange, int256 actualRawBalanceChange)\n{\n // ...\n address(token).safeApproveWithRetry(address(vault), absAmount);\n reserveChange = vault.deposit(absAmount, address(this)).toInt256();\n // ...\n```\n\n*Figure 2.2: The \\_updateVaultReserveViaClaimTokens function ([src/BunniHub.sol#L432–L433](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L432-L433))*\n\nHowever, since the vault implementation could be malicious, the deposit function is not guaranteed to perform the operation correctly and consume the token approvals. While the balance updates should prevent the tokens from being stolen, there could be a vulnerability in some other piece of the codebase that would allow this to be abused.\n",
      "markdown_body": "| Severity: Informational                                | Diffi culty: Medium     |\n|-----------------------------------------------------------|-------------------------------|\n| Type: Access Controls                               | Finding ID: TOB-BUNNI-2 |\n| Target: src/BunniHub.sol, src/lib/BunniHubLogic.sol |                               |\n\n#### Description\n\nThe BunniHub contract can approve an arbitrary ERC-4626 vault to handle its tokens when calling the deposit function of the vault; however, these approvals are never revoked.\n\nThe BunniHub contract can give approvals to spend a certain amount of its tokens to an ERC-4626 vault in order to deposit these tokens into the vault. For instance, this is done when updating the reserves during a liquidity deposit (figure 2.1) or when a pool does not have a sufficient amount of output tokens (figure 2.2).\n\n```\n// ...\n// do vault deposit\naddress(token).safeApproveWithRetry(address(vault), amount);\nreserveChange = vault.deposit(amount, address(this));\nreserveChangeInUnderlying = vault.previewRedeem(reserveChange);\n// ...\n```\n\n*Figure 2.1: The \\_depositVaultReserve function ([src/lib/BunniHubLogic.sol#L665–L668](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L665-L668))*\n\n```\n// ...\nfunction _updateVaultReserveViaClaimTokens(int256 rawBalanceChange, Currency\ncurrency, ERC4626 vault)\n internal\n returns (int256 reserveChange, int256 actualRawBalanceChange)\n{\n // ...\n address(token).safeApproveWithRetry(address(vault), absAmount);\n reserveChange = vault.deposit(absAmount, address(this)).toInt256();\n // ...\n```\n\n*Figure 2.2: The \\_updateVaultReserveViaClaimTokens function ([src/BunniHub.sol#L432–L433](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L432-L433))*\n\nHowever, since the vault implementation could be malicious, the deposit function is not guaranteed to perform the operation correctly and consume the token approvals. While the balance updates should prevent the tokens from being stolen, there could be a vulnerability in some other piece of the codebase that would allow this to be abused.\n\n\n#### Recommendations\n\nShort term, reset the approvals to zero after the call to the deposit function.\n\nLong term, clearly identify the trust assumptions of external components. Use these assumptions to evaluate all the asset and token interactions (transfer and approval) and their safeguards against malicious actors.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Medium",
        "Type": "Access Controls",
        "Finding ID": "TOB-BUNNI-2",
        "Target": "src/BunniHub.sol, src/lib/BunniHubLogic.sol"
      },
      "heading_cleaned": "Token approvals to ERC-4626 vaults are never revoked"
    },
    {
      "index": 3,
      "page_start": 25,
      "heading": "3. Overly strict bid withdrawal validation reduces am-AMM eciency by enabling griefing",
      "markdown": "## 3. Overly strict bid withdrawal validation reduces am-AMM eciency by enabling griefing\n\n| Severity: Low            | Diffi culty: Low        |\n|-----------------------------|-------------------------------|\n| Type: Data Validation | Finding ID: TOB-BUNNI-3 |\n| Target: src/AmAmm.sol    |                               |\n\n#### Description\n\nThe AmAmm contract implements an auction mechanism that sells the rights to set and collect swap fees to the highest bidder. The proceeds of the auction are deducted over time as rent and distributed to liquidity providers in lieu of the swap fees that they have forfeited. The bidding process is defined in such a way that the top bidder and rent are determined K units of time (for Bunni v2, this is 24 hours) in advance of them taking effect.\n\nPer the written description, the next bidder should be able to withdraw their deposit as long as they leave enough deposit to cover any difference, if any, between the remaining time left on the current top bidder's deposit and 24 hours. Therefore, if the current top bidder has at least 24 hours of deposit left, the next highest bidder should be able to withdraw their full deposit. The implementation used by Bunni v2, however, requires that the next highest bidder always leaves at least 24 hours of deposit regardless of the state of the current top bidder's deposit.\n\n```\n273 // require D_next / R_next >= K\n274 if ((nextBid.deposit - amount) / nextBid.rent < K(id)) {\n275 revert AmAmm__BidLocked();\n276 }\n```\n\n*Figure 3.1: A snippet of the withdrawNextBid function ([src/AmAmm.sol#L273–L276](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L273-L276))*\n\nWhile there is a cancelNextBid function that the next highest bidder can use to cancel their pending bid, if there is currently an active top bidder, this is only available as long as the top bid's deposit can still cover at least 24 hours.\n\n```\n319 // require D_top / R_top >= K\n320 if (topBid.manager != address(0) && topBid.deposit / topBid.rent < K(id)) {\n321 revert AmAmm__BidLocked();\n322 }\n323\n324 // delete next bid from storage\n325 delete _nextBids[id];\n```\n\n*Figure 3.2: A snippet of the cancelNextBid function ([src/AmAmm.sol#L319–L325](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L319-L325))*\n\n\n\nThis difference in behavior introduces more risk to bidders who wish to act as the fee manager but do not wish to exceed the current top bidder, as some portion of their funds may remain locked in the contract until the current top bidder exhausts their deposit completely or they are outbid by somebody else. This may also unintentionally incentivize top bidders to extend their reign longer than strictly economically necessary in order to spite competitors and also incentivize bidders to wait until there is no active top bidder to begin submitting bids, creating more gaps where the pool falls back to the default swap fee mechanism that may expose LPs to more arbitrage opportunities and reduce their overall earnings.\n\n#### Exploit Scenario\n\nAlice is the current swap fee manager, pays 10 BunniToken in rent per epoch, and has 40 tokens deposited. Bob notices that Alice only has a small deposit remaining and submits a bid at eight tokens per epoch and includes a 192-token deposit. Alice also notices her deposit was running low and deposits tokens to top up her deposit to 23 hours total. Alice can repeat this top up every day. Bob cannot recover any of his 192 tokens until Alice's deposit is exhausted or someone outbids him.\n\n#### Recommendations\n\nShort term, update the user- and developer-facing documentation so that users bidding through the am-AMM are aware of the risks.\n\nLong term, carefully consider the economic (dis)incentives created when deviating from written specifications.\n\n#### References\n\n● am-AMM: An [Auction-Managed](https://arxiv.org/abs/2403.03367) Automated Market Maker\n",
      "finding_id": null,
      "markdown_raw": "## <span id=\"page-25-0\"></span>3. Overly strict bid withdrawal validation reduces am-AMM eciency by enabling griefing\n\n| Severity:<br>Low            | Diffi<br>culty:<br>Low        |\n|-----------------------------|-------------------------------|\n| Type:<br>Data<br>Validation | Finding<br>ID:<br>TOB-BUNNI-3 |\n| Target:<br>src/AmAmm.sol    |                               |\n\n#### Description\n\nThe AmAmm contract implements an auction mechanism that sells the rights to set and collect swap fees to the highest bidder. The proceeds of the auction are deducted over time as rent and distributed to liquidity providers in lieu of the swap fees that they have forfeited. The bidding process is defined in such a way that the top bidder and rent are determined K units of time (for Bunni v2, this is 24 hours) in advance of them taking effect.\n\nPer the written description, the next bidder should be able to withdraw their deposit as long as they leave enough deposit to cover any difference, if any, between the remaining time left on the current top bidder's deposit and 24 hours. Therefore, if the current top bidder has at least 24 hours of deposit left, the next highest bidder should be able to withdraw their full deposit. The implementation used by Bunni v2, however, requires that the next highest bidder always leaves at least 24 hours of deposit regardless of the state of the current top bidder's deposit.\n\n```\n273 // require D_next / R_next >= K\n274 if ((nextBid.deposit - amount) / nextBid.rent < K(id)) {\n275 revert AmAmm__BidLocked();\n276 }\n```\n\n*Figure 3.1: A snippet of the withdrawNextBid function ([src/AmAmm.sol#L273–L276](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L273-L276))*\n\nWhile there is a cancelNextBid function that the next highest bidder can use to cancel their pending bid, if there is currently an active top bidder, this is only available as long as the top bid's deposit can still cover at least 24 hours.\n\n```\n319 // require D_top / R_top >= K\n320 if (topBid.manager != address(0) && topBid.deposit / topBid.rent < K(id)) {\n321 revert AmAmm__BidLocked();\n322 }\n323 \n324 // delete next bid from storage\n325 delete _nextBids[id];\n```\n\n*Figure 3.2: A snippet of the cancelNextBid function ([src/AmAmm.sol#L319–L325](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L319-L325))*\n\n![](_page_25_Picture_10.jpeg)\n\n{26}------------------------------------------------\n\nThis difference in behavior introduces more risk to bidders who wish to act as the fee manager but do not wish to exceed the current top bidder, as some portion of their funds may remain locked in the contract until the current top bidder exhausts their deposit completely or they are outbid by somebody else. This may also unintentionally incentivize top bidders to extend their reign longer than strictly economically necessary in order to spite competitors and also incentivize bidders to wait until there is no active top bidder to begin submitting bids, creating more gaps where the pool falls back to the default swap fee mechanism that may expose LPs to more arbitrage opportunities and reduce their overall earnings.\n\n#### Exploit Scenario\n\nAlice is the current swap fee manager, pays 10 BunniToken in rent per epoch, and has 40 tokens deposited. Bob notices that Alice only has a small deposit remaining and submits a bid at eight tokens per epoch and includes a 192-token deposit. Alice also notices her deposit was running low and deposits tokens to top up her deposit to 23 hours total. Alice can repeat this top up every day. Bob cannot recover any of his 192 tokens until Alice's deposit is exhausted or someone outbids him.\n\n#### Recommendations\n\nShort term, update the user- and developer-facing documentation so that users bidding through the am-AMM are aware of the risks.\n\nLong term, carefully consider the economic (dis)incentives created when deviating from written specifications.\n\n#### References\n\n● am-AMM: An [Auction-Managed](https://arxiv.org/abs/2403.03367) Automated Market Maker\n\n![](_page_26_Picture_8.jpeg)\n\n{27}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe AmAmm contract implements an auction mechanism that sells the rights to set and collect swap fees to the highest bidder. The proceeds of the auction are deducted over time as rent and distributed to liquidity providers in lieu of the swap fees that they have forfeited. The bidding process is defined in such a way that the top bidder and rent are determined K units of time (for Bunni v2, this is 24 hours) in advance of them taking effect.\n\nPer the written description, the next bidder should be able to withdraw their deposit as long as they leave enough deposit to cover any difference, if any, between the remaining time left on the current top bidder's deposit and 24 hours. Therefore, if the current top bidder has at least 24 hours of deposit left, the next highest bidder should be able to withdraw their full deposit. The implementation used by Bunni v2, however, requires that the next highest bidder always leaves at least 24 hours of deposit regardless of the state of the current top bidder's deposit.\n\n```\n273 // require D_next / R_next >= K\n274 if ((nextBid.deposit - amount) / nextBid.rent < K(id)) {\n275 revert AmAmm__BidLocked();\n276 }\n```\n\n*Figure 3.1: A snippet of the withdrawNextBid function ([src/AmAmm.sol#L273–L276](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L273-L276))*\n\nWhile there is a cancelNextBid function that the next highest bidder can use to cancel their pending bid, if there is currently an active top bidder, this is only available as long as the top bid's deposit can still cover at least 24 hours.\n\n```\n319 // require D_top / R_top >= K\n320 if (topBid.manager != address(0) && topBid.deposit / topBid.rent < K(id)) {\n321 revert AmAmm__BidLocked();\n322 }\n323\n324 // delete next bid from storage\n325 delete _nextBids[id];\n```\n\n*Figure 3.2: A snippet of the cancelNextBid function ([src/AmAmm.sol#L319–L325](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L319-L325))*\n\n\n\nThis difference in behavior introduces more risk to bidders who wish to act as the fee manager but do not wish to exceed the current top bidder, as some portion of their funds may remain locked in the contract until the current top bidder exhausts their deposit completely or they are outbid by somebody else. This may also unintentionally incentivize top bidders to extend their reign longer than strictly economically necessary in order to spite competitors and also incentivize bidders to wait until there is no active top bidder to begin submitting bids, creating more gaps where the pool falls back to the default swap fee mechanism that may expose LPs to more arbitrage opportunities and reduce their overall earnings.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, update the user- and developer-facing documentation so that users bidding through the am-AMM are aware of the risks.\n\nLong term, carefully consider the economic (dis)incentives created when deviating from written specifications.\n\n#### References\n\n● am-AMM: An [Auction-Managed](https://arxiv.org/abs/2403.03367) Automated Market Maker\n",
        "poc": "#### Exploit Scenario\n\nAlice is the current swap fee manager, pays 10 BunniToken in rent per epoch, and has 40 tokens deposited. Bob notices that Alice only has a small deposit remaining and submits a bid at eight tokens per epoch and includes a 192-token deposit. Alice also notices her deposit was running low and deposits tokens to top up her deposit to 23 hours total. Alice can repeat this top up every day. Bob cannot recover any of his 192 tokens until Alice's deposit is exhausted or someone outbids him.\n",
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe AmAmm contract implements an auction mechanism that sells the rights to set and collect swap fees to the highest bidder. The proceeds of the auction are deducted over time as rent and distributed to liquidity providers in lieu of the swap fees that they have forfeited. The bidding process is defined in such a way that the top bidder and rent are determined K units of time (for Bunni v2, this is 24 hours) in advance of them taking effect.\n\nPer the written description, the next bidder should be able to withdraw their deposit as long as they leave enough deposit to cover any difference, if any, between the remaining time left on the current top bidder's deposit and 24 hours. Therefore, if the current top bidder has at least 24 hours of deposit left, the next highest bidder should be able to withdraw their full deposit. The implementation used by Bunni v2, however, requires that the next highest bidder always leaves at least 24 hours of deposit regardless of the state of the current top bidder's deposit.\n\n```\n273 // require D_next / R_next >= K\n274 if ((nextBid.deposit - amount) / nextBid.rent < K(id)) {\n275 revert AmAmm__BidLocked();\n276 }\n```\n\n*Figure 3.1: A snippet of the withdrawNextBid function ([src/AmAmm.sol#L273–L276](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L273-L276))*\n\nWhile there is a cancelNextBid function that the next highest bidder can use to cancel their pending bid, if there is currently an active top bidder, this is only available as long as the top bid's deposit can still cover at least 24 hours.\n\n```\n319 // require D_top / R_top >= K\n320 if (topBid.manager != address(0) && topBid.deposit / topBid.rent < K(id)) {\n321 revert AmAmm__BidLocked();\n322 }\n323\n324 // delete next bid from storage\n325 delete _nextBids[id];\n```\n\n*Figure 3.2: A snippet of the cancelNextBid function ([src/AmAmm.sol#L319–L325](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L319-L325))*\n\n\n\nThis difference in behavior introduces more risk to bidders who wish to act as the fee manager but do not wish to exceed the current top bidder, as some portion of their funds may remain locked in the contract until the current top bidder exhausts their deposit completely or they are outbid by somebody else. This may also unintentionally incentivize top bidders to extend their reign longer than strictly economically necessary in order to spite competitors and also incentivize bidders to wait until there is no active top bidder to begin submitting bids, creating more gaps where the pool falls back to the default swap fee mechanism that may expose LPs to more arbitrage opportunities and reduce their overall earnings.\n",
      "markdown_body": "| Severity: Low            | Diffi culty: Low        |\n|-----------------------------|-------------------------------|\n| Type: Data Validation | Finding ID: TOB-BUNNI-3 |\n| Target: src/AmAmm.sol    |                               |\n\n#### Description\n\nThe AmAmm contract implements an auction mechanism that sells the rights to set and collect swap fees to the highest bidder. The proceeds of the auction are deducted over time as rent and distributed to liquidity providers in lieu of the swap fees that they have forfeited. The bidding process is defined in such a way that the top bidder and rent are determined K units of time (for Bunni v2, this is 24 hours) in advance of them taking effect.\n\nPer the written description, the next bidder should be able to withdraw their deposit as long as they leave enough deposit to cover any difference, if any, between the remaining time left on the current top bidder's deposit and 24 hours. Therefore, if the current top bidder has at least 24 hours of deposit left, the next highest bidder should be able to withdraw their full deposit. The implementation used by Bunni v2, however, requires that the next highest bidder always leaves at least 24 hours of deposit regardless of the state of the current top bidder's deposit.\n\n```\n273 // require D_next / R_next >= K\n274 if ((nextBid.deposit - amount) / nextBid.rent < K(id)) {\n275 revert AmAmm__BidLocked();\n276 }\n```\n\n*Figure 3.1: A snippet of the withdrawNextBid function ([src/AmAmm.sol#L273–L276](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L273-L276))*\n\nWhile there is a cancelNextBid function that the next highest bidder can use to cancel their pending bid, if there is currently an active top bidder, this is only available as long as the top bid's deposit can still cover at least 24 hours.\n\n```\n319 // require D_top / R_top >= K\n320 if (topBid.manager != address(0) && topBid.deposit / topBid.rent < K(id)) {\n321 revert AmAmm__BidLocked();\n322 }\n323\n324 // delete next bid from storage\n325 delete _nextBids[id];\n```\n\n*Figure 3.2: A snippet of the cancelNextBid function ([src/AmAmm.sol#L319–L325](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L319-L325))*\n\n\n\nThis difference in behavior introduces more risk to bidders who wish to act as the fee manager but do not wish to exceed the current top bidder, as some portion of their funds may remain locked in the contract until the current top bidder exhausts their deposit completely or they are outbid by somebody else. This may also unintentionally incentivize top bidders to extend their reign longer than strictly economically necessary in order to spite competitors and also incentivize bidders to wait until there is no active top bidder to begin submitting bids, creating more gaps where the pool falls back to the default swap fee mechanism that may expose LPs to more arbitrage opportunities and reduce their overall earnings.\n\n#### Exploit Scenario\n\nAlice is the current swap fee manager, pays 10 BunniToken in rent per epoch, and has 40 tokens deposited. Bob notices that Alice only has a small deposit remaining and submits a bid at eight tokens per epoch and includes a 192-token deposit. Alice also notices her deposit was running low and deposits tokens to top up her deposit to 23 hours total. Alice can repeat this top up every day. Bob cannot recover any of his 192 tokens until Alice's deposit is exhausted or someone outbids him.\n\n#### Recommendations\n\nShort term, update the user- and developer-facing documentation so that users bidding through the am-AMM are aware of the risks.\n\nLong term, carefully consider the economic (dis)incentives created when deviating from written specifications.\n\n#### References\n\n● am-AMM: An [Auction-Managed](https://arxiv.org/abs/2403.03367) Automated Market Maker\n",
      "metadata": {
        "Severity": "Low",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-3",
        "Target": "src/AmAmm.sol"
      },
      "heading_cleaned": "Overly strict bid withdrawal validation reduces am-AMM eciency by enabling griefing"
    },
    {
      "index": 4,
      "page_start": 27,
      "heading": "4. Users can bid arbitrarily low rent during the bidding process",
      "markdown": "| 4. Users can bid arbitrarily low rent during the bidding process |                               |\n|------------------------------------------------------------------------------------------------|-------------------------------|\n| Severity: Undetermined                                                                      | Diffi culty: Low        |\n| Type: Data Validation                                                                    | Finding ID: TOB-BUNNI-4 |\n| Target: lib/biddog/AmAMM.sol                                                                |                               |\n\n#### Description\n\nDuring the am-AMM auction bidding process, a user vying to be a future manager can bid extremely low rent, even zero, in the absence of a current am-AMM manager or next bids, distorting the bidding process.\n\nAs depicted in figure 4.1, in function bid in the AmAmm contract, when a user places a new bid, the rent is compared with the existing next bid rent and is set as the next bid if the rent is 10% more than the existing next bid rent. In the absence of an existing next bid, the user's rent can be zero and still pass the sanity checks. As a result, future bidders may also opt for bidding low rent, aiming to be just above 10% of the previous rent.\n\n```\n// update state machine\n_updateAmAmmWrite(id);\n// ensure bid is valid\n// - manager can't be zero address\n// - bid needs to be greater than the next bid by >10%\n// - deposit needs to cover the rent for K hours\n// - deposit needs to be a multiple of rent\n// - payload needs to be valid\nif (\n manager == address(0) || rent <=\n_nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id)) || deposit < rent * K(id)\n || deposit % rent != 0 || !_payloadIsValid(id, payload)\n) {\n revert AmAmm__InvalidBid();\n}\n```\n\n*Figure 4.1: A snippet of the bid function in the AmAmm contract ([src/AmAmm.sol#L75–L86](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L75-L86))*\n\nMoreover, as illustrated in figure 4.2, in the function \\_stateTransitionWrite in the contract AmAmm where the new manager is set, a remarkably low next bid rent could still become the manager if there is no existing top bid, given that the rent must be greater than 10% of the existing top bid rent. This scenario allows the winning bidder to attain the manager's role at a substantially low rent and earn significantly more in swap fees.\n\n\n```\n// State D\n// we charge rent from the top bid only until K epochs after the next bid was\nsubmitted\n// assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise\nwe don't care about\n// the next bid\nbool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\nuint40 epochsPassed;\n```\n\n*Figure 4.2: A snippet of the \\_stateTransitionWrite function in the AmAmm contract ([src/AmAmm.sol#L676–L680](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L676-L680))*\n\n#### Recommendations\n\nShort term, implement a minimum rent requirement to ensure that there is a lowest acceptable bid that a bidder must provide to qualify for consideration as the next bid.\n",
      "finding_id": null,
      "markdown_raw": "<span id=\"page-27-0\"></span>\n\n| 4.<br>Users<br>can<br>bid<br>arbitrarily<br>low<br>rent<br>during<br>the<br>bidding<br>process |                               |\n|------------------------------------------------------------------------------------------------|-------------------------------|\n| Severity:<br>Undetermined                                                                      | Diffi<br>culty:<br>Low        |\n| Type:<br>Data<br>Validation                                                                    | Finding<br>ID:<br>TOB-BUNNI-4 |\n| Target:<br>lib/biddog/AmAMM.sol                                                                |                               |\n\n#### Description\n\nDuring the am-AMM auction bidding process, a user vying to be a future manager can bid extremely low rent, even zero, in the absence of a current am-AMM manager or next bids, distorting the bidding process.\n\nAs depicted in figure 4.1, in function bid in the AmAmm contract, when a user places a new bid, the rent is compared with the existing next bid rent and is set as the next bid if the rent is 10% more than the existing next bid rent. In the absence of an existing next bid, the user's rent can be zero and still pass the sanity checks. As a result, future bidders may also opt for bidding low rent, aiming to be just above 10% of the previous rent.\n\n```\n// update state machine\n_updateAmAmmWrite(id);\n// ensure bid is valid\n// - manager can't be zero address\n// - bid needs to be greater than the next bid by >10%\n// - deposit needs to cover the rent for K hours\n// - deposit needs to be a multiple of rent\n// - payload needs to be valid\nif (\n manager == address(0) || rent <=\n_nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id)) || deposit < rent * K(id)\n || deposit % rent != 0 || !_payloadIsValid(id, payload)\n) {\n revert AmAmm__InvalidBid();\n}\n```\n\n*Figure 4.1: A snippet of the bid function in the AmAmm contract ([src/AmAmm.sol#L75–L86](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L75-L86))*\n\nMoreover, as illustrated in figure 4.2, in the function \\_stateTransitionWrite in the contract AmAmm where the new manager is set, a remarkably low next bid rent could still become the manager if there is no existing top bid, given that the rent must be greater than 10% of the existing top bid rent. This scenario allows the winning bidder to attain the manager's role at a substantially low rent and earn significantly more in swap fees.\n\n{28}------------------------------------------------\n\n```\n// State D\n// we charge rent from the top bid only until K epochs after the next bid was\nsubmitted\n// assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise\nwe don't care about\n// the next bid\nbool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\nuint40 epochsPassed;\n```\n\n*Figure 4.2: A snippet of the \\_stateTransitionWrite function in the AmAmm contract ([src/AmAmm.sol#L676–L680](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L676-L680))*\n\n#### Recommendations\n\nShort term, implement a minimum rent requirement to ensure that there is a lowest acceptable bid that a bidder must provide to qualify for consideration as the next bid.\n\n{29}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nDuring the am-AMM auction bidding process, a user vying to be a future manager can bid extremely low rent, even zero, in the absence of a current am-AMM manager or next bids, distorting the bidding process.\n\nAs depicted in figure 4.1, in function bid in the AmAmm contract, when a user places a new bid, the rent is compared with the existing next bid rent and is set as the next bid if the rent is 10% more than the existing next bid rent. In the absence of an existing next bid, the user's rent can be zero and still pass the sanity checks. As a result, future bidders may also opt for bidding low rent, aiming to be just above 10% of the previous rent.\n\n```\n// update state machine\n_updateAmAmmWrite(id);\n// ensure bid is valid\n// - manager can't be zero address\n// - bid needs to be greater than the next bid by >10%\n// - deposit needs to cover the rent for K hours\n// - deposit needs to be a multiple of rent\n// - payload needs to be valid\nif (\n manager == address(0) || rent <=\n_nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id)) || deposit < rent * K(id)\n || deposit % rent != 0 || !_payloadIsValid(id, payload)\n) {\n revert AmAmm__InvalidBid();\n}\n```\n\n*Figure 4.1: A snippet of the bid function in the AmAmm contract ([src/AmAmm.sol#L75–L86](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L75-L86))*\n\nMoreover, as illustrated in figure 4.2, in the function \\_stateTransitionWrite in the contract AmAmm where the new manager is set, a remarkably low next bid rent could still become the manager if there is no existing top bid, given that the rent must be greater than 10% of the existing top bid rent. This scenario allows the winning bidder to attain the manager's role at a substantially low rent and earn significantly more in swap fees.\n\n\n```\n// State D\n// we charge rent from the top bid only until K epochs after the next bid was\nsubmitted\n// assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise\nwe don't care about\n// the next bid\nbool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\nuint40 epochsPassed;\n```\n\n*Figure 4.2: A snippet of the \\_stateTransitionWrite function in the AmAmm contract ([src/AmAmm.sol#L676–L680](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L676-L680))*\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, implement a minimum rent requirement to ensure that there is a lowest acceptable bid that a bidder must provide to qualify for consideration as the next bid.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nDuring the am-AMM auction bidding process, a user vying to be a future manager can bid extremely low rent, even zero, in the absence of a current am-AMM manager or next bids, distorting the bidding process.\n\nAs depicted in figure 4.1, in function bid in the AmAmm contract, when a user places a new bid, the rent is compared with the existing next bid rent and is set as the next bid if the rent is 10% more than the existing next bid rent. In the absence of an existing next bid, the user's rent can be zero and still pass the sanity checks. As a result, future bidders may also opt for bidding low rent, aiming to be just above 10% of the previous rent.\n\n```\n// update state machine\n_updateAmAmmWrite(id);\n// ensure bid is valid\n// - manager can't be zero address\n// - bid needs to be greater than the next bid by >10%\n// - deposit needs to cover the rent for K hours\n// - deposit needs to be a multiple of rent\n// - payload needs to be valid\nif (\n manager == address(0) || rent <=\n_nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id)) || deposit < rent * K(id)\n || deposit % rent != 0 || !_payloadIsValid(id, payload)\n) {\n revert AmAmm__InvalidBid();\n}\n```\n\n*Figure 4.1: A snippet of the bid function in the AmAmm contract ([src/AmAmm.sol#L75–L86](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L75-L86))*\n\nMoreover, as illustrated in figure 4.2, in the function \\_stateTransitionWrite in the contract AmAmm where the new manager is set, a remarkably low next bid rent could still become the manager if there is no existing top bid, given that the rent must be greater than 10% of the existing top bid rent. This scenario allows the winning bidder to attain the manager's role at a substantially low rent and earn significantly more in swap fees.\n\n\n```\n// State D\n// we charge rent from the top bid only until K epochs after the next bid was\nsubmitted\n// assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise\nwe don't care about\n// the next bid\nbool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\nuint40 epochsPassed;\n```\n\n*Figure 4.2: A snippet of the \\_stateTransitionWrite function in the AmAmm contract ([src/AmAmm.sol#L676–L680](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L676-L680))*\n",
      "markdown_body": "| 4. Users can bid arbitrarily low rent during the bidding process |                               |\n|------------------------------------------------------------------------------------------------|-------------------------------|\n| Severity: Undetermined                                                                      | Diffi culty: Low        |\n| Type: Data Validation                                                                    | Finding ID: TOB-BUNNI-4 |\n| Target: lib/biddog/AmAMM.sol                                                                |                               |\n\n#### Description\n\nDuring the am-AMM auction bidding process, a user vying to be a future manager can bid extremely low rent, even zero, in the absence of a current am-AMM manager or next bids, distorting the bidding process.\n\nAs depicted in figure 4.1, in function bid in the AmAmm contract, when a user places a new bid, the rent is compared with the existing next bid rent and is set as the next bid if the rent is 10% more than the existing next bid rent. In the absence of an existing next bid, the user's rent can be zero and still pass the sanity checks. As a result, future bidders may also opt for bidding low rent, aiming to be just above 10% of the previous rent.\n\n```\n// update state machine\n_updateAmAmmWrite(id);\n// ensure bid is valid\n// - manager can't be zero address\n// - bid needs to be greater than the next bid by >10%\n// - deposit needs to cover the rent for K hours\n// - deposit needs to be a multiple of rent\n// - payload needs to be valid\nif (\n manager == address(0) || rent <=\n_nextBids[id].rent.mulWad(MIN_BID_MULTIPLIER(id)) || deposit < rent * K(id)\n || deposit % rent != 0 || !_payloadIsValid(id, payload)\n) {\n revert AmAmm__InvalidBid();\n}\n```\n\n*Figure 4.1: A snippet of the bid function in the AmAmm contract ([src/AmAmm.sol#L75–L86](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L75-L86))*\n\nMoreover, as illustrated in figure 4.2, in the function \\_stateTransitionWrite in the contract AmAmm where the new manager is set, a remarkably low next bid rent could still become the manager if there is no existing top bid, given that the rent must be greater than 10% of the existing top bid rent. This scenario allows the winning bidder to attain the manager's role at a substantially low rent and earn significantly more in swap fees.\n\n\n```\n// State D\n// we charge rent from the top bid only until K epochs after the next bid was\nsubmitted\n// assuming the next bid's rent is greater than the top bid's rent + 10%, otherwise\nwe don't care about\n// the next bid\nbool nextBidIsBetter = nextBid.rent > topBid.rent.mulWad(MIN_BID_MULTIPLIER(id));\nuint40 epochsPassed;\n```\n\n*Figure 4.2: A snippet of the \\_stateTransitionWrite function in the AmAmm contract ([src/AmAmm.sol#L676–L680](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L676-L680))*\n\n#### Recommendations\n\nShort term, implement a minimum rent requirement to ensure that there is a lowest acceptable bid that a bidder must provide to qualify for consideration as the next bid.\n",
      "metadata": {
        "Severity": null,
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-4",
        "Target": "lib/biddog/AmAMM.sol"
      },
      "heading_cleaned": "Users can bid arbitrarily low rent during the bidding process"
    },
    {
      "index": 5,
      "page_start": 29,
      "heading": "5. Dirty bits of narrow types are not cleaned",
      "markdown": "## 5. Dirty bits of narrow types are not cleaned\n\n| Severity: Informational      | Diffi culty: High       |\n|---------------------------------|-------------------------------|\n| Type: Data Validation     | Finding ID: TOB-BUNNI-5 |\n| Target: src/lib/SwapMath.sol |                               |\n\n#### Description\n\nThe SwapMath library used by Bunni v2 is based on the library of the same name from Uniswap v4. However, the getSqrtPriceTarget function in the Uniswap library has been updated to properly clean the higher bits of the sqrtPrice\\* parameters. Solidity makes no guarantees about the contents of these unused bits in the case of types smaller than one word (e.g., uint24, uint160, address).\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), zeroForOne)\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.1: The body of the getSqrtPriceTarget function in the Bunni v2 SwapMath contract, showing the 160-bit values being used directly ([src/lib/SwapMath.sol#L19–L34](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/SwapMath.sol#L19-L34))*\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly (\"memory-safe\") {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n```\n\n\n```\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceNextX96 := and(sqrtPriceNextX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n sqrtPriceLimitX96 := and(sqrtPriceLimitX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96),\nand(zeroForOne, 0x1))\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.2: The body of the getSqrtPriceTarget function in the Uniswap v4 SwapMath contract, showing the high bits of the values being cleared before being used ([src/libraries/SwapMath.sol#L20–L37](https://github.com/Uniswap/v4-core/blob/9293e5ab1deed87e03c176d8af94b1af19eb3900/src/libraries/SwapMath.sol#L20-L37))*\n\n#### Recommendations\n\nShort term, update the getSqrtPriceTarget function to clear the higher-order bits before using them.\n\nLong term, regularly review the sources of any modified third-party code to ensure you use the most up-to-date version and benefit from any security improvements.\n",
      "finding_id": null,
      "markdown_raw": "## <span id=\"page-29-0\"></span>5. Dirty bits of narrow types are not cleaned\n\n| Severity:<br>Informational      | Diffi<br>culty:<br>High       |\n|---------------------------------|-------------------------------|\n| Type:<br>Data<br>Validation     | Finding<br>ID:<br>TOB-BUNNI-5 |\n| Target:<br>src/lib/SwapMath.sol |                               |\n\n#### Description\n\nThe SwapMath library used by Bunni v2 is based on the library of the same name from Uniswap v4. However, the getSqrtPriceTarget function in the Uniswap library has been updated to properly clean the higher bits of the sqrtPrice\\* parameters. Solidity makes no guarantees about the contents of these unused bits in the case of types smaller than one word (e.g., uint24, uint160, address).\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), zeroForOne)\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.1: The body of the getSqrtPriceTarget function in the Bunni v2 SwapMath contract, showing the 160-bit values being used directly ([src/lib/SwapMath.sol#L19–L34](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/SwapMath.sol#L19-L34))*\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly (\"memory-safe\") {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n```\n\n{30}------------------------------------------------\n\n```\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceNextX96 := and(sqrtPriceNextX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n sqrtPriceLimitX96 := and(sqrtPriceLimitX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96),\nand(zeroForOne, 0x1))\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.2: The body of the getSqrtPriceTarget function in the Uniswap v4 SwapMath contract, showing the high bits of the values being cleared before being used ([src/libraries/SwapMath.sol#L20–L37](https://github.com/Uniswap/v4-core/blob/9293e5ab1deed87e03c176d8af94b1af19eb3900/src/libraries/SwapMath.sol#L20-L37))*\n\n#### Recommendations\n\nShort term, update the getSqrtPriceTarget function to clear the higher-order bits before using them.\n\nLong term, regularly review the sources of any modified third-party code to ensure you use the most up-to-date version and benefit from any security improvements.\n\n{31}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe SwapMath library used by Bunni v2 is based on the library of the same name from Uniswap v4. However, the getSqrtPriceTarget function in the Uniswap library has been updated to properly clean the higher bits of the sqrtPrice\\* parameters. Solidity makes no guarantees about the contents of these unused bits in the case of types smaller than one word (e.g., uint24, uint160, address).\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), zeroForOne)\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.1: The body of the getSqrtPriceTarget function in the Bunni v2 SwapMath contract, showing the 160-bit values being used directly ([src/lib/SwapMath.sol#L19–L34](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/SwapMath.sol#L19-L34))*\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly (\"memory-safe\") {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n```\n\n\n```\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceNextX96 := and(sqrtPriceNextX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n sqrtPriceLimitX96 := and(sqrtPriceLimitX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96),\nand(zeroForOne, 0x1))\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.2: The body of the getSqrtPriceTarget function in the Uniswap v4 SwapMath contract, showing the high bits of the values being cleared before being used ([src/libraries/SwapMath.sol#L20–L37](https://github.com/Uniswap/v4-core/blob/9293e5ab1deed87e03c176d8af94b1af19eb3900/src/libraries/SwapMath.sol#L20-L37))*\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, update the getSqrtPriceTarget function to clear the higher-order bits before using them.\n\nLong term, regularly review the sources of any modified third-party code to ensure you use the most up-to-date version and benefit from any security improvements.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe SwapMath library used by Bunni v2 is based on the library of the same name from Uniswap v4. However, the getSqrtPriceTarget function in the Uniswap library has been updated to properly clean the higher bits of the sqrtPrice\\* parameters. Solidity makes no guarantees about the contents of these unused bits in the case of types smaller than one word (e.g., uint24, uint160, address).\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), zeroForOne)\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.1: The body of the getSqrtPriceTarget function in the Bunni v2 SwapMath contract, showing the 160-bit values being used directly ([src/lib/SwapMath.sol#L19–L34](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/SwapMath.sol#L19-L34))*\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly (\"memory-safe\") {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n```\n\n\n```\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceNextX96 := and(sqrtPriceNextX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n sqrtPriceLimitX96 := and(sqrtPriceLimitX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96),\nand(zeroForOne, 0x1))\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.2: The body of the getSqrtPriceTarget function in the Uniswap v4 SwapMath contract, showing the high bits of the values being cleared before being used ([src/libraries/SwapMath.sol#L20–L37](https://github.com/Uniswap/v4-core/blob/9293e5ab1deed87e03c176d8af94b1af19eb3900/src/libraries/SwapMath.sol#L20-L37))*\n",
      "markdown_body": "| Severity: Informational      | Diffi culty: High       |\n|---------------------------------|-------------------------------|\n| Type: Data Validation     | Finding ID: TOB-BUNNI-5 |\n| Target: src/lib/SwapMath.sol |                               |\n\n#### Description\n\nThe SwapMath library used by Bunni v2 is based on the library of the same name from Uniswap v4. However, the getSqrtPriceTarget function in the Uniswap library has been updated to properly clean the higher bits of the sqrtPrice\\* parameters. Solidity makes no guarantees about the contents of these unused bits in the case of types smaller than one word (e.g., uint24, uint160, address).\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96), zeroForOne)\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.1: The body of the getSqrtPriceTarget function in the Bunni v2 SwapMath contract, showing the 160-bit values being used directly ([src/lib/SwapMath.sol#L19–L34](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/SwapMath.sol#L19-L34))*\n\n```\nfunction getSqrtPriceTarget(bool zeroForOne, uint160 sqrtPriceNextX96, uint160\nsqrtPriceLimitX96)\n internal\n pure\n returns (uint160 sqrtPriceTargetX96)\n{\n assembly (\"memory-safe\") {\n // a flag to toggle between sqrtPriceNextX96 and sqrtPriceLimitX96\n```\n\n\n```\n // when zeroForOne == true, nextOrLimit reduces to sqrtPriceNextX96 >=\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = max(sqrtPriceNextX96, sqrtPriceLimitX96)\n // when zeroForOne == false, nextOrLimit reduces to sqrtPriceNextX96 <\nsqrtPriceLimitX96\n // sqrtPriceTargetX96 = min(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceNextX96 := and(sqrtPriceNextX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n sqrtPriceLimitX96 := and(sqrtPriceLimitX96,\n0xffffffffffffffffffffffffffffffffffffffff)\n let nextOrLimit := xor(lt(sqrtPriceNextX96, sqrtPriceLimitX96),\nand(zeroForOne, 0x1))\n let symDiff := xor(sqrtPriceNextX96, sqrtPriceLimitX96)\n sqrtPriceTargetX96 := xor(sqrtPriceLimitX96, mul(symDiff, nextOrLimit))\n }\n}\n```\n\n*Figure 5.2: The body of the getSqrtPriceTarget function in the Uniswap v4 SwapMath contract, showing the high bits of the values being cleared before being used ([src/libraries/SwapMath.sol#L20–L37](https://github.com/Uniswap/v4-core/blob/9293e5ab1deed87e03c176d8af94b1af19eb3900/src/libraries/SwapMath.sol#L20-L37))*\n\n#### Recommendations\n\nShort term, update the getSqrtPriceTarget function to clear the higher-order bits before using them.\n\nLong term, regularly review the sources of any modified third-party code to ensure you use the most up-to-date version and benefit from any security improvements.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-5",
        "Target": "src/lib/SwapMath.sol"
      },
      "heading_cleaned": "Dirty bits of narrow types are not cleaned"
    },
    {
      "index": 6,
      "page_start": 31,
      "heading": "6. Rebalance mechanism access control can be bypassed Severity: **High** Difficulty: **Low** Type: Access Controls Finding ID: TOB-BUNNI-6 Target: src/BunniHook.sol, src/lib/BunniHookLogic.sol",
      "markdown": "# 6. Rebalance mechanism access control can be bypassed Severity: **High** Difficulty: **Low** Type: Access Controls Finding ID: TOB-BUNNI-6 Target: src/BunniHook.sol, src/lib/BunniHookLogic.sol\n\n#### Description\n\nThe access controls of the rebalance mechanism are ineffective, allowing anyone to execute the pre- and post-hooks of the mechanism.\n\nOnce a rebalance order is created, users can fulfill this order by calling one of the fulfillOrder functions of the FloodPlain contract. The functions will make a call to the BunniZone, if it is defined, in order to validate the caller, as shown in figure 6.1:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 6.1: One of the fulfillOrder functions ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\nHowever, as figure 6.2 shows, the BunniZone does not perform any validation on the contents of the order, but only on the fulfiller (msg.sender in the highlighted line of figure 6.1):\n\n```\nfunction validate(IFloodPlain.Order calldata order, address fulfiller) external view\nreturns (bool) {\n // extract PoolKey from order's preHooks\n IBunniHook.RebalanceOrderHookArgs memory hookArgs =\n abi.decode(order.preHooks[0].data[4:], (IBunniHook.RebalanceOrderHookArgs));\n PoolKey memory key = hookArgs.key;\n PoolId id = key.toId();\n // query the hook for the am-AMM manager\n IAmAmm amAmm = IAmAmm(address(key.hooks));\n IAmAmm.Bid memory topBid = amAmm.getTopBid(id);\n // allow fulfiller if they are whitelisted or if they are the am-AMM manager\n return isWhitelisted[fulfiller] || topBid.manager == fulfiller;\n}\n```\n\n*Figure 6.2: The validate function ([src/BunniZone.sol#L41–L54](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniZone.sol#L41-L54))*\n\nThis allows anyone to execute the pre- and post-hooks by creating a fake order and then inserting a real order into the preHooks and postHooks arrays.\n\nAdditionally, the BunniHook contract considers the poolId of the created order combined with the order hash to be a valid permit signature, as visible in figures 6.3 and 6.4:\n\n```\nfunction _createRebalanceOrder(\n HookStorage storage s,\n Env calldata env,\n PoolId id,\n PoolKey memory key,\n uint16 rebalanceOrderTTL,\n Currency inputToken,\n Currency outputToken,\n uint256 inputAmount,\n uint256 outputAmount\n) internal {\n // ...\n // approve input token to permit2\n if (inputERC20Token.allowance(address(this), env.permit2) < inputAmount) {\n address(inputERC20Token).safeApproveWithRetry(env.permit2,\ntype(uint256).max);\n }\n // etch order so fillers can pick it up\n // use PoolId as signature to enable isValidSignature() to find the correct\norder hash\n IOnChainOrders(address(env.floodPlain)).etchOrder(\n```\n\n\n```\n IFloodPlain.SignedOrder({order: order, signature: abi.encode(id)})\n );\n}\n```\n\n*Figure 6.3: The rebalance order signature creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L733–L743](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L733-L743))*\n\n```\nfunction isValidSignature(bytes32 hash, bytes memory signature)\n external\n view\n override\n returns (bytes4 magicValue)\n{\n // verify rebalance order\n PoolId id = abi.decode(signature, (PoolId)); // we use the signature field to\nstore the pool id\n if (s.rebalanceOrderHash[id] == hash) {\n return this.isValidSignature.selector;\n }\n}\n```\n\n*Figure 6.4: The rebalance order signature verification in the isValidSignature function ([src/BunniHook.sol#L120–L131](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L120-L131))*\n\nSince the FloodPlain contract allows arbitrary functions to be executed on arbitrary targets, this contract has a high-severity vulnerability where a call to permit2 can be inserted into the preHooks or postHooks array in order to consume the permit2 coupon for other users and steal their tokens.\n\nDue to this, anyone can drain the balance of the BunniHook contract for any token that has an outstanding rebalance order by inserting a call to permit2 into the preHooks or postHooks arrays with the correct witness, witnessTypeString, and poolId variables but a changed receiver address.\n\n#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a fake order that contains the actual rebalance pre- and post-hook in the preHooks array, but leaves the postHooks array empty. The output amount is pulled from the BunniHub contract and stays in the BunniHook contract. Eve then creates another fake order and inserts a call to the permit2 contract's permitWitnessTransferFrom function in the preHooks array to transfer the amount to herself. This passes since the signature is considered valid whenever the correct hash and PoolId are supplied to the isValidSignature function and since the permit2 call was made from the FloodPlain contract.\n\n#### Recommendations\n\nShort term, do not deploy any pools with rebalancing enabled until Flood addresses this issue and undergoes a security review. Otherwise, consider either creating custom\n\n\n\nwrappers for interaction with the FloodPlain contract that would validate the order, caller, and the hooks at once, or using a different provider for order fulfillment.\n\nLong term, redesign the rebalance flow in order to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n",
      "finding_id": null,
      "markdown_raw": "# <span id=\"page-31-0\"></span>6. Rebalance mechanism access control can be bypassed Severity: **High** Difficulty: **Low** Type: Access Controls Finding ID: TOB-BUNNI-6 Target: src/BunniHook.sol, src/lib/BunniHookLogic.sol\n\n#### Description\n\nThe access controls of the rebalance mechanism are ineffective, allowing anyone to execute the pre- and post-hooks of the mechanism.\n\nOnce a rebalance order is created, users can fulfill this order by calling one of the fulfillOrder functions of the FloodPlain contract. The functions will make a call to the BunniZone, if it is defined, in order to validate the caller, as shown in figure 6.1:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 6.1: One of the fulfillOrder functions ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n{32}------------------------------------------------\n\nHowever, as figure 6.2 shows, the BunniZone does not perform any validation on the contents of the order, but only on the fulfiller (msg.sender in the highlighted line of figure 6.1):\n\n```\nfunction validate(IFloodPlain.Order calldata order, address fulfiller) external view\nreturns (bool) {\n // extract PoolKey from order's preHooks\n IBunniHook.RebalanceOrderHookArgs memory hookArgs =\n abi.decode(order.preHooks[0].data[4:], (IBunniHook.RebalanceOrderHookArgs));\n PoolKey memory key = hookArgs.key;\n PoolId id = key.toId();\n // query the hook for the am-AMM manager\n IAmAmm amAmm = IAmAmm(address(key.hooks));\n IAmAmm.Bid memory topBid = amAmm.getTopBid(id);\n // allow fulfiller if they are whitelisted or if they are the am-AMM manager\n return isWhitelisted[fulfiller] || topBid.manager == fulfiller;\n}\n```\n\n*Figure 6.2: The validate function ([src/BunniZone.sol#L41–L54](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniZone.sol#L41-L54))*\n\nThis allows anyone to execute the pre- and post-hooks by creating a fake order and then inserting a real order into the preHooks and postHooks arrays.\n\nAdditionally, the BunniHook contract considers the poolId of the created order combined with the order hash to be a valid permit signature, as visible in figures 6.3 and 6.4:\n\n```\nfunction _createRebalanceOrder(\n HookStorage storage s,\n Env calldata env,\n PoolId id,\n PoolKey memory key,\n uint16 rebalanceOrderTTL,\n Currency inputToken,\n Currency outputToken,\n uint256 inputAmount,\n uint256 outputAmount\n) internal {\n // ...\n // approve input token to permit2\n if (inputERC20Token.allowance(address(this), env.permit2) < inputAmount) {\n address(inputERC20Token).safeApproveWithRetry(env.permit2,\ntype(uint256).max);\n }\n // etch order so fillers can pick it up\n // use PoolId as signature to enable isValidSignature() to find the correct\norder hash\n IOnChainOrders(address(env.floodPlain)).etchOrder(\n```\n\n{33}------------------------------------------------\n\n```\n IFloodPlain.SignedOrder({order: order, signature: abi.encode(id)})\n );\n}\n```\n\n*Figure 6.3: The rebalance order signature creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L733–L743](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L733-L743))*\n\n```\nfunction isValidSignature(bytes32 hash, bytes memory signature)\n external\n view\n override\n returns (bytes4 magicValue)\n{\n // verify rebalance order\n PoolId id = abi.decode(signature, (PoolId)); // we use the signature field to\nstore the pool id\n if (s.rebalanceOrderHash[id] == hash) {\n return this.isValidSignature.selector;\n }\n}\n```\n\n*Figure 6.4: The rebalance order signature verification in the isValidSignature function ([src/BunniHook.sol#L120–L131](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L120-L131))*\n\nSince the FloodPlain contract allows arbitrary functions to be executed on arbitrary targets, this contract has a high-severity vulnerability where a call to permit2 can be inserted into the preHooks or postHooks array in order to consume the permit2 coupon for other users and steal their tokens.\n\nDue to this, anyone can drain the balance of the BunniHook contract for any token that has an outstanding rebalance order by inserting a call to permit2 into the preHooks or postHooks arrays with the correct witness, witnessTypeString, and poolId variables but a changed receiver address.\n\n#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a fake order that contains the actual rebalance pre- and post-hook in the preHooks array, but leaves the postHooks array empty. The output amount is pulled from the BunniHub contract and stays in the BunniHook contract. Eve then creates another fake order and inserts a call to the permit2 contract's permitWitnessTransferFrom function in the preHooks array to transfer the amount to herself. This passes since the signature is considered valid whenever the correct hash and PoolId are supplied to the isValidSignature function and since the permit2 call was made from the FloodPlain contract.\n\n#### Recommendations\n\nShort term, do not deploy any pools with rebalancing enabled until Flood addresses this issue and undergoes a security review. Otherwise, consider either creating custom\n\n![](_page_33_Picture_10.jpeg)\n\n{34}------------------------------------------------\n\nwrappers for interaction with the FloodPlain contract that would validate the order, caller, and the hooks at once, or using a different provider for order fulfillment.\n\nLong term, redesign the rebalance flow in order to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n\n![](_page_34_Picture_2.jpeg)\n\n{35}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe access controls of the rebalance mechanism are ineffective, allowing anyone to execute the pre- and post-hooks of the mechanism.\n\nOnce a rebalance order is created, users can fulfill this order by calling one of the fulfillOrder functions of the FloodPlain contract. The functions will make a call to the BunniZone, if it is defined, in order to validate the caller, as shown in figure 6.1:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 6.1: One of the fulfillOrder functions ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\nHowever, as figure 6.2 shows, the BunniZone does not perform any validation on the contents of the order, but only on the fulfiller (msg.sender in the highlighted line of figure 6.1):\n\n```\nfunction validate(IFloodPlain.Order calldata order, address fulfiller) external view\nreturns (bool) {\n // extract PoolKey from order's preHooks\n IBunniHook.RebalanceOrderHookArgs memory hookArgs =\n abi.decode(order.preHooks[0].data[4:], (IBunniHook.RebalanceOrderHookArgs));\n PoolKey memory key = hookArgs.key;\n PoolId id = key.toId();\n // query the hook for the am-AMM manager\n IAmAmm amAmm = IAmAmm(address(key.hooks));\n IAmAmm.Bid memory topBid = amAmm.getTopBid(id);\n // allow fulfiller if they are whitelisted or if they are the am-AMM manager\n return isWhitelisted[fulfiller] || topBid.manager == fulfiller;\n}\n```\n\n*Figure 6.2: The validate function ([src/BunniZone.sol#L41–L54](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniZone.sol#L41-L54))*\n\nThis allows anyone to execute the pre- and post-hooks by creating a fake order and then inserting a real order into the preHooks and postHooks arrays.\n\nAdditionally, the BunniHook contract considers the poolId of the created order combined with the order hash to be a valid permit signature, as visible in figures 6.3 and 6.4:\n\n```\nfunction _createRebalanceOrder(\n HookStorage storage s,\n Env calldata env,\n PoolId id,\n PoolKey memory key,\n uint16 rebalanceOrderTTL,\n Currency inputToken,\n Currency outputToken,\n uint256 inputAmount,\n uint256 outputAmount\n) internal {\n // ...\n // approve input token to permit2\n if (inputERC20Token.allowance(address(this), env.permit2) < inputAmount) {\n address(inputERC20Token).safeApproveWithRetry(env.permit2,\ntype(uint256).max);\n }\n // etch order so fillers can pick it up\n // use PoolId as signature to enable isValidSignature() to find the correct\norder hash\n IOnChainOrders(address(env.floodPlain)).etchOrder(\n```\n\n\n```\n IFloodPlain.SignedOrder({order: order, signature: abi.encode(id)})\n );\n}\n```\n\n*Figure 6.3: The rebalance order signature creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L733–L743](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L733-L743))*\n\n```\nfunction isValidSignature(bytes32 hash, bytes memory signature)\n external\n view\n override\n returns (bytes4 magicValue)\n{\n // verify rebalance order\n PoolId id = abi.decode(signature, (PoolId)); // we use the signature field to\nstore the pool id\n if (s.rebalanceOrderHash[id] == hash) {\n return this.isValidSignature.selector;\n }\n}\n```\n\n*Figure 6.4: The rebalance order signature verification in the isValidSignature function ([src/BunniHook.sol#L120–L131](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L120-L131))*\n\nSince the FloodPlain contract allows arbitrary functions to be executed on arbitrary targets, this contract has a high-severity vulnerability where a call to permit2 can be inserted into the preHooks or postHooks array in order to consume the permit2 coupon for other users and steal their tokens.\n\nDue to this, anyone can drain the balance of the BunniHook contract for any token that has an outstanding rebalance order by inserting a call to permit2 into the preHooks or postHooks arrays with the correct witness, witnessTypeString, and poolId variables but a changed receiver address.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, do not deploy any pools with rebalancing enabled until Flood addresses this issue and undergoes a security review. Otherwise, consider either creating custom\n\n\n\nwrappers for interaction with the FloodPlain contract that would validate the order, caller, and the hooks at once, or using a different provider for order fulfillment.\n\nLong term, redesign the rebalance flow in order to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n",
        "poc": "#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a fake order that contains the actual rebalance pre- and post-hook in the preHooks array, but leaves the postHooks array empty. The output amount is pulled from the BunniHub contract and stays in the BunniHook contract. Eve then creates another fake order and inserts a call to the permit2 contract's permitWitnessTransferFrom function in the preHooks array to transfer the amount to herself. This passes since the signature is considered valid whenever the correct hash and PoolId are supplied to the isValidSignature function and since the permit2 call was made from the FloodPlain contract.\n",
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe access controls of the rebalance mechanism are ineffective, allowing anyone to execute the pre- and post-hooks of the mechanism.\n\nOnce a rebalance order is created, users can fulfill this order by calling one of the fulfillOrder functions of the FloodPlain contract. The functions will make a call to the BunniZone, if it is defined, in order to validate the caller, as shown in figure 6.1:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 6.1: One of the fulfillOrder functions ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\nHowever, as figure 6.2 shows, the BunniZone does not perform any validation on the contents of the order, but only on the fulfiller (msg.sender in the highlighted line of figure 6.1):\n\n```\nfunction validate(IFloodPlain.Order calldata order, address fulfiller) external view\nreturns (bool) {\n // extract PoolKey from order's preHooks\n IBunniHook.RebalanceOrderHookArgs memory hookArgs =\n abi.decode(order.preHooks[0].data[4:], (IBunniHook.RebalanceOrderHookArgs));\n PoolKey memory key = hookArgs.key;\n PoolId id = key.toId();\n // query the hook for the am-AMM manager\n IAmAmm amAmm = IAmAmm(address(key.hooks));\n IAmAmm.Bid memory topBid = amAmm.getTopBid(id);\n // allow fulfiller if they are whitelisted or if they are the am-AMM manager\n return isWhitelisted[fulfiller] || topBid.manager == fulfiller;\n}\n```\n\n*Figure 6.2: The validate function ([src/BunniZone.sol#L41–L54](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniZone.sol#L41-L54))*\n\nThis allows anyone to execute the pre- and post-hooks by creating a fake order and then inserting a real order into the preHooks and postHooks arrays.\n\nAdditionally, the BunniHook contract considers the poolId of the created order combined with the order hash to be a valid permit signature, as visible in figures 6.3 and 6.4:\n\n```\nfunction _createRebalanceOrder(\n HookStorage storage s,\n Env calldata env,\n PoolId id,\n PoolKey memory key,\n uint16 rebalanceOrderTTL,\n Currency inputToken,\n Currency outputToken,\n uint256 inputAmount,\n uint256 outputAmount\n) internal {\n // ...\n // approve input token to permit2\n if (inputERC20Token.allowance(address(this), env.permit2) < inputAmount) {\n address(inputERC20Token).safeApproveWithRetry(env.permit2,\ntype(uint256).max);\n }\n // etch order so fillers can pick it up\n // use PoolId as signature to enable isValidSignature() to find the correct\norder hash\n IOnChainOrders(address(env.floodPlain)).etchOrder(\n```\n\n\n```\n IFloodPlain.SignedOrder({order: order, signature: abi.encode(id)})\n );\n}\n```\n\n*Figure 6.3: The rebalance order signature creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L733–L743](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L733-L743))*\n\n```\nfunction isValidSignature(bytes32 hash, bytes memory signature)\n external\n view\n override\n returns (bytes4 magicValue)\n{\n // verify rebalance order\n PoolId id = abi.decode(signature, (PoolId)); // we use the signature field to\nstore the pool id\n if (s.rebalanceOrderHash[id] == hash) {\n return this.isValidSignature.selector;\n }\n}\n```\n\n*Figure 6.4: The rebalance order signature verification in the isValidSignature function ([src/BunniHook.sol#L120–L131](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L120-L131))*\n\nSince the FloodPlain contract allows arbitrary functions to be executed on arbitrary targets, this contract has a high-severity vulnerability where a call to permit2 can be inserted into the preHooks or postHooks array in order to consume the permit2 coupon for other users and steal their tokens.\n\nDue to this, anyone can drain the balance of the BunniHook contract for any token that has an outstanding rebalance order by inserting a call to permit2 into the preHooks or postHooks arrays with the correct witness, witnessTypeString, and poolId variables but a changed receiver address.\n",
      "markdown_body": "#### Description\n\nThe access controls of the rebalance mechanism are ineffective, allowing anyone to execute the pre- and post-hooks of the mechanism.\n\nOnce a rebalance order is created, users can fulfill this order by calling one of the fulfillOrder functions of the FloodPlain contract. The functions will make a call to the BunniZone, if it is defined, in order to validate the caller, as shown in figure 6.1:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 6.1: One of the fulfillOrder functions ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\nHowever, as figure 6.2 shows, the BunniZone does not perform any validation on the contents of the order, but only on the fulfiller (msg.sender in the highlighted line of figure 6.1):\n\n```\nfunction validate(IFloodPlain.Order calldata order, address fulfiller) external view\nreturns (bool) {\n // extract PoolKey from order's preHooks\n IBunniHook.RebalanceOrderHookArgs memory hookArgs =\n abi.decode(order.preHooks[0].data[4:], (IBunniHook.RebalanceOrderHookArgs));\n PoolKey memory key = hookArgs.key;\n PoolId id = key.toId();\n // query the hook for the am-AMM manager\n IAmAmm amAmm = IAmAmm(address(key.hooks));\n IAmAmm.Bid memory topBid = amAmm.getTopBid(id);\n // allow fulfiller if they are whitelisted or if they are the am-AMM manager\n return isWhitelisted[fulfiller] || topBid.manager == fulfiller;\n}\n```\n\n*Figure 6.2: The validate function ([src/BunniZone.sol#L41–L54](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniZone.sol#L41-L54))*\n\nThis allows anyone to execute the pre- and post-hooks by creating a fake order and then inserting a real order into the preHooks and postHooks arrays.\n\nAdditionally, the BunniHook contract considers the poolId of the created order combined with the order hash to be a valid permit signature, as visible in figures 6.3 and 6.4:\n\n```\nfunction _createRebalanceOrder(\n HookStorage storage s,\n Env calldata env,\n PoolId id,\n PoolKey memory key,\n uint16 rebalanceOrderTTL,\n Currency inputToken,\n Currency outputToken,\n uint256 inputAmount,\n uint256 outputAmount\n) internal {\n // ...\n // approve input token to permit2\n if (inputERC20Token.allowance(address(this), env.permit2) < inputAmount) {\n address(inputERC20Token).safeApproveWithRetry(env.permit2,\ntype(uint256).max);\n }\n // etch order so fillers can pick it up\n // use PoolId as signature to enable isValidSignature() to find the correct\norder hash\n IOnChainOrders(address(env.floodPlain)).etchOrder(\n```\n\n\n```\n IFloodPlain.SignedOrder({order: order, signature: abi.encode(id)})\n );\n}\n```\n\n*Figure 6.3: The rebalance order signature creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L733–L743](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L733-L743))*\n\n```\nfunction isValidSignature(bytes32 hash, bytes memory signature)\n external\n view\n override\n returns (bytes4 magicValue)\n{\n // verify rebalance order\n PoolId id = abi.decode(signature, (PoolId)); // we use the signature field to\nstore the pool id\n if (s.rebalanceOrderHash[id] == hash) {\n return this.isValidSignature.selector;\n }\n}\n```\n\n*Figure 6.4: The rebalance order signature verification in the isValidSignature function ([src/BunniHook.sol#L120–L131](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L120-L131))*\n\nSince the FloodPlain contract allows arbitrary functions to be executed on arbitrary targets, this contract has a high-severity vulnerability where a call to permit2 can be inserted into the preHooks or postHooks array in order to consume the permit2 coupon for other users and steal their tokens.\n\nDue to this, anyone can drain the balance of the BunniHook contract for any token that has an outstanding rebalance order by inserting a call to permit2 into the preHooks or postHooks arrays with the correct witness, witnessTypeString, and poolId variables but a changed receiver address.\n\n#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a fake order that contains the actual rebalance pre- and post-hook in the preHooks array, but leaves the postHooks array empty. The output amount is pulled from the BunniHub contract and stays in the BunniHook contract. Eve then creates another fake order and inserts a call to the permit2 contract's permitWitnessTransferFrom function in the preHooks array to transfer the amount to herself. This passes since the signature is considered valid whenever the correct hash and PoolId are supplied to the isValidSignature function and since the permit2 call was made from the FloodPlain contract.\n\n#### Recommendations\n\nShort term, do not deploy any pools with rebalancing enabled until Flood addresses this issue and undergoes a security review. Otherwise, consider either creating custom\n\n\n\nwrappers for interaction with the FloodPlain contract that would validate the order, caller, and the hooks at once, or using a different provider for order fulfillment.\n\nLong term, redesign the rebalance flow in order to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Access Controls",
        "Finding ID": "TOB-BUNNI-6",
        "Target": "src/BunniHook.sol, src/lib/BunniHookLogic.sol"
      },
      "heading_cleaned": "Rebalance mechanism access control can be bypassed"
    },
    {
      "index": 7,
      "page_start": 35,
      "heading": "7. Pools can be drained via the rebalance mechanism by selectively executing the rebalanceOrderPreHook and the rebalanceOrderPostHook",
      "markdown": "### 7. Pools can be drained via the rebalance mechanism by selectively executing the rebalanceOrderPreHook and the rebalanceOrderPostHook\n\n| Severity: High                                           | Diffi culty: Low        |\n|-------------------------------------------------------------|-------------------------------|\n| Type: Data Validation                                 | Finding ID: TOB-BUNNI-7 |\n| Target: src/BunniHook.sol, src/lib/BunniHookLogic.sol |                               |\n\n#### Description\n\nAny pool that has an active rebalance order can be drained because the BunniHook does not enforce that a rebalanceOrderPreHook and rebalanceOrderPostHook need to be executed together.\n\nWhen a rebalance order is fulfilled by using the fulfillOrder function of the FloodPlain contract, the actual data passed to the rebalanceOrderPreHook and rebalanceOrderPostHook functions is arbitrary, as shown in figures 7.1 and 7.2:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 7.1: The fulfillOrder function ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\n```\nfunction execute(IFloodPlain.Hook calldata hook) internal {\n address target = hook.target;\n bytes calldata data = hook.data;\n bytes28 extension;\n assembly (\"memory-safe\") {\n extension := shl(32, calldataload(data.offset))\n }\n require(extension != SELECTOR_EXTENSION, \"MALICIOUS_CALL\");\n assembly (\"memory-safe\") {\n let fmp := mload(0x40)\n calldatacopy(fmp, data.offset, data.length)\n if iszero(call(gas(), target, 0, fmp, data.length, 0, 0)) {\n returndatacopy(0, 0, returndatasize())\n revert(0, returndatasize())\n }\n }\n}\n```\n\n*Figure 7.2: The execute function called on the preHooks and postHooks array elements ([flood-contracts/master/src/lib/Hooks.sol#L9–L27](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/libraries/Hooks.sol#L9-L27))*\n\nThe rebalanceOrderPreHook and rebalanceOrderPostHook functions do check that the data provided matches the hash of both order hooks in the respective functions, as shown in figures 7.3 and 7.4:\n\n```\nIBunniHook.RebalanceOrderHookArgs memory hookArgs =\nIBunniHook.RebalanceOrderHookArgs({\n key: key,\n preHookArgs: IBunniHook.RebalanceOrderPreHookArgs({currency: inputToken, amount:\ninputAmount}),\n postHookArgs: IBunniHook.RebalanceOrderPostHookArgs({currency: outputToken})\n});\n// prehook should pull input tokens from BunniHub to BunniHook and update pool\nbalances\nIFloodPlain.Hook[] memory preHooks = new IFloodPlain.Hook[](1);\npreHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPreHook, (hookArgs))\n});\n// posthook should push output tokens from BunniHook to BunniHub and update pool\nbalances\nIFloodPlain.Hook[] memory postHooks = new IFloodPlain.Hook[](1);\npostHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPostHook, (hookArgs))\n});\n```\n\n\n*Figure 7.3: The hook data creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L696–L714](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L696-L714))*\n\n```\n // verify call came from Flood\n if (msg.sender != address(floodPlain)) {\n revert BunniHook__Unauthorized();\n }\n // ensure args can be trusted\n if (keccak256(abi.encode(hookArgs)) !=\ns.rebalanceOrderHookArgsHash[hookArgs.key.toId()]) {\n revert BunniHook__InvalidRebalanceOrderHookArgs();\n }\n```\n\n*Figure 7.4: The hook data validation in the rebalanceOrderPreHook and rebalanceOrderPostHook functions ([src/BunniHook.sol#L429–L438](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L438) and [src/BunniHook.sol#L465–L474](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L474))*\n\nHowever, as described in [TOB-BUNNI-6,](#page-31-0) we can provide an arbitrary order and then execute any arbitrary valid pre- and post-hook. Additionally, the functions have no way of guaranteeing that the pre- and post-hook for a particular order are executed sequentially and in the same block.\n\nDue to this, an attacker can execute a valid order's pre-hook to increase the balance of the BunniHook, and then drain the balance by executing a malicious pool's post-hook.\n\n#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a pool using the same BunniHook, one malicious token, and USDT. She then creates a fake order, signs it, and submits it to the fulfillOrder function of the FloodPlain contract.\n\nThe valid pre-hook of the honest pool is executed first, increasing the BunniHook balance by 5,000 USDT; then the malicious post-hook is executed, increasing the balance of Eve's pool by 5,000 USDT. Eve then withdraws the liquidity from her malicious pool and steals the 5,000 USDT. She can repeat this action until she fully drains the USDT balance of the honest pool, and then performs swaps in order to drain the other half of the pool.\n\n#### Recommendations\n\nShort term, add a stateful mechanism to the execution of pre- and post-hooks to ensure that they must be executed together.\n\nLong term, redesign the rebalance flow to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n",
      "finding_id": null,
      "markdown_raw": "### <span id=\"page-35-0\"></span>7. Pools can be drained via the rebalance mechanism by selectively executing the rebalanceOrderPreHook and the rebalanceOrderPostHook\n\n| Severity:<br>High                                           | Diffi<br>culty:<br>Low        |\n|-------------------------------------------------------------|-------------------------------|\n| Type:<br>Data<br>Validation                                 | Finding<br>ID:<br>TOB-BUNNI-7 |\n| Target:<br>src/BunniHook.sol,<br>src/lib/BunniHookLogic.sol |                               |\n\n#### Description\n\nAny pool that has an active rebalance order can be drained because the BunniHook does not enforce that a rebalanceOrderPreHook and rebalanceOrderPostHook need to be executed together.\n\nWhen a rebalance order is fulfilled by using the fulfillOrder function of the FloodPlain contract, the actual data passed to the rebalanceOrderPreHook and rebalanceOrderPostHook functions is arbitrary, as shown in figures 7.1 and 7.2:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 7.1: The fulfillOrder function ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n{36}------------------------------------------------\n\n```\nfunction execute(IFloodPlain.Hook calldata hook) internal {\n address target = hook.target;\n bytes calldata data = hook.data;\n bytes28 extension;\n assembly (\"memory-safe\") {\n extension := shl(32, calldataload(data.offset))\n }\n require(extension != SELECTOR_EXTENSION, \"MALICIOUS_CALL\");\n assembly (\"memory-safe\") {\n let fmp := mload(0x40)\n calldatacopy(fmp, data.offset, data.length)\n if iszero(call(gas(), target, 0, fmp, data.length, 0, 0)) {\n returndatacopy(0, 0, returndatasize())\n revert(0, returndatasize())\n }\n }\n}\n```\n\n*Figure 7.2: The execute function called on the preHooks and postHooks array elements ([flood-contracts/master/src/lib/Hooks.sol#L9–L27](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/libraries/Hooks.sol#L9-L27))*\n\nThe rebalanceOrderPreHook and rebalanceOrderPostHook functions do check that the data provided matches the hash of both order hooks in the respective functions, as shown in figures 7.3 and 7.4:\n\n```\nIBunniHook.RebalanceOrderHookArgs memory hookArgs =\nIBunniHook.RebalanceOrderHookArgs({\n key: key,\n preHookArgs: IBunniHook.RebalanceOrderPreHookArgs({currency: inputToken, amount:\ninputAmount}),\n postHookArgs: IBunniHook.RebalanceOrderPostHookArgs({currency: outputToken})\n});\n// prehook should pull input tokens from BunniHub to BunniHook and update pool\nbalances\nIFloodPlain.Hook[] memory preHooks = new IFloodPlain.Hook[](1);\npreHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPreHook, (hookArgs))\n});\n// posthook should push output tokens from BunniHook to BunniHub and update pool\nbalances\nIFloodPlain.Hook[] memory postHooks = new IFloodPlain.Hook[](1);\npostHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPostHook, (hookArgs))\n});\n```\n\n{37}------------------------------------------------\n\n*Figure 7.3: The hook data creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L696–L714](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L696-L714))*\n\n```\n // verify call came from Flood\n if (msg.sender != address(floodPlain)) {\n revert BunniHook__Unauthorized();\n }\n // ensure args can be trusted\n if (keccak256(abi.encode(hookArgs)) !=\ns.rebalanceOrderHookArgsHash[hookArgs.key.toId()]) {\n revert BunniHook__InvalidRebalanceOrderHookArgs();\n }\n```\n\n*Figure 7.4: The hook data validation in the rebalanceOrderPreHook and rebalanceOrderPostHook functions ([src/BunniHook.sol#L429–L438](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L438) and [src/BunniHook.sol#L465–L474](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L474))*\n\nHowever, as described in [TOB-BUNNI-6,](#page-31-0) we can provide an arbitrary order and then execute any arbitrary valid pre- and post-hook. Additionally, the functions have no way of guaranteeing that the pre- and post-hook for a particular order are executed sequentially and in the same block.\n\nDue to this, an attacker can execute a valid order's pre-hook to increase the balance of the BunniHook, and then drain the balance by executing a malicious pool's post-hook.\n\n#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a pool using the same BunniHook, one malicious token, and USDT. She then creates a fake order, signs it, and submits it to the fulfillOrder function of the FloodPlain contract.\n\nThe valid pre-hook of the honest pool is executed first, increasing the BunniHook balance by 5,000 USDT; then the malicious post-hook is executed, increasing the balance of Eve's pool by 5,000 USDT. Eve then withdraws the liquidity from her malicious pool and steals the 5,000 USDT. She can repeat this action until she fully drains the USDT balance of the honest pool, and then performs swaps in order to drain the other half of the pool.\n\n#### Recommendations\n\nShort term, add a stateful mechanism to the execution of pre- and post-hooks to ensure that they must be executed together.\n\nLong term, redesign the rebalance flow to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n\n![](_page_37_Picture_11.jpeg)\n\n{38}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nAny pool that has an active rebalance order can be drained because the BunniHook does not enforce that a rebalanceOrderPreHook and rebalanceOrderPostHook need to be executed together.\n\nWhen a rebalance order is fulfilled by using the fulfillOrder function of the FloodPlain contract, the actual data passed to the rebalanceOrderPreHook and rebalanceOrderPostHook functions is arbitrary, as shown in figures 7.1 and 7.2:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 7.1: The fulfillOrder function ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\n```\nfunction execute(IFloodPlain.Hook calldata hook) internal {\n address target = hook.target;\n bytes calldata data = hook.data;\n bytes28 extension;\n assembly (\"memory-safe\") {\n extension := shl(32, calldataload(data.offset))\n }\n require(extension != SELECTOR_EXTENSION, \"MALICIOUS_CALL\");\n assembly (\"memory-safe\") {\n let fmp := mload(0x40)\n calldatacopy(fmp, data.offset, data.length)\n if iszero(call(gas(), target, 0, fmp, data.length, 0, 0)) {\n returndatacopy(0, 0, returndatasize())\n revert(0, returndatasize())\n }\n }\n}\n```\n\n*Figure 7.2: The execute function called on the preHooks and postHooks array elements ([flood-contracts/master/src/lib/Hooks.sol#L9–L27](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/libraries/Hooks.sol#L9-L27))*\n\nThe rebalanceOrderPreHook and rebalanceOrderPostHook functions do check that the data provided matches the hash of both order hooks in the respective functions, as shown in figures 7.3 and 7.4:\n\n```\nIBunniHook.RebalanceOrderHookArgs memory hookArgs =\nIBunniHook.RebalanceOrderHookArgs({\n key: key,\n preHookArgs: IBunniHook.RebalanceOrderPreHookArgs({currency: inputToken, amount:\ninputAmount}),\n postHookArgs: IBunniHook.RebalanceOrderPostHookArgs({currency: outputToken})\n});\n// prehook should pull input tokens from BunniHub to BunniHook and update pool\nbalances\nIFloodPlain.Hook[] memory preHooks = new IFloodPlain.Hook[](1);\npreHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPreHook, (hookArgs))\n});\n// posthook should push output tokens from BunniHook to BunniHub and update pool\nbalances\nIFloodPlain.Hook[] memory postHooks = new IFloodPlain.Hook[](1);\npostHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPostHook, (hookArgs))\n});\n```\n\n\n*Figure 7.3: The hook data creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L696–L714](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L696-L714))*\n\n```\n // verify call came from Flood\n if (msg.sender != address(floodPlain)) {\n revert BunniHook__Unauthorized();\n }\n // ensure args can be trusted\n if (keccak256(abi.encode(hookArgs)) !=\ns.rebalanceOrderHookArgsHash[hookArgs.key.toId()]) {\n revert BunniHook__InvalidRebalanceOrderHookArgs();\n }\n```\n\n*Figure 7.4: The hook data validation in the rebalanceOrderPreHook and rebalanceOrderPostHook functions ([src/BunniHook.sol#L429–L438](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L438) and [src/BunniHook.sol#L465–L474](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L474))*\n\nHowever, as described in [TOB-BUNNI-6,](#page-31-0) we can provide an arbitrary order and then execute any arbitrary valid pre- and post-hook. Additionally, the functions have no way of guaranteeing that the pre- and post-hook for a particular order are executed sequentially and in the same block.\n\nDue to this, an attacker can execute a valid order's pre-hook to increase the balance of the BunniHook, and then drain the balance by executing a malicious pool's post-hook.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, add a stateful mechanism to the execution of pre- and post-hooks to ensure that they must be executed together.\n\nLong term, redesign the rebalance flow to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n",
        "poc": "#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a pool using the same BunniHook, one malicious token, and USDT. She then creates a fake order, signs it, and submits it to the fulfillOrder function of the FloodPlain contract.\n\nThe valid pre-hook of the honest pool is executed first, increasing the BunniHook balance by 5,000 USDT; then the malicious post-hook is executed, increasing the balance of Eve's pool by 5,000 USDT. Eve then withdraws the liquidity from her malicious pool and steals the 5,000 USDT. She can repeat this action until she fully drains the USDT balance of the honest pool, and then performs swaps in order to drain the other half of the pool.\n",
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nAny pool that has an active rebalance order can be drained because the BunniHook does not enforce that a rebalanceOrderPreHook and rebalanceOrderPostHook need to be executed together.\n\nWhen a rebalance order is fulfilled by using the fulfillOrder function of the FloodPlain contract, the actual data passed to the rebalanceOrderPreHook and rebalanceOrderPostHook functions is arbitrary, as shown in figures 7.1 and 7.2:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 7.1: The fulfillOrder function ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\n```\nfunction execute(IFloodPlain.Hook calldata hook) internal {\n address target = hook.target;\n bytes calldata data = hook.data;\n bytes28 extension;\n assembly (\"memory-safe\") {\n extension := shl(32, calldataload(data.offset))\n }\n require(extension != SELECTOR_EXTENSION, \"MALICIOUS_CALL\");\n assembly (\"memory-safe\") {\n let fmp := mload(0x40)\n calldatacopy(fmp, data.offset, data.length)\n if iszero(call(gas(), target, 0, fmp, data.length, 0, 0)) {\n returndatacopy(0, 0, returndatasize())\n revert(0, returndatasize())\n }\n }\n}\n```\n\n*Figure 7.2: The execute function called on the preHooks and postHooks array elements ([flood-contracts/master/src/lib/Hooks.sol#L9–L27](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/libraries/Hooks.sol#L9-L27))*\n\nThe rebalanceOrderPreHook and rebalanceOrderPostHook functions do check that the data provided matches the hash of both order hooks in the respective functions, as shown in figures 7.3 and 7.4:\n\n```\nIBunniHook.RebalanceOrderHookArgs memory hookArgs =\nIBunniHook.RebalanceOrderHookArgs({\n key: key,\n preHookArgs: IBunniHook.RebalanceOrderPreHookArgs({currency: inputToken, amount:\ninputAmount}),\n postHookArgs: IBunniHook.RebalanceOrderPostHookArgs({currency: outputToken})\n});\n// prehook should pull input tokens from BunniHub to BunniHook and update pool\nbalances\nIFloodPlain.Hook[] memory preHooks = new IFloodPlain.Hook[](1);\npreHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPreHook, (hookArgs))\n});\n// posthook should push output tokens from BunniHook to BunniHub and update pool\nbalances\nIFloodPlain.Hook[] memory postHooks = new IFloodPlain.Hook[](1);\npostHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPostHook, (hookArgs))\n});\n```\n\n\n*Figure 7.3: The hook data creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L696–L714](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L696-L714))*\n\n```\n // verify call came from Flood\n if (msg.sender != address(floodPlain)) {\n revert BunniHook__Unauthorized();\n }\n // ensure args can be trusted\n if (keccak256(abi.encode(hookArgs)) !=\ns.rebalanceOrderHookArgsHash[hookArgs.key.toId()]) {\n revert BunniHook__InvalidRebalanceOrderHookArgs();\n }\n```\n\n*Figure 7.4: The hook data validation in the rebalanceOrderPreHook and rebalanceOrderPostHook functions ([src/BunniHook.sol#L429–L438](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L438) and [src/BunniHook.sol#L465–L474](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L474))*\n\nHowever, as described in [TOB-BUNNI-6,](#page-31-0) we can provide an arbitrary order and then execute any arbitrary valid pre- and post-hook. Additionally, the functions have no way of guaranteeing that the pre- and post-hook for a particular order are executed sequentially and in the same block.\n\nDue to this, an attacker can execute a valid order's pre-hook to increase the balance of the BunniHook, and then drain the balance by executing a malicious pool's post-hook.\n",
      "markdown_body": "| Severity: High                                           | Diffi culty: Low        |\n|-------------------------------------------------------------|-------------------------------|\n| Type: Data Validation                                 | Finding ID: TOB-BUNNI-7 |\n| Target: src/BunniHook.sol, src/lib/BunniHookLogic.sol |                               |\n\n#### Description\n\nAny pool that has an active rebalance order can be drained because the BunniHook does not enforce that a rebalanceOrderPreHook and rebalanceOrderPostHook need to be executed together.\n\nWhen a rebalance order is fulfilled by using the fulfillOrder function of the FloodPlain contract, the actual data passed to the rebalanceOrderPreHook and rebalanceOrderPostHook functions is arbitrary, as shown in figures 7.1 and 7.2:\n\n```\nfunction fulfillOrder(SignedOrder calldata package) external payable nonReentrant {\n Order calldata order = package.order;\n bytes32 orderHash = order.hash();\n // Check zone accepts the fulfiller. Fulfiller is msg.sender in direct fills.\n if (order.zone != address(0)) if (!(IZone(order.zone).validate(order,\nmsg.sender))) revert ZoneDenied();\n // Execute pre hooks.\n order.preHooks.execute();\n // Transfer each offer item to msg.sender using Permit2.\n _permitTransferOffer(order, package.signature, orderHash, msg.sender);\n // Transfer consideration item from msg.sender to offerer.\n uint256 amount = order.consideration.amount;\n IERC20(order.consideration.token).safeTransferFrom(msg.sender, order.recipient,\namount);\n // Execute post hooks.\n order.postHooks.execute();\n // Emit an event signifying that the order has been fulfilled.\n emit OrderFulfilled(orderHash, order.zone, msg.sender, amount);\n}\n```\n\n*Figure 7.1: The fulfillOrder function ([flood-contracts/master/src/FloodPlain.sol#L55–L78](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/FloodPlain.sol#L55-L78))*\n\n\n```\nfunction execute(IFloodPlain.Hook calldata hook) internal {\n address target = hook.target;\n bytes calldata data = hook.data;\n bytes28 extension;\n assembly (\"memory-safe\") {\n extension := shl(32, calldataload(data.offset))\n }\n require(extension != SELECTOR_EXTENSION, \"MALICIOUS_CALL\");\n assembly (\"memory-safe\") {\n let fmp := mload(0x40)\n calldatacopy(fmp, data.offset, data.length)\n if iszero(call(gas(), target, 0, fmp, data.length, 0, 0)) {\n returndatacopy(0, 0, returndatasize())\n revert(0, returndatasize())\n }\n }\n}\n```\n\n*Figure 7.2: The execute function called on the preHooks and postHooks array elements ([flood-contracts/master/src/lib/Hooks.sol#L9–L27](https://github.com/flood-protocol/flood-contracts/blob/c9891965b29f8e32ed00d9b98356a0833f806e18/src/libraries/Hooks.sol#L9-L27))*\n\nThe rebalanceOrderPreHook and rebalanceOrderPostHook functions do check that the data provided matches the hash of both order hooks in the respective functions, as shown in figures 7.3 and 7.4:\n\n```\nIBunniHook.RebalanceOrderHookArgs memory hookArgs =\nIBunniHook.RebalanceOrderHookArgs({\n key: key,\n preHookArgs: IBunniHook.RebalanceOrderPreHookArgs({currency: inputToken, amount:\ninputAmount}),\n postHookArgs: IBunniHook.RebalanceOrderPostHookArgs({currency: outputToken})\n});\n// prehook should pull input tokens from BunniHub to BunniHook and update pool\nbalances\nIFloodPlain.Hook[] memory preHooks = new IFloodPlain.Hook[](1);\npreHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPreHook, (hookArgs))\n});\n// posthook should push output tokens from BunniHook to BunniHub and update pool\nbalances\nIFloodPlain.Hook[] memory postHooks = new IFloodPlain.Hook[](1);\npostHooks[0] = IFloodPlain.Hook({\n target: address(this),\n data: abi.encodeCall(IBunniHook.rebalanceOrderPostHook, (hookArgs))\n});\n```\n\n\n*Figure 7.3: The hook data creation in the \\_createRebalanceOrder function ([src/lib/BunniHookLogic.sol#L696–L714](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L696-L714))*\n\n```\n // verify call came from Flood\n if (msg.sender != address(floodPlain)) {\n revert BunniHook__Unauthorized();\n }\n // ensure args can be trusted\n if (keccak256(abi.encode(hookArgs)) !=\ns.rebalanceOrderHookArgsHash[hookArgs.key.toId()]) {\n revert BunniHook__InvalidRebalanceOrderHookArgs();\n }\n```\n\n*Figure 7.4: The hook data validation in the rebalanceOrderPreHook and rebalanceOrderPostHook functions ([src/BunniHook.sol#L429–L438](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L438) and [src/BunniHook.sol#L465–L474](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L474))*\n\nHowever, as described in [TOB-BUNNI-6,](#page-31-0) we can provide an arbitrary order and then execute any arbitrary valid pre- and post-hook. Additionally, the functions have no way of guaranteeing that the pre- and post-hook for a particular order are executed sequentially and in the same block.\n\nDue to this, an attacker can execute a valid order's pre-hook to increase the balance of the BunniHook, and then drain the balance by executing a malicious pool's post-hook.\n\n#### Exploit Scenario\n\nA pool contains 10,000 USDC and 20,000 USDT, and a rebalance order is created to sell 5,000 USDT and get 5,000 USDC. Eve creates a pool using the same BunniHook, one malicious token, and USDT. She then creates a fake order, signs it, and submits it to the fulfillOrder function of the FloodPlain contract.\n\nThe valid pre-hook of the honest pool is executed first, increasing the BunniHook balance by 5,000 USDT; then the malicious post-hook is executed, increasing the balance of Eve's pool by 5,000 USDT. Eve then withdraws the liquidity from her malicious pool and steals the 5,000 USDT. She can repeat this action until she fully drains the USDT balance of the honest pool, and then performs swaps in order to drain the other half of the pool.\n\n#### Recommendations\n\nShort term, add a stateful mechanism to the execution of pre- and post-hooks to ensure that they must be executed together.\n\nLong term, redesign the rebalance flow to connect the validation and execution of the rebalance actions. Ensure that this feature is thoroughly tested for common adversarial situations.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-7",
        "Target": "src/BunniHook.sol, src/lib/BunniHookLogic.sol"
      },
      "heading_cleaned": "Pools can be drained via the rebalance mechanism by selectively executing the rebalanceOrderPreHook and the rebalanceOrderPostHook"
    },
    {
      "index": 8,
      "page_start": 38,
      "heading": "8. Missing maximum bounds for rebalance parameters Severity: **Informational** Difficulty: **Medium** Type: Data Validation Finding ID: TOB-BUNNI-8 Target: src/BunniHook.sol",
      "markdown": "# 8. Missing maximum bounds for rebalance parameters Severity: **Informational** Difficulty: **Medium** Type: Data Validation Finding ID: TOB-BUNNI-8 Target: src/BunniHook.sol\n\n#### Description\n\nThe rebalance parameter validation lacks maximum bounds. This could allow the parameters to be so large that it affects the correct function of the pool.\n\nWhen a pool and BunniToken are deployed by using the deployBunniToken function of the BunniHub contract, the parameters for rebalancing are validated using the hooks contract, as shown in figure 8.1:\n\n```\nfunction deployBunniToken(HubStorage storage s, Env calldata env,\nIBunniHub.DeployBunniTokenParams calldata params)\n external\n returns (IBunniToken token, PoolKey memory key)\n{\n //...\n // ensure hook params are valid\n if (address(params.hooks) == address(0)) revert BunniHub__HookCannotBeZero();\n if (!params.hooks.isValidParams(params.hookParams)) revert\nBunniHub__InvalidHookParams();\n```\n\n*Figure 8.1: Validation of the rebalance parameters when deploying a pool ([src/lib/BunniHubLogic.sol#L489–L490](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L489-L490))*\n\nIf the hooks contract is the BunniHook contract, the validation ensures that either all or none of the values are set, as shown in figure 8.2:\n\n```\nfunction isValidParams(bytes calldata hookParams) external pure override returns\n(bool) {\n DecodedHookParams memory p = BunniHookLogic.decodeHookParams(hookParams);\n unchecked {\n return (p.feeMin <= p.feeMax) && (p.feeMax < SWAP_FEE_BASE)\n && (p.feeQuadraticMultiplier == 0 || p.feeMin == p.feeMax ||\np.feeTwapSecondsAgo != 0)\n && (p.surgeFee < SWAP_FEE_BASE)\n && (uint256(p.surgeFeeHalfLife) * uint256(p.vaultSurgeThreshold0) *\nuint256(p.vaultSurgeThreshold1) != 0)\n```\n\n\n```\n && (\n (\n p.rebalanceThreshold == 0 && p.rebalanceMaxSlippage == 0 &&\np.rebalanceTwapSecondsAgo == 0\n && p.rebalanceOrderTTL == 0\n )\n || (\n p.rebalanceThreshold != 0 && p.rebalanceMaxSlippage != 0 &&\np.rebalanceTwapSecondsAgo != 0\n && p.rebalanceOrderTTL != 0\n )\n ) && (p.oracleMinInterval != 0);\n }\n}\n```\n\n*Figure 8.2: The rebalance parameter validation in the isValidParams function ([src/BunniHook.sol#L319–L337](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L319-L337))*\n\nHowever, there are no maximum bounds placed on these values, other than the inherent bounds of their types. This means that a user can potentially deploy a pool with rebalance parameters that would prevent the pool from working correctly.\n\n#### Recommendations\n\nShort term, determine reasonable maximum bounds for the rebalanceMaxSlippage, rebalanceTwapSecondsAgo, and rebalanceOrderTTL parameters and enforce them. Clearly document these limits in the user- and developer-facing documentation.\n\nLong term, carefully document all caller-specified values in the system and ensure that they are properly constrained and documented.\n",
      "finding_id": null,
      "markdown_raw": "# <span id=\"page-38-0\"></span>8. Missing maximum bounds for rebalance parameters Severity: **Informational** Difficulty: **Medium** Type: Data Validation Finding ID: TOB-BUNNI-8 Target: src/BunniHook.sol\n\n#### Description\n\nThe rebalance parameter validation lacks maximum bounds. This could allow the parameters to be so large that it affects the correct function of the pool.\n\nWhen a pool and BunniToken are deployed by using the deployBunniToken function of the BunniHub contract, the parameters for rebalancing are validated using the hooks contract, as shown in figure 8.1:\n\n```\nfunction deployBunniToken(HubStorage storage s, Env calldata env,\nIBunniHub.DeployBunniTokenParams calldata params)\n external\n returns (IBunniToken token, PoolKey memory key)\n{\n //...\n // ensure hook params are valid\n if (address(params.hooks) == address(0)) revert BunniHub__HookCannotBeZero();\n if (!params.hooks.isValidParams(params.hookParams)) revert\nBunniHub__InvalidHookParams();\n```\n\n*Figure 8.1: Validation of the rebalance parameters when deploying a pool ([src/lib/BunniHubLogic.sol#L489–L490](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L489-L490))*\n\nIf the hooks contract is the BunniHook contract, the validation ensures that either all or none of the values are set, as shown in figure 8.2:\n\n```\nfunction isValidParams(bytes calldata hookParams) external pure override returns\n(bool) {\n DecodedHookParams memory p = BunniHookLogic.decodeHookParams(hookParams);\n unchecked {\n return (p.feeMin <= p.feeMax) && (p.feeMax < SWAP_FEE_BASE)\n && (p.feeQuadraticMultiplier == 0 || p.feeMin == p.feeMax ||\np.feeTwapSecondsAgo != 0)\n && (p.surgeFee < SWAP_FEE_BASE)\n && (uint256(p.surgeFeeHalfLife) * uint256(p.vaultSurgeThreshold0) *\nuint256(p.vaultSurgeThreshold1) != 0)\n```\n\n{39}------------------------------------------------\n\n```\n && (\n (\n p.rebalanceThreshold == 0 && p.rebalanceMaxSlippage == 0 &&\np.rebalanceTwapSecondsAgo == 0\n && p.rebalanceOrderTTL == 0\n )\n || (\n p.rebalanceThreshold != 0 && p.rebalanceMaxSlippage != 0 &&\np.rebalanceTwapSecondsAgo != 0\n && p.rebalanceOrderTTL != 0\n )\n ) && (p.oracleMinInterval != 0);\n }\n}\n```\n\n*Figure 8.2: The rebalance parameter validation in the isValidParams function ([src/BunniHook.sol#L319–L337](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L319-L337))*\n\nHowever, there are no maximum bounds placed on these values, other than the inherent bounds of their types. This means that a user can potentially deploy a pool with rebalance parameters that would prevent the pool from working correctly.\n\n#### Recommendations\n\nShort term, determine reasonable maximum bounds for the rebalanceMaxSlippage, rebalanceTwapSecondsAgo, and rebalanceOrderTTL parameters and enforce them. Clearly document these limits in the user- and developer-facing documentation.\n\nLong term, carefully document all caller-specified values in the system and ensure that they are properly constrained and documented.\n\n{40}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe rebalance parameter validation lacks maximum bounds. This could allow the parameters to be so large that it affects the correct function of the pool.\n\nWhen a pool and BunniToken are deployed by using the deployBunniToken function of the BunniHub contract, the parameters for rebalancing are validated using the hooks contract, as shown in figure 8.1:\n\n```\nfunction deployBunniToken(HubStorage storage s, Env calldata env,\nIBunniHub.DeployBunniTokenParams calldata params)\n external\n returns (IBunniToken token, PoolKey memory key)\n{\n //...\n // ensure hook params are valid\n if (address(params.hooks) == address(0)) revert BunniHub__HookCannotBeZero();\n if (!params.hooks.isValidParams(params.hookParams)) revert\nBunniHub__InvalidHookParams();\n```\n\n*Figure 8.1: Validation of the rebalance parameters when deploying a pool ([src/lib/BunniHubLogic.sol#L489–L490](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L489-L490))*\n\nIf the hooks contract is the BunniHook contract, the validation ensures that either all or none of the values are set, as shown in figure 8.2:\n\n```\nfunction isValidParams(bytes calldata hookParams) external pure override returns\n(bool) {\n DecodedHookParams memory p = BunniHookLogic.decodeHookParams(hookParams);\n unchecked {\n return (p.feeMin <= p.feeMax) && (p.feeMax < SWAP_FEE_BASE)\n && (p.feeQuadraticMultiplier == 0 || p.feeMin == p.feeMax ||\np.feeTwapSecondsAgo != 0)\n && (p.surgeFee < SWAP_FEE_BASE)\n && (uint256(p.surgeFeeHalfLife) * uint256(p.vaultSurgeThreshold0) *\nuint256(p.vaultSurgeThreshold1) != 0)\n```\n\n\n```\n && (\n (\n p.rebalanceThreshold == 0 && p.rebalanceMaxSlippage == 0 &&\np.rebalanceTwapSecondsAgo == 0\n && p.rebalanceOrderTTL == 0\n )\n || (\n p.rebalanceThreshold != 0 && p.rebalanceMaxSlippage != 0 &&\np.rebalanceTwapSecondsAgo != 0\n && p.rebalanceOrderTTL != 0\n )\n ) && (p.oracleMinInterval != 0);\n }\n}\n```\n\n*Figure 8.2: The rebalance parameter validation in the isValidParams function ([src/BunniHook.sol#L319–L337](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L319-L337))*\n\nHowever, there are no maximum bounds placed on these values, other than the inherent bounds of their types. This means that a user can potentially deploy a pool with rebalance parameters that would prevent the pool from working correctly.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, determine reasonable maximum bounds for the rebalanceMaxSlippage, rebalanceTwapSecondsAgo, and rebalanceOrderTTL parameters and enforce them. Clearly document these limits in the user- and developer-facing documentation.\n\nLong term, carefully document all caller-specified values in the system and ensure that they are properly constrained and documented.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe rebalance parameter validation lacks maximum bounds. This could allow the parameters to be so large that it affects the correct function of the pool.\n\nWhen a pool and BunniToken are deployed by using the deployBunniToken function of the BunniHub contract, the parameters for rebalancing are validated using the hooks contract, as shown in figure 8.1:\n\n```\nfunction deployBunniToken(HubStorage storage s, Env calldata env,\nIBunniHub.DeployBunniTokenParams calldata params)\n external\n returns (IBunniToken token, PoolKey memory key)\n{\n //...\n // ensure hook params are valid\n if (address(params.hooks) == address(0)) revert BunniHub__HookCannotBeZero();\n if (!params.hooks.isValidParams(params.hookParams)) revert\nBunniHub__InvalidHookParams();\n```\n\n*Figure 8.1: Validation of the rebalance parameters when deploying a pool ([src/lib/BunniHubLogic.sol#L489–L490](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L489-L490))*\n\nIf the hooks contract is the BunniHook contract, the validation ensures that either all or none of the values are set, as shown in figure 8.2:\n\n```\nfunction isValidParams(bytes calldata hookParams) external pure override returns\n(bool) {\n DecodedHookParams memory p = BunniHookLogic.decodeHookParams(hookParams);\n unchecked {\n return (p.feeMin <= p.feeMax) && (p.feeMax < SWAP_FEE_BASE)\n && (p.feeQuadraticMultiplier == 0 || p.feeMin == p.feeMax ||\np.feeTwapSecondsAgo != 0)\n && (p.surgeFee < SWAP_FEE_BASE)\n && (uint256(p.surgeFeeHalfLife) * uint256(p.vaultSurgeThreshold0) *\nuint256(p.vaultSurgeThreshold1) != 0)\n```\n\n\n```\n && (\n (\n p.rebalanceThreshold == 0 && p.rebalanceMaxSlippage == 0 &&\np.rebalanceTwapSecondsAgo == 0\n && p.rebalanceOrderTTL == 0\n )\n || (\n p.rebalanceThreshold != 0 && p.rebalanceMaxSlippage != 0 &&\np.rebalanceTwapSecondsAgo != 0\n && p.rebalanceOrderTTL != 0\n )\n ) && (p.oracleMinInterval != 0);\n }\n}\n```\n\n*Figure 8.2: The rebalance parameter validation in the isValidParams function ([src/BunniHook.sol#L319–L337](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L319-L337))*\n\nHowever, there are no maximum bounds placed on these values, other than the inherent bounds of their types. This means that a user can potentially deploy a pool with rebalance parameters that would prevent the pool from working correctly.\n",
      "markdown_body": "#### Description\n\nThe rebalance parameter validation lacks maximum bounds. This could allow the parameters to be so large that it affects the correct function of the pool.\n\nWhen a pool and BunniToken are deployed by using the deployBunniToken function of the BunniHub contract, the parameters for rebalancing are validated using the hooks contract, as shown in figure 8.1:\n\n```\nfunction deployBunniToken(HubStorage storage s, Env calldata env,\nIBunniHub.DeployBunniTokenParams calldata params)\n external\n returns (IBunniToken token, PoolKey memory key)\n{\n //...\n // ensure hook params are valid\n if (address(params.hooks) == address(0)) revert BunniHub__HookCannotBeZero();\n if (!params.hooks.isValidParams(params.hookParams)) revert\nBunniHub__InvalidHookParams();\n```\n\n*Figure 8.1: Validation of the rebalance parameters when deploying a pool ([src/lib/BunniHubLogic.sol#L489–L490](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L489-L490))*\n\nIf the hooks contract is the BunniHook contract, the validation ensures that either all or none of the values are set, as shown in figure 8.2:\n\n```\nfunction isValidParams(bytes calldata hookParams) external pure override returns\n(bool) {\n DecodedHookParams memory p = BunniHookLogic.decodeHookParams(hookParams);\n unchecked {\n return (p.feeMin <= p.feeMax) && (p.feeMax < SWAP_FEE_BASE)\n && (p.feeQuadraticMultiplier == 0 || p.feeMin == p.feeMax ||\np.feeTwapSecondsAgo != 0)\n && (p.surgeFee < SWAP_FEE_BASE)\n && (uint256(p.surgeFeeHalfLife) * uint256(p.vaultSurgeThreshold0) *\nuint256(p.vaultSurgeThreshold1) != 0)\n```\n\n\n```\n && (\n (\n p.rebalanceThreshold == 0 && p.rebalanceMaxSlippage == 0 &&\np.rebalanceTwapSecondsAgo == 0\n && p.rebalanceOrderTTL == 0\n )\n || (\n p.rebalanceThreshold != 0 && p.rebalanceMaxSlippage != 0 &&\np.rebalanceTwapSecondsAgo != 0\n && p.rebalanceOrderTTL != 0\n )\n ) && (p.oracleMinInterval != 0);\n }\n}\n```\n\n*Figure 8.2: The rebalance parameter validation in the isValidParams function ([src/BunniHook.sol#L319–L337](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L319-L337))*\n\nHowever, there are no maximum bounds placed on these values, other than the inherent bounds of their types. This means that a user can potentially deploy a pool with rebalance parameters that would prevent the pool from working correctly.\n\n#### Recommendations\n\nShort term, determine reasonable maximum bounds for the rebalanceMaxSlippage, rebalanceTwapSecondsAgo, and rebalanceOrderTTL parameters and enforce them. Clearly document these limits in the user- and developer-facing documentation.\n\nLong term, carefully document all caller-specified values in the system and ensure that they are properly constrained and documented.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Medium",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-8",
        "Target": "src/BunniHook.sol"
      },
      "heading_cleaned": "Missing maximum bounds for rebalance parameters"
    },
    {
      "index": 9,
      "page_start": 40,
      "heading": "9. Excess liquidity can be inflated to create arbitrarily large rebalance orders",
      "markdown": "### 9. Excess liquidity can be inflated to create arbitrarily large rebalance orders\n\n| Severity: High                                                   | Diffi culty: Low        |\n|---------------------------------------------------------------------|-------------------------------|\n| Type: Data Validation                                         | Finding ID: TOB-BUNNI-9 |\n| Target: src/lib/BunniHookLogic.sol, src/lib/BunniHubLogic.sol |                               |\n\n#### Description\n\nThe liquidity density functions used by Bunni v2 pools can be configured to adapt to changes in market conditions. As a result, the protocol also includes a mechanism to autonomously rebalance the holdings of a pool to maximize the liquidity available. However, the way liquidity is added and removed from pools can be leveraged to artificially inflate pool balances temporarily in order to create abnormally large and profitable rebalance orders.\n\nThe amount of liquidity in a pool can be calculated by multiplying a token's balance by the overall token density according to the LDF. Since we have two tokens per pool, each with independent balances and densities, we can infer two possible liquidity amounts (figure 9.1). Under normal conditions, these values should be approximately equal, but if the LDF shifts or morphs somehow, the densities of each token may change. Since the balances will remain constant, this means that the liquidity values implied by the balances may differ. If the difference in these liquidity estimates exceeds a pool-configured threshold (figure 9.2), a rebalance order will be issued through flood.bid that trades a portion of the excess token to increase the overall liquidity.\n\n```\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\nif (totalLiquidityEstimate0 == 0) {\n totalLiquidity = totalLiquidityEstimate1;\n} else if (totalLiquidityEstimate1 == 0) {\n totalLiquidity = totalLiquidityEstimate0;\n} else {\n totalLiquidity = FixedPointMathLib.min(totalLiquidityEstimate0,\ntotalLiquidityEstimate1);\n}\n```\n\n*Figure 9.1: A snippet of the queryLDF function showing how totalLiquidity is calculated ([src/lib/QueryLDF.sol#L72–L84](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L72-L84))*\n\n\n```\n// should rebalance if excessLiquidity / totalLiquidity >= 1 / rebalanceThreshold\nbool shouldRebalance0 =\n excessLiquidity0 != 0 && excessLiquidity0 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nbool shouldRebalance1 =\n excessLiquidity1 != 0 && excessLiquidity1 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nif (!shouldRebalance0 && !shouldRebalance1) return (false, inputToken, outputToken,\ninputAmount, outputAmount);\n```\n\n*Figure 9.2: A snippet of the \\_computeRebalanceParams function that checks if a rebalance order should be created ([src/lib/BunniHookLogic.sol#L618–L623](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L618-L623))*\n\nTo simplify the process of adding and removing liquidity after the pool has been initialized with some balance, these operations allow tokens to be added or removed from the pool only in proportion to the current balances (figure 9.3). Note that these balances include any excess liquidity; as a result, the overall proportion of excess liquidity will remain the same when liquidity is added or removed.\n\n```\n(returnData.balance0, returnData.balance1) =\n (inputData.state.rawBalance0 + reserveBalance0, inputData.state.rawBalance1 +\nreserveBalance1);\n// update TWAP oracle and optionally observe\nbool requiresLDF = returnData.balance0 == 0 && returnData.balance1 == 0;\nif (requiresLDF) {\n ...\n} else {\n // already initialized liquidity shape\n // simply add tokens at the current ratio\n // need to update: reserveAmount0, reserveAmount1, amount0, amount1\n // compute amount0 and amount1 such that the ratio is the same as the current\nratio\n uint256 amount0Desired = inputData.params.amount0Desired;\n uint256 amount1Desired = inputData.params.amount1Desired;\n uint256 balance0 = returnData.balance0;\n uint256 balance1 = returnData.balance1;\n returnData.amount0 = balance1 == 0\n ? amount0Desired\n : FixedPointMathLib.min(amount0Desired, amount1Desired.mulDiv(balance0,\nbalance1));\n returnData.amount1 = balance0 == 0\n ? amount1Desired\n : FixedPointMathLib.min(amount1Desired, amount0Desired.mulDiv(balance1,\nbalance0));\n```\n\n*Figure 9.3: A snippet of the \\_depositLogic function that shows how the token amounts to be deposited are calculated for initialized pools ([src/lib/BunniHubLogic.sol#L226–L312](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L226-L312))*\n\n\nSince rebalance orders are emitted automatically after a swap as a result of pool/market conditions, a malicious fulfiller can anticipate when this will occur and inject a large amount of liquidity before the rebalance order is calculated, remove the liquidity after the order is issued, then fill the order himself, profiting from the slippage tolerance (figure 9.4) and leaving the pool in an incredibly unbalanced state.\n\n```\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n// compute target amounts (i.e. the token amounts of the excess liquidity)\nuint256 excessLiquidity = willRebalanceToken0 ? excessLiquidity0 : excessLiquidity1;\nuint256 targetAmount0 = excessLiquidity.fullMulDiv(totalDensity0X96, Q96);\nuint256 targetAmount1 = excessLiquidity.fullMulDiv(totalDensity1X96, Q96);\n// determine input & output\n(inputToken, outputToken) = willRebalanceToken0\n ? (input.key.currency0, input.key.currency1)\n : (input.key.currency1, input.key.currency0);\nuint256 inputTokenExcessBalance =\n willRebalanceToken0 ? balance0 - currentActiveBalance0 : balance1 -\ncurrentActiveBalance1;\nuint256 inputTokenTarget = willRebalanceToken0 ? targetAmount0 : targetAmount1;\nuint256 outputTokenTarget = willRebalanceToken0 ? targetAmount1 : targetAmount0;\nif (inputTokenExcessBalance < inputTokenTarget) {\n // should never happen\n return (false, inputToken, outputToken, inputAmount, outputAmount);\n}\ninputAmount = inputTokenExcessBalance - inputTokenTarget;\noutputAmount = outputTokenTarget.mulDivUp(1e5 -\ninput.hookParams.rebalanceMaxSlippage, 1e5);\n```\n\n*Figure 9.4: A snippet of the \\_computeRebalanceParams function that shows the calculation of the amounts of tokens for the rebalance order ([src/lib/BunniHookLogic.sol#L652–L672](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L652-L672))*\n\nIf there is an active AmAmm manager, withdrawals would be subject to a timeout window, but the version of the code under review has a known issue that allows this to be bypassed. Since the AmAmm manager is also included on the allowlist of fulfillers, this would allow arbitrary attackers to fulfill orders provided they win the AmAmm auction 24 hours in advance. Otherwise, any allowlisted fulfiller would be able to execute this attack.\n\nAdditionally, regular depositors could use flash loans to provide just-in-time liquidity to inflate the rebalance order to require a greater amount of tokens than would naturally be in the pool, requiring fulfillers to also take the extra step of providing just-in-time liquidity back into the pool to carry out the rebalance, resulting in a swap that is less profitable than it appeared based on the order parameters alone.\n\n#### Exploit Scenario\n\nA pool's LDF shifts and has 120 TokenA and 100 TokenB, but the active balance of TokenA is only 100. Alice, a malicious fulfiller, notices that the pool will rebalance and deposits 1,080\n\n\n\nTokenA and 900 TokenB so the pool has 1,200 TokenA and 1,000 TokenB in total. She makes a small swap to trigger the creation of a rebalance order. This pool has a 5% rebalance slippage tolerance so the rebalance order will sell 100 TokenA for 95 TokenB. Alice withdraws all of her original liquidity and immediately fills the rebalance order. As a result, the pool has 20 TokenA and 195 TokenB. If Alice had not provided just-in-time liquidity, the pool would have only swapped 10 TokenA for 9.5 TokenB and ended at a total of 110 TokenA and 109.5 TokenB. Since the target ratio for the tokens is currently 1:1, we can assume they have the same price, and see that if each token was worth \\$1, Alice made an excess profit of \\$4.50, or just over 2% of the original total pool value.\n\n#### Recommendations\n\nShort term, add a check to enforce the withdrawal queue when rebalanceOrderDeadline is in the future.\n\nLong term, consider changing the add/remove liquidity flows to account for excess liquidity or adding checks to the rebalance hooks that enforce that the pool is in an improved state after the rebalance.\n",
      "finding_id": null,
      "markdown_raw": "### <span id=\"page-40-0\"></span>9. Excess liquidity can be inflated to create arbitrarily large rebalance orders\n\n| Severity:<br>High                                                   | Diffi<br>culty:<br>Low        |\n|---------------------------------------------------------------------|-------------------------------|\n| Type:<br>Data<br>Validation                                         | Finding<br>ID:<br>TOB-BUNNI-9 |\n| Target:<br>src/lib/BunniHookLogic.sol,<br>src/lib/BunniHubLogic.sol |                               |\n\n#### Description\n\nThe liquidity density functions used by Bunni v2 pools can be configured to adapt to changes in market conditions. As a result, the protocol also includes a mechanism to autonomously rebalance the holdings of a pool to maximize the liquidity available. However, the way liquidity is added and removed from pools can be leveraged to artificially inflate pool balances temporarily in order to create abnormally large and profitable rebalance orders.\n\nThe amount of liquidity in a pool can be calculated by multiplying a token's balance by the overall token density according to the LDF. Since we have two tokens per pool, each with independent balances and densities, we can infer two possible liquidity amounts (figure 9.1). Under normal conditions, these values should be approximately equal, but if the LDF shifts or morphs somehow, the densities of each token may change. Since the balances will remain constant, this means that the liquidity values implied by the balances may differ. If the difference in these liquidity estimates exceeds a pool-configured threshold (figure 9.2), a rebalance order will be issued through flood.bid that trades a portion of the excess token to increase the overall liquidity.\n\n```\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\nif (totalLiquidityEstimate0 == 0) {\n totalLiquidity = totalLiquidityEstimate1;\n} else if (totalLiquidityEstimate1 == 0) {\n totalLiquidity = totalLiquidityEstimate0;\n} else {\n totalLiquidity = FixedPointMathLib.min(totalLiquidityEstimate0,\ntotalLiquidityEstimate1);\n}\n```\n\n*Figure 9.1: A snippet of the queryLDF function showing how totalLiquidity is calculated ([src/lib/QueryLDF.sol#L72–L84](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L72-L84))*\n\n{41}------------------------------------------------\n\n```\n// should rebalance if excessLiquidity / totalLiquidity >= 1 / rebalanceThreshold\nbool shouldRebalance0 =\n excessLiquidity0 != 0 && excessLiquidity0 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nbool shouldRebalance1 =\n excessLiquidity1 != 0 && excessLiquidity1 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nif (!shouldRebalance0 && !shouldRebalance1) return (false, inputToken, outputToken,\ninputAmount, outputAmount);\n```\n\n*Figure 9.2: A snippet of the \\_computeRebalanceParams function that checks if a rebalance order should be created ([src/lib/BunniHookLogic.sol#L618–L623](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L618-L623))*\n\nTo simplify the process of adding and removing liquidity after the pool has been initialized with some balance, these operations allow tokens to be added or removed from the pool only in proportion to the current balances (figure 9.3). Note that these balances include any excess liquidity; as a result, the overall proportion of excess liquidity will remain the same when liquidity is added or removed.\n\n```\n(returnData.balance0, returnData.balance1) =\n (inputData.state.rawBalance0 + reserveBalance0, inputData.state.rawBalance1 +\nreserveBalance1);\n// update TWAP oracle and optionally observe\nbool requiresLDF = returnData.balance0 == 0 && returnData.balance1 == 0;\nif (requiresLDF) {\n ...\n} else {\n // already initialized liquidity shape\n // simply add tokens at the current ratio\n // need to update: reserveAmount0, reserveAmount1, amount0, amount1\n // compute amount0 and amount1 such that the ratio is the same as the current\nratio\n uint256 amount0Desired = inputData.params.amount0Desired;\n uint256 amount1Desired = inputData.params.amount1Desired;\n uint256 balance0 = returnData.balance0;\n uint256 balance1 = returnData.balance1;\n returnData.amount0 = balance1 == 0\n ? amount0Desired\n : FixedPointMathLib.min(amount0Desired, amount1Desired.mulDiv(balance0,\nbalance1));\n returnData.amount1 = balance0 == 0\n ? amount1Desired\n : FixedPointMathLib.min(amount1Desired, amount0Desired.mulDiv(balance1,\nbalance0));\n```\n\n*Figure 9.3: A snippet of the \\_depositLogic function that shows how the token amounts to be deposited are calculated for initialized pools ([src/lib/BunniHubLogic.sol#L226–L312](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L226-L312))*\n\n{42}------------------------------------------------\n\nSince rebalance orders are emitted automatically after a swap as a result of pool/market conditions, a malicious fulfiller can anticipate when this will occur and inject a large amount of liquidity before the rebalance order is calculated, remove the liquidity after the order is issued, then fill the order himself, profiting from the slippage tolerance (figure 9.4) and leaving the pool in an incredibly unbalanced state.\n\n```\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n// compute target amounts (i.e. the token amounts of the excess liquidity)\nuint256 excessLiquidity = willRebalanceToken0 ? excessLiquidity0 : excessLiquidity1;\nuint256 targetAmount0 = excessLiquidity.fullMulDiv(totalDensity0X96, Q96);\nuint256 targetAmount1 = excessLiquidity.fullMulDiv(totalDensity1X96, Q96);\n// determine input & output\n(inputToken, outputToken) = willRebalanceToken0\n ? (input.key.currency0, input.key.currency1)\n : (input.key.currency1, input.key.currency0);\nuint256 inputTokenExcessBalance =\n willRebalanceToken0 ? balance0 - currentActiveBalance0 : balance1 -\ncurrentActiveBalance1;\nuint256 inputTokenTarget = willRebalanceToken0 ? targetAmount0 : targetAmount1;\nuint256 outputTokenTarget = willRebalanceToken0 ? targetAmount1 : targetAmount0;\nif (inputTokenExcessBalance < inputTokenTarget) {\n // should never happen\n return (false, inputToken, outputToken, inputAmount, outputAmount);\n}\ninputAmount = inputTokenExcessBalance - inputTokenTarget;\noutputAmount = outputTokenTarget.mulDivUp(1e5 -\ninput.hookParams.rebalanceMaxSlippage, 1e5);\n```\n\n*Figure 9.4: A snippet of the \\_computeRebalanceParams function that shows the calculation of the amounts of tokens for the rebalance order ([src/lib/BunniHookLogic.sol#L652–L672](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L652-L672))*\n\nIf there is an active AmAmm manager, withdrawals would be subject to a timeout window, but the version of the code under review has a known issue that allows this to be bypassed. Since the AmAmm manager is also included on the allowlist of fulfillers, this would allow arbitrary attackers to fulfill orders provided they win the AmAmm auction 24 hours in advance. Otherwise, any allowlisted fulfiller would be able to execute this attack.\n\nAdditionally, regular depositors could use flash loans to provide just-in-time liquidity to inflate the rebalance order to require a greater amount of tokens than would naturally be in the pool, requiring fulfillers to also take the extra step of providing just-in-time liquidity back into the pool to carry out the rebalance, resulting in a swap that is less profitable than it appeared based on the order parameters alone.\n\n#### Exploit Scenario\n\nA pool's LDF shifts and has 120 TokenA and 100 TokenB, but the active balance of TokenA is only 100. Alice, a malicious fulfiller, notices that the pool will rebalance and deposits 1,080\n\n![](_page_42_Picture_7.jpeg)\n\n{43}------------------------------------------------\n\nTokenA and 900 TokenB so the pool has 1,200 TokenA and 1,000 TokenB in total. She makes a small swap to trigger the creation of a rebalance order. This pool has a 5% rebalance slippage tolerance so the rebalance order will sell 100 TokenA for 95 TokenB. Alice withdraws all of her original liquidity and immediately fills the rebalance order. As a result, the pool has 20 TokenA and 195 TokenB. If Alice had not provided just-in-time liquidity, the pool would have only swapped 10 TokenA for 9.5 TokenB and ended at a total of 110 TokenA and 109.5 TokenB. Since the target ratio for the tokens is currently 1:1, we can assume they have the same price, and see that if each token was worth \\$1, Alice made an excess profit of \\$4.50, or just over 2% of the original total pool value.\n\n#### Recommendations\n\nShort term, add a check to enforce the withdrawal queue when rebalanceOrderDeadline is in the future.\n\nLong term, consider changing the add/remove liquidity flows to account for excess liquidity or adding checks to the rebalance hooks that enforce that the pool is in an improved state after the rebalance.\n\n{44}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe liquidity density functions used by Bunni v2 pools can be configured to adapt to changes in market conditions. As a result, the protocol also includes a mechanism to autonomously rebalance the holdings of a pool to maximize the liquidity available. However, the way liquidity is added and removed from pools can be leveraged to artificially inflate pool balances temporarily in order to create abnormally large and profitable rebalance orders.\n\nThe amount of liquidity in a pool can be calculated by multiplying a token's balance by the overall token density according to the LDF. Since we have two tokens per pool, each with independent balances and densities, we can infer two possible liquidity amounts (figure 9.1). Under normal conditions, these values should be approximately equal, but if the LDF shifts or morphs somehow, the densities of each token may change. Since the balances will remain constant, this means that the liquidity values implied by the balances may differ. If the difference in these liquidity estimates exceeds a pool-configured threshold (figure 9.2), a rebalance order will be issued through flood.bid that trades a portion of the excess token to increase the overall liquidity.\n\n```\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\nif (totalLiquidityEstimate0 == 0) {\n totalLiquidity = totalLiquidityEstimate1;\n} else if (totalLiquidityEstimate1 == 0) {\n totalLiquidity = totalLiquidityEstimate0;\n} else {\n totalLiquidity = FixedPointMathLib.min(totalLiquidityEstimate0,\ntotalLiquidityEstimate1);\n}\n```\n\n*Figure 9.1: A snippet of the queryLDF function showing how totalLiquidity is calculated ([src/lib/QueryLDF.sol#L72–L84](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L72-L84))*\n\n\n```\n// should rebalance if excessLiquidity / totalLiquidity >= 1 / rebalanceThreshold\nbool shouldRebalance0 =\n excessLiquidity0 != 0 && excessLiquidity0 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nbool shouldRebalance1 =\n excessLiquidity1 != 0 && excessLiquidity1 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nif (!shouldRebalance0 && !shouldRebalance1) return (false, inputToken, outputToken,\ninputAmount, outputAmount);\n```\n\n*Figure 9.2: A snippet of the \\_computeRebalanceParams function that checks if a rebalance order should be created ([src/lib/BunniHookLogic.sol#L618–L623](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L618-L623))*\n\nTo simplify the process of adding and removing liquidity after the pool has been initialized with some balance, these operations allow tokens to be added or removed from the pool only in proportion to the current balances (figure 9.3). Note that these balances include any excess liquidity; as a result, the overall proportion of excess liquidity will remain the same when liquidity is added or removed.\n\n```\n(returnData.balance0, returnData.balance1) =\n (inputData.state.rawBalance0 + reserveBalance0, inputData.state.rawBalance1 +\nreserveBalance1);\n// update TWAP oracle and optionally observe\nbool requiresLDF = returnData.balance0 == 0 && returnData.balance1 == 0;\nif (requiresLDF) {\n ...\n} else {\n // already initialized liquidity shape\n // simply add tokens at the current ratio\n // need to update: reserveAmount0, reserveAmount1, amount0, amount1\n // compute amount0 and amount1 such that the ratio is the same as the current\nratio\n uint256 amount0Desired = inputData.params.amount0Desired;\n uint256 amount1Desired = inputData.params.amount1Desired;\n uint256 balance0 = returnData.balance0;\n uint256 balance1 = returnData.balance1;\n returnData.amount0 = balance1 == 0\n ? amount0Desired\n : FixedPointMathLib.min(amount0Desired, amount1Desired.mulDiv(balance0,\nbalance1));\n returnData.amount1 = balance0 == 0\n ? amount1Desired\n : FixedPointMathLib.min(amount1Desired, amount0Desired.mulDiv(balance1,\nbalance0));\n```\n\n*Figure 9.3: A snippet of the \\_depositLogic function that shows how the token amounts to be deposited are calculated for initialized pools ([src/lib/BunniHubLogic.sol#L226–L312](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L226-L312))*\n\n\nSince rebalance orders are emitted automatically after a swap as a result of pool/market conditions, a malicious fulfiller can anticipate when this will occur and inject a large amount of liquidity before the rebalance order is calculated, remove the liquidity after the order is issued, then fill the order himself, profiting from the slippage tolerance (figure 9.4) and leaving the pool in an incredibly unbalanced state.\n\n```\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n// compute target amounts (i.e. the token amounts of the excess liquidity)\nuint256 excessLiquidity = willRebalanceToken0 ? excessLiquidity0 : excessLiquidity1;\nuint256 targetAmount0 = excessLiquidity.fullMulDiv(totalDensity0X96, Q96);\nuint256 targetAmount1 = excessLiquidity.fullMulDiv(totalDensity1X96, Q96);\n// determine input & output\n(inputToken, outputToken) = willRebalanceToken0\n ? (input.key.currency0, input.key.currency1)\n : (input.key.currency1, input.key.currency0);\nuint256 inputTokenExcessBalance =\n willRebalanceToken0 ? balance0 - currentActiveBalance0 : balance1 -\ncurrentActiveBalance1;\nuint256 inputTokenTarget = willRebalanceToken0 ? targetAmount0 : targetAmount1;\nuint256 outputTokenTarget = willRebalanceToken0 ? targetAmount1 : targetAmount0;\nif (inputTokenExcessBalance < inputTokenTarget) {\n // should never happen\n return (false, inputToken, outputToken, inputAmount, outputAmount);\n}\ninputAmount = inputTokenExcessBalance - inputTokenTarget;\noutputAmount = outputTokenTarget.mulDivUp(1e5 -\ninput.hookParams.rebalanceMaxSlippage, 1e5);\n```\n\n*Figure 9.4: A snippet of the \\_computeRebalanceParams function that shows the calculation of the amounts of tokens for the rebalance order ([src/lib/BunniHookLogic.sol#L652–L672](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L652-L672))*\n\nIf there is an active AmAmm manager, withdrawals would be subject to a timeout window, but the version of the code under review has a known issue that allows this to be bypassed. Since the AmAmm manager is also included on the allowlist of fulfillers, this would allow arbitrary attackers to fulfill orders provided they win the AmAmm auction 24 hours in advance. Otherwise, any allowlisted fulfiller would be able to execute this attack.\n\nAdditionally, regular depositors could use flash loans to provide just-in-time liquidity to inflate the rebalance order to require a greater amount of tokens than would naturally be in the pool, requiring fulfillers to also take the extra step of providing just-in-time liquidity back into the pool to carry out the rebalance, resulting in a swap that is less profitable than it appeared based on the order parameters alone.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, add a check to enforce the withdrawal queue when rebalanceOrderDeadline is in the future.\n\nLong term, consider changing the add/remove liquidity flows to account for excess liquidity or adding checks to the rebalance hooks that enforce that the pool is in an improved state after the rebalance.\n",
        "poc": "#### Exploit Scenario\n\nA pool's LDF shifts and has 120 TokenA and 100 TokenB, but the active balance of TokenA is only 100. Alice, a malicious fulfiller, notices that the pool will rebalance and deposits 1,080\n\n\n\nTokenA and 900 TokenB so the pool has 1,200 TokenA and 1,000 TokenB in total. She makes a small swap to trigger the creation of a rebalance order. This pool has a 5% rebalance slippage tolerance so the rebalance order will sell 100 TokenA for 95 TokenB. Alice withdraws all of her original liquidity and immediately fills the rebalance order. As a result, the pool has 20 TokenA and 195 TokenB. If Alice had not provided just-in-time liquidity, the pool would have only swapped 10 TokenA for 9.5 TokenB and ended at a total of 110 TokenA and 109.5 TokenB. Since the target ratio for the tokens is currently 1:1, we can assume they have the same price, and see that if each token was worth \\$1, Alice made an excess profit of \\$4.50, or just over 2% of the original total pool value.\n",
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe liquidity density functions used by Bunni v2 pools can be configured to adapt to changes in market conditions. As a result, the protocol also includes a mechanism to autonomously rebalance the holdings of a pool to maximize the liquidity available. However, the way liquidity is added and removed from pools can be leveraged to artificially inflate pool balances temporarily in order to create abnormally large and profitable rebalance orders.\n\nThe amount of liquidity in a pool can be calculated by multiplying a token's balance by the overall token density according to the LDF. Since we have two tokens per pool, each with independent balances and densities, we can infer two possible liquidity amounts (figure 9.1). Under normal conditions, these values should be approximately equal, but if the LDF shifts or morphs somehow, the densities of each token may change. Since the balances will remain constant, this means that the liquidity values implied by the balances may differ. If the difference in these liquidity estimates exceeds a pool-configured threshold (figure 9.2), a rebalance order will be issued through flood.bid that trades a portion of the excess token to increase the overall liquidity.\n\n```\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\nif (totalLiquidityEstimate0 == 0) {\n totalLiquidity = totalLiquidityEstimate1;\n} else if (totalLiquidityEstimate1 == 0) {\n totalLiquidity = totalLiquidityEstimate0;\n} else {\n totalLiquidity = FixedPointMathLib.min(totalLiquidityEstimate0,\ntotalLiquidityEstimate1);\n}\n```\n\n*Figure 9.1: A snippet of the queryLDF function showing how totalLiquidity is calculated ([src/lib/QueryLDF.sol#L72–L84](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L72-L84))*\n\n\n```\n// should rebalance if excessLiquidity / totalLiquidity >= 1 / rebalanceThreshold\nbool shouldRebalance0 =\n excessLiquidity0 != 0 && excessLiquidity0 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nbool shouldRebalance1 =\n excessLiquidity1 != 0 && excessLiquidity1 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nif (!shouldRebalance0 && !shouldRebalance1) return (false, inputToken, outputToken,\ninputAmount, outputAmount);\n```\n\n*Figure 9.2: A snippet of the \\_computeRebalanceParams function that checks if a rebalance order should be created ([src/lib/BunniHookLogic.sol#L618–L623](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L618-L623))*\n\nTo simplify the process of adding and removing liquidity after the pool has been initialized with some balance, these operations allow tokens to be added or removed from the pool only in proportion to the current balances (figure 9.3). Note that these balances include any excess liquidity; as a result, the overall proportion of excess liquidity will remain the same when liquidity is added or removed.\n\n```\n(returnData.balance0, returnData.balance1) =\n (inputData.state.rawBalance0 + reserveBalance0, inputData.state.rawBalance1 +\nreserveBalance1);\n// update TWAP oracle and optionally observe\nbool requiresLDF = returnData.balance0 == 0 && returnData.balance1 == 0;\nif (requiresLDF) {\n ...\n} else {\n // already initialized liquidity shape\n // simply add tokens at the current ratio\n // need to update: reserveAmount0, reserveAmount1, amount0, amount1\n // compute amount0 and amount1 such that the ratio is the same as the current\nratio\n uint256 amount0Desired = inputData.params.amount0Desired;\n uint256 amount1Desired = inputData.params.amount1Desired;\n uint256 balance0 = returnData.balance0;\n uint256 balance1 = returnData.balance1;\n returnData.amount0 = balance1 == 0\n ? amount0Desired\n : FixedPointMathLib.min(amount0Desired, amount1Desired.mulDiv(balance0,\nbalance1));\n returnData.amount1 = balance0 == 0\n ? amount1Desired\n : FixedPointMathLib.min(amount1Desired, amount0Desired.mulDiv(balance1,\nbalance0));\n```\n\n*Figure 9.3: A snippet of the \\_depositLogic function that shows how the token amounts to be deposited are calculated for initialized pools ([src/lib/BunniHubLogic.sol#L226–L312](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L226-L312))*\n\n\nSince rebalance orders are emitted automatically after a swap as a result of pool/market conditions, a malicious fulfiller can anticipate when this will occur and inject a large amount of liquidity before the rebalance order is calculated, remove the liquidity after the order is issued, then fill the order himself, profiting from the slippage tolerance (figure 9.4) and leaving the pool in an incredibly unbalanced state.\n\n```\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n// compute target amounts (i.e. the token amounts of the excess liquidity)\nuint256 excessLiquidity = willRebalanceToken0 ? excessLiquidity0 : excessLiquidity1;\nuint256 targetAmount0 = excessLiquidity.fullMulDiv(totalDensity0X96, Q96);\nuint256 targetAmount1 = excessLiquidity.fullMulDiv(totalDensity1X96, Q96);\n// determine input & output\n(inputToken, outputToken) = willRebalanceToken0\n ? (input.key.currency0, input.key.currency1)\n : (input.key.currency1, input.key.currency0);\nuint256 inputTokenExcessBalance =\n willRebalanceToken0 ? balance0 - currentActiveBalance0 : balance1 -\ncurrentActiveBalance1;\nuint256 inputTokenTarget = willRebalanceToken0 ? targetAmount0 : targetAmount1;\nuint256 outputTokenTarget = willRebalanceToken0 ? targetAmount1 : targetAmount0;\nif (inputTokenExcessBalance < inputTokenTarget) {\n // should never happen\n return (false, inputToken, outputToken, inputAmount, outputAmount);\n}\ninputAmount = inputTokenExcessBalance - inputTokenTarget;\noutputAmount = outputTokenTarget.mulDivUp(1e5 -\ninput.hookParams.rebalanceMaxSlippage, 1e5);\n```\n\n*Figure 9.4: A snippet of the \\_computeRebalanceParams function that shows the calculation of the amounts of tokens for the rebalance order ([src/lib/BunniHookLogic.sol#L652–L672](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L652-L672))*\n\nIf there is an active AmAmm manager, withdrawals would be subject to a timeout window, but the version of the code under review has a known issue that allows this to be bypassed. Since the AmAmm manager is also included on the allowlist of fulfillers, this would allow arbitrary attackers to fulfill orders provided they win the AmAmm auction 24 hours in advance. Otherwise, any allowlisted fulfiller would be able to execute this attack.\n\nAdditionally, regular depositors could use flash loans to provide just-in-time liquidity to inflate the rebalance order to require a greater amount of tokens than would naturally be in the pool, requiring fulfillers to also take the extra step of providing just-in-time liquidity back into the pool to carry out the rebalance, resulting in a swap that is less profitable than it appeared based on the order parameters alone.\n",
      "markdown_body": "| Severity: High                                                   | Diffi culty: Low        |\n|---------------------------------------------------------------------|-------------------------------|\n| Type: Data Validation                                         | Finding ID: TOB-BUNNI-9 |\n| Target: src/lib/BunniHookLogic.sol, src/lib/BunniHubLogic.sol |                               |\n\n#### Description\n\nThe liquidity density functions used by Bunni v2 pools can be configured to adapt to changes in market conditions. As a result, the protocol also includes a mechanism to autonomously rebalance the holdings of a pool to maximize the liquidity available. However, the way liquidity is added and removed from pools can be leveraged to artificially inflate pool balances temporarily in order to create abnormally large and profitable rebalance orders.\n\nThe amount of liquidity in a pool can be calculated by multiplying a token's balance by the overall token density according to the LDF. Since we have two tokens per pool, each with independent balances and densities, we can infer two possible liquidity amounts (figure 9.1). Under normal conditions, these values should be approximately equal, but if the LDF shifts or morphs somehow, the densities of each token may change. Since the balances will remain constant, this means that the liquidity values implied by the balances may differ. If the difference in these liquidity estimates exceeds a pool-configured threshold (figure 9.2), a rebalance order will be issued through flood.bid that trades a portion of the excess token to increase the overall liquidity.\n\n```\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\nif (totalLiquidityEstimate0 == 0) {\n totalLiquidity = totalLiquidityEstimate1;\n} else if (totalLiquidityEstimate1 == 0) {\n totalLiquidity = totalLiquidityEstimate0;\n} else {\n totalLiquidity = FixedPointMathLib.min(totalLiquidityEstimate0,\ntotalLiquidityEstimate1);\n}\n```\n\n*Figure 9.1: A snippet of the queryLDF function showing how totalLiquidity is calculated ([src/lib/QueryLDF.sol#L72–L84](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L72-L84))*\n\n\n```\n// should rebalance if excessLiquidity / totalLiquidity >= 1 / rebalanceThreshold\nbool shouldRebalance0 =\n excessLiquidity0 != 0 && excessLiquidity0 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nbool shouldRebalance1 =\n excessLiquidity1 != 0 && excessLiquidity1 >= totalLiquidity /\ninput.hookParams.rebalanceThreshold;\nif (!shouldRebalance0 && !shouldRebalance1) return (false, inputToken, outputToken,\ninputAmount, outputAmount);\n```\n\n*Figure 9.2: A snippet of the \\_computeRebalanceParams function that checks if a rebalance order should be created ([src/lib/BunniHookLogic.sol#L618–L623](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L618-L623))*\n\nTo simplify the process of adding and removing liquidity after the pool has been initialized with some balance, these operations allow tokens to be added or removed from the pool only in proportion to the current balances (figure 9.3). Note that these balances include any excess liquidity; as a result, the overall proportion of excess liquidity will remain the same when liquidity is added or removed.\n\n```\n(returnData.balance0, returnData.balance1) =\n (inputData.state.rawBalance0 + reserveBalance0, inputData.state.rawBalance1 +\nreserveBalance1);\n// update TWAP oracle and optionally observe\nbool requiresLDF = returnData.balance0 == 0 && returnData.balance1 == 0;\nif (requiresLDF) {\n ...\n} else {\n // already initialized liquidity shape\n // simply add tokens at the current ratio\n // need to update: reserveAmount0, reserveAmount1, amount0, amount1\n // compute amount0 and amount1 such that the ratio is the same as the current\nratio\n uint256 amount0Desired = inputData.params.amount0Desired;\n uint256 amount1Desired = inputData.params.amount1Desired;\n uint256 balance0 = returnData.balance0;\n uint256 balance1 = returnData.balance1;\n returnData.amount0 = balance1 == 0\n ? amount0Desired\n : FixedPointMathLib.min(amount0Desired, amount1Desired.mulDiv(balance0,\nbalance1));\n returnData.amount1 = balance0 == 0\n ? amount1Desired\n : FixedPointMathLib.min(amount1Desired, amount0Desired.mulDiv(balance1,\nbalance0));\n```\n\n*Figure 9.3: A snippet of the \\_depositLogic function that shows how the token amounts to be deposited are calculated for initialized pools ([src/lib/BunniHubLogic.sol#L226–L312](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L226-L312))*\n\n\nSince rebalance orders are emitted automatically after a swap as a result of pool/market conditions, a malicious fulfiller can anticipate when this will occur and inject a large amount of liquidity before the rebalance order is calculated, remove the liquidity after the order is issued, then fill the order himself, profiting from the slippage tolerance (figure 9.4) and leaving the pool in an incredibly unbalanced state.\n\n```\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n// compute target amounts (i.e. the token amounts of the excess liquidity)\nuint256 excessLiquidity = willRebalanceToken0 ? excessLiquidity0 : excessLiquidity1;\nuint256 targetAmount0 = excessLiquidity.fullMulDiv(totalDensity0X96, Q96);\nuint256 targetAmount1 = excessLiquidity.fullMulDiv(totalDensity1X96, Q96);\n// determine input & output\n(inputToken, outputToken) = willRebalanceToken0\n ? (input.key.currency0, input.key.currency1)\n : (input.key.currency1, input.key.currency0);\nuint256 inputTokenExcessBalance =\n willRebalanceToken0 ? balance0 - currentActiveBalance0 : balance1 -\ncurrentActiveBalance1;\nuint256 inputTokenTarget = willRebalanceToken0 ? targetAmount0 : targetAmount1;\nuint256 outputTokenTarget = willRebalanceToken0 ? targetAmount1 : targetAmount0;\nif (inputTokenExcessBalance < inputTokenTarget) {\n // should never happen\n return (false, inputToken, outputToken, inputAmount, outputAmount);\n}\ninputAmount = inputTokenExcessBalance - inputTokenTarget;\noutputAmount = outputTokenTarget.mulDivUp(1e5 -\ninput.hookParams.rebalanceMaxSlippage, 1e5);\n```\n\n*Figure 9.4: A snippet of the \\_computeRebalanceParams function that shows the calculation of the amounts of tokens for the rebalance order ([src/lib/BunniHookLogic.sol#L652–L672](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L652-L672))*\n\nIf there is an active AmAmm manager, withdrawals would be subject to a timeout window, but the version of the code under review has a known issue that allows this to be bypassed. Since the AmAmm manager is also included on the allowlist of fulfillers, this would allow arbitrary attackers to fulfill orders provided they win the AmAmm auction 24 hours in advance. Otherwise, any allowlisted fulfiller would be able to execute this attack.\n\nAdditionally, regular depositors could use flash loans to provide just-in-time liquidity to inflate the rebalance order to require a greater amount of tokens than would naturally be in the pool, requiring fulfillers to also take the extra step of providing just-in-time liquidity back into the pool to carry out the rebalance, resulting in a swap that is less profitable than it appeared based on the order parameters alone.\n\n#### Exploit Scenario\n\nA pool's LDF shifts and has 120 TokenA and 100 TokenB, but the active balance of TokenA is only 100. Alice, a malicious fulfiller, notices that the pool will rebalance and deposits 1,080\n\n\n\nTokenA and 900 TokenB so the pool has 1,200 TokenA and 1,000 TokenB in total. She makes a small swap to trigger the creation of a rebalance order. This pool has a 5% rebalance slippage tolerance so the rebalance order will sell 100 TokenA for 95 TokenB. Alice withdraws all of her original liquidity and immediately fills the rebalance order. As a result, the pool has 20 TokenA and 195 TokenB. If Alice had not provided just-in-time liquidity, the pool would have only swapped 10 TokenA for 9.5 TokenB and ended at a total of 110 TokenA and 109.5 TokenB. Since the target ratio for the tokens is currently 1:1, we can assume they have the same price, and see that if each token was worth \\$1, Alice made an excess profit of \\$4.50, or just over 2% of the original total pool value.\n\n#### Recommendations\n\nShort term, add a check to enforce the withdrawal queue when rebalanceOrderDeadline is in the future.\n\nLong term, consider changing the add/remove liquidity flows to account for excess liquidity or adding checks to the rebalance hooks that enforce that the pool is in an improved state after the rebalance.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-9",
        "Target": "src/lib/BunniHookLogic.sol, src/lib/BunniHubLogic.sol"
      },
      "heading_cleaned": "Excess liquidity can be inflated to create arbitrarily large rebalance orders"
    },
    {
      "index": 10,
      "page_start": 44,
      "heading": "10. Insucient event generation",
      "markdown": "| 10. Insucient event generation                               |                        |\n|-----------------------------------------------------------------------|------------------------|\n| Severity: Informational                                            | Diffi culty: Low |\n| Type: Auditing and Logging Finding ID: TOB-BUNNI-10 |                        |\n| Target: bunni-v2/src/*, biddog/src/AmAmm.sol                    |                        |\n\n#### Description\n\nMultiple operations do not emit events. As a result, it will be difficult to review the contracts' behavior for correctness once they have been deployed.\n\nEvents generated during contract execution aid in monitoring, baselining of behavior, and detection of suspicious activity. Without events, users and blockchain-monitoring systems cannot easily detect behavior that falls outside the baseline conditions; malfunctioning contracts and attacks could go undetected.\n\nThe following operations should trigger events:\n\n- claimReferralRewards ([bunni-v2/src/BunniTokens.sol#L155-L196](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L155-L196))\n- distributeReferralRewards ([bunni-v2/src/BunniTokens.sol#L132-L152](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L132-L152))\n- claimProtocolFees ([bunni-v2/src/BunniHook.sol#L244-L246](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L244-L246))\n- rebalanceOrderPreHook ([bunni-v2/src/BunniHook.sol#L429-L462](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L462))\n- rebalanceOrderPostHook ([bunni-v2/src/BunniHook.sol#L465-L511](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L511))\n- \\_rebalance ([bunni-v2/src/lib/BunniHookLogic.sol#L532-L550](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L532-L550))\n- updateStateMachine ([biddog/src/AmAmm.sol#L432-L434](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L432-L434))\n\n#### Recommendations\n\nShort term, add events for all operations that could contribute to a higher level of monitoring and alerting.\n\nLong term, consider using a blockchain-monitoring system to track any suspicious behavior in the contracts. The system relies on several contracts to behave as expected. A monitoring mechanism for critical events would quickly detect any compromised system components.\n",
      "finding_id": null,
      "markdown_raw": "<span id=\"page-44-0\"></span>\n\n| 10.<br>Insucient<br>event<br>generation                               |                        |\n|-----------------------------------------------------------------------|------------------------|\n| Severity:<br>Informational                                            | Diffi<br>culty:<br>Low |\n| Type:<br>Auditing<br>and<br>Logging<br>Finding<br>ID:<br>TOB-BUNNI-10 |                        |\n| Target:<br>bunni-v2/src/*,<br>biddog/src/AmAmm.sol                    |                        |\n\n#### Description\n\nMultiple operations do not emit events. As a result, it will be difficult to review the contracts' behavior for correctness once they have been deployed.\n\nEvents generated during contract execution aid in monitoring, baselining of behavior, and detection of suspicious activity. Without events, users and blockchain-monitoring systems cannot easily detect behavior that falls outside the baseline conditions; malfunctioning contracts and attacks could go undetected.\n\nThe following operations should trigger events:\n\n- claimReferralRewards ([bunni-v2/src/BunniTokens.sol#L155-L196](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L155-L196))\n- distributeReferralRewards ([bunni-v2/src/BunniTokens.sol#L132-L152](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L132-L152))\n- claimProtocolFees ([bunni-v2/src/BunniHook.sol#L244-L246](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L244-L246))\n- rebalanceOrderPreHook ([bunni-v2/src/BunniHook.sol#L429-L462](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L462))\n- rebalanceOrderPostHook ([bunni-v2/src/BunniHook.sol#L465-L511](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L511))\n- \\_rebalance ([bunni-v2/src/lib/BunniHookLogic.sol#L532-L550](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L532-L550))\n- updateStateMachine ([biddog/src/AmAmm.sol#L432-L434](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L432-L434))\n\n#### Recommendations\n\nShort term, add events for all operations that could contribute to a higher level of monitoring and alerting.\n\nLong term, consider using a blockchain-monitoring system to track any suspicious behavior in the contracts. The system relies on several contracts to behave as expected. A monitoring mechanism for critical events would quickly detect any compromised system components.\n\n![](_page_44_Picture_15.jpeg)\n\n{45}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nMultiple operations do not emit events. As a result, it will be difficult to review the contracts' behavior for correctness once they have been deployed.\n\nEvents generated during contract execution aid in monitoring, baselining of behavior, and detection of suspicious activity. Without events, users and blockchain-monitoring systems cannot easily detect behavior that falls outside the baseline conditions; malfunctioning contracts and attacks could go undetected.\n\nThe following operations should trigger events:\n\n- claimReferralRewards ([bunni-v2/src/BunniTokens.sol#L155-L196](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L155-L196))\n- distributeReferralRewards ([bunni-v2/src/BunniTokens.sol#L132-L152](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L132-L152))\n- claimProtocolFees ([bunni-v2/src/BunniHook.sol#L244-L246](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L244-L246))\n- rebalanceOrderPreHook ([bunni-v2/src/BunniHook.sol#L429-L462](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L462))\n- rebalanceOrderPostHook ([bunni-v2/src/BunniHook.sol#L465-L511](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L511))\n- \\_rebalance ([bunni-v2/src/lib/BunniHookLogic.sol#L532-L550](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L532-L550))\n- updateStateMachine ([biddog/src/AmAmm.sol#L432-L434](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L432-L434))\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, add events for all operations that could contribute to a higher level of monitoring and alerting.\n\nLong term, consider using a blockchain-monitoring system to track any suspicious behavior in the contracts. The system relies on several contracts to behave as expected. A monitoring mechanism for critical events would quickly detect any compromised system components.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nMultiple operations do not emit events. As a result, it will be difficult to review the contracts' behavior for correctness once they have been deployed.\n\nEvents generated during contract execution aid in monitoring, baselining of behavior, and detection of suspicious activity. Without events, users and blockchain-monitoring systems cannot easily detect behavior that falls outside the baseline conditions; malfunctioning contracts and attacks could go undetected.\n\nThe following operations should trigger events:\n\n- claimReferralRewards ([bunni-v2/src/BunniTokens.sol#L155-L196](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L155-L196))\n- distributeReferralRewards ([bunni-v2/src/BunniTokens.sol#L132-L152](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L132-L152))\n- claimProtocolFees ([bunni-v2/src/BunniHook.sol#L244-L246](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L244-L246))\n- rebalanceOrderPreHook ([bunni-v2/src/BunniHook.sol#L429-L462](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L462))\n- rebalanceOrderPostHook ([bunni-v2/src/BunniHook.sol#L465-L511](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L511))\n- \\_rebalance ([bunni-v2/src/lib/BunniHookLogic.sol#L532-L550](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L532-L550))\n- updateStateMachine ([biddog/src/AmAmm.sol#L432-L434](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L432-L434))\n",
      "markdown_body": "| 10. Insucient event generation                               |                        |\n|-----------------------------------------------------------------------|------------------------|\n| Severity: Informational                                            | Diffi culty: Low |\n| Type: Auditing and Logging Finding ID: TOB-BUNNI-10 |                        |\n| Target: bunni-v2/src/*, biddog/src/AmAmm.sol                    |                        |\n\n#### Description\n\nMultiple operations do not emit events. As a result, it will be difficult to review the contracts' behavior for correctness once they have been deployed.\n\nEvents generated during contract execution aid in monitoring, baselining of behavior, and detection of suspicious activity. Without events, users and blockchain-monitoring systems cannot easily detect behavior that falls outside the baseline conditions; malfunctioning contracts and attacks could go undetected.\n\nThe following operations should trigger events:\n\n- claimReferralRewards ([bunni-v2/src/BunniTokens.sol#L155-L196](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L155-L196))\n- distributeReferralRewards ([bunni-v2/src/BunniTokens.sol#L132-L152](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniToken.sol#L132-L152))\n- claimProtocolFees ([bunni-v2/src/BunniHook.sol#L244-L246](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L244-L246))\n- rebalanceOrderPreHook ([bunni-v2/src/BunniHook.sol#L429-L462](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L429-L462))\n- rebalanceOrderPostHook ([bunni-v2/src/BunniHook.sol#L465-L511](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHook.sol#L465-L511))\n- \\_rebalance ([bunni-v2/src/lib/BunniHookLogic.sol#L532-L550](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L532-L550))\n- updateStateMachine ([biddog/src/AmAmm.sol#L432-L434](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L432-L434))\n\n#### Recommendations\n\nShort term, add events for all operations that could contribute to a higher level of monitoring and alerting.\n\nLong term, consider using a blockchain-monitoring system to track any suspicious behavior in the contracts. The system relies on several contracts to behave as expected. A monitoring mechanism for critical events would quickly detect any compromised system components.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Low",
        "Type": "Auditing and Logging",
        "Finding ID": "TOB-BUNNI-10",
        "Target": "bunni-v2/src/*, biddog/src/AmAmm.sol"
      },
      "heading_cleaned": "Insucient event generation"
    },
    {
      "index": 11,
      "page_start": 45,
      "heading": "11. AmAmm manager can manipulate TWAP prices without risk Severity: **Medium** Difficulty: **High** Type: Access Controls Finding ID: TOB-BUNNI-11 Target: biddog/src/AmAmm.sol",
      "markdown": "# 11. AmAmm manager can manipulate TWAP prices without risk Severity: **Medium** Difficulty: **High** Type: Access Controls Finding ID: TOB-BUNNI-11 Target: biddog/src/AmAmm.sol\n\n#### Description\n\nThe AmAmm manager of a pool can manipulate the TWAP price of the pool by swapping a large amount of assets and then setting the swap fee to a very high value in order to prevent others from arbitraging the pool.\n\nThe AmAmm manager of a pool can set the swap fees of this pool by calling the setBidPayload function of the AmAmm contract, as shown in figure 11.1:\n\n```\nfunction setBidPayload(PoolId id, bytes7 payload, bool topBid) external virtual\noverride {\n address msgSender = LibMulticaller.senderOrSigner();\n if (!_amAmmEnabled(id)) {\n revert AmAmm__NotEnabled();\n }\n // update state machine\n _updateAmAmmWrite(id);\n Bid storage relevantBid = topBid ? _topBids[id] : _nextBids[id];\n if (msgSender != relevantBid.manager) {\n revert AmAmm__Unauthorized();\n }\n if (!_payloadIsValid(id, payload)) {\n revert AmAmm__InvalidBid();\n }\n relevantBid.payload = payload;\n emit SetBidPayload(id, msgSender, payload, topBid);\n}\n```\n\n*Figure 11.1: Function to set the payload used for this pool ([biddog/src/AmAmm.sol#L406–L429](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L406-L429))*\n\nThe payload they set contains the swap fee parameter for each direction of the swap and a Boolean flag that determines if the pool will charge surge fees, as shown in figure 11.2:\n\n\n```\nfunction decodeAmAmmPayload(bytes7 payload)\n pure\n returns (uint24 swapFee0For1, uint24 swapFee1For0, bool enableSurgeFee)\n{\n swapFee0For1 = uint24(bytes3(payload));\n swapFee1For0 = uint24(bytes3(payload << 24));\n enableSurgeFee = uint8(payload[6]) != 0;\n}\n```\n\n*Figure 11.2: The parameters contained in the AmAmm payload ([src/lib/AmAmmPayload.sol#L11–L18](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/AmAmmPayload.sol#L11-L18))*\n\nOnce a swap is initiated and the beforeSwap function of the BunniHook contract is called, the function will determine the swap fees charged based on the bid payload of the current manager (if a manager is set), as shown in figure 11.3:\n\n```\n// update am-AMM state\nuint24 amAmmSwapFee;\nbool amAmmEnableSurgeFee;\nif (hookParams.amAmmEnabled) {\n bytes7 payload;\n IAmAmm.Bid memory topBid = IAmAmm(address(this)).getTopBidWrite(id);\n (amAmmManager, payload) = (topBid.manager, topBid.payload);\n uint24 swapFee0For1;\n uint24 swapFee1For0;\n (swapFee0For1, swapFee1For0, amAmmEnableSurgeFee) = decodeAmAmmPayload(payload);\n amAmmSwapFee = params.zeroForOne ? swapFee0For1 : swapFee1For0;\n}\n```\n\n*Figure 11.3: A code snippet of the beforeSwap function ([src/lib/BunniHookLogic.sol#L295–L305](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L295-L305))*\n\nHowever, a malicious AmAmm manager could use this mechanism to protect themselves from arbitrage while they are manipulating the TWAP price. It is important to note that the BunniHook defines a maximum swap fee that can be used; however, this value could be misconfigured or naively set to a high value. Additionally, the use of a truncated Oracle makes this manipulation take longer since the TWAP price will gradually update over several blocks.\n\n#### Exploit Scenario\n\nAlice deploys a pool with a BunniHook that has 100% as the maximum swap fee. Her pool's TWAP price is used in an external lending protocol to determine asset prices. Eve creates a large bid and becomes the AmAmm manager of this pool. She then proceeds to borrow a large amount of assets to manipulate the TWAP price over several blocks and sets the swap fees to 100% to protect her manipulation against arbitrage. Eve drains the lending pool that overvalued her assets due to the inflated TWAP price.\n\n\n\n#### Recommendations\n\nShort term, consider determining and setting a reasonable max swap fee upper bound in the BunniHook contract.\n\nLong term, create developer- and user-facing documentation that clearly outlines the risks of different pool and hook configurations, as well as the powers of the AmAmm manager.\n",
      "finding_id": null,
      "markdown_raw": "# <span id=\"page-45-0\"></span>11. AmAmm manager can manipulate TWAP prices without risk Severity: **Medium** Difficulty: **High** Type: Access Controls Finding ID: TOB-BUNNI-11 Target: biddog/src/AmAmm.sol\n\n#### Description\n\nThe AmAmm manager of a pool can manipulate the TWAP price of the pool by swapping a large amount of assets and then setting the swap fee to a very high value in order to prevent others from arbitraging the pool.\n\nThe AmAmm manager of a pool can set the swap fees of this pool by calling the setBidPayload function of the AmAmm contract, as shown in figure 11.1:\n\n```\nfunction setBidPayload(PoolId id, bytes7 payload, bool topBid) external virtual\noverride {\n address msgSender = LibMulticaller.senderOrSigner();\n if (!_amAmmEnabled(id)) {\n revert AmAmm__NotEnabled();\n }\n // update state machine\n _updateAmAmmWrite(id);\n Bid storage relevantBid = topBid ? _topBids[id] : _nextBids[id];\n if (msgSender != relevantBid.manager) {\n revert AmAmm__Unauthorized();\n }\n if (!_payloadIsValid(id, payload)) {\n revert AmAmm__InvalidBid();\n }\n relevantBid.payload = payload;\n emit SetBidPayload(id, msgSender, payload, topBid);\n}\n```\n\n*Figure 11.1: Function to set the payload used for this pool ([biddog/src/AmAmm.sol#L406–L429](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L406-L429))*\n\nThe payload they set contains the swap fee parameter for each direction of the swap and a Boolean flag that determines if the pool will charge surge fees, as shown in figure 11.2:\n\n{46}------------------------------------------------\n\n```\nfunction decodeAmAmmPayload(bytes7 payload)\n pure\n returns (uint24 swapFee0For1, uint24 swapFee1For0, bool enableSurgeFee)\n{\n swapFee0For1 = uint24(bytes3(payload));\n swapFee1For0 = uint24(bytes3(payload << 24));\n enableSurgeFee = uint8(payload[6]) != 0;\n}\n```\n\n*Figure 11.2: The parameters contained in the AmAmm payload ([src/lib/AmAmmPayload.sol#L11–L18](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/AmAmmPayload.sol#L11-L18))*\n\nOnce a swap is initiated and the beforeSwap function of the BunniHook contract is called, the function will determine the swap fees charged based on the bid payload of the current manager (if a manager is set), as shown in figure 11.3:\n\n```\n// update am-AMM state\nuint24 amAmmSwapFee;\nbool amAmmEnableSurgeFee;\nif (hookParams.amAmmEnabled) {\n bytes7 payload;\n IAmAmm.Bid memory topBid = IAmAmm(address(this)).getTopBidWrite(id);\n (amAmmManager, payload) = (topBid.manager, topBid.payload);\n uint24 swapFee0For1;\n uint24 swapFee1For0;\n (swapFee0For1, swapFee1For0, amAmmEnableSurgeFee) = decodeAmAmmPayload(payload);\n amAmmSwapFee = params.zeroForOne ? swapFee0For1 : swapFee1For0;\n}\n```\n\n*Figure 11.3: A code snippet of the beforeSwap function ([src/lib/BunniHookLogic.sol#L295–L305](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L295-L305))*\n\nHowever, a malicious AmAmm manager could use this mechanism to protect themselves from arbitrage while they are manipulating the TWAP price. It is important to note that the BunniHook defines a maximum swap fee that can be used; however, this value could be misconfigured or naively set to a high value. Additionally, the use of a truncated Oracle makes this manipulation take longer since the TWAP price will gradually update over several blocks.\n\n#### Exploit Scenario\n\nAlice deploys a pool with a BunniHook that has 100% as the maximum swap fee. Her pool's TWAP price is used in an external lending protocol to determine asset prices. Eve creates a large bid and becomes the AmAmm manager of this pool. She then proceeds to borrow a large amount of assets to manipulate the TWAP price over several blocks and sets the swap fees to 100% to protect her manipulation against arbitrage. Eve drains the lending pool that overvalued her assets due to the inflated TWAP price.\n\n![](_page_46_Picture_8.jpeg)\n\n{47}------------------------------------------------\n\n#### Recommendations\n\nShort term, consider determining and setting a reasonable max swap fee upper bound in the BunniHook contract.\n\nLong term, create developer- and user-facing documentation that clearly outlines the risks of different pool and hook configurations, as well as the powers of the AmAmm manager.\n\n![](_page_47_Picture_3.jpeg)\n\n{48}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe AmAmm manager of a pool can manipulate the TWAP price of the pool by swapping a large amount of assets and then setting the swap fee to a very high value in order to prevent others from arbitraging the pool.\n\nThe AmAmm manager of a pool can set the swap fees of this pool by calling the setBidPayload function of the AmAmm contract, as shown in figure 11.1:\n\n```\nfunction setBidPayload(PoolId id, bytes7 payload, bool topBid) external virtual\noverride {\n address msgSender = LibMulticaller.senderOrSigner();\n if (!_amAmmEnabled(id)) {\n revert AmAmm__NotEnabled();\n }\n // update state machine\n _updateAmAmmWrite(id);\n Bid storage relevantBid = topBid ? _topBids[id] : _nextBids[id];\n if (msgSender != relevantBid.manager) {\n revert AmAmm__Unauthorized();\n }\n if (!_payloadIsValid(id, payload)) {\n revert AmAmm__InvalidBid();\n }\n relevantBid.payload = payload;\n emit SetBidPayload(id, msgSender, payload, topBid);\n}\n```\n\n*Figure 11.1: Function to set the payload used for this pool ([biddog/src/AmAmm.sol#L406–L429](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L406-L429))*\n\nThe payload they set contains the swap fee parameter for each direction of the swap and a Boolean flag that determines if the pool will charge surge fees, as shown in figure 11.2:\n\n\n```\nfunction decodeAmAmmPayload(bytes7 payload)\n pure\n returns (uint24 swapFee0For1, uint24 swapFee1For0, bool enableSurgeFee)\n{\n swapFee0For1 = uint24(bytes3(payload));\n swapFee1For0 = uint24(bytes3(payload << 24));\n enableSurgeFee = uint8(payload[6]) != 0;\n}\n```\n\n*Figure 11.2: The parameters contained in the AmAmm payload ([src/lib/AmAmmPayload.sol#L11–L18](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/AmAmmPayload.sol#L11-L18))*\n\nOnce a swap is initiated and the beforeSwap function of the BunniHook contract is called, the function will determine the swap fees charged based on the bid payload of the current manager (if a manager is set), as shown in figure 11.3:\n\n```\n// update am-AMM state\nuint24 amAmmSwapFee;\nbool amAmmEnableSurgeFee;\nif (hookParams.amAmmEnabled) {\n bytes7 payload;\n IAmAmm.Bid memory topBid = IAmAmm(address(this)).getTopBidWrite(id);\n (amAmmManager, payload) = (topBid.manager, topBid.payload);\n uint24 swapFee0For1;\n uint24 swapFee1For0;\n (swapFee0For1, swapFee1For0, amAmmEnableSurgeFee) = decodeAmAmmPayload(payload);\n amAmmSwapFee = params.zeroForOne ? swapFee0For1 : swapFee1For0;\n}\n```\n\n*Figure 11.3: A code snippet of the beforeSwap function ([src/lib/BunniHookLogic.sol#L295–L305](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L295-L305))*\n\nHowever, a malicious AmAmm manager could use this mechanism to protect themselves from arbitrage while they are manipulating the TWAP price. It is important to note that the BunniHook defines a maximum swap fee that can be used; however, this value could be misconfigured or naively set to a high value. Additionally, the use of a truncated Oracle makes this manipulation take longer since the TWAP price will gradually update over several blocks.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, consider determining and setting a reasonable max swap fee upper bound in the BunniHook contract.\n\nLong term, create developer- and user-facing documentation that clearly outlines the risks of different pool and hook configurations, as well as the powers of the AmAmm manager.\n",
        "poc": "#### Exploit Scenario\n\nAlice deploys a pool with a BunniHook that has 100% as the maximum swap fee. Her pool's TWAP price is used in an external lending protocol to determine asset prices. Eve creates a large bid and becomes the AmAmm manager of this pool. She then proceeds to borrow a large amount of assets to manipulate the TWAP price over several blocks and sets the swap fees to 100% to protect her manipulation against arbitrage. Eve drains the lending pool that overvalued her assets due to the inflated TWAP price.\n",
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe AmAmm manager of a pool can manipulate the TWAP price of the pool by swapping a large amount of assets and then setting the swap fee to a very high value in order to prevent others from arbitraging the pool.\n\nThe AmAmm manager of a pool can set the swap fees of this pool by calling the setBidPayload function of the AmAmm contract, as shown in figure 11.1:\n\n```\nfunction setBidPayload(PoolId id, bytes7 payload, bool topBid) external virtual\noverride {\n address msgSender = LibMulticaller.senderOrSigner();\n if (!_amAmmEnabled(id)) {\n revert AmAmm__NotEnabled();\n }\n // update state machine\n _updateAmAmmWrite(id);\n Bid storage relevantBid = topBid ? _topBids[id] : _nextBids[id];\n if (msgSender != relevantBid.manager) {\n revert AmAmm__Unauthorized();\n }\n if (!_payloadIsValid(id, payload)) {\n revert AmAmm__InvalidBid();\n }\n relevantBid.payload = payload;\n emit SetBidPayload(id, msgSender, payload, topBid);\n}\n```\n\n*Figure 11.1: Function to set the payload used for this pool ([biddog/src/AmAmm.sol#L406–L429](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L406-L429))*\n\nThe payload they set contains the swap fee parameter for each direction of the swap and a Boolean flag that determines if the pool will charge surge fees, as shown in figure 11.2:\n\n\n```\nfunction decodeAmAmmPayload(bytes7 payload)\n pure\n returns (uint24 swapFee0For1, uint24 swapFee1For0, bool enableSurgeFee)\n{\n swapFee0For1 = uint24(bytes3(payload));\n swapFee1For0 = uint24(bytes3(payload << 24));\n enableSurgeFee = uint8(payload[6]) != 0;\n}\n```\n\n*Figure 11.2: The parameters contained in the AmAmm payload ([src/lib/AmAmmPayload.sol#L11–L18](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/AmAmmPayload.sol#L11-L18))*\n\nOnce a swap is initiated and the beforeSwap function of the BunniHook contract is called, the function will determine the swap fees charged based on the bid payload of the current manager (if a manager is set), as shown in figure 11.3:\n\n```\n// update am-AMM state\nuint24 amAmmSwapFee;\nbool amAmmEnableSurgeFee;\nif (hookParams.amAmmEnabled) {\n bytes7 payload;\n IAmAmm.Bid memory topBid = IAmAmm(address(this)).getTopBidWrite(id);\n (amAmmManager, payload) = (topBid.manager, topBid.payload);\n uint24 swapFee0For1;\n uint24 swapFee1For0;\n (swapFee0For1, swapFee1For0, amAmmEnableSurgeFee) = decodeAmAmmPayload(payload);\n amAmmSwapFee = params.zeroForOne ? swapFee0For1 : swapFee1For0;\n}\n```\n\n*Figure 11.3: A code snippet of the beforeSwap function ([src/lib/BunniHookLogic.sol#L295–L305](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L295-L305))*\n\nHowever, a malicious AmAmm manager could use this mechanism to protect themselves from arbitrage while they are manipulating the TWAP price. It is important to note that the BunniHook defines a maximum swap fee that can be used; however, this value could be misconfigured or naively set to a high value. Additionally, the use of a truncated Oracle makes this manipulation take longer since the TWAP price will gradually update over several blocks.\n",
      "markdown_body": "#### Description\n\nThe AmAmm manager of a pool can manipulate the TWAP price of the pool by swapping a large amount of assets and then setting the swap fee to a very high value in order to prevent others from arbitraging the pool.\n\nThe AmAmm manager of a pool can set the swap fees of this pool by calling the setBidPayload function of the AmAmm contract, as shown in figure 11.1:\n\n```\nfunction setBidPayload(PoolId id, bytes7 payload, bool topBid) external virtual\noverride {\n address msgSender = LibMulticaller.senderOrSigner();\n if (!_amAmmEnabled(id)) {\n revert AmAmm__NotEnabled();\n }\n // update state machine\n _updateAmAmmWrite(id);\n Bid storage relevantBid = topBid ? _topBids[id] : _nextBids[id];\n if (msgSender != relevantBid.manager) {\n revert AmAmm__Unauthorized();\n }\n if (!_payloadIsValid(id, payload)) {\n revert AmAmm__InvalidBid();\n }\n relevantBid.payload = payload;\n emit SetBidPayload(id, msgSender, payload, topBid);\n}\n```\n\n*Figure 11.1: Function to set the payload used for this pool ([biddog/src/AmAmm.sol#L406–L429](https://github.com/Bunniapp/biddog/blob/95f4270ad4447e96044973580afda9176730e7c8/src/AmAmm.sol#L406-L429))*\n\nThe payload they set contains the swap fee parameter for each direction of the swap and a Boolean flag that determines if the pool will charge surge fees, as shown in figure 11.2:\n\n\n```\nfunction decodeAmAmmPayload(bytes7 payload)\n pure\n returns (uint24 swapFee0For1, uint24 swapFee1For0, bool enableSurgeFee)\n{\n swapFee0For1 = uint24(bytes3(payload));\n swapFee1For0 = uint24(bytes3(payload << 24));\n enableSurgeFee = uint8(payload[6]) != 0;\n}\n```\n\n*Figure 11.2: The parameters contained in the AmAmm payload ([src/lib/AmAmmPayload.sol#L11–L18](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/AmAmmPayload.sol#L11-L18))*\n\nOnce a swap is initiated and the beforeSwap function of the BunniHook contract is called, the function will determine the swap fees charged based on the bid payload of the current manager (if a manager is set), as shown in figure 11.3:\n\n```\n// update am-AMM state\nuint24 amAmmSwapFee;\nbool amAmmEnableSurgeFee;\nif (hookParams.amAmmEnabled) {\n bytes7 payload;\n IAmAmm.Bid memory topBid = IAmAmm(address(this)).getTopBidWrite(id);\n (amAmmManager, payload) = (topBid.manager, topBid.payload);\n uint24 swapFee0For1;\n uint24 swapFee1For0;\n (swapFee0For1, swapFee1For0, amAmmEnableSurgeFee) = decodeAmAmmPayload(payload);\n amAmmSwapFee = params.zeroForOne ? swapFee0For1 : swapFee1For0;\n}\n```\n\n*Figure 11.3: A code snippet of the beforeSwap function ([src/lib/BunniHookLogic.sol#L295–L305](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L295-L305))*\n\nHowever, a malicious AmAmm manager could use this mechanism to protect themselves from arbitrage while they are manipulating the TWAP price. It is important to note that the BunniHook defines a maximum swap fee that can be used; however, this value could be misconfigured or naively set to a high value. Additionally, the use of a truncated Oracle makes this manipulation take longer since the TWAP price will gradually update over several blocks.\n\n#### Exploit Scenario\n\nAlice deploys a pool with a BunniHook that has 100% as the maximum swap fee. Her pool's TWAP price is used in an external lending protocol to determine asset prices. Eve creates a large bid and becomes the AmAmm manager of this pool. She then proceeds to borrow a large amount of assets to manipulate the TWAP price over several blocks and sets the swap fees to 100% to protect her manipulation against arbitrage. Eve drains the lending pool that overvalued her assets due to the inflated TWAP price.\n\n\n\n#### Recommendations\n\nShort term, consider determining and setting a reasonable max swap fee upper bound in the BunniHook contract.\n\nLong term, create developer- and user-facing documentation that clearly outlines the risks of different pool and hook configurations, as well as the powers of the AmAmm manager.\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": "High",
        "Type": "Access Controls",
        "Finding ID": "TOB-BUNNI-11",
        "Target": "biddog/src/AmAmm.sol"
      },
      "heading_cleaned": "AmAmm manager can manipulate TWAP prices without risk"
    },
    {
      "index": 12,
      "page_start": 48,
      "heading": "12. Lack of zero-value checks",
      "markdown": "| 12. Lack of zero-value checks                            |                                |\n|----------------------------------------------------------------------|--------------------------------|\n| Severity: Informational                                           | Diffi culty: Low         |\n| Type: Data Validation                                          | Finding ID: TOB-BUNNI-12 |\n| Target: src/BunniHub, src/BunniHook, src/lib/BunniHookLogic |                                |\n\n#### Description\n\nCertain functions fail to validate incoming arguments, so callers of these functions could mistakenly set important state variables to a zero value, misconfiguring the system.\n\nFor example, the constructor in the BunniHub contract sets the poolManager, weth, and bunniTokenImplementation variables, which store the addresses of external contracts Bunni v2 relies on:\n\n```\nconstructor(\n IPoolManager poolManager_,\n WETH weth_,\n IPermit2 permit2_,\n IBunniToken bunniTokenImplementation_,\n address initialOwner\n) Permit2Enabled(permit2_) {\n poolManager = poolManager_;\n weth = weth_;\n bunniTokenImplementation = bunniTokenImplementation_;\n _initializeOwner(initialOwner);\n}\n```\n\n*Figure 12.1: The constructor of the BunniHub contract ([src/BunniHub.sol#L75–L86](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L75-L86))*\n\nIf weth is set to a zero value, this deployment of the Bunni v2 protocol would be unable to handle native ether. Since all of the variables mentioned above are tagged as immutable, the contract will have to be redeployed to update to the correct address. This misconfiguration may not be noticed immediately, and forcing LPs to migrate would create a poor user experience.\n\nThe following functions are missing zero-value checks:\n\n- BunniHook.constructor\n- The inputAmount returned by the call to BunniSwapMath.computeSwap in BunnyHookLogic.beforeSwap for an exactOut swap\n\n\n\n#### Recommendations\n\nShort term, add zero-value checks to all function arguments to ensure that callers cannot set incorrect values, misconfiguring the system.\n\nLong term, use the Slither static [analyzer](https://github.com/crytic/slither) to catch common issues such as this one. Consider integrating a Slither scan into the project's CI pipeline, pre-commit hooks, or build scripts.\n",
      "finding_id": null,
      "markdown_raw": "<span id=\"page-48-0\"></span>\n\n| 12.<br>Lack<br>of<br>zero-value<br>checks                            |                                |\n|----------------------------------------------------------------------|--------------------------------|\n| Severity:<br>Informational                                           | Diffi<br>culty:<br>Low         |\n| Type:<br>Data<br>Validation                                          | Finding<br>ID:<br>TOB-BUNNI-12 |\n| Target:<br>src/BunniHub,<br>src/BunniHook,<br>src/lib/BunniHookLogic |                                |\n\n#### Description\n\nCertain functions fail to validate incoming arguments, so callers of these functions could mistakenly set important state variables to a zero value, misconfiguring the system.\n\nFor example, the constructor in the BunniHub contract sets the poolManager, weth, and bunniTokenImplementation variables, which store the addresses of external contracts Bunni v2 relies on:\n\n```\nconstructor(\n IPoolManager poolManager_,\n WETH weth_,\n IPermit2 permit2_,\n IBunniToken bunniTokenImplementation_,\n address initialOwner\n) Permit2Enabled(permit2_) {\n poolManager = poolManager_;\n weth = weth_;\n bunniTokenImplementation = bunniTokenImplementation_;\n _initializeOwner(initialOwner);\n}\n```\n\n*Figure 12.1: The constructor of the BunniHub contract ([src/BunniHub.sol#L75–L86](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L75-L86))*\n\nIf weth is set to a zero value, this deployment of the Bunni v2 protocol would be unable to handle native ether. Since all of the variables mentioned above are tagged as immutable, the contract will have to be redeployed to update to the correct address. This misconfiguration may not be noticed immediately, and forcing LPs to migrate would create a poor user experience.\n\nThe following functions are missing zero-value checks:\n\n- BunniHook.constructor\n- The inputAmount returned by the call to BunniSwapMath.computeSwap in BunnyHookLogic.beforeSwap for an exactOut swap\n\n![](_page_48_Picture_10.jpeg)\n\n{49}------------------------------------------------\n\n#### Recommendations\n\nShort term, add zero-value checks to all function arguments to ensure that callers cannot set incorrect values, misconfiguring the system.\n\nLong term, use the Slither static [analyzer](https://github.com/crytic/slither) to catch common issues such as this one. Consider integrating a Slither scan into the project's CI pipeline, pre-commit hooks, or build scripts.\n\n{50}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nCertain functions fail to validate incoming arguments, so callers of these functions could mistakenly set important state variables to a zero value, misconfiguring the system.\n\nFor example, the constructor in the BunniHub contract sets the poolManager, weth, and bunniTokenImplementation variables, which store the addresses of external contracts Bunni v2 relies on:\n\n```\nconstructor(\n IPoolManager poolManager_,\n WETH weth_,\n IPermit2 permit2_,\n IBunniToken bunniTokenImplementation_,\n address initialOwner\n) Permit2Enabled(permit2_) {\n poolManager = poolManager_;\n weth = weth_;\n bunniTokenImplementation = bunniTokenImplementation_;\n _initializeOwner(initialOwner);\n}\n```\n\n*Figure 12.1: The constructor of the BunniHub contract ([src/BunniHub.sol#L75–L86](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L75-L86))*\n\nIf weth is set to a zero value, this deployment of the Bunni v2 protocol would be unable to handle native ether. Since all of the variables mentioned above are tagged as immutable, the contract will have to be redeployed to update to the correct address. This misconfiguration may not be noticed immediately, and forcing LPs to migrate would create a poor user experience.\n\nThe following functions are missing zero-value checks:\n\n- BunniHook.constructor\n- The inputAmount returned by the call to BunniSwapMath.computeSwap in BunnyHookLogic.beforeSwap for an exactOut swap\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, add zero-value checks to all function arguments to ensure that callers cannot set incorrect values, misconfiguring the system.\n\nLong term, use the Slither static [analyzer](https://github.com/crytic/slither) to catch common issues such as this one. Consider integrating a Slither scan into the project's CI pipeline, pre-commit hooks, or build scripts.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nCertain functions fail to validate incoming arguments, so callers of these functions could mistakenly set important state variables to a zero value, misconfiguring the system.\n\nFor example, the constructor in the BunniHub contract sets the poolManager, weth, and bunniTokenImplementation variables, which store the addresses of external contracts Bunni v2 relies on:\n\n```\nconstructor(\n IPoolManager poolManager_,\n WETH weth_,\n IPermit2 permit2_,\n IBunniToken bunniTokenImplementation_,\n address initialOwner\n) Permit2Enabled(permit2_) {\n poolManager = poolManager_;\n weth = weth_;\n bunniTokenImplementation = bunniTokenImplementation_;\n _initializeOwner(initialOwner);\n}\n```\n\n*Figure 12.1: The constructor of the BunniHub contract ([src/BunniHub.sol#L75–L86](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L75-L86))*\n\nIf weth is set to a zero value, this deployment of the Bunni v2 protocol would be unable to handle native ether. Since all of the variables mentioned above are tagged as immutable, the contract will have to be redeployed to update to the correct address. This misconfiguration may not be noticed immediately, and forcing LPs to migrate would create a poor user experience.\n\nThe following functions are missing zero-value checks:\n\n- BunniHook.constructor\n- The inputAmount returned by the call to BunniSwapMath.computeSwap in BunnyHookLogic.beforeSwap for an exactOut swap\n",
      "markdown_body": "| 12. Lack of zero-value checks                            |                                |\n|----------------------------------------------------------------------|--------------------------------|\n| Severity: Informational                                           | Diffi culty: Low         |\n| Type: Data Validation                                          | Finding ID: TOB-BUNNI-12 |\n| Target: src/BunniHub, src/BunniHook, src/lib/BunniHookLogic |                                |\n\n#### Description\n\nCertain functions fail to validate incoming arguments, so callers of these functions could mistakenly set important state variables to a zero value, misconfiguring the system.\n\nFor example, the constructor in the BunniHub contract sets the poolManager, weth, and bunniTokenImplementation variables, which store the addresses of external contracts Bunni v2 relies on:\n\n```\nconstructor(\n IPoolManager poolManager_,\n WETH weth_,\n IPermit2 permit2_,\n IBunniToken bunniTokenImplementation_,\n address initialOwner\n) Permit2Enabled(permit2_) {\n poolManager = poolManager_;\n weth = weth_;\n bunniTokenImplementation = bunniTokenImplementation_;\n _initializeOwner(initialOwner);\n}\n```\n\n*Figure 12.1: The constructor of the BunniHub contract ([src/BunniHub.sol#L75–L86](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L75-L86))*\n\nIf weth is set to a zero value, this deployment of the Bunni v2 protocol would be unable to handle native ether. Since all of the variables mentioned above are tagged as immutable, the contract will have to be redeployed to update to the correct address. This misconfiguration may not be noticed immediately, and forcing LPs to migrate would create a poor user experience.\n\nThe following functions are missing zero-value checks:\n\n- BunniHook.constructor\n- The inputAmount returned by the call to BunniSwapMath.computeSwap in BunnyHookLogic.beforeSwap for an exactOut swap\n\n\n\n#### Recommendations\n\nShort term, add zero-value checks to all function arguments to ensure that callers cannot set incorrect values, misconfiguring the system.\n\nLong term, use the Slither static [analyzer](https://github.com/crytic/slither) to catch common issues such as this one. Consider integrating a Slither scan into the project's CI pipeline, pre-commit hooks, or build scripts.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-12",
        "Target": "src/BunniHub, src/BunniHook, src/lib/BunniHookLogic"
      },
      "heading_cleaned": "Lack of zero-value checks"
    },
    {
      "index": 13,
      "page_start": 50,
      "heading": "13. Lack of systematic approach to rounding and arithmetic errors",
      "markdown": "| 13. Lack of systematic approach to rounding and arithmetic errors |                                |  |\n|----------------------------------------------------------------------------------------------|--------------------------------|--|\n| Severity: Undetermined                                                                    | Diffi culty: Low         |  |\n| Type: Data Validation                                                                  | Finding ID: TOB-BUNNI-13 |  |\n| Target: bunni-v2/src/*                                                                    |                                |  |\n\n#### Description\n\nWhile reviewing the codebase, we noted several areas with seemingly excessive input validation that may hint at underlying issues stemming from improper rounding directions or other arithmetic errors. While we did not identify root causes or ways to exploit these instances, they warrant further investigation and testing. If the root cause is determined to be truly benign, it should be documented.\n\nOperations that suggest a lack of a systematic approach to rounding and arithmetic errors include the following:\n\n● The computeSwap function of the BunniSwapMath library computes the outputAmount multiple times, which indicates that there is a rounding or arithmetic error that is improperly handled:\n\n```\n// compute first pass result\n(updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) = _computeSwap(input,\namountSpecified);\n// ensure that the output amount is lte the output token balance\nif (outputAmount > outputTokenBalance) {\n // exactly output the output token's balance\n // need to recompute swap\n amountSpecified = outputTokenBalance.toInt256();\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n_computeSwap(input, amountSpecified);\n if (outputAmount > outputTokenBalance) {\n // somehow the output amount is still greater than the balance due to\nrounding errors\n // just set outputAmount to the balance\n outputAmount = outputTokenBalance;\n }\n}\n```\n\n*Figure 13.1: A snippet of the computeSwap function that may result in two trial swaps before a cap is applied to outputAmount ([src/lib/BunniSwapMath.sol#L62–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L62-L77))*\n\n\n● The \\_computeSwap function of the BunniSwapMath library allows a user to get up to 2 wei of tokens for free:\n\n```\nif (exactIn) {\n uint256 inputAmountSpecified = uint256(-amountSpecified);\n if (inputAmount > inputAmountSpecified && inputAmount < inputAmountSpecified +\n3) {\n // if it's an exact input swap and inputAmount is greater than the specified\ninput amount by 1 or 2 wei,\n // round down to the specified input amount to avoid reverts. this assumes\nthat it's not feasible to\n // extract significant value from the pool if each swap can at most extract\n2 wei.\n inputAmount = inputAmountSpecified;\n }\n}\n```\n\n*Figure 13.2: A snippet of the \\_computeSwap function that shows the input amount being rounded down in certain situations, favoring the user instead of the pool ([src/lib/BunniSwapMath.sol#L336–L344](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L336-L344))*\n\n● The \\_computeRebalanceParams function of the BunniHookLogic library has a case where both tokens have excess liquidity. This indicates a rounding or arithmetic error in the way excess liquidity is computed:\n\n```\n// decide which token will be rebalanced (i.e., sold into the other token)\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n```\n\n*Figure 13.3: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L651–L652](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L651-L652))*\n\n● The token densities in the queryLDF function are rounded down. However, the density is later used as a denominator, which can result in the totalLiquidityEstimates rounding up. The getAmountsForLiquidity function always rounds down throughout the codebase, which may be incorrect in some cases, as shown in figure 13.4:\n\n```\n(uint256 density0OfRoundedTickX96, uint256 density1OfRoundedTickX96) =\nLiquidityAmounts.getAmountsForLiquidity(\n sqrtPriceX96, roundedTickSqrtRatio, nextRoundedTickSqrtRatio,\nuint128(liquidityDensityOfRoundedTickX96), false\n);\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\n```\n\n\n```\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\n```\n\n*Figure 13.4: A snippet of the queryLDF function ([src/lib/QueryLDF.sol#L69–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L69-L77))*\n\n● If the cumulativeAmounts0/cumulativeAmounts1 functions round down, the resulting excess liquidity is rounded up since the cumulative amounts are used as the denominator:\n\n```\nuint256 excessLiquidity0 = balance0 > currentActiveBalance0\n ? (balance0 - currentActiveBalance0).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount0(\n input.key,\n minUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\nuint256 excessLiquidity1 = balance1 > currentActiveBalance1\n ? (balance1 - currentActiveBalance1).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount1(\n input.key,\n maxUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\n```\n\n*Figure 13.5: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L591–L616](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L591-L616))*\n\n#### Recommendations\n\nShort term, review the system arithmetic and devise a systematic approach to rounding, ensuring rounding always favors the protocol. Implement smart contract fuzzing to determine the relative error bounds of each operation.\n\nLong term, explore whether exposing the rounding direction as an explicit parameter in higher-level functions may help to prevent these types of issues.\n",
      "finding_id": null,
      "markdown_raw": "<span id=\"page-50-0\"></span>\n\n| 13.<br>Lack<br>of<br>systematic<br>approach<br>to<br>rounding<br>and<br>arithmetic<br>errors |                                |  |\n|----------------------------------------------------------------------------------------------|--------------------------------|--|\n| Severity:<br>Undetermined                                                                    | Diffi<br>culty:<br>Low         |  |\n| Type:<br>Data<br>Validation                                                                  | Finding<br>ID:<br>TOB-BUNNI-13 |  |\n| Target:<br>bunni-v2/src/*                                                                    |                                |  |\n\n#### Description\n\nWhile reviewing the codebase, we noted several areas with seemingly excessive input validation that may hint at underlying issues stemming from improper rounding directions or other arithmetic errors. While we did not identify root causes or ways to exploit these instances, they warrant further investigation and testing. If the root cause is determined to be truly benign, it should be documented.\n\nOperations that suggest a lack of a systematic approach to rounding and arithmetic errors include the following:\n\n● The computeSwap function of the BunniSwapMath library computes the outputAmount multiple times, which indicates that there is a rounding or arithmetic error that is improperly handled:\n\n```\n// compute first pass result\n(updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) = _computeSwap(input,\namountSpecified);\n// ensure that the output amount is lte the output token balance\nif (outputAmount > outputTokenBalance) {\n // exactly output the output token's balance\n // need to recompute swap\n amountSpecified = outputTokenBalance.toInt256();\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n_computeSwap(input, amountSpecified);\n if (outputAmount > outputTokenBalance) {\n // somehow the output amount is still greater than the balance due to\nrounding errors\n // just set outputAmount to the balance\n outputAmount = outputTokenBalance;\n }\n}\n```\n\n*Figure 13.1: A snippet of the computeSwap function that may result in two trial swaps before a cap is applied to outputAmount ([src/lib/BunniSwapMath.sol#L62–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L62-L77))*\n\n{51}------------------------------------------------\n\n● The \\_computeSwap function of the BunniSwapMath library allows a user to get up to 2 wei of tokens for free:\n\n```\nif (exactIn) {\n uint256 inputAmountSpecified = uint256(-amountSpecified);\n if (inputAmount > inputAmountSpecified && inputAmount < inputAmountSpecified +\n3) {\n // if it's an exact input swap and inputAmount is greater than the specified\ninput amount by 1 or 2 wei,\n // round down to the specified input amount to avoid reverts. this assumes\nthat it's not feasible to\n // extract significant value from the pool if each swap can at most extract\n2 wei.\n inputAmount = inputAmountSpecified;\n }\n}\n```\n\n*Figure 13.2: A snippet of the \\_computeSwap function that shows the input amount being rounded down in certain situations, favoring the user instead of the pool ([src/lib/BunniSwapMath.sol#L336–L344](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L336-L344))*\n\n● The \\_computeRebalanceParams function of the BunniHookLogic library has a case where both tokens have excess liquidity. This indicates a rounding or arithmetic error in the way excess liquidity is computed:\n\n```\n// decide which token will be rebalanced (i.e., sold into the other token)\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n```\n\n*Figure 13.3: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L651–L652](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L651-L652))*\n\n● The token densities in the queryLDF function are rounded down. However, the density is later used as a denominator, which can result in the totalLiquidityEstimates rounding up. The getAmountsForLiquidity function always rounds down throughout the codebase, which may be incorrect in some cases, as shown in figure 13.4:\n\n```\n(uint256 density0OfRoundedTickX96, uint256 density1OfRoundedTickX96) =\nLiquidityAmounts.getAmountsForLiquidity(\n sqrtPriceX96, roundedTickSqrtRatio, nextRoundedTickSqrtRatio,\nuint128(liquidityDensityOfRoundedTickX96), false\n);\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\n```\n\n{52}------------------------------------------------\n\n```\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\n```\n\n*Figure 13.4: A snippet of the queryLDF function ([src/lib/QueryLDF.sol#L69–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L69-L77))*\n\n● If the cumulativeAmounts0/cumulativeAmounts1 functions round down, the resulting excess liquidity is rounded up since the cumulative amounts are used as the denominator:\n\n```\nuint256 excessLiquidity0 = balance0 > currentActiveBalance0\n ? (balance0 - currentActiveBalance0).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount0(\n input.key,\n minUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\nuint256 excessLiquidity1 = balance1 > currentActiveBalance1\n ? (balance1 - currentActiveBalance1).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount1(\n input.key,\n maxUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\n```\n\n*Figure 13.5: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L591–L616](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L591-L616))*\n\n#### Recommendations\n\nShort term, review the system arithmetic and devise a systematic approach to rounding, ensuring rounding always favors the protocol. Implement smart contract fuzzing to determine the relative error bounds of each operation.\n\nLong term, explore whether exposing the rounding direction as an explicit parameter in higher-level functions may help to prevent these types of issues.\n\n![](_page_52_Picture_8.jpeg)\n\n{53}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nWhile reviewing the codebase, we noted several areas with seemingly excessive input validation that may hint at underlying issues stemming from improper rounding directions or other arithmetic errors. While we did not identify root causes or ways to exploit these instances, they warrant further investigation and testing. If the root cause is determined to be truly benign, it should be documented.\n\nOperations that suggest a lack of a systematic approach to rounding and arithmetic errors include the following:\n\n● The computeSwap function of the BunniSwapMath library computes the outputAmount multiple times, which indicates that there is a rounding or arithmetic error that is improperly handled:\n\n```\n// compute first pass result\n(updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) = _computeSwap(input,\namountSpecified);\n// ensure that the output amount is lte the output token balance\nif (outputAmount > outputTokenBalance) {\n // exactly output the output token's balance\n // need to recompute swap\n amountSpecified = outputTokenBalance.toInt256();\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n_computeSwap(input, amountSpecified);\n if (outputAmount > outputTokenBalance) {\n // somehow the output amount is still greater than the balance due to\nrounding errors\n // just set outputAmount to the balance\n outputAmount = outputTokenBalance;\n }\n}\n```\n\n*Figure 13.1: A snippet of the computeSwap function that may result in two trial swaps before a cap is applied to outputAmount ([src/lib/BunniSwapMath.sol#L62–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L62-L77))*\n\n\n● The \\_computeSwap function of the BunniSwapMath library allows a user to get up to 2 wei of tokens for free:\n\n```\nif (exactIn) {\n uint256 inputAmountSpecified = uint256(-amountSpecified);\n if (inputAmount > inputAmountSpecified && inputAmount < inputAmountSpecified +\n3) {\n // if it's an exact input swap and inputAmount is greater than the specified\ninput amount by 1 or 2 wei,\n // round down to the specified input amount to avoid reverts. this assumes\nthat it's not feasible to\n // extract significant value from the pool if each swap can at most extract\n2 wei.\n inputAmount = inputAmountSpecified;\n }\n}\n```\n\n*Figure 13.2: A snippet of the \\_computeSwap function that shows the input amount being rounded down in certain situations, favoring the user instead of the pool ([src/lib/BunniSwapMath.sol#L336–L344](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L336-L344))*\n\n● The \\_computeRebalanceParams function of the BunniHookLogic library has a case where both tokens have excess liquidity. This indicates a rounding or arithmetic error in the way excess liquidity is computed:\n\n```\n// decide which token will be rebalanced (i.e., sold into the other token)\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n```\n\n*Figure 13.3: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L651–L652](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L651-L652))*\n\n● The token densities in the queryLDF function are rounded down. However, the density is later used as a denominator, which can result in the totalLiquidityEstimates rounding up. The getAmountsForLiquidity function always rounds down throughout the codebase, which may be incorrect in some cases, as shown in figure 13.4:\n\n```\n(uint256 density0OfRoundedTickX96, uint256 density1OfRoundedTickX96) =\nLiquidityAmounts.getAmountsForLiquidity(\n sqrtPriceX96, roundedTickSqrtRatio, nextRoundedTickSqrtRatio,\nuint128(liquidityDensityOfRoundedTickX96), false\n);\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\n```\n\n\n```\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\n```\n\n*Figure 13.4: A snippet of the queryLDF function ([src/lib/QueryLDF.sol#L69–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L69-L77))*\n\n● If the cumulativeAmounts0/cumulativeAmounts1 functions round down, the resulting excess liquidity is rounded up since the cumulative amounts are used as the denominator:\n\n```\nuint256 excessLiquidity0 = balance0 > currentActiveBalance0\n ? (balance0 - currentActiveBalance0).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount0(\n input.key,\n minUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\nuint256 excessLiquidity1 = balance1 > currentActiveBalance1\n ? (balance1 - currentActiveBalance1).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount1(\n input.key,\n maxUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\n```\n\n*Figure 13.5: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L591–L616](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L591-L616))*\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, review the system arithmetic and devise a systematic approach to rounding, ensuring rounding always favors the protocol. Implement smart contract fuzzing to determine the relative error bounds of each operation.\n\nLong term, explore whether exposing the rounding direction as an explicit parameter in higher-level functions may help to prevent these types of issues.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nWhile reviewing the codebase, we noted several areas with seemingly excessive input validation that may hint at underlying issues stemming from improper rounding directions or other arithmetic errors. While we did not identify root causes or ways to exploit these instances, they warrant further investigation and testing. If the root cause is determined to be truly benign, it should be documented.\n\nOperations that suggest a lack of a systematic approach to rounding and arithmetic errors include the following:\n\n● The computeSwap function of the BunniSwapMath library computes the outputAmount multiple times, which indicates that there is a rounding or arithmetic error that is improperly handled:\n\n```\n// compute first pass result\n(updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) = _computeSwap(input,\namountSpecified);\n// ensure that the output amount is lte the output token balance\nif (outputAmount > outputTokenBalance) {\n // exactly output the output token's balance\n // need to recompute swap\n amountSpecified = outputTokenBalance.toInt256();\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n_computeSwap(input, amountSpecified);\n if (outputAmount > outputTokenBalance) {\n // somehow the output amount is still greater than the balance due to\nrounding errors\n // just set outputAmount to the balance\n outputAmount = outputTokenBalance;\n }\n}\n```\n\n*Figure 13.1: A snippet of the computeSwap function that may result in two trial swaps before a cap is applied to outputAmount ([src/lib/BunniSwapMath.sol#L62–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L62-L77))*\n\n\n● The \\_computeSwap function of the BunniSwapMath library allows a user to get up to 2 wei of tokens for free:\n\n```\nif (exactIn) {\n uint256 inputAmountSpecified = uint256(-amountSpecified);\n if (inputAmount > inputAmountSpecified && inputAmount < inputAmountSpecified +\n3) {\n // if it's an exact input swap and inputAmount is greater than the specified\ninput amount by 1 or 2 wei,\n // round down to the specified input amount to avoid reverts. this assumes\nthat it's not feasible to\n // extract significant value from the pool if each swap can at most extract\n2 wei.\n inputAmount = inputAmountSpecified;\n }\n}\n```\n\n*Figure 13.2: A snippet of the \\_computeSwap function that shows the input amount being rounded down in certain situations, favoring the user instead of the pool ([src/lib/BunniSwapMath.sol#L336–L344](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L336-L344))*\n\n● The \\_computeRebalanceParams function of the BunniHookLogic library has a case where both tokens have excess liquidity. This indicates a rounding or arithmetic error in the way excess liquidity is computed:\n\n```\n// decide which token will be rebalanced (i.e., sold into the other token)\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n```\n\n*Figure 13.3: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L651–L652](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L651-L652))*\n\n● The token densities in the queryLDF function are rounded down. However, the density is later used as a denominator, which can result in the totalLiquidityEstimates rounding up. The getAmountsForLiquidity function always rounds down throughout the codebase, which may be incorrect in some cases, as shown in figure 13.4:\n\n```\n(uint256 density0OfRoundedTickX96, uint256 density1OfRoundedTickX96) =\nLiquidityAmounts.getAmountsForLiquidity(\n sqrtPriceX96, roundedTickSqrtRatio, nextRoundedTickSqrtRatio,\nuint128(liquidityDensityOfRoundedTickX96), false\n);\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\n```\n\n\n```\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\n```\n\n*Figure 13.4: A snippet of the queryLDF function ([src/lib/QueryLDF.sol#L69–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L69-L77))*\n\n● If the cumulativeAmounts0/cumulativeAmounts1 functions round down, the resulting excess liquidity is rounded up since the cumulative amounts are used as the denominator:\n\n```\nuint256 excessLiquidity0 = balance0 > currentActiveBalance0\n ? (balance0 - currentActiveBalance0).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount0(\n input.key,\n minUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\nuint256 excessLiquidity1 = balance1 > currentActiveBalance1\n ? (balance1 - currentActiveBalance1).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount1(\n input.key,\n maxUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\n```\n\n*Figure 13.5: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L591–L616](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L591-L616))*\n",
      "markdown_body": "| 13. Lack of systematic approach to rounding and arithmetic errors |                                |  |\n|----------------------------------------------------------------------------------------------|--------------------------------|--|\n| Severity: Undetermined                                                                    | Diffi culty: Low         |  |\n| Type: Data Validation                                                                  | Finding ID: TOB-BUNNI-13 |  |\n| Target: bunni-v2/src/*                                                                    |                                |  |\n\n#### Description\n\nWhile reviewing the codebase, we noted several areas with seemingly excessive input validation that may hint at underlying issues stemming from improper rounding directions or other arithmetic errors. While we did not identify root causes or ways to exploit these instances, they warrant further investigation and testing. If the root cause is determined to be truly benign, it should be documented.\n\nOperations that suggest a lack of a systematic approach to rounding and arithmetic errors include the following:\n\n● The computeSwap function of the BunniSwapMath library computes the outputAmount multiple times, which indicates that there is a rounding or arithmetic error that is improperly handled:\n\n```\n// compute first pass result\n(updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) = _computeSwap(input,\namountSpecified);\n// ensure that the output amount is lte the output token balance\nif (outputAmount > outputTokenBalance) {\n // exactly output the output token's balance\n // need to recompute swap\n amountSpecified = outputTokenBalance.toInt256();\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n_computeSwap(input, amountSpecified);\n if (outputAmount > outputTokenBalance) {\n // somehow the output amount is still greater than the balance due to\nrounding errors\n // just set outputAmount to the balance\n outputAmount = outputTokenBalance;\n }\n}\n```\n\n*Figure 13.1: A snippet of the computeSwap function that may result in two trial swaps before a cap is applied to outputAmount ([src/lib/BunniSwapMath.sol#L62–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L62-L77))*\n\n\n● The \\_computeSwap function of the BunniSwapMath library allows a user to get up to 2 wei of tokens for free:\n\n```\nif (exactIn) {\n uint256 inputAmountSpecified = uint256(-amountSpecified);\n if (inputAmount > inputAmountSpecified && inputAmount < inputAmountSpecified +\n3) {\n // if it's an exact input swap and inputAmount is greater than the specified\ninput amount by 1 or 2 wei,\n // round down to the specified input amount to avoid reverts. this assumes\nthat it's not feasible to\n // extract significant value from the pool if each swap can at most extract\n2 wei.\n inputAmount = inputAmountSpecified;\n }\n}\n```\n\n*Figure 13.2: A snippet of the \\_computeSwap function that shows the input amount being rounded down in certain situations, favoring the user instead of the pool ([src/lib/BunniSwapMath.sol#L336–L344](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L336-L344))*\n\n● The \\_computeRebalanceParams function of the BunniHookLogic library has a case where both tokens have excess liquidity. This indicates a rounding or arithmetic error in the way excess liquidity is computed:\n\n```\n// decide which token will be rebalanced (i.e., sold into the other token)\nbool willRebalanceToken0 = shouldRebalance0 && (!shouldRebalance1 ||\nexcessLiquidity0 > excessLiquidity1);\n```\n\n*Figure 13.3: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L651–L652](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L651-L652))*\n\n● The token densities in the queryLDF function are rounded down. However, the density is later used as a denominator, which can result in the totalLiquidityEstimates rounding up. The getAmountsForLiquidity function always rounds down throughout the codebase, which may be incorrect in some cases, as shown in figure 13.4:\n\n```\n(uint256 density0OfRoundedTickX96, uint256 density1OfRoundedTickX96) =\nLiquidityAmounts.getAmountsForLiquidity(\n sqrtPriceX96, roundedTickSqrtRatio, nextRoundedTickSqrtRatio,\nuint128(liquidityDensityOfRoundedTickX96), false\n);\ntotalDensity0X96 = density0RightOfRoundedTickX96 + density0OfRoundedTickX96;\ntotalDensity1X96 = density1LeftOfRoundedTickX96 + density1OfRoundedTickX96;\nuint256 totalLiquidityEstimate0 =\n (balance0 == 0 || totalDensity0X96 == 0) ? 0 : balance0.fullMulDiv(Q96,\ntotalDensity0X96);\n```\n\n\n```\nuint256 totalLiquidityEstimate1 =\n (balance1 == 0 || totalDensity1X96 == 0) ? 0 : balance1.fullMulDiv(Q96,\ntotalDensity1X96);\n```\n\n*Figure 13.4: A snippet of the queryLDF function ([src/lib/QueryLDF.sol#L69–L77](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/QueryLDF.sol#L69-L77))*\n\n● If the cumulativeAmounts0/cumulativeAmounts1 functions round down, the resulting excess liquidity is rounded up since the cumulative amounts are used as the denominator:\n\n```\nuint256 excessLiquidity0 = balance0 > currentActiveBalance0\n ? (balance0 - currentActiveBalance0).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount0(\n input.key,\n minUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\nuint256 excessLiquidity1 = balance1 > currentActiveBalance1\n ? (balance1 - currentActiveBalance1).divWad(\n bunniState.liquidityDensityFunction.cumulativeAmount1(\n input.key,\n maxUsableTick,\n WAD,\n input.arithmeticMeanTick,\n input.updatedTick,\n bunniState.ldfParams,\n input.newLdfState\n )\n )\n : 0;\n```\n\n*Figure 13.5: A snippet of the \\_computeRebalanceParams function ([src/lib/BunniHookLogic.sol#L591–L616](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHookLogic.sol#L591-L616))*\n\n#### Recommendations\n\nShort term, review the system arithmetic and devise a systematic approach to rounding, ensuring rounding always favors the protocol. Implement smart contract fuzzing to determine the relative error bounds of each operation.\n\nLong term, explore whether exposing the rounding direction as an explicit parameter in higher-level functions may help to prevent these types of issues.\n",
      "metadata": {
        "Severity": null,
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-13",
        "Target": "bunni-v2/src/*"
      },
      "heading_cleaned": "Lack of systematic approach to rounding and arithmetic errors"
    },
    {
      "index": 14,
      "page_start": 53,
      "heading": "14. Native assets deposited to pools with no native currencies are lost",
      "markdown": "## 14. Native assets deposited to pools with no native currencies are lost\n\n| Severity: Informational           | Diffi culty: High        |\n|--------------------------------------|--------------------------------|\n| Type: Data Validation          | Finding ID: TOB-BUNNI-14 |\n| Target: src/lib/BunniHubLogic.sol |                                |\n\n#### Description\n\nNative assets deposited to pools with no native currencies are lost.\n\nThe deposit function of the BunniHub contract is payable since it needs to handle native assets if one of the tokens of the pool is a native token, as shown in figure 14.1:\n\n```\nfunction deposit(DepositParams calldata params)\n external\n payable\n virtual\n override\n nonReentrant\n checkDeadline(params.deadline)\n returns (uint256 shares, uint256 amount0, uint256 amount1)\n{\n return BunniHubLogic.deposit(\n s,\n BunniHubLogic.Env({\n weth: weth,\n permit2: permit2,\n poolManager: poolManager,\n bunniTokenImplementation: bunniTokenImplementation\n }),\n params\n );\n}\n```\n\n*Figure 14.1: The payable deposit function in BunniHub ([src/BunniHub.sol#L93–L112](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L93-L112))*\n\nIf a user provides an excess of native assets, the function will refund the difference back to the user, as shown in figure 14.2:\n\n```\nif (params.poolKey.currency0.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount0)\n );\n }\n```\n\n\n```\n} else if (params.poolKey.currency1.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount1)\n );\n }\n}\n```\n\n*Figure 14.2: A code snippet of the deposit function in BunniHubLogic ([src/lib/BunniHubLogic.sol#L172–L184](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L172-L184))*\n\nHowever, if the pool's currencies are both non-native and a user mistakenly provides a nonzero msg.value, this value will not be refunded and will remain in the BunniHub. Although this value can be withdrawn by deploying a new pool and abusing some of the calls, there is no direct and easy way to do this.\n\n#### Recommendations\n\nAdd a check to the deposit function of BunniHub that msg.value is zero if both pool tokens are non-native; otherwise, have the function revert.\n",
      "finding_id": null,
      "markdown_raw": "## <span id=\"page-53-0\"></span>14. Native assets deposited to pools with no native currencies are lost\n\n| Severity:<br>Informational           | Diffi<br>culty:<br>High        |\n|--------------------------------------|--------------------------------|\n| Type:<br>Data<br>Validation          | Finding<br>ID:<br>TOB-BUNNI-14 |\n| Target:<br>src/lib/BunniHubLogic.sol |                                |\n\n#### Description\n\nNative assets deposited to pools with no native currencies are lost.\n\nThe deposit function of the BunniHub contract is payable since it needs to handle native assets if one of the tokens of the pool is a native token, as shown in figure 14.1:\n\n```\nfunction deposit(DepositParams calldata params)\n external\n payable\n virtual\n override\n nonReentrant\n checkDeadline(params.deadline)\n returns (uint256 shares, uint256 amount0, uint256 amount1)\n{\n return BunniHubLogic.deposit(\n s,\n BunniHubLogic.Env({\n weth: weth,\n permit2: permit2,\n poolManager: poolManager,\n bunniTokenImplementation: bunniTokenImplementation\n }),\n params\n );\n}\n```\n\n*Figure 14.1: The payable deposit function in BunniHub ([src/BunniHub.sol#L93–L112](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L93-L112))*\n\nIf a user provides an excess of native assets, the function will refund the difference back to the user, as shown in figure 14.2:\n\n```\nif (params.poolKey.currency0.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount0)\n );\n }\n```\n\n{54}------------------------------------------------\n\n```\n} else if (params.poolKey.currency1.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount1)\n );\n }\n}\n```\n\n*Figure 14.2: A code snippet of the deposit function in BunniHubLogic ([src/lib/BunniHubLogic.sol#L172–L184](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L172-L184))*\n\nHowever, if the pool's currencies are both non-native and a user mistakenly provides a nonzero msg.value, this value will not be refunded and will remain in the BunniHub. Although this value can be withdrawn by deploying a new pool and abusing some of the calls, there is no direct and easy way to do this.\n\n#### Recommendations\n\nAdd a check to the deposit function of BunniHub that msg.value is zero if both pool tokens are non-native; otherwise, have the function revert.\n\n{55}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nNative assets deposited to pools with no native currencies are lost.\n\nThe deposit function of the BunniHub contract is payable since it needs to handle native assets if one of the tokens of the pool is a native token, as shown in figure 14.1:\n\n```\nfunction deposit(DepositParams calldata params)\n external\n payable\n virtual\n override\n nonReentrant\n checkDeadline(params.deadline)\n returns (uint256 shares, uint256 amount0, uint256 amount1)\n{\n return BunniHubLogic.deposit(\n s,\n BunniHubLogic.Env({\n weth: weth,\n permit2: permit2,\n poolManager: poolManager,\n bunniTokenImplementation: bunniTokenImplementation\n }),\n params\n );\n}\n```\n\n*Figure 14.1: The payable deposit function in BunniHub ([src/BunniHub.sol#L93–L112](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L93-L112))*\n\nIf a user provides an excess of native assets, the function will refund the difference back to the user, as shown in figure 14.2:\n\n```\nif (params.poolKey.currency0.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount0)\n );\n }\n```\n\n\n```\n} else if (params.poolKey.currency1.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount1)\n );\n }\n}\n```\n\n*Figure 14.2: A code snippet of the deposit function in BunniHubLogic ([src/lib/BunniHubLogic.sol#L172–L184](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L172-L184))*\n\nHowever, if the pool's currencies are both non-native and a user mistakenly provides a nonzero msg.value, this value will not be refunded and will remain in the BunniHub. Although this value can be withdrawn by deploying a new pool and abusing some of the calls, there is no direct and easy way to do this.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nAdd a check to the deposit function of BunniHub that msg.value is zero if both pool tokens are non-native; otherwise, have the function revert.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nNative assets deposited to pools with no native currencies are lost.\n\nThe deposit function of the BunniHub contract is payable since it needs to handle native assets if one of the tokens of the pool is a native token, as shown in figure 14.1:\n\n```\nfunction deposit(DepositParams calldata params)\n external\n payable\n virtual\n override\n nonReentrant\n checkDeadline(params.deadline)\n returns (uint256 shares, uint256 amount0, uint256 amount1)\n{\n return BunniHubLogic.deposit(\n s,\n BunniHubLogic.Env({\n weth: weth,\n permit2: permit2,\n poolManager: poolManager,\n bunniTokenImplementation: bunniTokenImplementation\n }),\n params\n );\n}\n```\n\n*Figure 14.1: The payable deposit function in BunniHub ([src/BunniHub.sol#L93–L112](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L93-L112))*\n\nIf a user provides an excess of native assets, the function will refund the difference back to the user, as shown in figure 14.2:\n\n```\nif (params.poolKey.currency0.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount0)\n );\n }\n```\n\n\n```\n} else if (params.poolKey.currency1.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount1)\n );\n }\n}\n```\n\n*Figure 14.2: A code snippet of the deposit function in BunniHubLogic ([src/lib/BunniHubLogic.sol#L172–L184](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L172-L184))*\n\nHowever, if the pool's currencies are both non-native and a user mistakenly provides a nonzero msg.value, this value will not be refunded and will remain in the BunniHub. Although this value can be withdrawn by deploying a new pool and abusing some of the calls, there is no direct and easy way to do this.\n",
      "markdown_body": "| Severity: Informational           | Diffi culty: High        |\n|--------------------------------------|--------------------------------|\n| Type: Data Validation          | Finding ID: TOB-BUNNI-14 |\n| Target: src/lib/BunniHubLogic.sol |                                |\n\n#### Description\n\nNative assets deposited to pools with no native currencies are lost.\n\nThe deposit function of the BunniHub contract is payable since it needs to handle native assets if one of the tokens of the pool is a native token, as shown in figure 14.1:\n\n```\nfunction deposit(DepositParams calldata params)\n external\n payable\n virtual\n override\n nonReentrant\n checkDeadline(params.deadline)\n returns (uint256 shares, uint256 amount0, uint256 amount1)\n{\n return BunniHubLogic.deposit(\n s,\n BunniHubLogic.Env({\n weth: weth,\n permit2: permit2,\n poolManager: poolManager,\n bunniTokenImplementation: bunniTokenImplementation\n }),\n params\n );\n}\n```\n\n*Figure 14.1: The payable deposit function in BunniHub ([src/BunniHub.sol#L93–L112](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/BunniHub.sol#L93-L112))*\n\nIf a user provides an excess of native assets, the function will refund the difference back to the user, as shown in figure 14.2:\n\n```\nif (params.poolKey.currency0.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount0)\n );\n }\n```\n\n\n```\n} else if (params.poolKey.currency1.isNative()) {\n if (address(this).balance != 0) {\n params.refundRecipient.safeTransferETH(\n FixedPointMathLib.min(address(this).balance, msg.value - amount1)\n );\n }\n}\n```\n\n*Figure 14.2: A code snippet of the deposit function in BunniHubLogic ([src/lib/BunniHubLogic.sol#L172–L184](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniHubLogic.sol#L172-L184))*\n\nHowever, if the pool's currencies are both non-native and a user mistakenly provides a nonzero msg.value, this value will not be refunded and will remain in the BunniHub. Although this value can be withdrawn by deploying a new pool and abusing some of the calls, there is no direct and easy way to do this.\n\n#### Recommendations\n\nAdd a check to the deposit function of BunniHub that msg.value is zero if both pool tokens are non-native; otherwise, have the function revert.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-14",
        "Target": "src/lib/BunniHubLogic.sol"
      },
      "heading_cleaned": "Native assets deposited to pools with no native currencies are lost"
    },
    {
      "index": 15,
      "page_start": 55,
      "heading": "15. Users can gain free tokens through the BunniSwap swap functionality",
      "markdown": "# 15. Users can gain free tokens through the BunniSwap swap functionality\n\n| Severity: High                    | Diffi culty: High        |\n|--------------------------------------|--------------------------------|\n| Type: Data Validation          | Finding ID: TOB-BUNNI-15 |\n| src/lib/BunniSwapMath.col Target: |                                |\n\n#### Description\n\nDuring token swaps, users can receive a nonzero amount of output tokens even when they provide zero input tokens, allowing them to acquire free tokens without contributing any input tokens for the swap.\n\nThe computeSwap function in the BunniSwapMath library executes swap operations based on a user-specified token amountSpecified as one of the inputs to the function. As shown in figure 15.1, depending on whether the amountSpecified is negative or positive, the swap is configured to be an ExactIn or ExactOut swap.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 15.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nAs shown in figure 15.2, after a swap occurs, computeSwap returns the updated pool state and the amount of input tokens swapped by the user for the output tokens. The expectation is that, given a valid pool state, if the amountSpecified is nonzero, the swap should proceed, and if the output token amount is nonzero, the input token amount should also not be zero. In other words, users should not be able to acquire tokens for free. However, even if the user provides a nonzero amountSpecified during the swap, the function can still result in zero input tokens provided by the user while returning a nonzero amount of output tokens, enabling users to gain tokens for free during the swap.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount){\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n```\n\n\n```\n ...\n}\n```\n\n*Figure 15.2: Snippet of the computeSwap function in the library BunniSwapMath ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nWe found this issue with Medusa during the invariant testing process.\n\n#### Recommendations\n\nShort term, triage this issue's underlying root cause and deploy a fix such that swap functionality behaves as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "finding_id": null,
      "markdown_raw": "# <span id=\"page-55-0\"></span>15. Users can gain free tokens through the BunniSwap swap functionality\n\n| Severity:<br>High                    | Diffi<br>culty:<br>High        |\n|--------------------------------------|--------------------------------|\n| Type:<br>Data<br>Validation          | Finding<br>ID:<br>TOB-BUNNI-15 |\n| src/lib/BunniSwapMath.col<br>Target: |                                |\n\n#### Description\n\nDuring token swaps, users can receive a nonzero amount of output tokens even when they provide zero input tokens, allowing them to acquire free tokens without contributing any input tokens for the swap.\n\nThe computeSwap function in the BunniSwapMath library executes swap operations based on a user-specified token amountSpecified as one of the inputs to the function. As shown in figure 15.1, depending on whether the amountSpecified is negative or positive, the swap is configured to be an ExactIn or ExactOut swap.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 15.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nAs shown in figure 15.2, after a swap occurs, computeSwap returns the updated pool state and the amount of input tokens swapped by the user for the output tokens. The expectation is that, given a valid pool state, if the amountSpecified is nonzero, the swap should proceed, and if the output token amount is nonzero, the input token amount should also not be zero. In other words, users should not be able to acquire tokens for free. However, even if the user provides a nonzero amountSpecified during the swap, the function can still result in zero input tokens provided by the user while returning a nonzero amount of output tokens, enabling users to gain tokens for free during the swap.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount){\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n```\n\n{56}------------------------------------------------\n\n```\n ...\n}\n```\n\n*Figure 15.2: Snippet of the computeSwap function in the library BunniSwapMath ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nWe found this issue with Medusa during the invariant testing process.\n\n#### Recommendations\n\nShort term, triage this issue's underlying root cause and deploy a fix such that swap functionality behaves as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n\n{57}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nDuring token swaps, users can receive a nonzero amount of output tokens even when they provide zero input tokens, allowing them to acquire free tokens without contributing any input tokens for the swap.\n\nThe computeSwap function in the BunniSwapMath library executes swap operations based on a user-specified token amountSpecified as one of the inputs to the function. As shown in figure 15.1, depending on whether the amountSpecified is negative or positive, the swap is configured to be an ExactIn or ExactOut swap.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 15.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nAs shown in figure 15.2, after a swap occurs, computeSwap returns the updated pool state and the amount of input tokens swapped by the user for the output tokens. The expectation is that, given a valid pool state, if the amountSpecified is nonzero, the swap should proceed, and if the output token amount is nonzero, the input token amount should also not be zero. In other words, users should not be able to acquire tokens for free. However, even if the user provides a nonzero amountSpecified during the swap, the function can still result in zero input tokens provided by the user while returning a nonzero amount of output tokens, enabling users to gain tokens for free during the swap.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount){\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n```\n\n\n```\n ...\n}\n```\n\n*Figure 15.2: Snippet of the computeSwap function in the library BunniSwapMath ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nWe found this issue with Medusa during the invariant testing process.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, triage this issue's underlying root cause and deploy a fix such that swap functionality behaves as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nDuring token swaps, users can receive a nonzero amount of output tokens even when they provide zero input tokens, allowing them to acquire free tokens without contributing any input tokens for the swap.\n\nThe computeSwap function in the BunniSwapMath library executes swap operations based on a user-specified token amountSpecified as one of the inputs to the function. As shown in figure 15.1, depending on whether the amountSpecified is negative or positive, the swap is configured to be an ExactIn or ExactOut swap.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 15.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nAs shown in figure 15.2, after a swap occurs, computeSwap returns the updated pool state and the amount of input tokens swapped by the user for the output tokens. The expectation is that, given a valid pool state, if the amountSpecified is nonzero, the swap should proceed, and if the output token amount is nonzero, the input token amount should also not be zero. In other words, users should not be able to acquire tokens for free. However, even if the user provides a nonzero amountSpecified during the swap, the function can still result in zero input tokens provided by the user while returning a nonzero amount of output tokens, enabling users to gain tokens for free during the swap.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount){\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n```\n\n\n```\n ...\n}\n```\n\n*Figure 15.2: Snippet of the computeSwap function in the library BunniSwapMath ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nWe found this issue with Medusa during the invariant testing process.\n",
      "markdown_body": "| Severity: High                    | Diffi culty: High        |\n|--------------------------------------|--------------------------------|\n| Type: Data Validation          | Finding ID: TOB-BUNNI-15 |\n| src/lib/BunniSwapMath.col Target: |                                |\n\n#### Description\n\nDuring token swaps, users can receive a nonzero amount of output tokens even when they provide zero input tokens, allowing them to acquire free tokens without contributing any input tokens for the swap.\n\nThe computeSwap function in the BunniSwapMath library executes swap operations based on a user-specified token amountSpecified as one of the inputs to the function. As shown in figure 15.1, depending on whether the amountSpecified is negative or positive, the swap is configured to be an ExactIn or ExactOut swap.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 15.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nAs shown in figure 15.2, after a swap occurs, computeSwap returns the updated pool state and the amount of input tokens swapped by the user for the output tokens. The expectation is that, given a valid pool state, if the amountSpecified is nonzero, the swap should proceed, and if the output token amount is nonzero, the input token amount should also not be zero. In other words, users should not be able to acquire tokens for free. However, even if the user provides a nonzero amountSpecified during the swap, the function can still result in zero input tokens provided by the user while returning a nonzero amount of output tokens, enabling users to gain tokens for free during the swap.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount){\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n```\n\n\n```\n ...\n}\n```\n\n*Figure 15.2: Snippet of the computeSwap function in the library BunniSwapMath ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nWe found this issue with Medusa during the invariant testing process.\n\n#### Recommendations\n\nShort term, triage this issue's underlying root cause and deploy a fix such that swap functionality behaves as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-15",
        "Target": "src/lib/BunniSwapMath.sol"
      },
      "heading_cleaned": "Users can gain free tokens through the BunniSwap swap functionality"
    },
    {
      "index": 16,
      "page_start": 57,
      "heading": "16. Users can gain tokens during round-trip swaps",
      "markdown": "| 16. Users can gain tokens during round-trip swaps |                        |\n|------------------------------------------------------------------------|------------------------|\n| Severity: High                                                      | Diffi culty: Low |\n| Type: Data Validation Finding ID: TOB-BUNNI-16          |                        |\n| Target: src/lib/BunniSwapMath.col                                   |                        |\n\n#### Description\n\nThe swap functionality of BunniSwapMath library is not accurately implemented, allowing users to gain tokens during round-trip swaps (i.e., swapping token0 for token1 and then swapping the same amount of token1 for token0).\n\nThe computeSwap function in the BunniSwapMath library allows users to swap tokens on a valid pool state. Given an amountSpecified and the swap direction, the function calculates the input tokens exchanged for the output tokens. In a zeroForOne swap, the user exchanges token0 for token1, and the pool state is updated to reflect the new token balances and price ratio, as shown in figure 16.1.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount)\n{\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n ...\n // compute first pass result\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n _computeSwap(input, amountSpecified);\n ...\n}\n```\n\n*Figure 16.1: Snippet of the computeSwap function in the BunniSwapMath library showing the updated pool state ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nIf the user then performs a OneForZero swap—exchanging the previously gained token1 for token0—the expectation is that the user should receive the same amount of token0 they initially provided. However, due to the incorrect implementation of computeSwap, the input tokens received after the OneForZero swap exceed the expected amount, allowing users to gain tokens during round-trip swaps.\n\n\nThis is, in part, due to the updatedTick never being initialized when both branches in the highlighted lines of figure 16.2 are skipped.\n\n```\nif (\n (zeroForOne && sqrtPriceLimitX96 <= leastChangeSqrtPriceX96)\n || (!zeroForOne && sqrtPriceLimitX96 >= leastChangeSqrtPriceX96)\n) {\n // ...\n if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n unchecked {\n // cannot cast a bool to an int24 in Solidity\n int24 _zeroForOne;\n assembly {\n _zeroForOne := zeroForOne\n }\n updatedTick = tickNext - _zeroForOne;\n }\n } else if (naiveSwapResultSqrtPriceX96 != startSqrtPriceX96) {\n // recompute unless we're on a lower tick boundary (i.e. already\ntransitioned ticks), and haven't moved\n updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n }\n // ...\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n```\n\n*Figure 16.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L228–L302](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L228-L302))*\n\nWe found this issue with Medusa during the invariant testing process.\n\n#### Recommendations\n\nShort term, initialize the updatedTick to the correct value when the branches in figure 16.2 are skipped. Run the invariant tests again with the updated code and triage any outstanding invariant failures.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "finding_id": null,
      "markdown_raw": "<span id=\"page-57-0\"></span>\n\n| 16.<br>Users<br>can<br>gain<br>tokens<br>during<br>round-trip<br>swaps |                        |\n|------------------------------------------------------------------------|------------------------|\n| Severity:<br>High                                                      | Diffi<br>culty:<br>Low |\n| Type:<br>Data<br>Validation<br>Finding<br>ID:<br>TOB-BUNNI-16          |                        |\n| Target:<br>src/lib/BunniSwapMath.col                                   |                        |\n\n#### Description\n\nThe swap functionality of BunniSwapMath library is not accurately implemented, allowing users to gain tokens during round-trip swaps (i.e., swapping token0 for token1 and then swapping the same amount of token1 for token0).\n\nThe computeSwap function in the BunniSwapMath library allows users to swap tokens on a valid pool state. Given an amountSpecified and the swap direction, the function calculates the input tokens exchanged for the output tokens. In a zeroForOne swap, the user exchanges token0 for token1, and the pool state is updated to reflect the new token balances and price ratio, as shown in figure 16.1.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount)\n{\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n ...\n // compute first pass result\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n _computeSwap(input, amountSpecified);\n ...\n}\n```\n\n*Figure 16.1: Snippet of the computeSwap function in the BunniSwapMath library showing the updated pool state ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nIf the user then performs a OneForZero swap—exchanging the previously gained token1 for token0—the expectation is that the user should receive the same amount of token0 they initially provided. However, due to the incorrect implementation of computeSwap, the input tokens received after the OneForZero swap exceed the expected amount, allowing users to gain tokens during round-trip swaps.\n\n{58}------------------------------------------------\n\nThis is, in part, due to the updatedTick never being initialized when both branches in the highlighted lines of figure 16.2 are skipped.\n\n```\nif (\n (zeroForOne && sqrtPriceLimitX96 <= leastChangeSqrtPriceX96)\n || (!zeroForOne && sqrtPriceLimitX96 >= leastChangeSqrtPriceX96)\n) {\n // ...\n if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n unchecked {\n // cannot cast a bool to an int24 in Solidity\n int24 _zeroForOne;\n assembly {\n _zeroForOne := zeroForOne\n }\n updatedTick = tickNext - _zeroForOne;\n }\n } else if (naiveSwapResultSqrtPriceX96 != startSqrtPriceX96) {\n // recompute unless we're on a lower tick boundary (i.e. already\ntransitioned ticks), and haven't moved\n updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n }\n // ...\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n```\n\n*Figure 16.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L228–L302](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L228-L302))*\n\nWe found this issue with Medusa during the invariant testing process.\n\n#### Recommendations\n\nShort term, initialize the updatedTick to the correct value when the branches in figure 16.2 are skipped. Run the invariant tests again with the updated code and triage any outstanding invariant failures.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n\n{59}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe swap functionality of BunniSwapMath library is not accurately implemented, allowing users to gain tokens during round-trip swaps (i.e., swapping token0 for token1 and then swapping the same amount of token1 for token0).\n\nThe computeSwap function in the BunniSwapMath library allows users to swap tokens on a valid pool state. Given an amountSpecified and the swap direction, the function calculates the input tokens exchanged for the output tokens. In a zeroForOne swap, the user exchanges token0 for token1, and the pool state is updated to reflect the new token balances and price ratio, as shown in figure 16.1.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount)\n{\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n ...\n // compute first pass result\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n _computeSwap(input, amountSpecified);\n ...\n}\n```\n\n*Figure 16.1: Snippet of the computeSwap function in the BunniSwapMath library showing the updated pool state ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nIf the user then performs a OneForZero swap—exchanging the previously gained token1 for token0—the expectation is that the user should receive the same amount of token0 they initially provided. However, due to the incorrect implementation of computeSwap, the input tokens received after the OneForZero swap exceed the expected amount, allowing users to gain tokens during round-trip swaps.\n\n\nThis is, in part, due to the updatedTick never being initialized when both branches in the highlighted lines of figure 16.2 are skipped.\n\n```\nif (\n (zeroForOne && sqrtPriceLimitX96 <= leastChangeSqrtPriceX96)\n || (!zeroForOne && sqrtPriceLimitX96 >= leastChangeSqrtPriceX96)\n) {\n // ...\n if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n unchecked {\n // cannot cast a bool to an int24 in Solidity\n int24 _zeroForOne;\n assembly {\n _zeroForOne := zeroForOne\n }\n updatedTick = tickNext - _zeroForOne;\n }\n } else if (naiveSwapResultSqrtPriceX96 != startSqrtPriceX96) {\n // recompute unless we're on a lower tick boundary (i.e. already\ntransitioned ticks), and haven't moved\n updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n }\n // ...\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n```\n\n*Figure 16.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L228–L302](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L228-L302))*\n\nWe found this issue with Medusa during the invariant testing process.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, initialize the updatedTick to the correct value when the branches in figure 16.2 are skipped. Run the invariant tests again with the updated code and triage any outstanding invariant failures.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe swap functionality of BunniSwapMath library is not accurately implemented, allowing users to gain tokens during round-trip swaps (i.e., swapping token0 for token1 and then swapping the same amount of token1 for token0).\n\nThe computeSwap function in the BunniSwapMath library allows users to swap tokens on a valid pool state. Given an amountSpecified and the swap direction, the function calculates the input tokens exchanged for the output tokens. In a zeroForOne swap, the user exchanges token0 for token1, and the pool state is updated to reflect the new token balances and price ratio, as shown in figure 16.1.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount)\n{\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n ...\n // compute first pass result\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n _computeSwap(input, amountSpecified);\n ...\n}\n```\n\n*Figure 16.1: Snippet of the computeSwap function in the BunniSwapMath library showing the updated pool state ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nIf the user then performs a OneForZero swap—exchanging the previously gained token1 for token0—the expectation is that the user should receive the same amount of token0 they initially provided. However, due to the incorrect implementation of computeSwap, the input tokens received after the OneForZero swap exceed the expected amount, allowing users to gain tokens during round-trip swaps.\n\n\nThis is, in part, due to the updatedTick never being initialized when both branches in the highlighted lines of figure 16.2 are skipped.\n\n```\nif (\n (zeroForOne && sqrtPriceLimitX96 <= leastChangeSqrtPriceX96)\n || (!zeroForOne && sqrtPriceLimitX96 >= leastChangeSqrtPriceX96)\n) {\n // ...\n if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n unchecked {\n // cannot cast a bool to an int24 in Solidity\n int24 _zeroForOne;\n assembly {\n _zeroForOne := zeroForOne\n }\n updatedTick = tickNext - _zeroForOne;\n }\n } else if (naiveSwapResultSqrtPriceX96 != startSqrtPriceX96) {\n // recompute unless we're on a lower tick boundary (i.e. already\ntransitioned ticks), and haven't moved\n updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n }\n // ...\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n```\n\n*Figure 16.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L228–L302](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L228-L302))*\n\nWe found this issue with Medusa during the invariant testing process.\n",
      "markdown_body": "| 16. Users can gain tokens during round-trip swaps |                        |\n|------------------------------------------------------------------------|------------------------|\n| Severity: High                                                      | Diffi culty: Low |\n| Type: Data Validation Finding ID: TOB-BUNNI-16          |                        |\n| Target: src/lib/BunniSwapMath.col                                   |                        |\n\n#### Description\n\nThe swap functionality of BunniSwapMath library is not accurately implemented, allowing users to gain tokens during round-trip swaps (i.e., swapping token0 for token1 and then swapping the same amount of token1 for token0).\n\nThe computeSwap function in the BunniSwapMath library allows users to swap tokens on a valid pool state. Given an amountSpecified and the swap direction, the function calculates the input tokens exchanged for the output tokens. In a zeroForOne swap, the user exchanges token0 for token1, and the pool state is updated to reflect the new token balances and price ratio, as shown in figure 16.1.\n\n```\nfunction computeSwap(BunniComputeSwapInput calldata input,\nuint256 balance0, uint256 balance1)\n external\n view\n returns (uint160 updatedSqrtPriceX96, int24 updatedTick,\n uint256 inputAmount, uint256 outputAmount)\n{\n uint256 outputTokenBalance = input.swapParams.zeroForOne ? balance1 : balance0;\n int256 amountSpecified = input.swapParams.amountSpecified;\n ...\n // compute first pass result\n (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount) =\n _computeSwap(input, amountSpecified);\n ...\n}\n```\n\n*Figure 16.1: Snippet of the computeSwap function in the BunniSwapMath library showing the updated pool state ([src/lib/BunniSwapMath.sol#L49–78](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L49-L78))*\n\nIf the user then performs a OneForZero swap—exchanging the previously gained token1 for token0—the expectation is that the user should receive the same amount of token0 they initially provided. However, due to the incorrect implementation of computeSwap, the input tokens received after the OneForZero swap exceed the expected amount, allowing users to gain tokens during round-trip swaps.\n\n\nThis is, in part, due to the updatedTick never being initialized when both branches in the highlighted lines of figure 16.2 are skipped.\n\n```\nif (\n (zeroForOne && sqrtPriceLimitX96 <= leastChangeSqrtPriceX96)\n || (!zeroForOne && sqrtPriceLimitX96 >= leastChangeSqrtPriceX96)\n) {\n // ...\n if (naiveSwapResultSqrtPriceX96 == sqrtPriceNextX96) {\n // Equivalent to `updatedTick = zeroForOne ? tickNext - 1 : tickNext;`\n unchecked {\n // cannot cast a bool to an int24 in Solidity\n int24 _zeroForOne;\n assembly {\n _zeroForOne := zeroForOne\n }\n updatedTick = tickNext - _zeroForOne;\n }\n } else if (naiveSwapResultSqrtPriceX96 != startSqrtPriceX96) {\n // recompute unless we're on a lower tick boundary (i.e. already\ntransitioned ticks), and haven't moved\n updatedTick = TickMath.getTickAtSqrtPrice(naiveSwapResultSqrtPriceX96);\n }\n // ...\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n```\n\n*Figure 16.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L228–L302](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L228-L302))*\n\nWe found this issue with Medusa during the invariant testing process.\n\n#### Recommendations\n\nShort term, initialize the updatedTick to the correct value when the branches in figure 16.2 are skipped. Run the invariant tests again with the updated code and triage any outstanding invariant failures.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-16",
        "Target": "src/lib/BunniSwapMath.sol"
      },
      "heading_cleaned": "Users can gain tokens during round-trip swaps"
    },
    {
      "index": 17,
      "page_start": 59,
      "heading": "17. Dierent amount of input/output tokens can be returned in ExactIn and ExactOut configurations during the swap",
      "markdown": "## 17. Dierent amount of input/output tokens can be returned in ExactIn and ExactOut configurations during the swap\n\n| Severity: Low                     | Diffi culty: Low         |\n|--------------------------------------|--------------------------------|\n| Type: Data Validation          | Finding ID: TOB-BUNNI-17 |\n| Target: src/lib/BunniSwapMath.col |                                |\n\n#### Description\n\nThe swap functionality of BunniSwapMath can yield different input and output token amounts on the same pool state, depending on the swap configuration (ExactIn or ExactOut). This enables users to provide fewer tokens by choosing one configuration over the other.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it determines the input tokens exchanged for output tokens. If the amountSpecified is negative, the swap is an ExactIn swap, meaning the function calculates the amount of output tokens for an amountSpecified input token amount. Conversely, if the amountSpecified is positive, the swap is an ExactOut swap, where the function determines the required input tokens for an amountSpecified output token amount, as shown in the figure 17.1.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 17.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nThe expectation is that, for the same pool state, both swap configurations (ExactIn and ExactOut) should result in the same amounts of input and output tokens. However, the computeSwap function deviates from this expected behavior. For example, in an ExactIn configuration, computeSwap may exchange x amount of input tokens for y output tokens, but in an ExactOut configuration, it may exchange x' input tokens for the same y output tokens, where x' is smaller than x. This allows users to provide fewer input tokens in the ExactOut configuration for the same amount of y tokens compared to an ExactIn swap.\n\nWe found this issue with Medusa during the invariant testing process.\n\n\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that ExactIn and ExactOut swaps behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "finding_id": null,
      "markdown_raw": "## <span id=\"page-59-0\"></span>17. Dierent amount of input/output tokens can be returned in ExactIn and ExactOut configurations during the swap\n\n| Severity:<br>Low                     | Diffi<br>culty:<br>Low         |\n|--------------------------------------|--------------------------------|\n| Type:<br>Data<br>Validation          | Finding<br>ID:<br>TOB-BUNNI-17 |\n| Target:<br>src/lib/BunniSwapMath.col |                                |\n\n#### Description\n\nThe swap functionality of BunniSwapMath can yield different input and output token amounts on the same pool state, depending on the swap configuration (ExactIn or ExactOut). This enables users to provide fewer tokens by choosing one configuration over the other.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it determines the input tokens exchanged for output tokens. If the amountSpecified is negative, the swap is an ExactIn swap, meaning the function calculates the amount of output tokens for an amountSpecified input token amount. Conversely, if the amountSpecified is positive, the swap is an ExactOut swap, where the function determines the required input tokens for an amountSpecified output token amount, as shown in the figure 17.1.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 17.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nThe expectation is that, for the same pool state, both swap configurations (ExactIn and ExactOut) should result in the same amounts of input and output tokens. However, the computeSwap function deviates from this expected behavior. For example, in an ExactIn configuration, computeSwap may exchange x amount of input tokens for y output tokens, but in an ExactOut configuration, it may exchange x' input tokens for the same y output tokens, where x' is smaller than x. This allows users to provide fewer input tokens in the ExactOut configuration for the same amount of y tokens compared to an ExactIn swap.\n\nWe found this issue with Medusa during the invariant testing process.\n\n![](_page_59_Picture_9.jpeg)\n\n{60}------------------------------------------------\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that ExactIn and ExactOut swaps behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n\n![](_page_60_Picture_3.jpeg)\n\n{61}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe swap functionality of BunniSwapMath can yield different input and output token amounts on the same pool state, depending on the swap configuration (ExactIn or ExactOut). This enables users to provide fewer tokens by choosing one configuration over the other.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it determines the input tokens exchanged for output tokens. If the amountSpecified is negative, the swap is an ExactIn swap, meaning the function calculates the amount of output tokens for an amountSpecified input token amount. Conversely, if the amountSpecified is positive, the swap is an ExactOut swap, where the function determines the required input tokens for an amountSpecified output token amount, as shown in the figure 17.1.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 17.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nThe expectation is that, for the same pool state, both swap configurations (ExactIn and ExactOut) should result in the same amounts of input and output tokens. However, the computeSwap function deviates from this expected behavior. For example, in an ExactIn configuration, computeSwap may exchange x amount of input tokens for y output tokens, but in an ExactOut configuration, it may exchange x' input tokens for the same y output tokens, where x' is smaller than x. This allows users to provide fewer input tokens in the ExactOut configuration for the same amount of y tokens compared to an ExactIn swap.\n\nWe found this issue with Medusa during the invariant testing process.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that ExactIn and ExactOut swaps behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe swap functionality of BunniSwapMath can yield different input and output token amounts on the same pool state, depending on the swap configuration (ExactIn or ExactOut). This enables users to provide fewer tokens by choosing one configuration over the other.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it determines the input tokens exchanged for output tokens. If the amountSpecified is negative, the swap is an ExactIn swap, meaning the function calculates the amount of output tokens for an amountSpecified input token amount. Conversely, if the amountSpecified is positive, the swap is an ExactOut swap, where the function determines the required input tokens for an amountSpecified output token amount, as shown in the figure 17.1.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 17.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nThe expectation is that, for the same pool state, both swap configurations (ExactIn and ExactOut) should result in the same amounts of input and output tokens. However, the computeSwap function deviates from this expected behavior. For example, in an ExactIn configuration, computeSwap may exchange x amount of input tokens for y output tokens, but in an ExactOut configuration, it may exchange x' input tokens for the same y output tokens, where x' is smaller than x. This allows users to provide fewer input tokens in the ExactOut configuration for the same amount of y tokens compared to an ExactIn swap.\n\nWe found this issue with Medusa during the invariant testing process.\n",
      "markdown_body": "| Severity: Low                     | Diffi culty: Low         |\n|--------------------------------------|--------------------------------|\n| Type: Data Validation          | Finding ID: TOB-BUNNI-17 |\n| Target: src/lib/BunniSwapMath.col |                                |\n\n#### Description\n\nThe swap functionality of BunniSwapMath can yield different input and output token amounts on the same pool state, depending on the swap configuration (ExactIn or ExactOut). This enables users to provide fewer tokens by choosing one configuration over the other.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it determines the input tokens exchanged for output tokens. If the amountSpecified is negative, the swap is an ExactIn swap, meaning the function calculates the amount of output tokens for an amountSpecified input token amount. Conversely, if the amountSpecified is positive, the swap is an ExactOut swap, where the function determines the required input tokens for an amountSpecified output token amount, as shown in the figure 17.1.\n\n```\n// initialize input and output amounts based on initial info\nbool exactIn = amountSpecified < 0;\ninputAmount = exactIn ? uint256(-amountSpecified) : 0;\noutputAmount = exactIn ? 0 : uint256(amountSpecified);\n```\n\n*Figure 17.1: Snippet of the function \\_computeSwap showing the computation of ExactIn and ExactOut ([src/lib/BunniSwapMath.sol#L101–L104](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L101-L104))*\n\nThe expectation is that, for the same pool state, both swap configurations (ExactIn and ExactOut) should result in the same amounts of input and output tokens. However, the computeSwap function deviates from this expected behavior. For example, in an ExactIn configuration, computeSwap may exchange x amount of input tokens for y output tokens, but in an ExactOut configuration, it may exchange x' input tokens for the same y output tokens, where x' is smaller than x. This allows users to provide fewer input tokens in the ExactOut configuration for the same amount of y tokens compared to an ExactIn swap.\n\nWe found this issue with Medusa during the invariant testing process.\n\n\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that ExactIn and ExactOut swaps behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "metadata": {
        "Severity": "Low",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-17",
        "Target": "src/lib/BunniSwapMath.sol"
      },
      "heading_cleaned": "Dierent amount of input/output tokens can be returned in ExactIn and ExactOut configurations during the swap"
    },
    {
      "index": 18,
      "page_start": 61,
      "heading": "18. BunniSwap swap functionality can cause panics during the swap",
      "markdown": "| 18. BunniSwap swap functionality can cause panics during the swap |                                |  |\n|----------------------------------------------------------------------------------------------|--------------------------------|--|\n| Severity: Undetermined                                                                    | Diffi culty: High        |  |\n| Type: Data Validation                                                                  | Finding ID: TOB-BUNNI-18 |  |\n| Target: src/lib/BunniSwapMath.col                                                         |                                |  |\n\n#### Description\n\nThe swap functionality of BunniSwapMath can result in arithmetic underflow during the swap on a valid pool state, disrupting swap operations.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it calculates the input tokens exchanged for output tokens and updates the pool's state and pricing ratio at the end of the swap.\n\n```\n(inputAmount, outputAmount) = zeroForOne\n ? (\n updatedActiveBalance0 - currentActiveBalance0,\n currentActiveBalance1 < updatedActiveBalance1 ? 0 : currentActiveBalance1 -\nupdatedActiveBalance1\n )\n : (\n updatedActiveBalance1 - currentActiveBalance1,\n currentActiveBalance0 < updatedActiveBalance0 ? 0 : currentActiveBalance0 -\nupdatedActiveBalance0\n );\n```\n\n*Figure 18.1: Snippet of the \\_computeSwap function ([src/lib/BunniSwapMath.sol#L326–334](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L326-L334))*\n\nGiven a valid pool state and input parameters for the computeSwap function, the swap should succeed. However, BunniSwapMath deviates from this expected behavior, leading to an arithmetic underflow during the swap. For a OneForZero swap, during the calculation of input and output amount, the updatedActiveBalance for token1 becomes less than the currentActiveBalance of token1; this condition is not accounted for, as highlighted in figure 18.1. This results in an arithmetic underflow that causes the swap operation to revert.\n\nWe discovered this issue with Medusa during the invariant testing process.\n\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the swap operation does not cause an underflow.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "finding_id": null,
      "markdown_raw": "<span id=\"page-61-0\"></span>\n\n| 18.<br>BunniSwap<br>swap<br>functionality<br>can<br>cause<br>panics<br>during<br>the<br>swap |                                |  |\n|----------------------------------------------------------------------------------------------|--------------------------------|--|\n| Severity:<br>Undetermined                                                                    | Diffi<br>culty:<br>High        |  |\n| Type:<br>Data<br>Validation                                                                  | Finding<br>ID:<br>TOB-BUNNI-18 |  |\n| Target:<br>src/lib/BunniSwapMath.col                                                         |                                |  |\n\n#### Description\n\nThe swap functionality of BunniSwapMath can result in arithmetic underflow during the swap on a valid pool state, disrupting swap operations.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it calculates the input tokens exchanged for output tokens and updates the pool's state and pricing ratio at the end of the swap.\n\n```\n(inputAmount, outputAmount) = zeroForOne\n ? (\n updatedActiveBalance0 - currentActiveBalance0,\n currentActiveBalance1 < updatedActiveBalance1 ? 0 : currentActiveBalance1 -\nupdatedActiveBalance1\n )\n : (\n updatedActiveBalance1 - currentActiveBalance1,\n currentActiveBalance0 < updatedActiveBalance0 ? 0 : currentActiveBalance0 -\nupdatedActiveBalance0\n );\n```\n\n*Figure 18.1: Snippet of the \\_computeSwap function ([src/lib/BunniSwapMath.sol#L326–334](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L326-L334))*\n\nGiven a valid pool state and input parameters for the computeSwap function, the swap should succeed. However, BunniSwapMath deviates from this expected behavior, leading to an arithmetic underflow during the swap. For a OneForZero swap, during the calculation of input and output amount, the updatedActiveBalance for token1 becomes less than the currentActiveBalance of token1; this condition is not accounted for, as highlighted in figure 18.1. This results in an arithmetic underflow that causes the swap operation to revert.\n\nWe discovered this issue with Medusa during the invariant testing process.\n\n{62}------------------------------------------------\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the swap operation does not cause an underflow.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n\n![](_page_62_Picture_3.jpeg)\n\n{63}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe swap functionality of BunniSwapMath can result in arithmetic underflow during the swap on a valid pool state, disrupting swap operations.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it calculates the input tokens exchanged for output tokens and updates the pool's state and pricing ratio at the end of the swap.\n\n```\n(inputAmount, outputAmount) = zeroForOne\n ? (\n updatedActiveBalance0 - currentActiveBalance0,\n currentActiveBalance1 < updatedActiveBalance1 ? 0 : currentActiveBalance1 -\nupdatedActiveBalance1\n )\n : (\n updatedActiveBalance1 - currentActiveBalance1,\n currentActiveBalance0 < updatedActiveBalance0 ? 0 : currentActiveBalance0 -\nupdatedActiveBalance0\n );\n```\n\n*Figure 18.1: Snippet of the \\_computeSwap function ([src/lib/BunniSwapMath.sol#L326–334](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L326-L334))*\n\nGiven a valid pool state and input parameters for the computeSwap function, the swap should succeed. However, BunniSwapMath deviates from this expected behavior, leading to an arithmetic underflow during the swap. For a OneForZero swap, during the calculation of input and output amount, the updatedActiveBalance for token1 becomes less than the currentActiveBalance of token1; this condition is not accounted for, as highlighted in figure 18.1. This results in an arithmetic underflow that causes the swap operation to revert.\n\nWe discovered this issue with Medusa during the invariant testing process.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the swap operation does not cause an underflow.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe swap functionality of BunniSwapMath can result in arithmetic underflow during the swap on a valid pool state, disrupting swap operations.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it calculates the input tokens exchanged for output tokens and updates the pool's state and pricing ratio at the end of the swap.\n\n```\n(inputAmount, outputAmount) = zeroForOne\n ? (\n updatedActiveBalance0 - currentActiveBalance0,\n currentActiveBalance1 < updatedActiveBalance1 ? 0 : currentActiveBalance1 -\nupdatedActiveBalance1\n )\n : (\n updatedActiveBalance1 - currentActiveBalance1,\n currentActiveBalance0 < updatedActiveBalance0 ? 0 : currentActiveBalance0 -\nupdatedActiveBalance0\n );\n```\n\n*Figure 18.1: Snippet of the \\_computeSwap function ([src/lib/BunniSwapMath.sol#L326–334](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L326-L334))*\n\nGiven a valid pool state and input parameters for the computeSwap function, the swap should succeed. However, BunniSwapMath deviates from this expected behavior, leading to an arithmetic underflow during the swap. For a OneForZero swap, during the calculation of input and output amount, the updatedActiveBalance for token1 becomes less than the currentActiveBalance of token1; this condition is not accounted for, as highlighted in figure 18.1. This results in an arithmetic underflow that causes the swap operation to revert.\n\nWe discovered this issue with Medusa during the invariant testing process.\n",
      "markdown_body": "| 18. BunniSwap swap functionality can cause panics during the swap |                                |  |\n|----------------------------------------------------------------------------------------------|--------------------------------|--|\n| Severity: Undetermined                                                                    | Diffi culty: High        |  |\n| Type: Data Validation                                                                  | Finding ID: TOB-BUNNI-18 |  |\n| Target: src/lib/BunniSwapMath.col                                                         |                                |  |\n\n#### Description\n\nThe swap functionality of BunniSwapMath can result in arithmetic underflow during the swap on a valid pool state, disrupting swap operations.\n\nThe computeSwap function in the BunniSwapMath library enables users to swap tokens on a valid pool state. Based on the amountSpecified and swap direction, it calculates the input tokens exchanged for output tokens and updates the pool's state and pricing ratio at the end of the swap.\n\n```\n(inputAmount, outputAmount) = zeroForOne\n ? (\n updatedActiveBalance0 - currentActiveBalance0,\n currentActiveBalance1 < updatedActiveBalance1 ? 0 : currentActiveBalance1 -\nupdatedActiveBalance1\n )\n : (\n updatedActiveBalance1 - currentActiveBalance1,\n currentActiveBalance0 < updatedActiveBalance0 ? 0 : currentActiveBalance0 -\nupdatedActiveBalance0\n );\n```\n\n*Figure 18.1: Snippet of the \\_computeSwap function ([src/lib/BunniSwapMath.sol#L326–334](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L326-L334))*\n\nGiven a valid pool state and input parameters for the computeSwap function, the swap should succeed. However, BunniSwapMath deviates from this expected behavior, leading to an arithmetic underflow during the swap. For a OneForZero swap, during the calculation of input and output amount, the updatedActiveBalance for token1 becomes less than the currentActiveBalance of token1; this condition is not accounted for, as highlighted in figure 18.1. This results in an arithmetic underflow that causes the swap operation to revert.\n\nWe discovered this issue with Medusa during the invariant testing process.\n\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the swap operation does not cause an underflow.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "metadata": {
        "Severity": null,
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-18",
        "Target": "src/lib/BunniSwapMath.sol"
      },
      "heading_cleaned": "BunniSwap swap functionality can cause panics during the swap"
    },
    {
      "index": 19,
      "page_start": 63,
      "heading": "19. cumulativeAmount0 can be greater than the cumulative amount computed through inverse functionality for certain LDFs",
      "markdown": "## 19. cumulativeAmount0 can be greater than the cumulative amount computed through inverse functionality for certain LDFs\n\n| Severity: Undetermined     | Diffi culty: Low         |\n|-------------------------------|--------------------------------|\n| Type: Data Validation   | Finding ID: TOB-BUNNI-19 |\n| Target: Various targets |                                |\n\n#### Description\n\nThe cumulative amount of token0, when computed through different methods, can vary for certain types of LDFs, leading to incorrect calculations of liquidity densities for token0.\n\nGiven a cumulativeAmount0, the function inverseCumulativeAmount0, in the contracts UniformDistribution and CarpetedGeometricDistribution, computes the rounded tick whose cumulativeAmount0 is expected to be less than or equal to the given cumulativeAmount0.\n\n```\nif (exactIn) {\n (inputAmount, outputAmount) = zeroForOne\n ? ...\n : (\n naiveSwapAmountIn + cumulativeAmount - currentActiveBalance1,\n currentActiveBalance0 + naiveSwapAmountOut\n - input.liquidityDensityFunction.cumulativeAmount0(...)\n );\n } else {\n (inputAmount, outputAmount) = zeroForOne\n ? (\n input.liquidityDensityFunction.cumulativeAmount0(...)\n : ...\n }\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n}\n```\n\n*Figure 19.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L246–L303](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L246-L303))*\n\nHowever, both distributions deviate from the expected behavior, as in some cases, the computed cumulativeAmount0 exceeds the given cumulativeAmount0. These cumulativeAmount0 values are used throughout the swap process to calculate the input and output amounts, as illustrated in figure 19.1, leading to inaccurate swap computations.\n\nWe discovered this issue with Medusa during the invariant testing process.\n\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the LDF functionalities behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "finding_id": null,
      "markdown_raw": "## <span id=\"page-63-0\"></span>19. cumulativeAmount0 can be greater than the cumulative amount computed through inverse functionality for certain LDFs\n\n| Severity:<br>Undetermined     | Diffi<br>culty:<br>Low         |\n|-------------------------------|--------------------------------|\n| Type:<br>Data<br>Validation   | Finding<br>ID:<br>TOB-BUNNI-19 |\n| Target:<br>Various<br>targets |                                |\n\n#### Description\n\nThe cumulative amount of token0, when computed through different methods, can vary for certain types of LDFs, leading to incorrect calculations of liquidity densities for token0.\n\nGiven a cumulativeAmount0, the function inverseCumulativeAmount0, in the contracts UniformDistribution and CarpetedGeometricDistribution, computes the rounded tick whose cumulativeAmount0 is expected to be less than or equal to the given cumulativeAmount0.\n\n```\nif (exactIn) {\n (inputAmount, outputAmount) = zeroForOne\n ? ...\n : (\n naiveSwapAmountIn + cumulativeAmount - currentActiveBalance1,\n currentActiveBalance0 + naiveSwapAmountOut\n - input.liquidityDensityFunction.cumulativeAmount0(...)\n );\n } else {\n (inputAmount, outputAmount) = zeroForOne\n ? (\n input.liquidityDensityFunction.cumulativeAmount0(...)\n : ...\n }\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n}\n```\n\n*Figure 19.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L246–L303](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L246-L303))*\n\nHowever, both distributions deviate from the expected behavior, as in some cases, the computed cumulativeAmount0 exceeds the given cumulativeAmount0. These cumulativeAmount0 values are used throughout the swap process to calculate the input and output amounts, as illustrated in figure 19.1, leading to inaccurate swap computations.\n\nWe discovered this issue with Medusa during the invariant testing process.\n\n{64}------------------------------------------------\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the LDF functionalities behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n\n![](_page_64_Picture_3.jpeg)\n\n{65}------------------------------------------------\n",
      "sections": {
        "description": "#### Description\n\nThe cumulative amount of token0, when computed through different methods, can vary for certain types of LDFs, leading to incorrect calculations of liquidity densities for token0.\n\nGiven a cumulativeAmount0, the function inverseCumulativeAmount0, in the contracts UniformDistribution and CarpetedGeometricDistribution, computes the rounded tick whose cumulativeAmount0 is expected to be less than or equal to the given cumulativeAmount0.\n\n```\nif (exactIn) {\n (inputAmount, outputAmount) = zeroForOne\n ? ...\n : (\n naiveSwapAmountIn + cumulativeAmount - currentActiveBalance1,\n currentActiveBalance0 + naiveSwapAmountOut\n - input.liquidityDensityFunction.cumulativeAmount0(...)\n );\n } else {\n (inputAmount, outputAmount) = zeroForOne\n ? (\n input.liquidityDensityFunction.cumulativeAmount0(...)\n : ...\n }\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n}\n```\n\n*Figure 19.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L246–L303](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L246-L303))*\n\nHowever, both distributions deviate from the expected behavior, as in some cases, the computed cumulativeAmount0 exceeds the given cumulativeAmount0. These cumulativeAmount0 values are used throughout the swap process to calculate the input and output amounts, as illustrated in figure 19.1, leading to inaccurate swap computations.\n\nWe discovered this issue with Medusa during the invariant testing process.\n",
        "impact": null,
        "recommendation": "#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the LDF functionalities behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
        "poc": null,
        "fix_status": null,
        "other": null
      },
      "description": "#### Description\n\nThe cumulative amount of token0, when computed through different methods, can vary for certain types of LDFs, leading to incorrect calculations of liquidity densities for token0.\n\nGiven a cumulativeAmount0, the function inverseCumulativeAmount0, in the contracts UniformDistribution and CarpetedGeometricDistribution, computes the rounded tick whose cumulativeAmount0 is expected to be less than or equal to the given cumulativeAmount0.\n\n```\nif (exactIn) {\n (inputAmount, outputAmount) = zeroForOne\n ? ...\n : (\n naiveSwapAmountIn + cumulativeAmount - currentActiveBalance1,\n currentActiveBalance0 + naiveSwapAmountOut\n - input.liquidityDensityFunction.cumulativeAmount0(...)\n );\n } else {\n (inputAmount, outputAmount) = zeroForOne\n ? (\n input.liquidityDensityFunction.cumulativeAmount0(...)\n : ...\n }\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n}\n```\n\n*Figure 19.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L246–L303](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L246-L303))*\n\nHowever, both distributions deviate from the expected behavior, as in some cases, the computed cumulativeAmount0 exceeds the given cumulativeAmount0. These cumulativeAmount0 values are used throughout the swap process to calculate the input and output amounts, as illustrated in figure 19.1, leading to inaccurate swap computations.\n\nWe discovered this issue with Medusa during the invariant testing process.\n",
      "markdown_body": "| Severity: Undetermined     | Diffi culty: Low         |\n|-------------------------------|--------------------------------|\n| Type: Data Validation   | Finding ID: TOB-BUNNI-19 |\n| Target: Various targets |                                |\n\n#### Description\n\nThe cumulative amount of token0, when computed through different methods, can vary for certain types of LDFs, leading to incorrect calculations of liquidity densities for token0.\n\nGiven a cumulativeAmount0, the function inverseCumulativeAmount0, in the contracts UniformDistribution and CarpetedGeometricDistribution, computes the rounded tick whose cumulativeAmount0 is expected to be less than or equal to the given cumulativeAmount0.\n\n```\nif (exactIn) {\n (inputAmount, outputAmount) = zeroForOne\n ? ...\n : (\n naiveSwapAmountIn + cumulativeAmount - currentActiveBalance1,\n currentActiveBalance0 + naiveSwapAmountOut\n - input.liquidityDensityFunction.cumulativeAmount0(...)\n );\n } else {\n (inputAmount, outputAmount) = zeroForOne\n ? (\n input.liquidityDensityFunction.cumulativeAmount0(...)\n : ...\n }\n return (updatedSqrtPriceX96, updatedTick, inputAmount, outputAmount);\n}\n```\n\n*Figure 19.1: Snippet of the \\_computeSwap function in the BunniSwapMath library ([src/lib/BunniSwapMath.sol#L246–L303](https://github.com/timeless-fi/bunni-v2/blob/7faae4718eecda1b33dc3abd894431ed2d16c929/src/lib/BunniSwapMath.sol#L246-L303))*\n\nHowever, both distributions deviate from the expected behavior, as in some cases, the computed cumulativeAmount0 exceeds the given cumulativeAmount0. These cumulativeAmount0 values are used throughout the swap process to calculate the input and output amounts, as illustrated in figure 19.1, leading to inaccurate swap computations.\n\nWe discovered this issue with Medusa during the invariant testing process.\n\n\n#### Recommendations\n\nShort term, triage the underlying root cause of the above finding and deploy a fix such that the LDF functionalities behave as expected.\n\nLong term, consider integrating Medusa to generate invariants at both the function and system levels, enabling the testing of operations that involve complex mathematics and liquidity pricing curves.\n",
      "metadata": {
        "Severity": null,
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-BUNNI-19",
        "Target": "Various targets"
      },
      "heading_cleaned": "cumulativeAmount0 can be greater than the cumulative amount computed through inverse functionality for certain LDFs"
    }
  ]
}