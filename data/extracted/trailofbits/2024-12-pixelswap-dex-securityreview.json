{
  "doc_id": "trailofbits_2024-12-pixelswap-dex-securityreview",
  "source_pdf": "2024-12-pixelswap-dex-securityreview.pdf",
  "source_mtime": "2025-11-01T12:04:44+00:00",
  "extracted_at": "2025-11-12T02:12:15.739604+00:00",
  "extractor_version": "poc-0.4",
  "repositories": [
    {
      "url": "https://github.com/trailofbits/publications",
      "org": "trailofbits",
      "repo": "publications",
      "commit": null,
      "evidence": {
        "page": 1,
        "snippet": "We maintain an exhaustive list of publications at [https://github.com/trailofbits/publications,](https://github.com/trailofbits/publications) with links to papers, presentations, public audit reports,..."
      }
    },
    {
      "url": "https://github.com/nx-fi/pixelswap",
      "org": "nx-fi",
      "repo": "pixelswap",
      "commit": null,
      "evidence": {
        "page": 9,
        "snippet": "Repository https://github.com/nx-fi/pixelswap"
      }
    },
    {
      "url": "https://github.com/nx-fi/pixelswap",
      "org": "nx-fi",
      "repo": "pixelswap",
      "commit": "5c24e13fcae51b250bd70e0a812ce69a9b3dee4a",
      "evidence": {
        "page": 40,
        "snippet": "- [OrderJettonNotification](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L419-L419) handler in pixelswap\\_settlement.tact"
      }
    },
    {
      "url": "https://github.com/ton-blockchain/TEPs",
      "org": "ton-blockchain",
      "repo": "TEPs",
      "commit": null,
      "evidence": {
        "page": 46,
        "snippet": "The Jetton notification message for [transfer\\\\_notification](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md), with ID 0x7362d09c, is defined differently for the sett..."
      }
    }
  ],
  "report_schema": [
    {
      "key": "Severity",
      "meaning": "How serious the impact of this finding is.",
      "expected_values": "Informational / Low / Medium / High"
    },
    {
      "key": "Difficulty",
      "meaning": "How hard it is to exploit this issue.",
      "expected_values": "Low / Medium / High"
    },
    {
      "key": "Type",
      "meaning": "The category of the vulnerability.",
      "expected_values": "Authentication / Data Validation / etc."
    },
    {
      "key": "Finding ID",
      "meaning": "Unique identifier for the finding.",
      "expected_values": "TOB-PXL-1, TOB-PXL-2, etc."
    },
    {
      "key": "Target",
      "meaning": "Path to the affected file or contract.",
      "expected_values": "contracts/pixelswap_funding.tact, etc."
    }
  ],
  "vulnerability_sections": [
    {
      "index": 1,
      "page_start": 18,
      "heading": "1. The BulkInternalTransfer receiver computes the wrong total amounts",
      "markdown": "| 1. The BulkInternalTransfer receiver computes the wrong total amounts |                             |\n|-----------------------------------------------------------------------------------------------|-----------------------------|\n| Severity: High                                                                             | Diffi culty: Low      |\n| Type: Data Validation                                                                   | Finding ID: TOB-PXL-1 |\n| Target: contracts/pixelswap_funding.tact                                                   |                             |\n\n#### Description\n\nThe BulkInternalTransfer receiver function of the PixelswapFundingWallet contract computes the wrong total amounts to spend by adding the amount of the first entry multiple times.\n\nIn the PixelswapFundingWallet contract, when a BulkInternalTransfer message is processed, a loop calculates the total amount of tokens to be spent from the wallet. However, the loop does not increase the index variable i, so the result values will be the amounts for the first entry times the total number of entries.\n\nConsequently, when the spend\\_wallet internal function is called, an incorrect balance will be deducted, or a panic will be raised if the balance is insufficient.\n\n#### **[Redacted]**\n\nAdditionally, the loop in the receiver for BulkInternalTransfer in the PixelswapFunding contract is correctly implemented, which can result in the sum of user balances not matching the balance of the PixelswapSettlement contract, allowing users to withdraw more than they own and incorrectly decreasing the balance of the sender.\n\n#### Exploit Scenario\n\nBob sends a BulkInternalTransfer message with three entries, the first of which has 0 token\\_amt and 0 ton\\_amt. Bob's funding wallet spends 0 of his tokens, but the master funding contract correctly adds funds to the receivers' wallets. Bob is able to withdraw funds that do not belong to him from the funding contract.\n\n#### Recommendations\n\nShort term, increment the index variable i in the loop.\n\nIn the long term, expand the test suite to implement test cases for bulk transfers and ensure that these tests also consider malicious inputs.\n\n\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe BulkInternalTransfer receiver function of the PixelswapFundingWallet contract computes the wrong total amounts to spend by adding the amount of the first entry multiple times.\n\nIn the PixelswapFundingWallet contract, when a BulkInternalTransfer message is processed, a loop calculates the total amount of tokens to be spent from the wallet. However, the loop does not increase the index variable i, so the result values will be the amounts for the first entry times the total number of entries.\n\nConsequently, when the spend\\_wallet internal function is called, an incorrect balance will be deducted, or a panic will be raised if the balance is insufficient.\n\n#### **[Redacted]**\n\nAdditionally, the loop in the receiver for BulkInternalTransfer in the PixelswapFunding contract is correctly implemented, which can result in the sum of user balances not matching the balance of the PixelswapSettlement contract, allowing users to withdraw more than they own and incorrectly decreasing the balance of the sender.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-1",
        "Target": "contracts/pixelswap_funding.tact"
      },
      "heading_cleaned": "The BulkInternalTransfer receiver computes the wrong total amounts"
    },
    {
      "index": 2,
      "page_start": 20,
      "heading": "2. Granting the role to the master funding contract on a funding wallet contract will result in draining the funding wallet balance",
      "markdown": "# 2. Granting the role to the master funding contract on a funding wallet contract will result in draining the funding wallet balance\n\n| Severity: High                           | Diffi culty: High     |\n|---------------------------------------------|-----------------------------|\n| Type: Authentication                     | Finding ID: TOB-PXL-2 |\n| contracts/pixelswap_funding.tact Target: |                             |\n\n#### Description\n\nGranting the privileged role to the PixelswapFunding contract on a user-owned PixelswapFundingWallet contract will result in the user balance being spent even if the user is the recipient of the InternalTransfer message. This can drain the user's balance by repeatedly forwarding the InternalTransfer message between the funding wallet and the master contract.\n\nUsers have funding wallets to interact with the system. In these wallets, they are both owners and privileged users (they have a privileged role). Any user can grant the privileged role to an address on their funding wallets via the GrantRole message of the access control trait, as shown in figure 2.1:\n\n#### **[Redacted]**\n\nIf a user grants the privileged role to the master funding contract, then the InternalTransfer message receiver function will always execute the first if block for the messages sent from the master funding contract, as shown in figure 2.2:\n\n#### **[Redacted]**\n\nThis will spend the user's balance instead of adding funds to the user's wallet and send the same message to the master funding contract, which will then send it back to the user's funding wallet contract, and it will keep spending the user's balance repeatedly until the gas sent with the message is consumed.\n\n### Exploit Scenario\n\nAlice accidentally grants the privileged role to the master funding contract on her funding wallet. From then on, any internal transfer she receives will not be accrued to her wallet and will drain her wallet balance.\n\n\n\n#### Recommendations\n\nShort term, review the order in which the checks are performed to ensure that even if the funding contract is privileged, it does not affect the expected outcome of the process. Also, consider limiting accounts that can get privileged roles in each system contract.\n\nLong term, identify and document all possible actions that privileged accounts can take, along with their associated risks. This will facilitate codebase reviews and prevent future mistakes.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nGranting the privileged role to the PixelswapFunding contract on a user-owned PixelswapFundingWallet contract will result in the user balance being spent even if the user is the recipient of the InternalTransfer message. This can drain the user's balance by repeatedly forwarding the InternalTransfer message between the funding wallet and the master contract.\n\nUsers have funding wallets to interact with the system. In these wallets, they are both owners and privileged users (they have a privileged role). Any user can grant the privileged role to an address on their funding wallets via the GrantRole message of the access control trait, as shown in figure 2.1:\n\n#### **[Redacted]**\n\nIf a user grants the privileged role to the master funding contract, then the InternalTransfer message receiver function will always execute the first if block for the messages sent from the master funding contract, as shown in figure 2.2:\n\n#### **[Redacted]**\n\nThis will spend the user's balance instead of adding funds to the user's wallet and send the same message to the master funding contract, which will then send it back to the user's funding wallet contract, and it will keep spending the user's balance repeatedly until the gas sent with the message is consumed.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "High",
        "Type": "Authentication",
        "Finding ID": "TOB-PXL-2",
        "Target": "contracts/pixelswap_funding.tact"
      },
      "heading_cleaned": "Granting the role to the master funding contract on a funding wallet contract will result in draining the funding wallet balance"
    },
    {
      "index": 3,
      "page_start": 22,
      "heading": "3. Users can inflate their funding wallet balance by sending an expired Swap message to the settlement contract",
      "markdown": "# 3. Users can inflate their funding wallet balance by sending an expired Swap message to the settlement contract\n\n| Severity: High                              | Diffi culty: Low      |\n|------------------------------------------------|-----------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-3 |\n| contracts/pixelswap_streampool.tact Target: |                             |\n\n#### Description\n\nUsers can inflate their funding wallet balance of any token by sending a Swap message that will trigger a failure reply message from the PixelswapStreamPool contract. Users can use this to drain the settlement contract.\n\nThere are two ways to initiate a swap in the system: sending a PlaceOrder message to the user's funding wallet and sending a Swap message to the PixelswapSettlement contract.\n\nThe Swap message to the PixelswapSettlement contract has an extra\\_tokens field. The token\\_gas and token\\_forward\\_milliton fields of the extra\\_tokens structure are used to calculate the required gas amount and to decide if the output tokens should be added to the user's funding wallet or sent to the user's external wallet. All other fields of the extra\\_tokens values are ignored in the Swap message receiver function of the PixelswapSettlement contract. The Swap receiver of the settlement contract then creates a PlaceOrder message and sends it to the PixelswapStreamPool contract for execution.\n\nIf the place\\_order internal function of the PixelswapStreamPool contract detects a failure case, it sends the PlaceOrder message back to the PixelswapSettlement contract as a failure reply message. The settlement contract then forwards it to the PixelswapFunding contract, which forwards it to the user's PixelswapFundingWallet contract.\n\nThe PixelswapFundingWallet then processes the PlaceOrder message as unspent order, as shown in figure 3.1:\n\n#### **[Redacted]**\n\nHowever, the unspent\\_order\\_inputs function of the PixelswapFundingWallet contract assumes that the tokens included in the extra\\_tokens field were spent from the user's wallet if the token\\_is\\_input is set to true and adds these tokens to the user's balance, while the input tokens in the extra\\_tokens are not spent from the user's funding wallet if they initiate the swap by sending a Swap message to the settlement contract.\n\n\n\n#### Exploit Scenario\n\nEve sends an expired Swap message with an extra\\_tokens field containing a TokenInfo for 1,000 USDT tokens with the token\\_is\\_input variable set to true. This message triggers a failure reply message from the PixelswapStreamPool contract, which is forwarded to Eve's funding wallet contract. The funding wallet contract adds 1,000 USDT to her balance, assuming they were spent from her wallet to initiate the swap. Eve withdraws these USDT tokens from her funding wallet and repeats this process to drain all the tokens from the settlement contract.\n\n#### Recommendations\n\nShort term, in the Swap message receiver of the settlement contract, check that the extra\\_tokens field of the message does not include any input tokens.\n\nLong term, document the message flow in both success and failure cases and write test cases to ensure correct behavior in each case.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nUsers can inflate their funding wallet balance of any token by sending a Swap message that will trigger a failure reply message from the PixelswapStreamPool contract. Users can use this to drain the settlement contract.\n\nThere are two ways to initiate a swap in the system: sending a PlaceOrder message to the user's funding wallet and sending a Swap message to the PixelswapSettlement contract.\n\nThe Swap message to the PixelswapSettlement contract has an extra\\_tokens field. The token\\_gas and token\\_forward\\_milliton fields of the extra\\_tokens structure are used to calculate the required gas amount and to decide if the output tokens should be added to the user's funding wallet or sent to the user's external wallet. All other fields of the extra\\_tokens values are ignored in the Swap message receiver function of the PixelswapSettlement contract. The Swap receiver of the settlement contract then creates a PlaceOrder message and sends it to the PixelswapStreamPool contract for execution.\n\nIf the place\\_order internal function of the PixelswapStreamPool contract detects a failure case, it sends the PlaceOrder message back to the PixelswapSettlement contract as a failure reply message. The settlement contract then forwards it to the PixelswapFunding contract, which forwards it to the user's PixelswapFundingWallet contract.\n\nThe PixelswapFundingWallet then processes the PlaceOrder message as unspent order, as shown in figure 3.1:\n\n#### **[Redacted]**\n\nHowever, the unspent\\_order\\_inputs function of the PixelswapFundingWallet contract assumes that the tokens included in the extra\\_tokens field were spent from the user's wallet if the token\\_is\\_input is set to true and adds these tokens to the user's balance, while the input tokens in the extra\\_tokens are not spent from the user's funding wallet if they initiate the swap by sending a Swap message to the settlement contract.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-3",
        "Target": "contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "Users can inflate their funding wallet balance by sending an expired Swap message to the settlement contract"
    },
    {
      "index": 4,
      "page_start": 24,
      "heading": "4. SettlementVault balances are not updated in the PlaceOrder\\_Partial\\_2 receiver of the settlement contract",
      "markdown": "# 4. SettlementVault balances are not updated in the PlaceOrder\\_Partial\\_2 receiver of the settlement contract\n\n| Severity: Informational                     | Diffi culty: Low      |\n|------------------------------------------------|-----------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-4 |\n| Target: contracts/pixelswap_settlement.tact |                             |\n\n#### Description\n\nThe PlaceOrder\\_Partial\\_2 message receiver function of the PixelswapSettlement contract is used to relay messages between the funding contract and execution contracts, but it does not update the SettlementVault balances to reflect the transfer of funds between funding and execution contracts.\n\nWhen a user initiates an order from their funding wallet, the PlaceOrder message is sent from their funding wallet to the master funding contract, which sends the same message to the PixelswapSettlement contract. The settlement contract then fetches the execution contract address from its storage and sends the PlaceOrder message to the PixelswapSteampool contract. However, the PlaceOrder\\_Partial\\_2 message receiver of the PixelswapSettlement contract does not remove the input tokens from the SettlementVault of the funding contract and does not add the same tokens to the SettlementVault of the execution contract.\n\nSimilarly, when a failure message is sent from the execution contract to the settlement contract, the PlaceOrder\\_Partial\\_2 message receiver of the PixelswapSettlement contract does not remove the input tokens from SettlementVault of the execution contract and does not add the same tokens to the SettlementVault of the funding contract before sending the message to the funding contract.\n\nThis results in an imbalance between the balances stored in the funding contracts, settlement vaults, and reserves stored in the execution contracts.\n\n#### **[Redacted]**\n\n#### Recommendations\n\nShort term, add calls to the token\\_balance\\_add and token\\_balance\\_reduce internal functions to correctly update the settlement vault balances of the funding and execution contracts while processing the PlaceOrder\\_Partial\\_2 message.\n\nLong term, create message flow and fund flow diagrams, and document all of the places where the balances of different components and users are tracked in the system.\n\n\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe PlaceOrder\\_Partial\\_2 message receiver function of the PixelswapSettlement contract is used to relay messages between the funding contract and execution contracts, but it does not update the SettlementVault balances to reflect the transfer of funds between funding and execution contracts.\n\nWhen a user initiates an order from their funding wallet, the PlaceOrder message is sent from their funding wallet to the master funding contract, which sends the same message to the PixelswapSettlement contract. The settlement contract then fetches the execution contract address from its storage and sends the PlaceOrder message to the PixelswapSteampool contract. However, the PlaceOrder\\_Partial\\_2 message receiver of the PixelswapSettlement contract does not remove the input tokens from the SettlementVault of the funding contract and does not add the same tokens to the SettlementVault of the execution contract.\n\nSimilarly, when a failure message is sent from the execution contract to the settlement contract, the PlaceOrder\\_Partial\\_2 message receiver of the PixelswapSettlement contract does not remove the input tokens from SettlementVault of the execution contract and does not add the same tokens to the SettlementVault of the funding contract before sending the message to the funding contract.\n\nThis results in an imbalance between the balances stored in the funding contracts, settlement vaults, and reserves stored in the execution contracts.\n\n#### **[Redacted]**\n",
      "metadata": null,
      "heading_cleaned": "SettlementVault balances are not updated in the PlaceOrder\\_Partial\\_2 receiver of the settlement contract"
    },
    {
      "index": 5,
      "page_start": 26,
      "heading": "5. Lack of validation of PixelswapStreamPool configuration parameters",
      "markdown": "# 5. Lack of validation of PixelswapStreamPool configuration parameters\n\n| Severity: Informational                     | Diffi culty: High     |\n|------------------------------------------------|-----------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-5 |\n| Target: contracts/pixelswap_streampool.tact |                             |\n\n#### Description\n\nThe owner of the PixelSwapStreamPool contracts can set the configuration parameters for the pool and the gas to any value without limits. This can lead to broken functionality or high TON spending for users in the pools until the values are fixed.\n\nAccording to the documentation, the owner role belongs to a multisignature wallet, so it is expected that prior to executing a configuration change, more than one actor will review the transaction. Thus, using a multisignature wallet makes it difficult to set wrong configuration values.\n\n#### **[Redacted]**\n\n#### Exploit Scenario\n\nAlice and Bob are signers for the 2-out-of-3 multisignature wallet that controls the deployed PixelswapStreamPool contract. Alice creates and signs a configuration change transaction, accidentally setting the remove\\_liquidity gas configuration to an extremely high value. Bob trusts Alice, so he signs the transaction without reviewing it. When it is executed, users' interactions are more expensive than expected.\n\n#### Recommendations\n\nShort term, set some reasonable limits to the configuration parameters that can be set in the PixelswapStreamPool contract.\n\nLong term, document the expected values for each parameter and their safe ranges. Add test cases for the configuration change functions.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe owner of the PixelSwapStreamPool contracts can set the configuration parameters for the pool and the gas to any value without limits. This can lead to broken functionality or high TON spending for users in the pools until the values are fixed.\n\nAccording to the documentation, the owner role belongs to a multisignature wallet, so it is expected that prior to executing a configuration change, more than one actor will review the transaction. Thus, using a multisignature wallet makes it difficult to set wrong configuration values.\n\n#### **[Redacted]**\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-5",
        "Target": "contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "Lack of validation of PixelswapStreamPool configuration parameters"
    },
    {
      "index": 6,
      "page_start": 27,
      "heading": "6. Users can drain the TON balance of the PixelswapSettlement contract",
      "markdown": "# 6. Users can drain the TON balance of the PixelswapSettlement contract\n\n| Severity: High                              | Diffi culty: Low      |\n|------------------------------------------------|-----------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-6 |\n| Target: contracts/pixelswap_settlement.tact |                             |\n\n#### Description\n\nThe gas parameter fields forward\\_milliton and gas\\_transfer of the WithdrawFunds message can be used to drain the TON balance of the PixelswapSettlement contract, as the values specified in these fields are not spent from the user's funding wallet.\n\nThe WithdrawFunds message in the Settlement contract allows users to withdraw the balance of their funding wallet to their external wallet. The WithdrawFunds receiver function of the settlement contract calls the send\\_tokens internal function to transfer the specified token and amount to the user:\n\n#### **[Redacted]**\n\nThe send\\_tokens function transfers the sum of the token\\_amt, forward\\_milliton, and gas\\_transfer values when the provided token\\_id is the TON native currency:\n\n#### **[Redacted]**\n\nHowever, the WithdrawFunds message receiver of the PixelSwapFundingWallet contract does not spend the user's TON balance by the sum of forward\\_milliton and gas\\_transfer values for TON transfer:\n\n#### **[Redacted]**\n\nA user can specify non-zero values for the forward\\_milliton and gas\\_transfer fields in the WithdrawFunds message to drain the TON balance of the settlement contract.\n\n#### Exploit Scenario\n\nBob sends 1 nanoton to his funding wallet and creates a message to withdraw all TON balance from the settlement contract.\n\n### Recommendations\n\nShort term, consider one of the following:\n\n\n\n- Ensure that the sum of the token\\_amt, forward\\_milliton, and gas\\_transfer values is deducted from the user's funding wallet while processing the WithdrawFunds message.\n- Or ensure that the forward\\_milliton and gas\\_transfer values are zero when the msg.token\\_id is the TON address.\n- Or update the send\\_tokens to send only token\\_amt TON when transferring the native TON.\n\nLong term, implement tests that verify the total amount of TON balance of the system smart contracts is kept constant after each user action.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe gas parameter fields forward\\_milliton and gas\\_transfer of the WithdrawFunds message can be used to drain the TON balance of the PixelswapSettlement contract, as the values specified in these fields are not spent from the user's funding wallet.\n\nThe WithdrawFunds message in the Settlement contract allows users to withdraw the balance of their funding wallet to their external wallet. The WithdrawFunds receiver function of the settlement contract calls the send\\_tokens internal function to transfer the specified token and amount to the user:\n\n#### **[Redacted]**\n\nThe send\\_tokens function transfers the sum of the token\\_amt, forward\\_milliton, and gas\\_transfer values when the provided token\\_id is the TON native currency:\n\n#### **[Redacted]**\n\nHowever, the WithdrawFunds message receiver of the PixelSwapFundingWallet contract does not spend the user's TON balance by the sum of forward\\_milliton and gas\\_transfer values for TON transfer:\n\n#### **[Redacted]**\n\nA user can specify non-zero values for the forward\\_milliton and gas\\_transfer fields in the WithdrawFunds message to drain the TON balance of the settlement contract.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-6",
        "Target": "contracts/pixelswap_settlement.tact"
      },
      "heading_cleaned": "Users can drain the TON balance of the PixelswapSettlement contract"
    },
    {
      "index": 7,
      "page_start": 29,
      "heading": "7. Users can avoid paying the gas fee for the token creation transaction",
      "markdown": "# 7. Users can avoid paying the gas fee for the token creation transaction\n\n| Severity: Low                               | Diffi culty: Low      |\n|------------------------------------------------|-----------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-7 |\n| Target: contracts/pixelswap_streampool.tact |                             |\n\n#### Description\n\nTo create a new token, a user must send a CreateToken message to the Stream Pool contract with enough value to pay for the token creation fee. This fee is also used as a mitigation feature to disincentivize the creation of excessively many tokens, given that the tokens are stored in a mapping structure inside the Stream Pool contract's storage.\n\nIn the CreateToken message handler, the message value is checked to ensure that it is enough to pay the creation fee, but it doesn't take into account the gas costs needed to execute the transaction.\n\nThis allows any user to create new tokens without paying for the computation gas required to create them, using the Stream Pool contract balance to pay for it.\n\n#### **[Redacted]**\n\n#### Exploit Scenario\n\nAlice decides to drain the balance of a PixelswapStreamPool contract. To do this, she starts sending CreateToken messages to the Stream Pool with a value just above (i.e., by 1 nanoton) the token creation fee.\n\nRepeating this will drain the PixelswapStreamPool contract balance, which will be used to pay for all the CreateToken message processing. Admins will need to send TON to it to continue paying the storage fee.\n\n### Recommendations\n\nShort term, modify the value check in the CreateToken message receiver to ensure the user provides enough TON for the required gas.\n\nLong term, expand checks in the test cases to ensure that the TON balance of the system smart contracts does not go down after user actions that do not transfer TON.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nTo create a new token, a user must send a CreateToken message to the Stream Pool contract with enough value to pay for the token creation fee. This fee is also used as a mitigation feature to disincentivize the creation of excessively many tokens, given that the tokens are stored in a mapping structure inside the Stream Pool contract's storage.\n\nIn the CreateToken message handler, the message value is checked to ensure that it is enough to pay the creation fee, but it doesn't take into account the gas costs needed to execute the transaction.\n\nThis allows any user to create new tokens without paying for the computation gas required to create them, using the Stream Pool contract balance to pay for it.\n\n#### **[Redacted]**\n",
      "metadata": {
        "Severity": "Low",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-7",
        "Target": "contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "Users can avoid paying the gas fee for the token creation transaction"
    },
    {
      "index": 8,
      "page_start": 30,
      "heading": "8. The tokens\\_count initial value in the PixelswapStreamPool contract is zero",
      "markdown": "### 8. The tokens\\_count initial value in the PixelswapStreamPool contract is zero\n\n| Severity: Informational                     | Diffi culty: Undetermined |\n|------------------------------------------------|---------------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-8     |\n| Target: contracts/pixelswap_streampool.tact |                                 |\n\n#### Description\n\nThe token\\_count variable in the PixelswapStreamPool contract is meant to track how many tokens are added. All stream pool contracts add the TON as a token in the init function, but the tokens\\_count variable is not updated in the init function, and it remains 0.\n\nThis has no impact on the current state of the codebase, as the tokens are stored in a non-iterable mapping.\n\n#### Recommendations\n\nShort term, make sure the tokens\\_count variable is updated in the init function to track the correct number of tokens added to the PixelswapStreamPool contract.\n\nLong term, expand the test suite to implement test cases to check the variable values in all of the contracts. This will ensure correct value updates.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe token\\_count variable in the PixelswapStreamPool contract is meant to track how many tokens are added. All stream pool contracts add the TON as a token in the init function, but the tokens\\_count variable is not updated in the init function, and it remains 0.\n\nThis has no impact on the current state of the codebase, as the tokens are stored in a non-iterable mapping.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Undetermined",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-8",
        "Target": "contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "The tokens\\_count initial value in the PixelswapStreamPool contract is zero"
    },
    {
      "index": 9,
      "page_start": 31,
      "heading": "9. The returned TON amount from an order execution result is ignored",
      "markdown": "# 9. The returned TON amount from an order execution result is ignored\n\n| Severity: Informational                     | Diffi culty: High     |\n|------------------------------------------------|-----------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-9 |\n| Target: contracts/pixelswap_settlement.tact |                             |\n\n#### Description\n\nWhen an order is processed in the PixelswapStreamPool contract, an OrderExecutionResult message is returned to the settlement contract. This message contains information about the amounts of tokens and TON that should be deducted from the settlement vault balance of the exec\\_id and added to the settlement vault balance of the fund\\_id.\n\nThe process\\_order\\_execution\\_result internal function of the settlement contract reduces the token\\_amt of the token\\_id token from the settlement vault balance of the exec\\_id and adds the same balance to the settlement vault of the fund\\_id if the tokens are not transferred to the user's external wallet. However, this function ignores the value of the ton\\_amt field of the OrderExecutionResult message and does not update the settlement vault balance for the native TON token:\n\n#### **[Redacted]**\n\nThe existing execution contract PixelswapStreamPool does not send a non-zero value of the ton\\_amt in the OrderExecutionResult message; therefore, this issue does not lead to any loss of funds in the current system. New execution contracts may send a Jetton and TON together in a single OrderExecutionResult message, which will result in an out-of-sync balance of settlement vaults and other contracts.\n\n#### Recommendations\n\nShort term, if the ton\\_amt value is non-zero, update the settlement vault balances of the exec\\_id and fund\\_id for the TON token when processing the OrderExecutionResult message.\n\nLong term, create message flow and fund flow diagrams and document all of the places where the balances of different components and users are tracked in the system.\n\n### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nWhen an order is processed in the PixelswapStreamPool contract, an OrderExecutionResult message is returned to the settlement contract. This message contains information about the amounts of tokens and TON that should be deducted from the settlement vault balance of the exec\\_id and added to the settlement vault balance of the fund\\_id.\n\nThe process\\_order\\_execution\\_result internal function of the settlement contract reduces the token\\_amt of the token\\_id token from the settlement vault balance of the exec\\_id and adds the same balance to the settlement vault of the fund\\_id if the tokens are not transferred to the user's external wallet. However, this function ignores the value of the ton\\_amt field of the OrderExecutionResult message and does not update the settlement vault balance for the native TON token:\n\n#### **[Redacted]**\n\nThe existing execution contract PixelswapStreamPool does not send a non-zero value of the ton\\_amt in the OrderExecutionResult message; therefore, this issue does not lead to any loss of funds in the current system. New execution contracts may send a Jetton and TON together in a single OrderExecutionResult message, which will result in an out-of-sync balance of settlement vaults and other contracts.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-9",
        "Target": "contracts/pixelswap_settlement.tact"
      },
      "heading_cleaned": "The returned TON amount from an order execution result is ignored"
    },
    {
      "index": 10,
      "page_start": 32,
      "heading": "10. Wrong formula used for LP amount calculation",
      "markdown": "| 10. Wrong formula used for LP amount calculation |                              |\n|-----------------------------------------------------------------------|------------------------------|\n| Severity: High                                                     | Diffi culty: Low       |\n| Type: Data Validation                                           | Finding ID: TOB-PXL-10 |\n| Target: contracts/univ2_math.tact                                  |                              |\n\n#### Description\n\nThe PixelswapStreamPool contract uses the wrong formula to compute the LP token amount for adding liquidity. This results in liquidity providers losing on the fee earned from the swaps.\n\nThe PixelswapStreamPool contract calls the calc\\_add\\_lp\\_balanced function of the univ2\\_math.tact library contract to compute the LP token amount to mint for a liquidity provider. The calc\\_add\\_lp\\_balanced function computes the LP token amount by computing the square root of the new reserves and deducting the last total supply of the LP tokens from the result of the square root:\n\n#### **[Redacted]**\n\nHowever, the remove liquidity function computes the amount of tokens to transfer in proportion to the LP tokens to burn with respect to the total supply of the LP tokens. This results in liquidity providers losing their share of the swap fee because the swap fee accrued by the pool up to a certain time is given to the new liquidity providers instead of being distributed among the existing liquidity providers.\n\nThe calc\\_add\\_lp\\_unbalanced function of the univ2\\_math.tact library contract also uses the wrong formula for calculating the LP token amount.\n\n### Exploit Scenario\n\nLet us consider a TON / USDC pool with 0 liquidity.\n\n- Alice deposits 10,000,000,000 nanotons TON and 10,000,000,000 nanotons USDC in the pool and mints 10,000,000,000 nanotons LP tokens.\n- Bob swaps 1,000,000,000 nanotons TON for 908,264,387 nanotons USDC. The reserves after the swap are 10,999,970,000 nanotons TON and 9,091,735,613 nanotons USDC.\n- Eve deposits 10,999,970,000 nanotons TON and 9,091,735,613 nanotons USDC, and the protocol mints 10,000,881,879 nanotons LP tokens for Eve.\n\n\n\n‚óè Eve redeems her LP tokens for 11,000,455,010 nanotons TON and 9,092,136,485 nanotons USDC, which is more than the 10,999,484,989 nanotons TON and 9,091,334,740 nanotons USDC that Alice can redeem by removing all her liquidity.\n\n#### Recommendations\n\nShort term, use the following formula for the LP token amount calculation in the calc\\_add\\_lp\\_balanced and calc\\_add\\_lp\\_unbalanced functions when a user adds liquidity to a non-empty pool:\n\n#### **[Redacted]**\n\nLong term, define high-level system invariants and implement end-to-end test cases to check these invariants with multiple transactions by different users. Consider using a fuzzer to test these invariants.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe PixelswapStreamPool contract uses the wrong formula to compute the LP token amount for adding liquidity. This results in liquidity providers losing on the fee earned from the swaps.\n\nThe PixelswapStreamPool contract calls the calc\\_add\\_lp\\_balanced function of the univ2\\_math.tact library contract to compute the LP token amount to mint for a liquidity provider. The calc\\_add\\_lp\\_balanced function computes the LP token amount by computing the square root of the new reserves and deducting the last total supply of the LP tokens from the result of the square root:\n\n#### **[Redacted]**\n\nHowever, the remove liquidity function computes the amount of tokens to transfer in proportion to the LP tokens to burn with respect to the total supply of the LP tokens. This results in liquidity providers losing their share of the swap fee because the swap fee accrued by the pool up to a certain time is given to the new liquidity providers instead of being distributed among the existing liquidity providers.\n\nThe calc\\_add\\_lp\\_unbalanced function of the univ2\\_math.tact library contract also uses the wrong formula for calculating the LP token amount.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-10",
        "Target": "contracts/univ2_math.tact"
      },
      "heading_cleaned": "Wrong formula used for LP amount calculation"
    },
    {
      "index": 11,
      "page_start": 34,
      "heading": "11. Users can use nested PlaceOrders to drain the settlement contract",
      "markdown": "### 11. Users can use nested PlaceOrders to drain the settlement contract\n\n| Severity: High                           | Diffi culty: Low       |\n|---------------------------------------------|------------------------------|\n| Type: Data Validation                 | Finding ID: TOB-PXL-11 |\n| Target: contracts/pixelswap_funding.tact |                              |\n\n#### Description\n\nThe spend\\_order\\_inputs function of the PixelswapFundingWallet contract does not spend the input tokens of the nested PlaceOrder messages, which allows users to use nested PlaceOrder messages to drain all the assets from the settlement contract.\n\nThe PlaceOrder receiver function of the PixelswapFundingWallet contract calls the spend\\_order\\_inputs internal function to update the user's balance of tokens for the order. The PlaceOrder message has an optional ref\\_po field, which can have a ref to another PlaceOrder message. The spend\\_order\\_inputs function processes these nested PlaceOrder messages by recursively calling the spend\\_order\\_inputs function:\n\n#### **[Redacted]**\n\nHowever, the return statement of the spend\\_order\\_inputs function compiles to the following FunC code:\n\n#### **[Redacted]**\n\nThe above FunC code returns the first FunC tensor, which is computed by processing the input tokens specified in the outermost PlaceOrder instead of returning the result of the recursive call of the \\$PixelswapFundingWallet\\$\\_fun\\_spend\\_order\\_inputs FunC function. The value returned from this function is then stored in the contract storage.\n\n#### Exploit Scenario\n\nEve deposits 1000,000,000 nanotons TON and 1000,000,000 nanotons USDC in her funding wallet. Eve then sends a PlaceOrder message to add liquidity of 1000,000,000 nanotons TON and 1000,000,000 nanotons USDC to the TON/USDC pool, with the ref\\_po having another PlaceOrder order message to add the same liquidity again. The spend\\_order\\_inputs function of the funding wallet contract deducts Eve's balance for only the outermost PlaceOrder message, stores the new values of 0 TON and 0 USDC balance in the contract storage, and sends the whole PlaceOrder message to the funding master contract. The whole PlaceOrder is then successfully processed by the PixelswapStreamPool contract to mint LP token amounts for both PlaceOrder\n\n\n\nmessages for Eve. Eve then redeems all her LP tokens from the pool and withdraws 2000,000,000 nanotons TON and 2000,000,000 nanotons USDC.\n\n#### Recommendations\n\nShort term, replace the return statement of the recursive call with the following:\n\n#### **[Redacted]**\n\nLong term, expand the test suite to check execution of nested orders. Check the whole system state after a transaction in a test case to ensure correctness of the test cases.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe spend\\_order\\_inputs function of the PixelswapFundingWallet contract does not spend the input tokens of the nested PlaceOrder messages, which allows users to use nested PlaceOrder messages to drain all the assets from the settlement contract.\n\nThe PlaceOrder receiver function of the PixelswapFundingWallet contract calls the spend\\_order\\_inputs internal function to update the user's balance of tokens for the order. The PlaceOrder message has an optional ref\\_po field, which can have a ref to another PlaceOrder message. The spend\\_order\\_inputs function processes these nested PlaceOrder messages by recursively calling the spend\\_order\\_inputs function:\n\n#### **[Redacted]**\n\nHowever, the return statement of the spend\\_order\\_inputs function compiles to the following FunC code:\n\n#### **[Redacted]**\n\nThe above FunC code returns the first FunC tensor, which is computed by processing the input tokens specified in the outermost PlaceOrder instead of returning the result of the recursive call of the \\$PixelswapFundingWallet\\$\\_fun\\_spend\\_order\\_inputs FunC function. The value returned from this function is then stored in the contract storage.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-11",
        "Target": "contracts/pixelswap_funding.tact"
      },
      "heading_cleaned": "Users can use nested PlaceOrders to drain the settlement contract"
    },
    {
      "index": 12,
      "page_start": 36,
      "heading": "12. The LP tokens are never burned by the Stream Pool contract",
      "markdown": "# 12. The LP tokens are never burned by the Stream Pool contract\n\n| Severity: High | Diffi culty: Low |\n|-------------------|------------------------|\n| Type:             | Finding                |\n| Data              | ID:                    |\n| Validation        | TOB-PXL-12             |\n\nTarget: contracts/jetton/jetton\\_factory.tact\n\n#### Description\n\nThe PixelswapStreamPool contract sends the burn message to the Jetton master contract of the pair's LP token instead of the Jetton wallet owned by itself. This results in the LP tokens never being burned.\n\nUsers remove their liquidity by transferring their LP tokens to the PixelswapStreamPool contract with a payload to send the RemoveLiquidityJettonNotification message to the PixelswapStreamPool contract. The RemoveLiquidityJettonNotification handler function of the Stream Pool contract updates the reserves and LP token supply stored in the pair\\_config map and calls the self.burn function. The burn function is inherited from the JettonFactory trait contract:\n\n#### **[Redacted]**\n\nThe burn function of the JettonFactory trait sends the burn message to the Jetton master contract of the LP token with the bounce flag set to false. The Jetton master contract reverts the transaction, and the burn message is never processed by the Jetton contracts of the LP token.\n\n#### Exploit Scenario\n\nAlice adds 1000,000,000 nanotons TON and 1000,000,000 nanotons USDC to the pool and mints 1000,000,000 nanotons LP tokens. After some time, Alice removes her liquidity by transferring her LP tokens to the PixelswapStreamPool contract, but the LP tokens are not burned by the Stream Pool contract, and the LP token balance of the Stream Pool contract is increased by 1,000,000,000 nanotons LP tokens.\n\n#### Recommendations\n\nShort term, update the burn function of the JettonFactory trait contract to send the burn message to the Jetton wallet owned by the Stream Pool contract.\n\nLong term, check the whole system state after a transaction in a test case to ensure correctness of the test cases.\n\n\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe PixelswapStreamPool contract sends the burn message to the Jetton master contract of the pair's LP token instead of the Jetton wallet owned by itself. This results in the LP tokens never being burned.\n\nUsers remove their liquidity by transferring their LP tokens to the PixelswapStreamPool contract with a payload to send the RemoveLiquidityJettonNotification message to the PixelswapStreamPool contract. The RemoveLiquidityJettonNotification handler function of the Stream Pool contract updates the reserves and LP token supply stored in the pair\\_config map and calls the self.burn function. The burn function is inherited from the JettonFactory trait contract:\n\n#### **[Redacted]**\n\nThe burn function of the JettonFactory trait sends the burn message to the Jetton master contract of the LP token with the bounce flag set to false. The Jetton master contract reverts the transaction, and the burn message is never processed by the Jetton contracts of the LP token.\n",
      "metadata": null,
      "heading_cleaned": "The LP tokens are never burned by the Stream Pool contract"
    },
    {
      "index": 13,
      "page_start": 38,
      "heading": "13. Lack of the pair\\_id and token\\_id validation in the PixelswapStreamPool contract",
      "markdown": "# 13. Lack of the pair\\_id and token\\_id validation in the PixelswapStreamPool contract\n\n| Severity: High                              | Diffi culty: Low       |\n|------------------------------------------------|------------------------------|\n| Type: Data Validation                    | Finding ID: TOB-PXL-13 |\n| Target: contracts/pixelswap_streampool.tact |                              |\n\n#### Description\n\nThe PlaceOrder message receiver function of the PixelswapStreamPool contract does not validate that the pair\\_id specified in the message corresponds to the token\\_id values specified in the message. This allows users to provide arbitrary token\\_id values to execute a swap or add liquidity to a pair without transferring the required tokens.\n\nThe protocol allows users to transfer their Jettons and execute a protocol action in a single transaction by specifying order parameters in the forward\\_payload field of the transfer message of the Jetton contract. The Jetton contract sends the OrderJettonNotification message to the settlement contract, which adds a deposit to the user's funding wallet, executes a swap, or adds liquidity to the specified pair based on the forward\\_payload value specified in the OrderJettonNotification message.\n\nHowever, the OrderJettonNotification message receiver cannot verify that the message is sent by the correct Jetton wallet contract and is not sent by a malicious actor; it considers the sender as the token\\_id for the order to be executed. This allows users to add a funding wallet balance for an arbitrary token\\_id, execute a swap without transferring Jettons, and add liquidity to a pool without transferring Jettons by sending the OrderJettonNotification message from an arbitrary address.\n\n#### **[Redacted]**\n\nAs a result, the PlaceOrder message receiver function of the PixelswapStreamPool contract does not check if the user-provided value of the pair\\_id field corresponds to the token\\_id values provided in the PlaceOrder message. This allows attackers to send the OrderJettonNotification message from an arbitrary address to steal tokens from the settlement contract.\n\n#### Exploit Scenario 1\n\nEve sends an OrderJettonNotification message from her smart wallet to swap USDC for TON from the TON/USDC pool. The order is executed successfully, and Eve gets free TON from the settlement contract.\n\n\n\n#### Exploit Scenario 2\n\nEve sends an OrderJettonNotification message from her smart wallet to deposit a fake Jetton to her funding wallet. She then sends a PlaceOrder message to swap USDC for TON by specifying the fake Jetton as input token token\\_id and TON/USDC pair pair\\_id. The order is executed successfully, and Eve gets free TON from the settlement contract.\n\n#### Recommendations\n\nShort term, validate that the pair\\_id specified in the PlaceOrder message corresponds to the provided token\\_id values to ensure correct token transfers before executing an order.\n\nLong term, validate all user inputs at all of the system's entrypoints to ensure the correctness and security of the system.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe PlaceOrder message receiver function of the PixelswapStreamPool contract does not validate that the pair\\_id specified in the message corresponds to the token\\_id values specified in the message. This allows users to provide arbitrary token\\_id values to execute a swap or add liquidity to a pair without transferring the required tokens.\n\nThe protocol allows users to transfer their Jettons and execute a protocol action in a single transaction by specifying order parameters in the forward\\_payload field of the transfer message of the Jetton contract. The Jetton contract sends the OrderJettonNotification message to the settlement contract, which adds a deposit to the user's funding wallet, executes a swap, or adds liquidity to the specified pair based on the forward\\_payload value specified in the OrderJettonNotification message.\n\nHowever, the OrderJettonNotification message receiver cannot verify that the message is sent by the correct Jetton wallet contract and is not sent by a malicious actor; it considers the sender as the token\\_id for the order to be executed. This allows users to add a funding wallet balance for an arbitrary token\\_id, execute a swap without transferring Jettons, and add liquidity to a pool without transferring Jettons by sending the OrderJettonNotification message from an arbitrary address.\n\n#### **[Redacted]**\n\nAs a result, the PlaceOrder message receiver function of the PixelswapStreamPool contract does not check if the user-provided value of the pair\\_id field corresponds to the token\\_id values provided in the PlaceOrder message. This allows attackers to send the OrderJettonNotification message from an arbitrary address to steal tokens from the settlement contract.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-13",
        "Target": "contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "Lack of the pair\\_id and token\\_id validation in the PixelswapStreamPool contract"
    },
    {
      "index": 14,
      "page_start": 40,
      "heading": "14. The value attached to messages is not checked to be positive",
      "markdown": "| 14. The value attached to messages is not checked to be positive |                              |\n|------------------------------------------------------------------------------------------------|------------------------------|\n| Severity: Informational                                                                     | Diffi culty: High      |\n| Type: Data Validation                                                                    | Finding ID: TOB-PXL-14 |\n| Target: contracts/utils/msgtools.tact                                                       |                              |\n\n#### Description\n\nThe message tools library implements helper functions to deal with message passing between contracts. Some of these functions deal with messages that carry TON value, and the caller can specify the amount of TON to send.\n\nIn two of these functions, there is no check to ensure that the value to be set is positive. Given that the parameter is of type Int, it is possible to pass a negative value and break functionality.\n\nThe vulnerable functions are send\\_to\\_value and send\\_and\\_deploy\\_value, shown in figures 14.1 and 14.2:\n\n#### **[Redacted]**\n\nThe following list shows examples of potentially dangerous usages of this function in the current codebase:\n\n- [OrderJettonNotification](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L419-L419) handler in pixelswap\\_settlement.tact\n- [RemoveLiquidityJettonNotification](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L298-L298) handler in pixelswap\\_streampool.tact\n- Swap [handler](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L483-L483) in pixelswap\\_settlement.tact\n- [OrderExecutionResult](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L605-L605) handler in pixelswap\\_settlement.tact\n- [InternalTransfer](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L626-L626) handler in pixelswap\\_settlement.tact\n- [Deposit](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L762-L762) function in pixelswap\\_settlement.tact\n\nMost of these usages depend on the current values for the gas configuration, lack of check or enforcement of context().value that could be bypassed by future implementations, or values that depend on the execution state (reliance on gas\\_consumed()).\n\n#### Recommendations\n\nShort term, add a validation for the value parameter to be positive in the send\\_to\\_value and send\\_and\\_deploy\\_value functions.\n\n\n\nLong term, check all usages of these functions in the codebase and ensure that all calculations for the value parameters are well-defined, bounded, and never negative. Enforce these checks by creating new test cases.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe message tools library implements helper functions to deal with message passing between contracts. Some of these functions deal with messages that carry TON value, and the caller can specify the amount of TON to send.\n\nIn two of these functions, there is no check to ensure that the value to be set is positive. Given that the parameter is of type Int, it is possible to pass a negative value and break functionality.\n\nThe vulnerable functions are send\\_to\\_value and send\\_and\\_deploy\\_value, shown in figures 14.1 and 14.2:\n\n#### **[Redacted]**\n\nThe following list shows examples of potentially dangerous usages of this function in the current codebase:\n\n- [OrderJettonNotification](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L419-L419) handler in pixelswap\\_settlement.tact\n- [RemoveLiquidityJettonNotification](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L298-L298) handler in pixelswap\\_streampool.tact\n- Swap [handler](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L483-L483) in pixelswap\\_settlement.tact\n- [OrderExecutionResult](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L605-L605) handler in pixelswap\\_settlement.tact\n- [InternalTransfer](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L626-L626) handler in pixelswap\\_settlement.tact\n- [Deposit](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L762-L762) function in pixelswap\\_settlement.tact\n\nMost of these usages depend on the current values for the gas configuration, lack of check or enforcement of context().value that could be bypassed by future implementations, or values that depend on the execution state (reliance on gas\\_consumed()).\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-14",
        "Target": "contracts/utils/msgtools.tact"
      },
      "heading_cleaned": "The value attached to messages is not checked to be positive"
    },
    {
      "index": 15,
      "page_start": 42,
      "heading": "15. The current balance is not checked before sending a message with a non-zero value",
      "markdown": "# 15. The current balance is not checked before sending a message with a non-zero value\n\n| Severity: High                        | Diffi culty: Medium    |\n|------------------------------------------|------------------------------|\n| Type: Data Validation              | Finding ID: TOB-PXL-15 |\n| Target: contracts/utils/msgtools.tact |                              |\n\n#### Description\n\nAll message sending functions in the message tools library use the SendIgnoreErrors mode. If the sender contract's current TON balance is insufficient to send the specified value, the message will not be sent and will be dropped silently in the action phase. Consequently, funds can be lost, or the system state can become out of sync between contracts.\n\nThis issue can be exploited in different ways, one of which is described in the Exploit Scenario section below.\n\n#### Exploit Scenario\n\nIn the settlement contract, when the token\\_id is the TON native asset, the [send\\\\_tokens](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L728-L746) [function](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L728-L746) sends a token amount equal to the sum of the specified token\\_amt, the forwarding gas, and the gas cost to pay for the transfer. However, it never checks that the contract's current balance exceeds the value to be sent.\n\nThis results in a loss of funds for the user, because the funding wallet's TON balance has already been reduced at this point.\n\n#### Recommendations\n\nShort term, when dealing with TON amounts to be transferred in messages, first ensure that the current contract's balance is enough. In case of failure, notify the sender via AFR.\n\nLong term, document all gas usages in the different message flows; ensure that the contract balances cannot drop below a certain threshold; and implement tests that check that the functionality of the system is not broken in low-balance situations.\n\n### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nAll message sending functions in the message tools library use the SendIgnoreErrors mode. If the sender contract's current TON balance is insufficient to send the specified value, the message will not be sent and will be dropped silently in the action phase. Consequently, funds can be lost, or the system state can become out of sync between contracts.\n\nThis issue can be exploited in different ways, one of which is described in the Exploit Scenario section below.\n",
      "metadata": {
        "Severity": "High",
        "Difficulty": "Medium",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-15",
        "Target": "contracts/utils/msgtools.tact"
      },
      "heading_cleaned": "The current balance is not checked before sending a message with a non-zero value"
    },
    {
      "index": 16,
      "page_start": 43,
      "heading": "16. The exec\\_id value is not validated for the internal orders in nested PlaceOrder messages",
      "markdown": "# 16. The exec\\_id value is not validated for the internal orders in nested PlaceOrder messages\n\n| Severity: Medium                                                                    | Diffi culty: Low       |\n|----------------------------------------------------------------------------------------|------------------------------|\n| Type: Data Validation                                                            | Finding ID: TOB-PXL-16 |\n| Target: contracts/pixelswap_streampool.tact, contracts/pixelswap_settlement.tact |                              |\n\n#### Description\n\nWhen a PlaceOrder message arrives at the PixelswapStreamPool contract, the exec\\_id is checked to ensure it matches the current contract's exec\\_id. This is also checked in the settlement contract to ensure that the message is routed to the correct PixelswapStreamPool:\n\n#### **[Redacted]**\n\nHowever, PlaceOrder messages can have nested PlaceOrder messages in the ref\\_po field, and those nested exec\\_ids are never checked by the settlement or Stream Pool contracts.\n\nAdditionally, when the order is processed by process\\_order(), a ProcessOrderResult message is generated with the exec\\_id of the current Stream Pool, no matter what the original message's exec\\_id was. This result is sent back to the settlement contract to keep track of the accounting, and the process\\_order\\_execution function updates the settlement vault balances using the exec\\_id set by the Stream Pool.\n\n#### **[Redacted]**\n\n#### Exploit Scenario\n\nBob, a PixelSwap user, creates an order composed of a TON/USDC swap and a deposit to a USDC/USDT pool located in a different Stream Pool contract. In order to save some time, he nests both orders in a single PlaceOrder message, believing that the system will correctly identify the execution contracts that must be called. The order executes successfully and the resulting reserves of the TON/USDC pair will be incorrect since both orders were processed by the TON/USDC pool execution contract.\n\n#### Recommendations\n\nShort term, check that the exec\\_id value matches the current execution contract's ID for all orders in a nested PlaceOrder message. Notify the user in case an invalid order is not processed so they can retry later or at least be aware of the execution failure.\n\n\n\nLong term, consider re-engineering the architecture and the way nested orders are created, transmitted, and handled. Alternatively, consider rewriting the PlaceOrder nesting feature in order to make it less error-prone (e.g.,, by nesting only the non-redundant information).\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nWhen a PlaceOrder message arrives at the PixelswapStreamPool contract, the exec\\_id is checked to ensure it matches the current contract's exec\\_id. This is also checked in the settlement contract to ensure that the message is routed to the correct PixelswapStreamPool:\n\n#### **[Redacted]**\n\nHowever, PlaceOrder messages can have nested PlaceOrder messages in the ref\\_po field, and those nested exec\\_ids are never checked by the settlement or Stream Pool contracts.\n\nAdditionally, when the order is processed by process\\_order(), a ProcessOrderResult message is generated with the exec\\_id of the current Stream Pool, no matter what the original message's exec\\_id was. This result is sent back to the settlement contract to keep track of the accounting, and the process\\_order\\_execution function updates the settlement vault balances using the exec\\_id set by the Stream Pool.\n\n#### **[Redacted]**\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-16",
        "Target": "contracts/pixelswap_streampool.tact, contracts/pixelswap_settlement.tact"
      },
      "heading_cleaned": "The exec\\_id value is not validated for the internal orders in nested PlaceOrder messages"
    },
    {
      "index": 17,
      "page_start": 45,
      "heading": "17. The token_balance get function reverts if a user balance is 0",
      "markdown": "| 17. The token_balance get function reverts if a user balance is 0 |                              |\n|----------------------------------------------------------------------------------------------------|------------------------------|\n| Severity: Undetermined                                                                          | Diffi culty: Low       |\n| Type: Data Validation                                                                        | Finding ID: TOB-PXL-17 |\n|                                                                                                    |                              |\n\nTarget: contracts/pixelswap\\_funding.tact\n\n#### Description\n\nThe token\\_balance function in the PixelswapFundingWallet contract should return the current wallet's balance for the specified token. However, the balances mapping entry is deleted when the user balance becomes zero, so the token\\_balance function reverts when it is called for users with zero balance.\n\nThis can affect external off-chain integrations, potentially breaking external projects that are attempting to get information from Pixelswap.\n\n### **[Redacted]**\n\n#### Recommendations\n\nShort term, return the expected value of zero if the mapping entry does not exist.\n\nLong term, consider rewriting the parts of the code where the mapping entry is deleted for zero balance results. Since test cases can also break when this call reverts, it is recommended that the test suite be improved to detect this kind of unexpected behavior.\n\n### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe token\\_balance function in the PixelswapFundingWallet contract should return the current wallet's balance for the specified token. However, the balances mapping entry is deleted when the user balance becomes zero, so the token\\_balance function reverts when it is called for users with zero balance.\n\nThis can affect external off-chain integrations, potentially breaking external projects that are attempting to get information from Pixelswap.\n\n### **[Redacted]**\n",
      "metadata": {
        "Severity": "Undetermined",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-17",
        "Target": "contracts/pixelswap_funding.tact"
      },
      "heading_cleaned": "The token_balance get function reverts if a user balance is 0"
    },
    {
      "index": 18,
      "page_start": 46,
      "heading": "18. Different parsing formats for Jetton notification messages",
      "markdown": "# 18. Different parsing formats for Jetton notification messages\n\n| Severity: Medium                                                                             | Diffi culty: High      |  |\n|-------------------------------------------------------------------------------------------------|------------------------------|--|\n| Type: Data Validation                                                                     | Finding ID: TOB-PXL-18 |  |\n| contracts/pixelswap_settlement.tact, Target: contracts/pixelswap_streampool_messages.tact |                              |  |\n\n# Description\n\nThe Jetton notification message for [transfer\\\\_notification](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md), with ID 0x7362d09c, is defined differently for the settlement and the Stream Pool contracts. In particular, the fund\\_id and subaccount structure fields are read in reverse order, as shown in figures 18.1 and 18.2.\n\n#### **[Redacted]**\n\n#### Exploit Scenario\n\nOff-chain components and UI projects mistakenly send the wrong value for the fund\\_id and subaccount fields, causing funds to be lost.\n\n#### Recommendations\n\nShort term, standardize the structure of the messages that share the same ID or same fields.\n\nLong term, avoid duplication of message types. Even if the functions' data needs are different, having different names and structures for the same message is confusing and error-prone. Define shared messages in a single place.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "# Description\n\nThe Jetton notification message for [transfer\\\\_notification](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md), with ID 0x7362d09c, is defined differently for the settlement and the Stream Pool contracts. In particular, the fund\\_id and subaccount structure fields are read in reverse order, as shown in figures 18.1 and 18.2.\n\n#### **[Redacted]**\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-18",
        "Target": "contracts/pixelswap_streampool_messages.tact"
      },
      "heading_cleaned": "Different parsing formats for Jetton notification messages"
    },
    {
      "index": 19,
      "page_start": 47,
      "heading": "19. The JettonFactory contract allows minting zero tokens",
      "markdown": "# 19. The JettonFactory contract allows minting zero tokens\n\n| Severity: Informational  | Diffi culty: Undetermined |  |\n|-----------------------------|---------------------------------|--|\n| Type: Data Validation | Finding ID: TOB-PXL-19    |  |\n|                             |                                 |  |\n\nTarget: contracts/jetton/jetton\\_factory.tact\n\n#### Description\n\nThe mint function of the JettonFactory trait does not validate that the amount of coins to mint is greater than zero, therefore allowing a mint of zero tokens.\n\n#### **[Redacted]**\n\nIn the current state of the codebase, it is not possible to trigger this zero-amount mint for the LP tokens since the add\\_liquidity function checks for a minimum liquidity of 1000 to be added. However, if this same trait is used in other contracts, it can become an issue.\n\n#### Recommendations\n\nShort term, add a validation check to ensure the amount is greater than zero.\n\nLong term, consider the possible edge cases in all functions, define the behavior, and implement test cases to ensure compliance.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe mint function of the JettonFactory trait does not validate that the amount of coins to mint is greater than zero, therefore allowing a mint of zero tokens.\n\n#### **[Redacted]**\n\nIn the current state of the codebase, it is not possible to trigger this zero-amount mint for the LP tokens since the add\\_liquidity function checks for a minimum liquidity of 1000 to be added. However, if this same trait is used in other contracts, it can become an issue.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Undetermined",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-19",
        "Target": "contracts/jetton/jetton_factory.tact"
      },
      "heading_cleaned": "The JettonFactory contract allows minting zero tokens"
    },
    {
      "index": 20,
      "page_start": 48,
      "heading": "20. Incorrect gas calculations in several contracts",
      "markdown": "# 20. Incorrect gas calculations in several contracts\n\n| Severity: Undetermined                                                              | Diffi culty: Undetermined |  |\n|----------------------------------------------------------------------------------------|---------------------------------|--|\n| Type: Data Validation                                                            | Finding ID: TOB-PXL-20    |  |\n| contracts/pixelswap_streampool.tact, Target: contracts/pixelswap_settlement.tact |                                 |  |\n\n#### Description\n\nTON contracts, being a part of an asynchronous blockchain, can process messages in a non-deterministic order. In some cases, the incoming messages require the contract to perform changes in the storage, send new messages, and other gas-consuming tasks.\n\nIt is important to take into account the gas costs associated with executing functions or sending messages to ensure that the contract's final balance after execution does not drop below a threshold. Otherwise, if the balance is zero, the contract cannot pay for storage costs and can eventually be destroyed.\n\nWe noticed several places where the gas calculations were not correct or did not consider all of the costs that must be paid. We did not assess the exact severity of this issue because these calculations may have a long-reaching impact on the affected functions and further calls, and can depend on external factors unknown at the time.\n\n- Swap [message handler](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L442) in pixelswap\\_settlement.tact should consider the storage fees, the gas consumed, and the gas for paused contract refund.\n- Later, [line 463](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L463) should check that the resulting amount is greater than gas\\_check\\_swap\\_message.\n- Lines [454](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L454) and [468](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L468) should deduct gas\\_consumed().\n- PlaceOrder [message handler](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L185) in pixelswap\\_streampool.tact should consider the message transfer fee.\n- [RemoveLiquidityJettonNotification](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L273-L280) message handler should consider the transfer\\_notification\\_handler gas fee or use the remaining gas instead of context().value.\n- Later, [line 297](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L297) subtracts remove\\_liquidity gas twice because the call was already made. It is not checked that the remaining gas is more than the required token0 and token1 gas amounts.\n\n\n\n### Recommendations\n\nShort term, ensure that the gas calculations correctly account for the message transfer fee, storage fee, computation fee, and forward TON amount in the mentioned places and all other places where they are calculated.\n\nLong term, measure all execution paths and their gas requirements to ensure that the amounts are correctly calculated through tests.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nTON contracts, being a part of an asynchronous blockchain, can process messages in a non-deterministic order. In some cases, the incoming messages require the contract to perform changes in the storage, send new messages, and other gas-consuming tasks.\n\nIt is important to take into account the gas costs associated with executing functions or sending messages to ensure that the contract's final balance after execution does not drop below a threshold. Otherwise, if the balance is zero, the contract cannot pay for storage costs and can eventually be destroyed.\n\nWe noticed several places where the gas calculations were not correct or did not consider all of the costs that must be paid. We did not assess the exact severity of this issue because these calculations may have a long-reaching impact on the affected functions and further calls, and can depend on external factors unknown at the time.\n\n- Swap [message handler](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L442) in pixelswap\\_settlement.tact should consider the storage fees, the gas consumed, and the gas for paused contract refund.\n- Later, [line 463](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L463) should check that the resulting amount is greater than gas\\_check\\_swap\\_message.\n- Lines [454](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L454) and [468](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_settlement.tact#L468) should deduct gas\\_consumed().\n- PlaceOrder [message handler](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L185) in pixelswap\\_streampool.tact should consider the message transfer fee.\n- [RemoveLiquidityJettonNotification](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L273-L280) message handler should consider the transfer\\_notification\\_handler gas fee or use the remaining gas instead of context().value.\n- Later, [line 297](https://github.com/nx-fi/pixelswap/blob/5c24e13fcae51b250bd70e0a812ce69a9b3dee4a/contracts/pixelswap_streampool.tact#L297) subtracts remove\\_liquidity gas twice because the call was already made. It is not checked that the remaining gas is more than the required token0 and token1 gas amounts.\n",
      "metadata": {
        "Severity": "Undetermined",
        "Difficulty": "Undetermined",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-20",
        "Target": "contracts/pixelswap_settlement.tact, contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "Incorrect gas calculations in several contracts"
    },
    {
      "index": 21,
      "page_start": 50,
      "heading": "21. A privileged account can drain the PixelswapStreamPool contract",
      "markdown": "# 21. A privileged account can drain the PixelswapStreamPool contract\n\n| Severity: Low                                | Diffi culty: High      |  |\n|-------------------------------------------------|------------------------------|--|\n| Type: Access Controls                     | Finding ID: TOB-PXL-21 |  |\n| Target: fcontracts/pixelswap_streampool.tact |                              |  |\n\n#### Description\n\nIn the PixelswapStreamPool contract, there are two ways to create new tokens and new trading pairs by sending CreateToken and CreateTradingPair messages: the first one requires being a privileged account, and the second one requires the sender to be enabled for adding tokens and pairs, and also paying a creation fee intended to avoid spamming.\n\nSince the privileged account does not require paying the fee or sending TON at all, it is possible to drain the balance of the PixelswapStreamPool contract because the message handler sends the fee to the recipient in all cases.\n\n#### **[Redacted]**\n\n#### Exploit Scenario\n\nAlice, a privileged account in the Stream Pool contract, decides to add new tokens and trading pairs to the system. Since she is not required to send additional value in her messages, she sends messages with the minimum amount possible to pay for the computation.\n\nWhile the PixelswapStreamPool contract has a balance, she is able to add the tokens and pairs. However, once the balance becomes zero, the transactions will start failing, putting the contract at risk of not being able to pay storage fees.\n\n#### Recommendations\n\nShort term, check for the contract balance before sending the fee payment.\n\nLong term, improve the test suite to consider all combinations of privileged and unprivileged users performing actions on the system. Check for balances before and after the transactions are executed, and ensure that the final balance is enough for storage fees.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nIn the PixelswapStreamPool contract, there are two ways to create new tokens and new trading pairs by sending CreateToken and CreateTradingPair messages: the first one requires being a privileged account, and the second one requires the sender to be enabled for adding tokens and pairs, and also paying a creation fee intended to avoid spamming.\n\nSince the privileged account does not require paying the fee or sending TON at all, it is possible to drain the balance of the PixelswapStreamPool contract because the message handler sends the fee to the recipient in all cases.\n\n#### **[Redacted]**\n",
      "metadata": {
        "Severity": "Low",
        "Difficulty": "High",
        "Type": "Access Controls",
        "Finding ID": "TOB-PXL-21",
        "Target": "fcontracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "A privileged account can drain the PixelswapStreamPool contract"
    },
    {
      "index": 22,
      "page_start": 51,
      "heading": "22. The fee recipient accounts cannot be changed in the Stream Pool contract",
      "markdown": "### 22. The fee recipient accounts cannot be changed in the Stream Pool contract\n\n| Severity: Informational                     | Diffi culty: Undetermined |  |\n|------------------------------------------------|---------------------------------|--|\n| Type: Access Controls                    | Finding ID: TOB-PXL-22    |  |\n| contracts/pixelswap_streampool.tact Target: |                                 |  |\n\n#### Description\n\nThe creation\\_fee\\_recipient and protocol\\_fee\\_recipient addresses are set once in the PixelswapStreamPool contract constructor and cannot be changed.\n\nIf, for some reason, access to those accounts is lost or compromised, the protocol will continue to send funds to them, increasing the financial damage over time and making it impossible for the team to recover funds.\n\nMoreover, the protocol\\_fee\\_recipient account is not used in the PixelswapStreamPool contract.\n\n#### Recommendations\n\nShort term, consider having a privileged method to change these fee recipients.\n\nLong term, determine if these accounts will be used, what security measures will be in place for setting and changing their values, and under what circumstances the change should be made.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe creation\\_fee\\_recipient and protocol\\_fee\\_recipient addresses are set once in the PixelswapStreamPool contract constructor and cannot be changed.\n\nIf, for some reason, access to those accounts is lost or compromised, the protocol will continue to send funds to them, increasing the financial damage over time and making it impossible for the team to recover funds.\n\nMoreover, the protocol\\_fee\\_recipient account is not used in the PixelswapStreamPool contract.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Undetermined",
        "Type": "Access Controls",
        "Finding ID": "TOB-PXL-22",
        "Target": "contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "The fee recipient accounts cannot be changed in the Stream Pool contract"
    },
    {
      "index": 23,
      "page_start": 52,
      "heading": "23. The gas checks in the PixelswapStreamPool contract are wrongly placed",
      "markdown": "# 23. The gas checks in the PixelswapStreamPool contract are wrongly placed\n\n| Severity: Informational                     | Diffi culty: High      |  |\n|------------------------------------------------|------------------------------|--|\n| Type: Data Validation                    | Finding ID: TOB-PXL-23 |  |\n| Target: contracts/pixelswap_streampool.tact |                              |  |\n\n#### Description\n\nThe gas checks in the PlaceOrder message receiver of the PixelswapStreamPool contract are placed after the pair\\_status update. This can lead to loss of funds for user and pair reserves and balances going out of sync.\n\nThe PlaceOrder message receiver of the PixelswapStreamPool contract adds two gas checks. It adds one at the end of the process\\_order internal function:\n\n#### **[Redacted]**\n\nIt adds another at the end of the receiver function:\n\n#### **[Redacted]**\n\nHowever, the process\\_order function updates the pair reserves in the pair\\_status map for the specified pair\\_id before these gas checks. If, for some reason, these gas checks fail, then it can have the following effect:\n\n- If the gas check in the receiver function fails, then the PlaceOrder message will be sent back to the settlement contract and will add the input tokens back to the user's funding wallet balance.\n- If the gas check in the process\\_order function fails while processing a nested PlaceOrder message, then only the current PlaceOrder and its nested PlaceOrder messages are returned to the settlement contract. This adds input tokens to the user's funding wallet balance only for these orders instead of all of the orders. The user also loses the output token of swaps for successfully executed PlaceOrder messages.\n- In every case, the reserves of the specified pair and token balances of the settlement contract go out of sync, resulting in an unstable system state.\n\nCurrently, the gas checks in the PixelswapFundingWallet and PixelswapSettlement contracts ensure that the gas checks in the PixelswapStreamPool contract do not fail. However, future updates to the codebase could introduce a path to fail these gas checks.\n\n\n\n#### Recommendations\n\nShort term, place the above-mentioned gas checks before calls to the state-modifying functions to ensure the correct state in case of gas check failure.\n\nLong term, document the system state specification with user actions and their effect on the system state to identify potential issues arising from complex user interactions.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": "#### Description\n\nThe gas checks in the PlaceOrder message receiver of the PixelswapStreamPool contract are placed after the pair\\_status update. This can lead to loss of funds for user and pair reserves and balances going out of sync.\n\nThe PlaceOrder message receiver of the PixelswapStreamPool contract adds two gas checks. It adds one at the end of the process\\_order internal function:\n\n#### **[Redacted]**\n\nIt adds another at the end of the receiver function:\n\n#### **[Redacted]**\n\nHowever, the process\\_order function updates the pair reserves in the pair\\_status map for the specified pair\\_id before these gas checks. If, for some reason, these gas checks fail, then it can have the following effect:\n\n- If the gas check in the receiver function fails, then the PlaceOrder message will be sent back to the settlement contract and will add the input tokens back to the user's funding wallet balance.\n- If the gas check in the process\\_order function fails while processing a nested PlaceOrder message, then only the current PlaceOrder and its nested PlaceOrder messages are returned to the settlement contract. This adds input tokens to the user's funding wallet balance only for these orders instead of all of the orders. The user also loses the output token of swaps for successfully executed PlaceOrder messages.\n- In every case, the reserves of the specified pair and token balances of the settlement contract go out of sync, resulting in an unstable system state.\n\nCurrently, the gas checks in the PixelswapFundingWallet and PixelswapSettlement contracts ensure that the gas checks in the PixelswapStreamPool contract do not fail. However, future updates to the codebase could introduce a path to fail these gas checks.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "High",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-23",
        "Target": "contracts/pixelswap_streampool.tact"
      },
      "heading_cleaned": "The gas checks in the PixelswapStreamPool contract are wrongly placed"
    },
    {
      "index": 24,
      "page_start": 54,
      "heading": "24. Users cannot deposit only Jetton to their funding wallet",
      "markdown": "| 24. Users cannot deposit only Jetton to their funding wallet |                              |  |\n|-----------------------------------------------------------------------------------------|------------------------------|--|\n| Severity: Informational                                                              | Diffi culty: Low       |  |\n| Type: Data Validation                                                             | Finding ID: TOB-PXL-24 |  |\n| contracts/pixelswap_settlement.tact Target:                                          |                              |  |\n\nThe gas check in the OrderJettonNotification handler of the PixelswapSettlement contract ensures that the TON sent by the user is more than the value of the gas\\_check\\_jetton\\_notification parameter, which is 500 millitons, and that the ton\\_amt is calculated by subtracting the gas\\_for\\_incoming\\_jetton\\_transfer value, which is 400 millitons, from the message value.\n\nBecause of this, the user needs to deposit at least 100 millitons of TON along with any Jetton deposit, and there is no way for a user to deposit only Jetton to their funding wallet.\n\n#### **[Redacted]**\n\nDescription\n\n### Recommendations\n\nShort term, accept the TON amount to deposit as a message parameter instead of calculating it in the contract, and return the excess TON sent as the message value.\n\nLong term, implement test cases for all real-life use cases to ensure expected behavior from the smart contracts.\n\n#### **Fix Review Status**\n",
      "finding_id": null,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": "Low",
        "Type": "Data Validation",
        "Finding ID": "TOB-PXL-24",
        "Target": "contracts/pixelswap_settlement.tact"
      },
      "heading_cleaned": "Users cannot deposit only Jetton to their funding wallet"
    }
  ]
}