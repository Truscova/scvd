{
  "doc_id": "cyfrin_2024-05-04-cyfrin-solidly-v2-memecore-v2-2",
  "source_pdf": "2024-05-04-cyfrin-solidly-v2-memecore-v2-2.md",
  "source_mtime": "2025-11-01T12:04:59+00:00",
  "extracted_at": "2025-11-16T22:12:10.165630+00:00",
  "extractor_version": "poc-0.4-md-no-llm",
  "repositories": [
    {
      "url": "https://github.com/SolidlyLabs/v2-core",
      "org": "SolidlyLabs",
      "repo": "v2-core",
      "commit": "757b18ad05780d2af22018b0c2c9d59422dc59d3",
      "evidence": {
        "page": null,
        "snippet": "**Description:** Due to a silent overflow in [`SolidityV2ERC42069::lockToken`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L38..."
      }
    },
    {
      "url": "https://github.com/SolidlyLabs/v2-core",
      "org": "SolidlyLabs",
      "repo": "v2-core",
      "commit": "14533e758f42009ca1d2cf4e98e2e7f33bcd4538",
      "evidence": {
        "page": null,
        "snippet": "**Solidly Labs:** Fixed in commit [14533e7](https://github.com/SolidlyLabs/v2-core/tree/14533e758f42009ca1d2cf4e98e2e7f33bcd4538)."
      }
    },
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts",
      "org": "OpenZeppelin",
      "repo": "openzeppelin-contracts",
      "commit": null,
      "evidence": {
        "page": null,
        "snippet": "**Recommended Mitigation:** Consider implementing a two-step ownership transfer where `owner` first sets a `pendingOwner` then the `pendingOwner` can accept the new ownership , like OpenZeppelin [`Own..."
      }
    },
    {
      "url": "https://github.com/transmissions11/solmate",
      "org": "transmissions11",
      "repo": "solmate",
      "commit": "c892309933b25c03d32b1b0d674df7ae292ba925",
      "evidence": {
        "page": null,
        "snippet": "For greater gas efficiency, it is recommended that the current chain ID be cached on contract creation and that the domain separator be recomputed only if a change of chain ID is detected (i.e., ` blo..."
      }
    }
  ],
  "report_schema": [
    {
      "key": "Severity",
      "meaning": "How serious the impact of this finding is.",
      "expected_values": "Informational / Low / Medium / High"
    },
    {
      "key": "Difficulty",
      "meaning": "How hard it is to exploit this vulnerability.",
      "expected_values": "Low / Medium / High"
    },
    {
      "key": "Type",
      "meaning": "The category or nature of the vulnerability.",
      "expected_values": "String describing the type of vulnerability (e.g., Data Validation, Reentrancy)"
    },
    {
      "key": "Finding ID",
      "meaning": "A unique identifier for the specific finding.",
      "expected_values": "String with a consistent format (e.g., TOB-ELA-1)"
    },
    {
      "key": "Target",
      "meaning": "The location of the vulnerability in the codebase.",
      "expected_values": "Path to affected file / contract"
    }
  ],
  "vulnerability_sections": [
    {
      "index": 1,
      "page_start": null,
      "heading": "1. Locks can be created with expiry in the past",
      "markdown": "### Locks can be created with expiry in the past\n\n**Description:** Due to a silent overflow in [`SolidityV2ERC42069::lockToken`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L387), a sufficiently large duration will cause the unlock date to be in the past. This could allow the caller to create a fraudulent lock, advertising that they have locked for the maximum duration but which can actually be withdrawn immediately. However, the impact is somewhat limited as this will be visible to anyone who calls [`SolidityV2ERC42069::getLock(s)`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L459-L471) with the owner's address (perhaps in a UI). From the attacker's perspective, the extension functionality could ideally be used to wrap around at will, hiding this malicious intent; however, this is not possible due to the checked math revert when incrementing the date.\n\n**Impact:** This bug has a high likelihood of being abused with a more limited impact; therefore, it is categorized as a medium-severity finding.\n\n**Proof of Concept:** Append this test to `MultiTest.js`:\n```javascript\nit(\"lock can be created in the past\", async function () {\n  const { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  let token0 = test0;\n  let token1 = test1;\n\n  // Approve tokens for liquidity provision\n  await token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n  await token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n  // Provide liquidity\n  await router.connect(user1).addLiquidity(\n    token0.address,\n    token1.address,\n    ethers.utils.parseUnits(\"100\", 18),\n    ethers.utils.parseUnits(\"100\", 18),\n    0,\n    0,\n    user1.address,\n    ethers.constants.MaxUint256\n  );\n\n  const liquidityBalance = await pair.balanceOf(user1.address);\n\n  let blockTimestamp = (await ethers.provider.getBlock('latest')).timestamp;\n\n  let maxUint128 = ethers.BigNumber.from(\"340282366920938463463374607431768211455\");\n\n  // Lock LP tokens\n  await pair.connect(user1).lockToken(user1.address, liquidityBalance, maxUint128.sub(blockTimestamp));\n\n\n  let ret = await pair.getLock(user1.address, 0);\n  expect(ret.date).to.be.eq(0);\n});\n  ```\n**Recommended Mitigation:** Cast the timestamp to `uint128` prior to performing the addition rather than unsafely downcasting the result of the addition:\n\n```diff\nlocks[from].push(LockData({\n    amount: uint128(amount - fee),\n-     date: uint128(block.timestamp + duration)\n+     date: uint128(block.timestamp) + duration\n}));\n```\n\n**Solidly Labs:** Fixed in commit [14533e7](https://github.com/SolidlyLabs/v2-core/tree/14533e758f42009ca1d2cf4e98e2e7f33bcd4538).\n\n**Cyfrin:** Verified. The timestamp is first cast to `uint128` prior to performing the addition.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 15,
      "end_line": 74,
      "markdown_raw": "### Locks can be created with expiry in the past\n\n**Description:** Due to a silent overflow in [`SolidityV2ERC42069::lockToken`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L387), a sufficiently large duration will cause the unlock date to be in the past. This could allow the caller to create a fraudulent lock, advertising that they have locked for the maximum duration but which can actually be withdrawn immediately. However, the impact is somewhat limited as this will be visible to anyone who calls [`SolidityV2ERC42069::getLock(s)`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L459-L471) with the owner's address (perhaps in a UI). From the attacker's perspective, the extension functionality could ideally be used to wrap around at will, hiding this malicious intent; however, this is not possible due to the checked math revert when incrementing the date.\n\n**Impact:** This bug has a high likelihood of being abused with a more limited impact; therefore, it is categorized as a medium-severity finding.\n\n**Proof of Concept:** Append this test to `MultiTest.js`:\n```javascript\nit(\"lock can be created in the past\", async function () {\n  const { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  let token0 = test0;\n  let token1 = test1;\n\n  // Approve tokens for liquidity provision\n  await token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n  await token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n  // Provide liquidity\n  await router.connect(user1).addLiquidity(\n    token0.address,\n    token1.address,\n    ethers.utils.parseUnits(\"100\", 18),\n    ethers.utils.parseUnits(\"100\", 18),\n    0,\n    0,\n    user1.address,\n    ethers.constants.MaxUint256\n  );\n\n  const liquidityBalance = await pair.balanceOf(user1.address);\n\n  let blockTimestamp = (await ethers.provider.getBlock('latest')).timestamp;\n\n  let maxUint128 = ethers.BigNumber.from(\"340282366920938463463374607431768211455\");\n\n  // Lock LP tokens\n  await pair.connect(user1).lockToken(user1.address, liquidityBalance, maxUint128.sub(blockTimestamp));\n\n\n  let ret = await pair.getLock(user1.address, 0);\n  expect(ret.date).to.be.eq(0);\n});\n  ```\n**Recommended Mitigation:** Cast the timestamp to `uint128` prior to performing the addition rather than unsafely downcasting the result of the addition:\n\n```diff\nlocks[from].push(LockData({\n    amount: uint128(amount - fee),\n-     date: uint128(block.timestamp + duration)\n+     date: uint128(block.timestamp) + duration\n}));\n```\n\n**Solidly Labs:** Fixed in commit [14533e7](https://github.com/SolidlyLabs/v2-core/tree/14533e758f42009ca1d2cf4e98e2e7f33bcd4538).\n\n**Cyfrin:** Verified. The timestamp is first cast to `uint128` prior to performing the addition.\n\n\\clearpage\n",
      "sections": {
        "description": "**Description:** Due to a silent overflow in [`SolidityV2ERC42069::lockToken`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L387), a sufficiently large duration will cause the unlock date to be in the past. This could allow the caller to create a fraudulent lock, advertising that they have locked for the maximum duration but which can actually be withdrawn immediately. However, the impact is somewhat limited as this will be visible to anyone who calls [`SolidityV2ERC42069::getLock(s)`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L459-L471) with the owner's address (perhaps in a UI). From the attacker's perspective, the extension functionality could ideally be used to wrap around at will, hiding this malicious intent; however, this is not possible due to the checked math revert when incrementing the date.\n",
        "impact": "**Impact:** This bug has a high likelihood of being abused with a more limited impact; therefore, it is categorized as a medium-severity finding.\n",
        "recommendation": "**Recommended Mitigation:** Cast the timestamp to `uint128` prior to performing the addition rather than unsafely downcasting the result of the addition:\n\n```diff\nlocks[from].push(LockData({\n    amount: uint128(amount - fee),\n-     date: uint128(block.timestamp + duration)\n+     date: uint128(block.timestamp) + duration\n}));\n```\n",
        "poc": "**Proof of Concept:** Append this test to `MultiTest.js`:\n```javascript\nit(\"lock can be created in the past\", async function () {\n  const { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  let token0 = test0;\n  let token1 = test1;\n\n  // Approve tokens for liquidity provision\n  await token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n  await token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n  // Provide liquidity\n  await router.connect(user1).addLiquidity(\n    token0.address,\n    token1.address,\n    ethers.utils.parseUnits(\"100\", 18),\n    ethers.utils.parseUnits(\"100\", 18),\n    0,\n    0,\n    user1.address,\n    ethers.constants.MaxUint256\n  );\n\n  const liquidityBalance = await pair.balanceOf(user1.address);\n\n  let blockTimestamp = (await ethers.provider.getBlock('latest')).timestamp;\n\n  let maxUint128 = ethers.BigNumber.from(\"340282366920938463463374607431768211455\");\n\n  // Lock LP tokens\n  await pair.connect(user1).lockToken(user1.address, liquidityBalance, maxUint128.sub(blockTimestamp));\n\n\n  let ret = await pair.getLock(user1.address, 0);\n  expect(ret.date).to.be.eq(0);\n});\n  ```\n",
        "fix_status": null,
        "other": "**Solidly Labs:** Fixed in commit [14533e7](https://github.com/SolidlyLabs/v2-core/tree/14533e758f42009ca1d2cf4e98e2e7f33bcd4538).\n\n**Cyfrin:** Verified. The timestamp is first cast to `uint128` prior to performing the addition.\n\n\\clearpage\n"
      },
      "description": "**Description:** Due to a silent overflow in [`SolidityV2ERC42069::lockToken`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L387), a sufficiently large duration will cause the unlock date to be in the past. This could allow the caller to create a fraudulent lock, advertising that they have locked for the maximum duration but which can actually be withdrawn immediately. However, the impact is somewhat limited as this will be visible to anyone who calls [`SolidityV2ERC42069::getLock(s)`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L459-L471) with the owner's address (perhaps in a UI). From the attacker's perspective, the extension functionality could ideally be used to wrap around at will, hiding this malicious intent; however, this is not possible due to the checked math revert when incrementing the date.\n",
      "markdown_body": "**Description:** Due to a silent overflow in [`SolidityV2ERC42069::lockToken`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L387), a sufficiently large duration will cause the unlock date to be in the past. This could allow the caller to create a fraudulent lock, advertising that they have locked for the maximum duration but which can actually be withdrawn immediately. However, the impact is somewhat limited as this will be visible to anyone who calls [`SolidityV2ERC42069::getLock(s)`](https://github.com/SolidlyLabs/v2-core/blob/757b18ad05780d2af22018b0c2c9d59422dc59d3/contracts/SolidlyV2-memecore.sol#L459-L471) with the owner's address (perhaps in a UI). From the attacker's perspective, the extension functionality could ideally be used to wrap around at will, hiding this malicious intent; however, this is not possible due to the checked math revert when incrementing the date.\n\n**Impact:** This bug has a high likelihood of being abused with a more limited impact; therefore, it is categorized as a medium-severity finding.\n\n**Proof of Concept:** Append this test to `MultiTest.js`:\n```javascript\nit(\"lock can be created in the past\", async function () {\n  const { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  let token0 = test0;\n  let token1 = test1;\n\n  // Approve tokens for liquidity provision\n  await token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n  await token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n  // Provide liquidity\n  await router.connect(user1).addLiquidity(\n    token0.address,\n    token1.address,\n    ethers.utils.parseUnits(\"100\", 18),\n    ethers.utils.parseUnits(\"100\", 18),\n    0,\n    0,\n    user1.address,\n    ethers.constants.MaxUint256\n  );\n\n  const liquidityBalance = await pair.balanceOf(user1.address);\n\n  let blockTimestamp = (await ethers.provider.getBlock('latest')).timestamp;\n\n  let maxUint128 = ethers.BigNumber.from(\"340282366920938463463374607431768211455\");\n\n  // Lock LP tokens\n  await pair.connect(user1).lockToken(user1.address, liquidityBalance, maxUint128.sub(blockTimestamp));\n\n\n  let ret = await pair.getLock(user1.address, 0);\n  expect(ret.date).to.be.eq(0);\n});\n  ```\n**Recommended Mitigation:** Cast the timestamp to `uint128` prior to performing the addition rather than unsafely downcasting the result of the addition:\n\n```diff\nlocks[from].push(LockData({\n    amount: uint128(amount - fee),\n-     date: uint128(block.timestamp + duration)\n+     date: uint128(block.timestamp) + duration\n}));\n```\n\n**Solidly Labs:** Fixed in commit [14533e7](https://github.com/SolidlyLabs/v2-core/tree/14533e758f42009ca1d2cf4e98e2e7f33bcd4538).\n\n**Cyfrin:** Verified. The timestamp is first cast to `uint128` prior to performing the addition.\n\n\\clearpage\n",
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Locks can be created with expiry in the past"
    },
    {
      "index": 2,
      "page_start": null,
      "heading": "2. Accounts blocked by the token cannot claim their fees",
      "markdown": "### Accounts blocked by the token cannot claim their fees\n\n**Description:** In `SolidlyV2`, liquidity providers accrue fees from trades made in the pool. These fees are bound to the account holding the liquidity position at the time of trading as the fees are synced on transfers.\n\nWhen the liquidity provider wants to claim their fees they call `SolidlyV2Pair::claimFees`:\n```solidity\nif (feeState.feeOwed0 > 1) {\n    amount0 = feeState.feeOwed0 - 1;\n    _safeTransfer(token0, msg.sender, uint256(amount0));\n    feesClaimedLP0 += amount0;\n    feesClaimedTotal0 += amount0;\n    feeState.feeOwed0 = 1;\n}\n```\nHere the tokens are transferred to `msg.sender`.\n\nThe issue is that some tokens, such as `USDC`, have block lists where some accounts are blocked from receiving or doing transfers. Were this to happen to `msg.sender`, they would never be able to claim their fees, and these funds would be locked in the pool indefinitely.\n\n**Impact:** If an account is blocked by, for example, `USDC,` the user will not be able to claim their fees.\n\n**Recommended Mitigation:** Add a parameter `address to` to `SolidlyV2Pair::claimFees` so that the fees can be transferred to a different account.\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 77,
      "end_line": 104,
      "markdown_raw": "### Accounts blocked by the token cannot claim their fees\n\n**Description:** In `SolidlyV2`, liquidity providers accrue fees from trades made in the pool. These fees are bound to the account holding the liquidity position at the time of trading as the fees are synced on transfers.\n\nWhen the liquidity provider wants to claim their fees they call `SolidlyV2Pair::claimFees`:\n```solidity\nif (feeState.feeOwed0 > 1) {\n    amount0 = feeState.feeOwed0 - 1;\n    _safeTransfer(token0, msg.sender, uint256(amount0));\n    feesClaimedLP0 += amount0;\n    feesClaimedTotal0 += amount0;\n    feeState.feeOwed0 = 1;\n}\n```\nHere the tokens are transferred to `msg.sender`.\n\nThe issue is that some tokens, such as `USDC`, have block lists where some accounts are blocked from receiving or doing transfers. Were this to happen to `msg.sender`, they would never be able to claim their fees, and these funds would be locked in the pool indefinitely.\n\n**Impact:** If an account is blocked by, for example, `USDC,` the user will not be able to claim their fees.\n\n**Recommended Mitigation:** Add a parameter `address to` to `SolidlyV2Pair::claimFees` so that the fees can be transferred to a different account.\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "sections": {
        "description": "**Description:** In `SolidlyV2`, liquidity providers accrue fees from trades made in the pool. These fees are bound to the account holding the liquidity position at the time of trading as the fees are synced on transfers.\n\nWhen the liquidity provider wants to claim their fees they call `SolidlyV2Pair::claimFees`:\n```solidity\nif (feeState.feeOwed0 > 1) {\n    amount0 = feeState.feeOwed0 - 1;\n    _safeTransfer(token0, msg.sender, uint256(amount0));\n    feesClaimedLP0 += amount0;\n    feesClaimedTotal0 += amount0;\n    feeState.feeOwed0 = 1;\n}\n```\nHere the tokens are transferred to `msg.sender`.\n\nThe issue is that some tokens, such as `USDC`, have block lists where some accounts are blocked from receiving or doing transfers. Were this to happen to `msg.sender`, they would never be able to claim their fees, and these funds would be locked in the pool indefinitely.\n",
        "impact": "**Impact:** If an account is blocked by, for example, `USDC,` the user will not be able to claim their fees.\n",
        "recommendation": "**Recommended Mitigation:** Add a parameter `address to` to `SolidlyV2Pair::claimFees` so that the fees can be transferred to a different account.\n",
        "poc": null,
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n"
      },
      "description": "**Description:** In `SolidlyV2`, liquidity providers accrue fees from trades made in the pool. These fees are bound to the account holding the liquidity position at the time of trading as the fees are synced on transfers.\n\nWhen the liquidity provider wants to claim their fees they call `SolidlyV2Pair::claimFees`:\n```solidity\nif (feeState.feeOwed0 > 1) {\n    amount0 = feeState.feeOwed0 - 1;\n    _safeTransfer(token0, msg.sender, uint256(amount0));\n    feesClaimedLP0 += amount0;\n    feesClaimedTotal0 += amount0;\n    feeState.feeOwed0 = 1;\n}\n```\nHere the tokens are transferred to `msg.sender`.\n\nThe issue is that some tokens, such as `USDC`, have block lists where some accounts are blocked from receiving or doing transfers. Were this to happen to `msg.sender`, they would never be able to claim their fees, and these funds would be locked in the pool indefinitely.\n",
      "markdown_body": "**Description:** In `SolidlyV2`, liquidity providers accrue fees from trades made in the pool. These fees are bound to the account holding the liquidity position at the time of trading as the fees are synced on transfers.\n\nWhen the liquidity provider wants to claim their fees they call `SolidlyV2Pair::claimFees`:\n```solidity\nif (feeState.feeOwed0 > 1) {\n    amount0 = feeState.feeOwed0 - 1;\n    _safeTransfer(token0, msg.sender, uint256(amount0));\n    feesClaimedLP0 += amount0;\n    feesClaimedTotal0 += amount0;\n    feeState.feeOwed0 = 1;\n}\n```\nHere the tokens are transferred to `msg.sender`.\n\nThe issue is that some tokens, such as `USDC`, have block lists where some accounts are blocked from receiving or doing transfers. Were this to happen to `msg.sender`, they would never be able to claim their fees, and these funds would be locked in the pool indefinitely.\n\n**Impact:** If an account is blocked by, for example, `USDC,` the user will not be able to claim their fees.\n\n**Recommended Mitigation:** Add a parameter `address to` to `SolidlyV2Pair::claimFees` so that the fees can be transferred to a different account.\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Accounts blocked by the token cannot claim their fees"
    },
    {
      "index": 3,
      "page_start": null,
      "heading": "3. Consider a two-step ownership transfer",
      "markdown": "### Consider a two-step ownership transfer\n\n**Description:** In the `SolidtlyV2-memecore` contracts the owner is set as `msg.sender` in `SolidlyV2Factory` when deployed.\n\nIt can also be changed using `SolidlyV2Factory::setOwner`:\n```solidity\n    function setOwner(address _newOwner) external {\n        require(msg.sender == owner);\n        owner = _newOwner;\n    }\n```\n\nHere there's a risk that the owner is lost if the new address not correct. This would result in some functionality not being available, like assigning new copilots and adjusting fees.\n\n**Impact:** The `owner` can mistakenly be given to an account that is out of the protocol's control.\n\n**Recommended Mitigation:** Consider implementing a two-step ownership transfer where `owner` first sets a `pendingOwner` then the `pendingOwner` can accept the new ownership , like OpenZeppelin [`Ownable2Step`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 104,
      "end_line": 127,
      "markdown_raw": "### Consider a two-step ownership transfer\n\n**Description:** In the `SolidtlyV2-memecore` contracts the owner is set as `msg.sender` in `SolidlyV2Factory` when deployed.\n\nIt can also be changed using `SolidlyV2Factory::setOwner`:\n```solidity\n    function setOwner(address _newOwner) external {\n        require(msg.sender == owner);\n        owner = _newOwner;\n    }\n```\n\nHere there's a risk that the owner is lost if the new address not correct. This would result in some functionality not being available, like assigning new copilots and adjusting fees.\n\n**Impact:** The `owner` can mistakenly be given to an account that is out of the protocol's control.\n\n**Recommended Mitigation:** Consider implementing a two-step ownership transfer where `owner` first sets a `pendingOwner` then the `pendingOwner` can accept the new ownership , like OpenZeppelin [`Ownable2Step`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "sections": {
        "description": "**Description:** In the `SolidtlyV2-memecore` contracts the owner is set as `msg.sender` in `SolidlyV2Factory` when deployed.\n\nIt can also be changed using `SolidlyV2Factory::setOwner`:\n```solidity\n    function setOwner(address _newOwner) external {\n        require(msg.sender == owner);\n        owner = _newOwner;\n    }\n```\n\nHere there's a risk that the owner is lost if the new address not correct. This would result in some functionality not being available, like assigning new copilots and adjusting fees.\n",
        "impact": "**Impact:** The `owner` can mistakenly be given to an account that is out of the protocol's control.\n",
        "recommendation": "**Recommended Mitigation:** Consider implementing a two-step ownership transfer where `owner` first sets a `pendingOwner` then the `pendingOwner` can accept the new ownership , like OpenZeppelin [`Ownable2Step`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)\n",
        "poc": null,
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n"
      },
      "description": "**Description:** In the `SolidtlyV2-memecore` contracts the owner is set as `msg.sender` in `SolidlyV2Factory` when deployed.\n\nIt can also be changed using `SolidlyV2Factory::setOwner`:\n```solidity\n    function setOwner(address _newOwner) external {\n        require(msg.sender == owner);\n        owner = _newOwner;\n    }\n```\n\nHere there's a risk that the owner is lost if the new address not correct. This would result in some functionality not being available, like assigning new copilots and adjusting fees.\n",
      "markdown_body": "**Description:** In the `SolidtlyV2-memecore` contracts the owner is set as `msg.sender` in `SolidlyV2Factory` when deployed.\n\nIt can also be changed using `SolidlyV2Factory::setOwner`:\n```solidity\n    function setOwner(address _newOwner) external {\n        require(msg.sender == owner);\n        owner = _newOwner;\n    }\n```\n\nHere there's a risk that the owner is lost if the new address not correct. This would result in some functionality not being available, like assigning new copilots and adjusting fees.\n\n**Impact:** The `owner` can mistakenly be given to an account that is out of the protocol's control.\n\n**Recommended Mitigation:** Consider implementing a two-step ownership transfer where `owner` first sets a `pendingOwner` then the `pendingOwner` can accept the new ownership , like OpenZeppelin [`Ownable2Step`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Consider a two-step ownership transfer"
    },
    {
      "index": 4,
      "page_start": null,
      "heading": "4. SolidlyV2Pair::setPoolFee fails to adequately consider fee setters defined by SolidlyV2Factory",
      "markdown": "### `SolidlyV2Pair::setPoolFee` fails to adequately consider fee setters defined by `SolidlyV2Factory`\n\n**Description:** If a new `feeSetter` is registered by the owner of `SolidlyV2Factory`, then it is possible for the pool fee to be set below the minimum specified by the factory. This breaks the invariant that the pool fee should always be between the defined min/max values since it is only possible for the protocol to influence this value by explicitly modifying it on the factory itself, whereas a fee setter can modify it on the pool directly to become out of sync with the factory.\n\n```solidity\nfunction setPoolFee(uint16 _poolFee) external {\n    require(ISolidlyV2Factory(factory).isFeeSetter(msg.sender) || msg.sender == copilot, 'UA');\n    if (msg.sender == copilot) {\n        require(_poolFee >= ISolidlyV2Factory(factory).minFee() && !copilotRevoked); // minimum fee enforced for copilot\n    } else {\n        require(!protocolRevoked);\n    }\n    require(_poolFee <= 1000); // pool fee capped at 10%\n    uint16 feeOld = poolFee;\n    poolFee = _poolFee;\n    emit SetPoolFee(feeOld, _poolFee);\n}\n```\n\nAdditionally, if the owner of `SolidlyV2Factory` calls `SolidlyV2Pair::revokeFeeRole`, then registered fee setters are no longer able to call `SolidlyV2Pair::setPoolFee` despite no explicit consideration of fee setters.\n\n**Impact:**\n- The pool fee can become out of sync with `SolidlyV2Factory::minFee`.\n- Fee setters cannot set fees once the protocol has revoked its fee role.\n\n**Proof of Concept:**\n```javascript\nit(\"fee below min\", async function () {\n  const { user1, factory, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  await factory.setFeeSetter(user1.address, true);\n  pair.connect(user1).setPoolFee(0);\n  await factory.minFee().then(minFee => console.log(`SolidlyV2Factory::minFee: ${minFee}`));\n  await pair.poolFee().then(poolFee => console.log(`SolidlyV2Pair::poolFee: ${poolFee}`));\n\n  await pair.revokeFeeRole();\n  const minFee = await factory.minFee();\n  await expect(pair.connect(user1).setPoolFee(minFee)).to.revertedWithoutReason();\n});\n```\n\n**Recommended Mitigation:** Explicitly handle calls from fee setters as distinct from the factory owner in `SolidlyV2Pair::setPoolFee`, also enforcing that the pool fee cannot be set below the defined global minimum.\n\n**Solidly Labs:** Acknowledged. Both these things are like this by design – `feeSetters` are not constrained by `minFee`, and both protocol and `feeSetter` are considered the same for revoke.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 127,
      "end_line": 175,
      "markdown_raw": "### `SolidlyV2Pair::setPoolFee` fails to adequately consider fee setters defined by `SolidlyV2Factory`\n\n**Description:** If a new `feeSetter` is registered by the owner of `SolidlyV2Factory`, then it is possible for the pool fee to be set below the minimum specified by the factory. This breaks the invariant that the pool fee should always be between the defined min/max values since it is only possible for the protocol to influence this value by explicitly modifying it on the factory itself, whereas a fee setter can modify it on the pool directly to become out of sync with the factory.\n\n```solidity\nfunction setPoolFee(uint16 _poolFee) external {\n    require(ISolidlyV2Factory(factory).isFeeSetter(msg.sender) || msg.sender == copilot, 'UA');\n    if (msg.sender == copilot) {\n        require(_poolFee >= ISolidlyV2Factory(factory).minFee() && !copilotRevoked); // minimum fee enforced for copilot\n    } else {\n        require(!protocolRevoked);\n    }\n    require(_poolFee <= 1000); // pool fee capped at 10%\n    uint16 feeOld = poolFee;\n    poolFee = _poolFee;\n    emit SetPoolFee(feeOld, _poolFee);\n}\n```\n\nAdditionally, if the owner of `SolidlyV2Factory` calls `SolidlyV2Pair::revokeFeeRole`, then registered fee setters are no longer able to call `SolidlyV2Pair::setPoolFee` despite no explicit consideration of fee setters.\n\n**Impact:**\n- The pool fee can become out of sync with `SolidlyV2Factory::minFee`.\n- Fee setters cannot set fees once the protocol has revoked its fee role.\n\n**Proof of Concept:**\n```javascript\nit(\"fee below min\", async function () {\n  const { user1, factory, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  await factory.setFeeSetter(user1.address, true);\n  pair.connect(user1).setPoolFee(0);\n  await factory.minFee().then(minFee => console.log(`SolidlyV2Factory::minFee: ${minFee}`));\n  await pair.poolFee().then(poolFee => console.log(`SolidlyV2Pair::poolFee: ${poolFee}`));\n\n  await pair.revokeFeeRole();\n  const minFee = await factory.minFee();\n  await expect(pair.connect(user1).setPoolFee(minFee)).to.revertedWithoutReason();\n});\n```\n\n**Recommended Mitigation:** Explicitly handle calls from fee setters as distinct from the factory owner in `SolidlyV2Pair::setPoolFee`, also enforcing that the pool fee cannot be set below the defined global minimum.\n\n**Solidly Labs:** Acknowledged. Both these things are like this by design – `feeSetters` are not constrained by `minFee`, and both protocol and `feeSetter` are considered the same for revoke.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n",
      "sections": {
        "description": "**Description:** If a new `feeSetter` is registered by the owner of `SolidlyV2Factory`, then it is possible for the pool fee to be set below the minimum specified by the factory. This breaks the invariant that the pool fee should always be between the defined min/max values since it is only possible for the protocol to influence this value by explicitly modifying it on the factory itself, whereas a fee setter can modify it on the pool directly to become out of sync with the factory.\n\n```solidity\nfunction setPoolFee(uint16 _poolFee) external {\n    require(ISolidlyV2Factory(factory).isFeeSetter(msg.sender) || msg.sender == copilot, 'UA');\n    if (msg.sender == copilot) {\n        require(_poolFee >= ISolidlyV2Factory(factory).minFee() && !copilotRevoked); // minimum fee enforced for copilot\n    } else {\n        require(!protocolRevoked);\n    }\n    require(_poolFee <= 1000); // pool fee capped at 10%\n    uint16 feeOld = poolFee;\n    poolFee = _poolFee;\n    emit SetPoolFee(feeOld, _poolFee);\n}\n```\n\nAdditionally, if the owner of `SolidlyV2Factory` calls `SolidlyV2Pair::revokeFeeRole`, then registered fee setters are no longer able to call `SolidlyV2Pair::setPoolFee` despite no explicit consideration of fee setters.\n",
        "impact": "**Impact:**\n- The pool fee can become out of sync with `SolidlyV2Factory::minFee`.\n- Fee setters cannot set fees once the protocol has revoked its fee role.\n",
        "recommendation": "**Recommended Mitigation:** Explicitly handle calls from fee setters as distinct from the factory owner in `SolidlyV2Pair::setPoolFee`, also enforcing that the pool fee cannot be set below the defined global minimum.\n",
        "poc": "**Proof of Concept:**\n```javascript\nit(\"fee below min\", async function () {\n  const { user1, factory, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  await factory.setFeeSetter(user1.address, true);\n  pair.connect(user1).setPoolFee(0);\n  await factory.minFee().then(minFee => console.log(`SolidlyV2Factory::minFee: ${minFee}`));\n  await pair.poolFee().then(poolFee => console.log(`SolidlyV2Pair::poolFee: ${poolFee}`));\n\n  await pair.revokeFeeRole();\n  const minFee = await factory.minFee();\n  await expect(pair.connect(user1).setPoolFee(minFee)).to.revertedWithoutReason();\n});\n```\n",
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged. Both these things are like this by design – `feeSetters` are not constrained by `minFee`, and both protocol and `feeSetter` are considered the same for revoke.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n"
      },
      "description": "**Description:** If a new `feeSetter` is registered by the owner of `SolidlyV2Factory`, then it is possible for the pool fee to be set below the minimum specified by the factory. This breaks the invariant that the pool fee should always be between the defined min/max values since it is only possible for the protocol to influence this value by explicitly modifying it on the factory itself, whereas a fee setter can modify it on the pool directly to become out of sync with the factory.\n\n```solidity\nfunction setPoolFee(uint16 _poolFee) external {\n    require(ISolidlyV2Factory(factory).isFeeSetter(msg.sender) || msg.sender == copilot, 'UA');\n    if (msg.sender == copilot) {\n        require(_poolFee >= ISolidlyV2Factory(factory).minFee() && !copilotRevoked); // minimum fee enforced for copilot\n    } else {\n        require(!protocolRevoked);\n    }\n    require(_poolFee <= 1000); // pool fee capped at 10%\n    uint16 feeOld = poolFee;\n    poolFee = _poolFee;\n    emit SetPoolFee(feeOld, _poolFee);\n}\n```\n\nAdditionally, if the owner of `SolidlyV2Factory` calls `SolidlyV2Pair::revokeFeeRole`, then registered fee setters are no longer able to call `SolidlyV2Pair::setPoolFee` despite no explicit consideration of fee setters.\n",
      "markdown_body": "**Description:** If a new `feeSetter` is registered by the owner of `SolidlyV2Factory`, then it is possible for the pool fee to be set below the minimum specified by the factory. This breaks the invariant that the pool fee should always be between the defined min/max values since it is only possible for the protocol to influence this value by explicitly modifying it on the factory itself, whereas a fee setter can modify it on the pool directly to become out of sync with the factory.\n\n```solidity\nfunction setPoolFee(uint16 _poolFee) external {\n    require(ISolidlyV2Factory(factory).isFeeSetter(msg.sender) || msg.sender == copilot, 'UA');\n    if (msg.sender == copilot) {\n        require(_poolFee >= ISolidlyV2Factory(factory).minFee() && !copilotRevoked); // minimum fee enforced for copilot\n    } else {\n        require(!protocolRevoked);\n    }\n    require(_poolFee <= 1000); // pool fee capped at 10%\n    uint16 feeOld = poolFee;\n    poolFee = _poolFee;\n    emit SetPoolFee(feeOld, _poolFee);\n}\n```\n\nAdditionally, if the owner of `SolidlyV2Factory` calls `SolidlyV2Pair::revokeFeeRole`, then registered fee setters are no longer able to call `SolidlyV2Pair::setPoolFee` despite no explicit consideration of fee setters.\n\n**Impact:**\n- The pool fee can become out of sync with `SolidlyV2Factory::minFee`.\n- Fee setters cannot set fees once the protocol has revoked its fee role.\n\n**Proof of Concept:**\n```javascript\nit(\"fee below min\", async function () {\n  const { user1, factory, pair } = await loadFixture(deploySolidlyV2Fixture);\n\n  await factory.setFeeSetter(user1.address, true);\n  pair.connect(user1).setPoolFee(0);\n  await factory.minFee().then(minFee => console.log(`SolidlyV2Factory::minFee: ${minFee}`));\n  await pair.poolFee().then(poolFee => console.log(`SolidlyV2Pair::poolFee: ${poolFee}`));\n\n  await pair.revokeFeeRole();\n  const minFee = await factory.minFee();\n  await expect(pair.connect(user1).setPoolFee(minFee)).to.revertedWithoutReason();\n});\n```\n\n**Recommended Mitigation:** Explicitly handle calls from fee setters as distinct from the factory owner in `SolidlyV2Pair::setPoolFee`, also enforcing that the pool fee cannot be set below the defined global minimum.\n\n**Solidly Labs:** Acknowledged. Both these things are like this by design – `feeSetters` are not constrained by `minFee`, and both protocol and `feeSetter` are considered the same for revoke.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n",
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "SolidlyV2Pair::setPoolFee fails to adequately consider fee setters defined by SolidlyV2Factory"
    },
    {
      "index": 5,
      "page_start": null,
      "heading": "5. Flash loans can be taken for free",
      "markdown": "### Flash loans can be taken for free\n\n**Description:** Unlike other AMM implementations, `SolidlyV2Pair` calculates fees independently for each underlying pool token. Showing just the `amount0Out` calculation:\n```solidity\nif (amount0Out > 0) {\n    uint256 amount1In = balance1 - (_reserve1 - amount1Out);\n    uint256 fee1 = _updateFees(1, amount1In, _poolFee, _protocolRatio);\n    _k(balance0, balance1 - fee1, uint256(_reserve0), uint256(_reserve1));\n    _updateReserves(balance0, (balance1 - fee1));\n    _emitSwap(0, amount1In, amount0Out, amount1Out, to);\n}\n```\n\nSince it is only possible to swap a single token, say `token0`, only `token0Out` will be non-zero. Since `amount1Out` is `0` the calculation `uint256 amount1In = balance1 - (_reserve1 - amount1Out);` will yield `amount1In = 0`. Hence, no fee will be charged.\n\n**Impact:** This has a high likelihood, but it is up to the project to determine the impact of being able to take flash swaps for free.\n\n**Proof of Concept:** Add this test to `MultiTest.js`:\n```javascript\nit(\"charges no fee for flashloans\", async function () {\nconst { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\nlet token0 = test0;\nlet token1 = test1;\n\n\n// Approve tokens for liquidity provision\nawait token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\nawait token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n// Provide liquidity\nawait router.connect(user1).addLiquidity(\n  token0.address,\n  token1.address,\n  ethers.utils.parseUnits(\"100\", 18),\n  ethers.utils.parseUnits(\"100\", 18),\n  0,\n  0,\n  user1.address,\n  ethers.constants.MaxUint256\n);\n\nconst FlashRecipient = await ethers.getContractFactory(\"FlashRecipient\");\nconst flashRecipient = await FlashRecipient.deploy(token0.address, pair.address);\n\n// doesn't revert\nawait flashRecipient.takeFlashloan();\n});\n```\n\nwith this file in `contracts/test/FlashRecipient.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {SolidlyV2Pair} from \"../SolidlyV2Pair.sol\";\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract FlashRecipient {\n\n    IERC20 public token0;\n    SolidlyV2Pair public pair;\n\n    constructor(address _token0, address _pair) {\n        token0 = IERC20(_token0);\n        pair = SolidlyV2Pair(_pair);\n    }\n\n    function takeFlashloan() external {\n        pair.swap(1e18, 0, address(this), \"data\");\n    }\n\n    function solidlyV2Call(address , uint256 amount0Out, uint256, bytes memory) external returns (bool) {\n        // no fee being paid\n        token0.transfer(msg.sender, amount0Out);\n        return true;\n    }\n}\n```\n\n\n**Recommended Mitigation:** Calculate the fee for both sides, but only call `_updateFees()` if they have changed.\n\n**Solidly Labs:** Acknowledged. Flashloans are not a big market, especially with memecoins, we see more potential benefits in leaving them free of charge.\n\n**Cyfrin:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 178,
      "end_line": 266,
      "markdown_raw": "### Flash loans can be taken for free\n\n**Description:** Unlike other AMM implementations, `SolidlyV2Pair` calculates fees independently for each underlying pool token. Showing just the `amount0Out` calculation:\n```solidity\nif (amount0Out > 0) {\n    uint256 amount1In = balance1 - (_reserve1 - amount1Out);\n    uint256 fee1 = _updateFees(1, amount1In, _poolFee, _protocolRatio);\n    _k(balance0, balance1 - fee1, uint256(_reserve0), uint256(_reserve1));\n    _updateReserves(balance0, (balance1 - fee1));\n    _emitSwap(0, amount1In, amount0Out, amount1Out, to);\n}\n```\n\nSince it is only possible to swap a single token, say `token0`, only `token0Out` will be non-zero. Since `amount1Out` is `0` the calculation `uint256 amount1In = balance1 - (_reserve1 - amount1Out);` will yield `amount1In = 0`. Hence, no fee will be charged.\n\n**Impact:** This has a high likelihood, but it is up to the project to determine the impact of being able to take flash swaps for free.\n\n**Proof of Concept:** Add this test to `MultiTest.js`:\n```javascript\nit(\"charges no fee for flashloans\", async function () {\nconst { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\nlet token0 = test0;\nlet token1 = test1;\n\n\n// Approve tokens for liquidity provision\nawait token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\nawait token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n// Provide liquidity\nawait router.connect(user1).addLiquidity(\n  token0.address,\n  token1.address,\n  ethers.utils.parseUnits(\"100\", 18),\n  ethers.utils.parseUnits(\"100\", 18),\n  0,\n  0,\n  user1.address,\n  ethers.constants.MaxUint256\n);\n\nconst FlashRecipient = await ethers.getContractFactory(\"FlashRecipient\");\nconst flashRecipient = await FlashRecipient.deploy(token0.address, pair.address);\n\n// doesn't revert\nawait flashRecipient.takeFlashloan();\n});\n```\n\nwith this file in `contracts/test/FlashRecipient.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {SolidlyV2Pair} from \"../SolidlyV2Pair.sol\";\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract FlashRecipient {\n\n    IERC20 public token0;\n    SolidlyV2Pair public pair;\n\n    constructor(address _token0, address _pair) {\n        token0 = IERC20(_token0);\n        pair = SolidlyV2Pair(_pair);\n    }\n\n    function takeFlashloan() external {\n        pair.swap(1e18, 0, address(this), \"data\");\n    }\n\n    function solidlyV2Call(address , uint256 amount0Out, uint256, bytes memory) external returns (bool) {\n        // no fee being paid\n        token0.transfer(msg.sender, amount0Out);\n        return true;\n    }\n}\n```\n\n\n**Recommended Mitigation:** Calculate the fee for both sides, but only call `_updateFees()` if they have changed.\n\n**Solidly Labs:** Acknowledged. Flashloans are not a big market, especially with memecoins, we see more potential benefits in leaving them free of charge.\n\n**Cyfrin:** Acknowledged.\n",
      "sections": {
        "description": "**Description:** Unlike other AMM implementations, `SolidlyV2Pair` calculates fees independently for each underlying pool token. Showing just the `amount0Out` calculation:\n```solidity\nif (amount0Out > 0) {\n    uint256 amount1In = balance1 - (_reserve1 - amount1Out);\n    uint256 fee1 = _updateFees(1, amount1In, _poolFee, _protocolRatio);\n    _k(balance0, balance1 - fee1, uint256(_reserve0), uint256(_reserve1));\n    _updateReserves(balance0, (balance1 - fee1));\n    _emitSwap(0, amount1In, amount0Out, amount1Out, to);\n}\n```\n\nSince it is only possible to swap a single token, say `token0`, only `token0Out` will be non-zero. Since `amount1Out` is `0` the calculation `uint256 amount1In = balance1 - (_reserve1 - amount1Out);` will yield `amount1In = 0`. Hence, no fee will be charged.\n",
        "impact": "**Impact:** This has a high likelihood, but it is up to the project to determine the impact of being able to take flash swaps for free.\n",
        "recommendation": "**Recommended Mitigation:** Calculate the fee for both sides, but only call `_updateFees()` if they have changed.\n",
        "poc": "**Proof of Concept:** Add this test to `MultiTest.js`:\n```javascript\nit(\"charges no fee for flashloans\", async function () {\nconst { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\nlet token0 = test0;\nlet token1 = test1;\n\n\n// Approve tokens for liquidity provision\nawait token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\nawait token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n// Provide liquidity\nawait router.connect(user1).addLiquidity(\n  token0.address,\n  token1.address,\n  ethers.utils.parseUnits(\"100\", 18),\n  ethers.utils.parseUnits(\"100\", 18),\n  0,\n  0,\n  user1.address,\n  ethers.constants.MaxUint256\n);\n\nconst FlashRecipient = await ethers.getContractFactory(\"FlashRecipient\");\nconst flashRecipient = await FlashRecipient.deploy(token0.address, pair.address);\n\n// doesn't revert\nawait flashRecipient.takeFlashloan();\n});\n```\n\nwith this file in `contracts/test/FlashRecipient.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {SolidlyV2Pair} from \"../SolidlyV2Pair.sol\";\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract FlashRecipient {\n\n    IERC20 public token0;\n    SolidlyV2Pair public pair;\n\n    constructor(address _token0, address _pair) {\n        token0 = IERC20(_token0);\n        pair = SolidlyV2Pair(_pair);\n    }\n\n    function takeFlashloan() external {\n        pair.swap(1e18, 0, address(this), \"data\");\n    }\n\n    function solidlyV2Call(address , uint256 amount0Out, uint256, bytes memory) external returns (bool) {\n        // no fee being paid\n        token0.transfer(msg.sender, amount0Out);\n        return true;\n    }\n}\n```\n",
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged. Flashloans are not a big market, especially with memecoins, we see more potential benefits in leaving them free of charge.\n\n**Cyfrin:** Acknowledged.\n"
      },
      "description": "**Description:** Unlike other AMM implementations, `SolidlyV2Pair` calculates fees independently for each underlying pool token. Showing just the `amount0Out` calculation:\n```solidity\nif (amount0Out > 0) {\n    uint256 amount1In = balance1 - (_reserve1 - amount1Out);\n    uint256 fee1 = _updateFees(1, amount1In, _poolFee, _protocolRatio);\n    _k(balance0, balance1 - fee1, uint256(_reserve0), uint256(_reserve1));\n    _updateReserves(balance0, (balance1 - fee1));\n    _emitSwap(0, amount1In, amount0Out, amount1Out, to);\n}\n```\n\nSince it is only possible to swap a single token, say `token0`, only `token0Out` will be non-zero. Since `amount1Out` is `0` the calculation `uint256 amount1In = balance1 - (_reserve1 - amount1Out);` will yield `amount1In = 0`. Hence, no fee will be charged.\n",
      "markdown_body": "**Description:** Unlike other AMM implementations, `SolidlyV2Pair` calculates fees independently for each underlying pool token. Showing just the `amount0Out` calculation:\n```solidity\nif (amount0Out > 0) {\n    uint256 amount1In = balance1 - (_reserve1 - amount1Out);\n    uint256 fee1 = _updateFees(1, amount1In, _poolFee, _protocolRatio);\n    _k(balance0, balance1 - fee1, uint256(_reserve0), uint256(_reserve1));\n    _updateReserves(balance0, (balance1 - fee1));\n    _emitSwap(0, amount1In, amount0Out, amount1Out, to);\n}\n```\n\nSince it is only possible to swap a single token, say `token0`, only `token0Out` will be non-zero. Since `amount1Out` is `0` the calculation `uint256 amount1In = balance1 - (_reserve1 - amount1Out);` will yield `amount1In = 0`. Hence, no fee will be charged.\n\n**Impact:** This has a high likelihood, but it is up to the project to determine the impact of being able to take flash swaps for free.\n\n**Proof of Concept:** Add this test to `MultiTest.js`:\n```javascript\nit(\"charges no fee for flashloans\", async function () {\nconst { user1, test0, test1, router, pair } = await loadFixture(deploySolidlyV2Fixture);\n\nlet token0 = test0;\nlet token1 = test1;\n\n\n// Approve tokens for liquidity provision\nawait token0.connect(user1).approve(router.address, ethers.constants.MaxUint256);\nawait token1.connect(user1).approve(router.address, ethers.constants.MaxUint256);\n\n// Provide liquidity\nawait router.connect(user1).addLiquidity(\n  token0.address,\n  token1.address,\n  ethers.utils.parseUnits(\"100\", 18),\n  ethers.utils.parseUnits(\"100\", 18),\n  0,\n  0,\n  user1.address,\n  ethers.constants.MaxUint256\n);\n\nconst FlashRecipient = await ethers.getContractFactory(\"FlashRecipient\");\nconst flashRecipient = await FlashRecipient.deploy(token0.address, pair.address);\n\n// doesn't revert\nawait flashRecipient.takeFlashloan();\n});\n```\n\nwith this file in `contracts/test/FlashRecipient.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {SolidlyV2Pair} from \"../SolidlyV2Pair.sol\";\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract FlashRecipient {\n\n    IERC20 public token0;\n    SolidlyV2Pair public pair;\n\n    constructor(address _token0, address _pair) {\n        token0 = IERC20(_token0);\n        pair = SolidlyV2Pair(_pair);\n    }\n\n    function takeFlashloan() external {\n        pair.swap(1e18, 0, address(this), \"data\");\n    }\n\n    function solidlyV2Call(address , uint256 amount0Out, uint256, bytes memory) external returns (bool) {\n        // no fee being paid\n        token0.transfer(msg.sender, amount0Out);\n        return true;\n    }\n}\n```\n\n\n**Recommended Mitigation:** Calculate the fee for both sides, but only call `_updateFees()` if they have changed.\n\n**Solidly Labs:** Acknowledged. Flashloans are not a big market, especially with memecoins, we see more potential benefits in leaving them free of charge.\n\n**Cyfrin:** Acknowledged.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Flash loans can be taken for free"
    },
    {
      "index": 6,
      "page_start": null,
      "heading": "6. Lack of events emitted for state changes",
      "markdown": "### Lack of events emitted for state changes\n\n**Description:** Events are useful to track contract changes off-chain. Hence emitting events for state changes is very valuable for off-chain monitoring and tracking of on-chain state.\n\n**Impact:** Important state changes can be missed in monitoring and off chain tracing.\n\n**Recommended Mitigation:** Consider emitting events for:\n* `SolidlyV2Factory::setOwner`\n* `SolidlyV2Factory::setFeeCollector`\n* `SolidlyV2Factory::setFeeSetter`\n* `SolidlyV2Pair::setCopilot`\n* `SolidlyV2Pair::revokeFeeRole`\n\nAlso consider emitting a special event when tokens are burnt (but kept tracked for fee accrual):\n* `SolidlyV2ERC42069::transferZero`\n* `SolidlyV2ERC42069::transferZeroFrom`\n\n**Solidly Labs:** Partially fixed. Most important events are covered, added `OwnerChanged` on factory. We're very constrained by bytecode space.\n\n**Cyfrin:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 266,
      "end_line": 288,
      "markdown_raw": "### Lack of events emitted for state changes\n\n**Description:** Events are useful to track contract changes off-chain. Hence emitting events for state changes is very valuable for off-chain monitoring and tracking of on-chain state.\n\n**Impact:** Important state changes can be missed in monitoring and off chain tracing.\n\n**Recommended Mitigation:** Consider emitting events for:\n* `SolidlyV2Factory::setOwner`\n* `SolidlyV2Factory::setFeeCollector`\n* `SolidlyV2Factory::setFeeSetter`\n* `SolidlyV2Pair::setCopilot`\n* `SolidlyV2Pair::revokeFeeRole`\n\nAlso consider emitting a special event when tokens are burnt (but kept tracked for fee accrual):\n* `SolidlyV2ERC42069::transferZero`\n* `SolidlyV2ERC42069::transferZeroFrom`\n\n**Solidly Labs:** Partially fixed. Most important events are covered, added `OwnerChanged` on factory. We're very constrained by bytecode space.\n\n**Cyfrin:** Acknowledged.\n",
      "sections": {
        "description": "**Description:** Events are useful to track contract changes off-chain. Hence emitting events for state changes is very valuable for off-chain monitoring and tracking of on-chain state.\n",
        "impact": "**Impact:** Important state changes can be missed in monitoring and off chain tracing.\n",
        "recommendation": "**Recommended Mitigation:** Consider emitting events for:\n* `SolidlyV2Factory::setOwner`\n* `SolidlyV2Factory::setFeeCollector`\n* `SolidlyV2Factory::setFeeSetter`\n* `SolidlyV2Pair::setCopilot`\n* `SolidlyV2Pair::revokeFeeRole`\n\nAlso consider emitting a special event when tokens are burnt (but kept tracked for fee accrual):\n* `SolidlyV2ERC42069::transferZero`\n* `SolidlyV2ERC42069::transferZeroFrom`\n",
        "poc": null,
        "fix_status": null,
        "other": "**Solidly Labs:** Partially fixed. Most important events are covered, added `OwnerChanged` on factory. We're very constrained by bytecode space.\n\n**Cyfrin:** Acknowledged.\n"
      },
      "description": "**Description:** Events are useful to track contract changes off-chain. Hence emitting events for state changes is very valuable for off-chain monitoring and tracking of on-chain state.\n",
      "markdown_body": "**Description:** Events are useful to track contract changes off-chain. Hence emitting events for state changes is very valuable for off-chain monitoring and tracking of on-chain state.\n\n**Impact:** Important state changes can be missed in monitoring and off chain tracing.\n\n**Recommended Mitigation:** Consider emitting events for:\n* `SolidlyV2Factory::setOwner`\n* `SolidlyV2Factory::setFeeCollector`\n* `SolidlyV2Factory::setFeeSetter`\n* `SolidlyV2Pair::setCopilot`\n* `SolidlyV2Pair::revokeFeeRole`\n\nAlso consider emitting a special event when tokens are burnt (but kept tracked for fee accrual):\n* `SolidlyV2ERC42069::transferZero`\n* `SolidlyV2ERC42069::transferZeroFrom`\n\n**Solidly Labs:** Partially fixed. Most important events are covered, added `OwnerChanged` on factory. We're very constrained by bytecode space.\n\n**Cyfrin:** Acknowledged.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Lack of events emitted for state changes"
    },
    {
      "index": 7,
      "page_start": null,
      "heading": "7. Secondary markets for LP tokens are problematic",
      "markdown": "### Secondary markets for LP tokens are problematic\n\n**Description:** Unlike other AMM implementations, where fees are accrued in the LP token, Solidly V2 implements an accrual system where the fees are tracked in `feeGrowthGlobal0`/`1` per LP token. Each liquidity provider can call `SolidlyV2Pair::claimFees` to collect their accrued fees, with the benefit being that a liquidity provider does not have to burn their position to access the fees they have accrued.\n\nFee accrual is synced with every action that changes the balance: when claiming fees, mints, locks, and, most importantly, on any transfer of LP tokens or locked or burnt positions. This means that the fees accrued are bound to the account holding the liquidity position at that time.\n\nTherefore, if these tokens are traded or used as collateral on secondary markets, the fees accrued while in escrow would be lost as these contracts cannot, without modification and knowledge of the Solidly V2 Memecore system, claim fees.\n\n**Impact:** Using Solidly V2 Memecore LP tokens in AMMs, such as within Solidly V2 itself, or different escrow/collateral style contracts will cause fees to be lost.\n\n**Recommended Mitigation:** Be clear about this behavior in the documentation. For the LP tokens to be safely used in a pool of any sort, these would need an ERC-4626-style wrapper vault to be developed. The locked/burnt positions are not so concerning as they would need a custom-built implementation to be traded anyway, which would cater to this in its development..\n\n**Solidly Labs:** Acknowledged. Secondary markets for memecoin LPs are close to non-existent anyway. The most important functions with meme LP tokens are directly available in the core contracts.\n\n**Cyfrin:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 288,
      "end_line": 305,
      "markdown_raw": "### Secondary markets for LP tokens are problematic\n\n**Description:** Unlike other AMM implementations, where fees are accrued in the LP token, Solidly V2 implements an accrual system where the fees are tracked in `feeGrowthGlobal0`/`1` per LP token. Each liquidity provider can call `SolidlyV2Pair::claimFees` to collect their accrued fees, with the benefit being that a liquidity provider does not have to burn their position to access the fees they have accrued.\n\nFee accrual is synced with every action that changes the balance: when claiming fees, mints, locks, and, most importantly, on any transfer of LP tokens or locked or burnt positions. This means that the fees accrued are bound to the account holding the liquidity position at that time.\n\nTherefore, if these tokens are traded or used as collateral on secondary markets, the fees accrued while in escrow would be lost as these contracts cannot, without modification and knowledge of the Solidly V2 Memecore system, claim fees.\n\n**Impact:** Using Solidly V2 Memecore LP tokens in AMMs, such as within Solidly V2 itself, or different escrow/collateral style contracts will cause fees to be lost.\n\n**Recommended Mitigation:** Be clear about this behavior in the documentation. For the LP tokens to be safely used in a pool of any sort, these would need an ERC-4626-style wrapper vault to be developed. The locked/burnt positions are not so concerning as they would need a custom-built implementation to be traded anyway, which would cater to this in its development..\n\n**Solidly Labs:** Acknowledged. Secondary markets for memecoin LPs are close to non-existent anyway. The most important functions with meme LP tokens are directly available in the core contracts.\n\n**Cyfrin:** Acknowledged.\n",
      "sections": {
        "description": "**Description:** Unlike other AMM implementations, where fees are accrued in the LP token, Solidly V2 implements an accrual system where the fees are tracked in `feeGrowthGlobal0`/`1` per LP token. Each liquidity provider can call `SolidlyV2Pair::claimFees` to collect their accrued fees, with the benefit being that a liquidity provider does not have to burn their position to access the fees they have accrued.\n\nFee accrual is synced with every action that changes the balance: when claiming fees, mints, locks, and, most importantly, on any transfer of LP tokens or locked or burnt positions. This means that the fees accrued are bound to the account holding the liquidity position at that time.\n\nTherefore, if these tokens are traded or used as collateral on secondary markets, the fees accrued while in escrow would be lost as these contracts cannot, without modification and knowledge of the Solidly V2 Memecore system, claim fees.\n",
        "impact": "**Impact:** Using Solidly V2 Memecore LP tokens in AMMs, such as within Solidly V2 itself, or different escrow/collateral style contracts will cause fees to be lost.\n",
        "recommendation": "**Recommended Mitigation:** Be clear about this behavior in the documentation. For the LP tokens to be safely used in a pool of any sort, these would need an ERC-4626-style wrapper vault to be developed. The locked/burnt positions are not so concerning as they would need a custom-built implementation to be traded anyway, which would cater to this in its development..\n",
        "poc": null,
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged. Secondary markets for memecoin LPs are close to non-existent anyway. The most important functions with meme LP tokens are directly available in the core contracts.\n\n**Cyfrin:** Acknowledged.\n"
      },
      "description": "**Description:** Unlike other AMM implementations, where fees are accrued in the LP token, Solidly V2 implements an accrual system where the fees are tracked in `feeGrowthGlobal0`/`1` per LP token. Each liquidity provider can call `SolidlyV2Pair::claimFees` to collect their accrued fees, with the benefit being that a liquidity provider does not have to burn their position to access the fees they have accrued.\n\nFee accrual is synced with every action that changes the balance: when claiming fees, mints, locks, and, most importantly, on any transfer of LP tokens or locked or burnt positions. This means that the fees accrued are bound to the account holding the liquidity position at that time.\n\nTherefore, if these tokens are traded or used as collateral on secondary markets, the fees accrued while in escrow would be lost as these contracts cannot, without modification and knowledge of the Solidly V2 Memecore system, claim fees.\n",
      "markdown_body": "**Description:** Unlike other AMM implementations, where fees are accrued in the LP token, Solidly V2 implements an accrual system where the fees are tracked in `feeGrowthGlobal0`/`1` per LP token. Each liquidity provider can call `SolidlyV2Pair::claimFees` to collect their accrued fees, with the benefit being that a liquidity provider does not have to burn their position to access the fees they have accrued.\n\nFee accrual is synced with every action that changes the balance: when claiming fees, mints, locks, and, most importantly, on any transfer of LP tokens or locked or burnt positions. This means that the fees accrued are bound to the account holding the liquidity position at that time.\n\nTherefore, if these tokens are traded or used as collateral on secondary markets, the fees accrued while in escrow would be lost as these contracts cannot, without modification and knowledge of the Solidly V2 Memecore system, claim fees.\n\n**Impact:** Using Solidly V2 Memecore LP tokens in AMMs, such as within Solidly V2 itself, or different escrow/collateral style contracts will cause fees to be lost.\n\n**Recommended Mitigation:** Be clear about this behavior in the documentation. For the LP tokens to be safely used in a pool of any sort, these would need an ERC-4626-style wrapper vault to be developed. The locked/burnt positions are not so concerning as they would need a custom-built implementation to be traded anyway, which would cater to this in its development..\n\n**Solidly Labs:** Acknowledged. Secondary markets for memecoin LPs are close to non-existent anyway. The most important functions with meme LP tokens are directly available in the core contracts.\n\n**Cyfrin:** Acknowledged.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Secondary markets for LP tokens are problematic"
    },
    {
      "index": 8,
      "page_start": null,
      "heading": "8. Users can hide liquidity in low-duration locks",
      "markdown": "### Users can hide liquidity in low-duration locks\n\n**Description:** One of the main features of SolidlyV2-memecore is the ability to lock liquidity for a period of time. This will transfer the liquidity to a `LockBox` contract, where it will be locked until the expiry (which is specified when locking).\n\nThis liquidity still accrues fees for the holder but is technically held by the `LockBox` contract. Thus `balanceOf` will show `0` for the account having the lock.\n\nThis could be used to \"hide\" liquidity as a user could have a lock with a `0` duration and then, when needing the liquidity, just withdraw the lock.\n\n**Impact:** A user could use locks to \"hide\" liquidity since a normal ERC20 `balanceOf` will not show it. However, there appears to be no clear way of abusing this, and hence, this is only for your information.\n\n**Recommended Mitigation:** If this is a concern, consider including locked liquidity as part of the `balanceOf`. This would break the ERC20 accounting, though, as the tokens would be double-counted on both the `LockBox` balance and the account balance.\n\n**Solidly Labs:** Acknowledged. Users can check that it's expired or close to expiry.\n\n**Cyfrin:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 305,
      "end_line": 322,
      "markdown_raw": "### Users can hide liquidity in low-duration locks\n\n**Description:** One of the main features of SolidlyV2-memecore is the ability to lock liquidity for a period of time. This will transfer the liquidity to a `LockBox` contract, where it will be locked until the expiry (which is specified when locking).\n\nThis liquidity still accrues fees for the holder but is technically held by the `LockBox` contract. Thus `balanceOf` will show `0` for the account having the lock.\n\nThis could be used to \"hide\" liquidity as a user could have a lock with a `0` duration and then, when needing the liquidity, just withdraw the lock.\n\n**Impact:** A user could use locks to \"hide\" liquidity since a normal ERC20 `balanceOf` will not show it. However, there appears to be no clear way of abusing this, and hence, this is only for your information.\n\n**Recommended Mitigation:** If this is a concern, consider including locked liquidity as part of the `balanceOf`. This would break the ERC20 accounting, though, as the tokens would be double-counted on both the `LockBox` balance and the account balance.\n\n**Solidly Labs:** Acknowledged. Users can check that it's expired or close to expiry.\n\n**Cyfrin:** Acknowledged.\n",
      "sections": {
        "description": "**Description:** One of the main features of SolidlyV2-memecore is the ability to lock liquidity for a period of time. This will transfer the liquidity to a `LockBox` contract, where it will be locked until the expiry (which is specified when locking).\n\nThis liquidity still accrues fees for the holder but is technically held by the `LockBox` contract. Thus `balanceOf` will show `0` for the account having the lock.\n\nThis could be used to \"hide\" liquidity as a user could have a lock with a `0` duration and then, when needing the liquidity, just withdraw the lock.\n",
        "impact": "**Impact:** A user could use locks to \"hide\" liquidity since a normal ERC20 `balanceOf` will not show it. However, there appears to be no clear way of abusing this, and hence, this is only for your information.\n",
        "recommendation": "**Recommended Mitigation:** If this is a concern, consider including locked liquidity as part of the `balanceOf`. This would break the ERC20 accounting, though, as the tokens would be double-counted on both the `LockBox` balance and the account balance.\n",
        "poc": null,
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged. Users can check that it's expired or close to expiry.\n\n**Cyfrin:** Acknowledged.\n"
      },
      "description": "**Description:** One of the main features of SolidlyV2-memecore is the ability to lock liquidity for a period of time. This will transfer the liquidity to a `LockBox` contract, where it will be locked until the expiry (which is specified when locking).\n\nThis liquidity still accrues fees for the holder but is technically held by the `LockBox` contract. Thus `balanceOf` will show `0` for the account having the lock.\n\nThis could be used to \"hide\" liquidity as a user could have a lock with a `0` duration and then, when needing the liquidity, just withdraw the lock.\n",
      "markdown_body": "**Description:** One of the main features of SolidlyV2-memecore is the ability to lock liquidity for a period of time. This will transfer the liquidity to a `LockBox` contract, where it will be locked until the expiry (which is specified when locking).\n\nThis liquidity still accrues fees for the holder but is technically held by the `LockBox` contract. Thus `balanceOf` will show `0` for the account having the lock.\n\nThis could be used to \"hide\" liquidity as a user could have a lock with a `0` duration and then, when needing the liquidity, just withdraw the lock.\n\n**Impact:** A user could use locks to \"hide\" liquidity since a normal ERC20 `balanceOf` will not show it. However, there appears to be no clear way of abusing this, and hence, this is only for your information.\n\n**Recommended Mitigation:** If this is a concern, consider including locked liquidity as part of the `balanceOf`. This would break the ERC20 accounting, though, as the tokens would be double-counted on both the `LockBox` balance and the account balance.\n\n**Solidly Labs:** Acknowledged. Users can check that it's expired or close to expiry.\n\n**Cyfrin:** Acknowledged.\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Users can hide liquidity in low-duration locks"
    },
    {
      "index": 9,
      "page_start": null,
      "heading": "9. Lock creation can be front-run",
      "markdown": "### Lock creation can be front-run\n\n**Description:** `SolidlyV2ERC42069::lockToken` can be front-run with the transfer of a dust lock. This would cause the index at which the lock is created to be different from what the sender expected when sending the transaction.\n\nIn the worst case, this could cause the wrong lock to be withdrawn, extended, or split. If the sender is attentive, this can be easily remedied, but it could waste the gas cost for one TX.\n\n**Impact:** The index at which a lock is created/split/transferred can be something other than expected.\n\n**Recommended Mitigation:** Consider mentioning in the documentation that the user needs to use the events emitted to verify at which index their lock was created.\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 322,
      "end_line": 337,
      "markdown_raw": "### Lock creation can be front-run\n\n**Description:** `SolidlyV2ERC42069::lockToken` can be front-run with the transfer of a dust lock. This would cause the index at which the lock is created to be different from what the sender expected when sending the transaction.\n\nIn the worst case, this could cause the wrong lock to be withdrawn, extended, or split. If the sender is attentive, this can be easily remedied, but it could waste the gas cost for one TX.\n\n**Impact:** The index at which a lock is created/split/transferred can be something other than expected.\n\n**Recommended Mitigation:** Consider mentioning in the documentation that the user needs to use the events emitted to verify at which index their lock was created.\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n",
      "sections": {
        "description": "**Description:** `SolidlyV2ERC42069::lockToken` can be front-run with the transfer of a dust lock. This would cause the index at which the lock is created to be different from what the sender expected when sending the transaction.\n\nIn the worst case, this could cause the wrong lock to be withdrawn, extended, or split. If the sender is attentive, this can be easily remedied, but it could waste the gas cost for one TX.\n",
        "impact": "**Impact:** The index at which a lock is created/split/transferred can be something other than expected.\n",
        "recommendation": "**Recommended Mitigation:** Consider mentioning in the documentation that the user needs to use the events emitted to verify at which index their lock was created.\n",
        "poc": null,
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n"
      },
      "description": "**Description:** `SolidlyV2ERC42069::lockToken` can be front-run with the transfer of a dust lock. This would cause the index at which the lock is created to be different from what the sender expected when sending the transaction.\n\nIn the worst case, this could cause the wrong lock to be withdrawn, extended, or split. If the sender is attentive, this can be easily remedied, but it could waste the gas cost for one TX.\n",
      "markdown_body": "**Description:** `SolidlyV2ERC42069::lockToken` can be front-run with the transfer of a dust lock. This would cause the index at which the lock is created to be different from what the sender expected when sending the transaction.\n\nIn the worst case, this could cause the wrong lock to be withdrawn, extended, or split. If the sender is attentive, this can be easily remedied, but it could waste the gas cost for one TX.\n\n**Impact:** The index at which a lock is created/split/transferred can be something other than expected.\n\n**Recommended Mitigation:** Consider mentioning in the documentation that the user needs to use the events emitted to verify at which index their lock was created.\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage\n",
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Lock creation can be front-run"
    },
    {
      "index": 10,
      "page_start": null,
      "heading": "10. Cache domain separator and only recompute if the chain ID has changed",
      "markdown": "### Cache domain separator and only recompute if the chain ID has changed\n\nFor greater gas efficiency, it is recommended that the current chain ID be cached on contract creation and that the domain separator be recomputed only if a change of chain ID is detected (i.e., ` block.chainid` != cached chain ID). An example can be seen in the implementation of [`Solmate::ERC20`](https://github.com/transmissions11/solmate/blob/c892309933b25c03d32b1b0d674df7ae292ba925/src/tokens/ERC20.sol).\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 340,
      "end_line": 347,
      "markdown_raw": "### Cache domain separator and only recompute if the chain ID has changed\n\nFor greater gas efficiency, it is recommended that the current chain ID be cached on contract creation and that the domain separator be recomputed only if a change of chain ID is detected (i.e., ` block.chainid` != cached chain ID). An example can be seen in the implementation of [`Solmate::ERC20`](https://github.com/transmissions11/solmate/blob/c892309933b25c03d32b1b0d674df7ae292ba925/src/tokens/ERC20.sol).\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "sections": {
        "description": "For greater gas efficiency, it is recommended that the current chain ID be cached on contract creation and that the domain separator be recomputed only if a change of chain ID is detected (i.e., ` block.chainid` != cached chain ID). An example can be seen in the implementation of [`Solmate::ERC20`](https://github.com/transmissions11/solmate/blob/c892309933b25c03d32b1b0d674df7ae292ba925/src/tokens/ERC20.sol).\n",
        "impact": null,
        "recommendation": null,
        "poc": null,
        "fix_status": null,
        "other": "**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n"
      },
      "description": "For greater gas efficiency, it is recommended that the current chain ID be cached on contract creation and that the domain separator be recomputed only if a change of chain ID is detected (i.e., ` block.chainid` != cached chain ID). An example can be seen in the implementation of [`Solmate::ERC20`](https://github.com/transmissions11/solmate/blob/c892309933b25c03d32b1b0d674df7ae292ba925/src/tokens/ERC20.sol).\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "markdown_body": "For greater gas efficiency, it is recommended that the current chain ID be cached on contract creation and that the domain separator be recomputed only if a change of chain ID is detected (i.e., ` block.chainid` != cached chain ID). An example can be seen in the implementation of [`Solmate::ERC20`](https://github.com/transmissions11/solmate/blob/c892309933b25c03d32b1b0d674df7ae292ba925/src/tokens/ERC20.sol).\n\n**Solidly Labs:** Acknowledged.\n\n**Cyfrin:** Acknowledged.\n",
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Cache domain separator and only recompute if the chain ID has changed"
    }
  ]
}