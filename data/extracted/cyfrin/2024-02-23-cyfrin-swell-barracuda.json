{
  "doc_id": "cyfrin_2024-02-23-cyfrin-swell-barracuda",
  "source_pdf": "2024-02-23-cyfrin-swell-barracuda.md",
  "source_mtime": "2025-11-01T12:04:59+00:00",
  "extracted_at": "2025-11-12T02:04:23.914761+00:00",
  "extractor_version": "poc-0.4-md-no-llm",
  "repositories": [
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "a95ea7942ba895ae84845ab7fec1163d667bee38",
      "evidence": {
        "page": null,
        "snippet": "The one exception is [`NodeOperatorRegistry::deleteActiveValidators`](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/NodeOpera..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "1a105b76899780e30b1fb88abdede11c0c0586ba",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [1a105b7](https://github.com/SwellNetwork/v3-contracts-lst/commit/1a105b76899780e30b1fb88abdede11c0c0586ba)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "c6f870847bdf276aee1bf9aeb1ed71771a2aba04",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [c6f8708](https://github.com/SwellNetwork/v3-contracts-lst/commit/c6f870847bdf276aee1bf9aeb1ed71771a2aba04), [64cfbdb](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "64cfbdbf67e28d84f2a706982e28925ab51fd5e6",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [c6f8708](https://github.com/SwellNetwork/v3-contracts-lst/commit/c6f870847bdf276aee1bf9aeb1ed71771a2aba04), [64cfbdb](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-core-public",
      "org": "SwellNetwork",
      "repo": "v3-core-public",
      "commit": null,
      "evidence": {
        "page": null,
        "snippet": "This issue has not been introduced in the new changes but is in the mainnet code ([1](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L267-..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "a9dfe5cef35404e4e957e8001d571b1cf43feb0a",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [a9dfe5c](https://github.com/SwellNetwork/v3-contracts-lst/commit/a9dfe5cef35404e4e957e8001d571b1cf43feb0a)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "4c8cbfde6fdb54385f8bab83c33f90409fd0a412",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [4c8cbfd](https://github.com/SwellNetwork/v3-contracts-lst/commit/4c8cbfde6fdb54385f8bab83c33f90409fd0a412), [262db73](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "262db7361f543611237e889313b8022a47b77144",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [4c8cbfd](https://github.com/SwellNetwork/v3-contracts-lst/commit/4c8cbfde6fdb54385f8bab83c33f90409fd0a412), [262db73](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "84a65178c31222d80559f6fd5f1b4c60f9249016",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [84a6517](https://github.com/SwellNetwork/v3-contracts-lst/commit/84a65178c31222d80559f6fd5f1b4c60f9249016)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "c9a1e6c06d0f5b358f5c3d4b7644db7a33952444",
      "evidence": {
        "page": null,
        "snippet": "If Swell scales to a large number of validators `swETH::reprice` may revert due to out of gas or make the reprice operation exorbitantly expensive. `NodeOperatorRegistry::getNextValidatorDetails` may ..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "55c7d5fba6d55c68558dcd15de016927e07e38fd",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [55c7d5f](https://github.com/SwellNetwork/v3-contracts-lst/commit/55c7d5fba6d55c68558dcd15de016927e07e38fd)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "b5d7a19e2f6de5c0ae086c8deaac5166767cd3fd",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [b5d7a19](https://github.com/SwellNetwork/v3-contracts-lst/commit/b5d7a19e2f6de5c0ae086c8deaac5166767cd3fd)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "5594e204083a8507e69f0c28f4d1d7162f9a20fd",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [5594e20](https://github.com/SwellNetwork/v3-contracts-lst/commit/5594e204083a8507e69f0c28f4d1d7162f9a20fd)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "cb093eac675e5248a3f736a01a3725d794dd177e",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [cb093ea](https://github.com/SwellNetwork/v3-contracts-lst/commit/cb093eac675e5248a3f736a01a3725d794dd177e)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "c82dd3c8ca6853816dd9f1982ab0a5ef50d78cf2",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [c82dd3c](https://github.com/SwellNetwork/v3-contracts-lst/commit/c82dd3c8ca6853816dd9f1982ab0a5ef50d78cf2)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "d13aa4390bb75c4e491b9cd92b7f7561cbe4ec15",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [d13aa43](https://github.com/SwellNetwork/v3-contracts-lst/commit/d13aa4390bb75c4e491b9cd92b7f7561cbe4ec15), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "3f85df3ba0e91b26e4234b15ad94f492fa6d46ec",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [d13aa43](https://github.com/SwellNetwork/v3-contracts-lst/commit/d13aa4390bb75c4e491b9cd92b7f7561cbe4ec15), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "584964072b1543128c02e3287fe7746a8a094226",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [5849640](https://github.com/SwellNetwork/v3-contracts-lst/commit/584964072b1543128c02e3287fe7746a8a094226)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "d457d8d109770f86b2b6ab3f785e1678ca341d6f",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commit [d457d8d](https://github.com/SwellNetwork/v3-contracts-lst/commit/d457d8d109770f86b2b6ab3f785e1678ca341d6f)."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "23be89740b7659ab4d98435d6a924364635fb9ca",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [23be897](https://github.com/SwellNetwork/v3-contracts-lst/commit/23be89740b7659ab4d98435d6a924364635fb9ca), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "3c67e88dbea1bb4cdf0bfeda27b40e71e494ef2c",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [3c67e88](https://github.com/SwellNetwork/v3-contracts-lst/commit/3c67e88dbea1bb4cdf0bfeda27b40e71e494ef2c), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/a16z/halmos",
      "org": "a16z",
      "repo": "halmos",
      "commit": null,
      "evidence": {
        "page": null,
        "snippet": "The following stand-alone test using Foundry & [Halmos](https://github.com/a16z/halmos/) verifies that the optimized version returns the same output as the original:"
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "7db187409c7161d981b32d639e8b925fafc431a8",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [7db1874](https://github.com/SwellNetwork/v3-contracts-lst/commit/7db187409c7161d981b32d639e8b925fafc431a8), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    },
    {
      "url": "https://github.com/SwellNetwork/v3-contracts-lst",
      "org": "SwellNetwork",
      "repo": "v3-contracts-lst",
      "commit": "1fca965019facc4dcc79c35bfc45c8a711043196",
      "evidence": {
        "page": null,
        "snippet": "**Swell:** Fixed in commits [1fca965](https://github.com/SwellNetwork/v3-contracts-lst/commit/1fca965019facc4dcc79c35bfc45c8a711043196), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/comm..."
      }
    }
  ],
  "report_schema": [
    {
      "key": "Severity",
      "meaning": "How serious the impact of this finding is.",
      "expected_values": "Informational / Low / Medium / High"
    },
    {
      "key": "Difficulty",
      "meaning": "How hard it is to exploit this vulnerability.",
      "expected_values": "Low / Medium / High"
    },
    {
      "key": "Type",
      "meaning": "The category or nature of the vulnerability.",
      "expected_values": "String describing the type of vulnerability (e.g., Data Validation, Reentrancy)"
    },
    {
      "key": "Finding ID",
      "meaning": "A unique identifier for the specific finding.",
      "expected_values": "String with a consistent format (e.g., TOB-ELA-1)"
    },
    {
      "key": "Target",
      "meaning": "The location of the vulnerability in the codebase.",
      "expected_values": "Path to affected file / contract"
    }
  ],
  "vulnerability_sections": [
    {
      "index": 1,
      "page_start": null,
      "heading": "`SwellLib.BOT` can delete active validators when bot methods are paused",
      "markdown": "### `SwellLib.BOT` can delete active validators when bot methods are paused\n\n**Description:** Almost all of the functions callable by `SwellLib.BOT` contain the following check to prevent bot functions from working when bot methods are paused:\n\n```solidity\nif (AccessControlManager.botMethodsPaused()) {\n  revert SwellLib.BotMethodsPaused();\n}\n```\n\nThe one exception is [`NodeOperatorRegistry::deleteActiveValidators`](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/NodeOperatorRegistry.sol#L417-L423) which is callable by `SwellLib.BOT` even when bot methods are paused. Consider:\n* adding a similar check to this function such that `SwellLib.BOT` is not able to call it when bot methods are paused\n* alternatively add an explicit comment to this function stating that it should be callable by `SwellLib.BOT` even when bot methods are paused.\n\nOne possible implementation for the first solution:\n```solidity\nbool isBot = AccessControlManager.hasRole(SwellLib.BOT, msg.sender);\n\n// prevent bot from calling this function when bot methods are paused\nif(isBot && AccessControlManager.botMethodsPaused()) {\n  revert SwellLib.BotMethodsPaused();\n}\n\n// function only callable by admin & bot\nif (!AccessControlManager.hasRole(SwellLib.PLATFORM_ADMIN, msg.sender) && !isBot) {\n  revert OnlyPlatformAdminOrBotCanDeleteActiveValidators();\n}\n```\n\n**Swell:** Fixed in commit [1a105b7](https://github.com/SwellNetwork/v3-contracts-lst/commit/1a105b76899780e30b1fb88abdede11c0c0586ba).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 16,
      "end_line": 51,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`SwellLib.BOT` can delete active validators when bot methods are paused"
    },
    {
      "index": 2,
      "page_start": null,
      "heading": "`SwellLib.BOT` can subtly rug-pull withdrawals by setting `_processedRate = 0` when calling `swEXIT::processWithdrawals`",
      "markdown": "### `SwellLib.BOT` can subtly rug-pull withdrawals by setting `_processedRate = 0` when calling `swEXIT::processWithdrawals`\n\n**Description:** When users create a withdrawal request, their `swETH` is [burned](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L202-L205) then the current exchange rate `rateWhenCreated` is [fetched](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L213) from `swETH::swETHToETHRate`:\n```solidity\nuint256 rateWhenCreated = AccessControlManager.swETH().swETHToETHRate();\n```\n\nHowever `SwellLib.BOT` can [pass an arbitrary value](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L111) for `_processedRate` when calling `swEXIT::processWithdrawals`:\n```solidity\nfunction processWithdrawals(\n  uint256 _lastTokenIdToProcess,\n  uint256 _processedRate\n) external override checkRole(SwellLib.BOT) {\n```\n\nThe [final rate](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L150-L152) used is the lesser of `rateWhenCreated` and `_processedRate`:\n```solidity\nuint256 finalRate = _processedRate > rateWhenCreated\n  ? rateWhenCreated\n  : _processedRate;\n```\n\nThis final rate is [multiplied](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L158) by the requested withdrawal amount to determine the actual amount sent to the user requesting a withdrawal:\n```solidity\nuint256 requestExitedETH = wrap(amount).mul(wrap(finalRate)).unwrap();\n```\n\nHence `SwellLib.BOT` can subtly rug-pull all withdrawals by setting `_processedRate = 0` when calling `swEXIT::processWithdrawals`.\n\n**Recommended Mitigation:** Two possible mitigations:\n1) Change `swEXIT::processWithdrawals` to always fetch the current rate from `swETH::swETHToETHRate`\n2) Only allow `swEXIT::processWithdrawals` to be called by the `RepricingOracle` contract which [calls it correctly](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L130-L132).\n\n**Swell:** Fixed in commits [c6f8708](https://github.com/SwellNetwork/v3-contracts-lst/commit/c6f870847bdf276aee1bf9aeb1ed71771a2aba04), [64cfbdb](https://github.com/SwellNetwork/v3-contracts-lst/commit/64cfbdbf67e28d84f2a706982e28925ab51fd5e6).\n\n**Cyfrin:**\nVerified.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Medium",
      "start_line": 51,
      "end_line": 90,
      "description": null,
      "metadata": {
        "Severity": "Medium",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`SwellLib.BOT` can subtly rug-pull withdrawals by setting `_processedRate = 0` when calling `swEXIT::processWithdrawals`"
    },
    {
      "index": 3,
      "page_start": null,
      "heading": "Precision loss in `swETH::reprice` from unnecessary division before multiplication",
      "markdown": "### Precision loss in `swETH::reprice` from unnecessary division before multiplication\n\n**Description:** `swETH::reprice` [L281-286](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L281-L286) performs unnecessary [division before multiplication](https://dacian.me/precision-loss-errors#heading-division-before-multiplication) when calculating node operator rewards which negatively impacts node operator rewards due to precision loss:\n\n```solidity\nUD60x18 nodeOperatorRewardPortion = wrap(nodeOperatorRewardPercentage)\n  .div(wrap(rewardPercentageTotal));\n\nnodeOperatorRewards = nodeOperatorRewardPortion\n  .mul(rewardsInSwETH) // @audit mult after division\n  .unwrap();\n```\n\nRefactor to perform division after multiplication:\n\n```solidity\nnodeOperatorRewards = wrap(nodeOperatorRewardPercentage)\n  .mul(rewardsInSwETH)\n  .div(wrap(rewardPercentageTotal))\n  .unwrap();\n```\n\nA similar issue occurs when calculating operators reward share [L310-313](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L310-L313):\n\n```solidity\nuint256 operatorsRewardShare = wrap(operatorActiveValidators)\n  .div(totalActiveValidators)\n  .mul(wrap(nodeOperatorRewards)) // @audit mult after division\n  .unwrap();\n```\n\nThis can be similarly refactored to prevent the precision loss by performing multiplication first:\n\n```solidity\nuint256 operatorsRewardShare = wrap(operatorActiveValidators)\n  .mul(wrap(nodeOperatorRewards))\n  .div(totalActiveValidators)\n  .unwrap();\n```\n\nThis issue has not been introduced in the new changes but is in the mainnet code ([1](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L267-L272), [2](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L296-L299)).\n\nThere is still one potential precision loss remaining as `rewardsInSwETH` which has had a [division performed](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L239) then gets [multiplied](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L285) but attempting to refactor this out resulted in a \"stack too deep\" error so it may be unavoidable.\n\n**Swell:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 93,
      "end_line": 140,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Precision loss in `swETH::reprice` from unnecessary division before multiplication"
    },
    {
      "index": 4,
      "page_start": null,
      "heading": "`swEXIT::setWithdrawRequestMaximum` and `setWithdrawRequestMinimum` lacking validation can lead to a state where `withdrawRequestMinimum > withdrawRequestMaximum`",
      "markdown": "### `swEXIT::setWithdrawRequestMaximum` and `setWithdrawRequestMinimum` lacking validation can lead to a state where `withdrawRequestMinimum > withdrawRequestMaximum`\n\n**Description:** Invariant `withdrawRequestMinimum <= withdrawRequestMaximum` must always hold, however this is not checked when new min/max withdraw values are set. Hence it is possible to enter a non-sensical state where `withdrawRequestMinimum > withdrawRequestMaximum`.\n\n**Recommended mitigation:**\n```diff\n  function setWithdrawRequestMaximum(\n    uint256 _withdrawRequestMaximum\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n+   require(withdrawRequestMinimum <= _withdrawRequestMaximum);\n\n    emit WithdrawalRequestMaximumUpdated(\n      withdrawRequestMaximum,\n      _withdrawRequestMaximum\n    );\n    withdrawRequestMaximum = _withdrawRequestMaximum;\n  }\n\n  function setWithdrawRequestMinimum(\n    uint256 _withdrawRequestMinimum\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n+   require(_withdrawRequestMinimum <= withdrawRequestMaximum);\n\n    emit WithdrawalRequestMinimumUpdated(\n      withdrawRequestMinimum,\n      _withdrawRequestMinimum\n    );\n    withdrawRequestMinimum = _withdrawRequestMinimum;\n  }\n```\n\n**Swell:** Fixed in commit [a9dfe5c](https://github.com/SwellNetwork/v3-contracts-lst/commit/a9dfe5cef35404e4e957e8001d571b1cf43feb0a).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 140,
      "end_line": 177,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`swEXIT::setWithdrawRequestMaximum` and `setWithdrawRequestMinimum` lacking validation can lead to a state where `withdrawRequestMinimum > withdrawRequestMaximum`"
    },
    {
      "index": 5,
      "page_start": null,
      "heading": "`swExit::getProcessedRateForTokenId` returns `true` with valid `processedRate` for non-existent `tokenId` input",
      "markdown": "### `swExit::getProcessedRateForTokenId` returns `true` with valid `processedRate` for non-existent `tokenId` input\n\n**Description:** `swExit::getProcessedRateForTokenId` returns `true` with valid `processedRate` for non-existent `tokenId` input.\n\n**Impact:** This `public` function can return valid output for invalid input. Currently it only appears to be used by `finalizeWithdrawal` where this behavior does not seem to be further exploitable as that function checks for non-existent tokens before calling `getProcessedRateForTokenId`.\n\n**Proof of Concept:** Add the following PoC to `getProcessedRateForTokenId.test.ts`:\n```typescript\n  it(\"Should return false for isProcessed when tokens have been processed but this token doesn't exist\", async () => {\n    await createWithdrawRequests(Deployer, 5);\n\n    await swEXIT_Deployer.processWithdrawals(4, parseEther(\"1\"));\n\n    // @audit this test fails\n    expect(await getProcessedRateForTokenId(0)).eql({\n      isProcessed: false,               // @audit returns true\n      processedRate: BigNumber.from(0), // @audit returns > 0\n    });\n  });\n```\n\n**Recommended Mitigation:** `swExit::getProcessedRateForTokenId` should `return(false, 0)` when `tokenId` doesn't exist. It appears that the only edge case which is currently unhandled by this function is when `tokenId = 0`.\n\n**Swell:** Fixed in commits [4c8cbfd](https://github.com/SwellNetwork/v3-contracts-lst/commit/4c8cbfde6fdb54385f8bab83c33f90409fd0a412), [262db73](https://github.com/SwellNetwork/v3-contracts-lst/commit/262db7361f543611237e889313b8022a47b77144).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 177,
      "end_line": 206,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`swExit::getProcessedRateForTokenId` returns `true` with valid `processedRate` for non-existent `tokenId` input"
    },
    {
      "index": 6,
      "page_start": null,
      "heading": "Check for staleness of data when fetching Proof of Reserves via Chainlink `Swell ETH PoR` Oracle",
      "markdown": "### Check for staleness of data when fetching Proof of Reserves via Chainlink `Swell ETH PoR` Oracle\n\n**Description:** `RepricingOracle::_assertRepricingSnapshotValidity` [uses](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L329-L331) the `Swell ETH PoR` Chainlink Proof Of Reserves Oracle to fetch an off-chain data source for Swell's current reserves.\n\nThe Oracle `Swell ETH PoR` is [listed](https://docs.chain.link/data-feeds/proof-of-reserve/addresses?network=ethereum&page=1#networks) on Chainlink's website as having a heartbeat of `86400` seconds (check the \"Show More Details\" box in the top-right corner of the table), however [no staleness check](https://medium.com/SwellNetwork/chainlink-oracle-defi-attacks-93b6cb6541bf#99af) is implemented by `RepricingOracle`:\n```solidity\n// @audit no staleness check\n(, int256 externallyReportedV3Balance, , , ) = AggregatorV3Interface(\n  ExternalV3ReservesPoROracle\n).latestRoundData();\n```\n\n**Impact:** If the `Swell ETH PoR` Chainlink Proof Of Reserves Oracle has stopped functioning correctly, `RepricingOracle::_assertRepricingSnapshotValidity` will continue processing with stale reserve data as if it were fresh.\n\n**Recommended Mitigation:** Implement a staleness check and if the Oracle is stale, either revert or skip using it as the code currently does [if the oracle is not set](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L325-L327).\n\nFor multi-chain deployments ensure that a [correct staleness check is used for each feed](https://medium.com/SwellNetwork/chainlink-oracle-defi-attacks-93b6cb6541bf#fb78) as the same feed can have different heartbeats on different chains.\n\nConsider adding an off-chain bot that periodically checks if the Oracle has become stale and if it has, raises an internal alert for the team to investigate.\n\n**Swell:** Fixed in commit [84a6517](https://github.com/SwellNetwork/v3-contracts-lst/commit/84a65178c31222d80559f6fd5f1b4c60f9249016).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 206,
      "end_line": 232,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Check for staleness of data when fetching Proof of Reserves via Chainlink `Swell ETH PoR` Oracle"
    },
    {
      "index": 7,
      "page_start": null,
      "heading": "`swETH::reprice` may run out of gas or become exorbitantly expensive when scaling to large number of validator operators due to iterating over them all",
      "markdown": "### `swETH::reprice` may run out of gas or become exorbitantly expensive when scaling to large number of validator operators due to iterating over them all\n\n**Description:** `swETH::reprice` [loops](https://github.com/SwellNetwork/v3-contracts-lst/tree/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L303-L321) through all validator operators to pay out their share of rewards:\n```solidity\n// @audit may run out of gas for larger number of validator operators\n// or make repricing exorbitantly expensive\nfor (uint128 i = 1; i <= totalOperators; ) {\n  (\n    address rewardAddress,\n    uint256 operatorActiveValidators\n  ) = nodeOperatorRegistry.getRewardDetailsForOperatorId(i);\n\n  if (operatorActiveValidators != 0) {\n    uint256 operatorsRewardShare = wrap(operatorActiveValidators)\n      .div(totalActiveValidators)\n      .mul(wrap(nodeOperatorRewards))\n      .unwrap();\n\n    _transfer(address(this), rewardAddress, operatorsRewardShare);\n  }\n\n  // Will never overflow as the total operators are capped at uint128\n  unchecked {\n    ++i;\n  }\n}\n```\nIf Swell scales to a large number of validators `swETH::reprice` may revert due to out of gas or make the reprice operation exorbitantly expensive. `NodeOperatorRegistry::getNextValidatorDetails` may be similarly [affected](https://github.com/SwellNetwork/v3-contracts-lst/blob/c9a1e6c06d0f5b358f5c3d4b7644db7a33952444/contracts/implementations/NodeOperatorRegistry.sol#L117-L125).\n\nCurrently this represents a low risk for Swell as the protocol uses a small set of [\"permissioned group of professional node operators\"](https://docs.swellnetwork.io/swell/sweth-liquid-staking/sweth-v1.0-system-design/node-operators-set).\n\nHowever Swell intends to [transition away from](https://docs.swellnetwork.io/swell/sweth-liquid-staking/sweth-v1.0-system-design/node-operators-set) this: _\"The subsequent iterations will see the operator set **expand** and ultimately be permissionless..\"_\n\nAs Swell expands the operator set this issue will become a more serious concern and may require mitigation.\n\n**Swell:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 232,
      "end_line": 270,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`swETH::reprice` may run out of gas or become exorbitantly expensive when scaling to large number of validator operators due to iterating over them all"
    },
    {
      "index": 8,
      "page_start": null,
      "heading": "`NodeOperatorRegistry::updateOperatorControllingAddress` allows to override `_newOperatorAddress` if its address is already assigned to an operator ID",
      "markdown": "### `NodeOperatorRegistry::updateOperatorControllingAddress` allows to override `_newOperatorAddress` if its address is already assigned to an operator ID\n\n**Description:** Current implementation does not check if the new assigned address has already been assigned to an operator ID. As a consequence, its current value can be over written in mapping `getOperatorIdForAddress`, and `getOperatorForOperatorId` will have 2 operator IDs pointing to the same operator.\n\nThe direct consequences of this are on `_getOperatorSafe` and `_getOperatorIdSafe`, which will only return data for the new assigned operator ID.\n\nTherefore:\n* `NodeOperatorRegistry::getOperatorsPendingValidatorDetails` won't be able to return old `_newOperatorAddress` associated validators details\n* `NodeOperatorRegistry::getOperatorsActiveValidatorDetails` won't be able to return old `_newOperatorAddress` associated active validators details\n* `enableOperator` won't be able to enable old operator record\n* **__`disableOperator` won't be able to disable old operator record__**.  This can affect function `usePubKeysForValidatorSetup` given that the protocol won't be able to disable already enabled public key to be used for validator setup given that there is no way to modify previous `getOperatorForOperatorId[_newOperatorAddress].enabled` storage and [force the function to revert](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/NodeOperatorRegistry.sol#L194-L196). Given that the only one allowed to call the function is the BOT by previously calling `DepositManager::setupValidators` the impact is limited.\n* `updateOperatorRewardAddress` won't be able to modify reward address from old operator record\n* `updateOperatorName` won't be able to modify name from old operator record\n\nThis issue has not been introduced in the new changes but is in the mainnet [code](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/NodeOperatorRegistry.sol#L348-L364).\n\n**Proof Of Concept:**\nAdd the following test to `updateOperatorFields.test.ts`:\n```typescript\n    it(\"Should revert updating operator controlling address to existing address\", async () => {\n      // create another operator\n      await NodeOperatorRegistry_Deployer.addOperator(\n        \"OPERATOR_2\",\n        NewOperator.address,\n        NewOperator.address\n      );\n\n      // attempt to update first operator's controlling address to be\n      // the same as the newly created operator - should revert but doesn't\n      await NodeOperatorRegistry_Deployer.updateOperatorControllingAddress(\n        Operator.address,\n        NewOperator.address\n      );\n    });\n```\n\n**Recommended mitigation:**\nCheck that `_newOperatorAddress` is not already assigned to an operator (similar to `addOperator` which [already does this](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/NodeOperatorRegistry.sol#L300-L302), may wish to create a new private or public function for code reuse):\n```diff\n  function updateOperatorControllingAddress(\n    address _operatorAddress,\n    address _newOperatorAddress\n  )\n    external\n    override\n    checkRole(SwellLib.PLATFORM_ADMIN)\n    checkZeroAddress(_newOperatorAddress)\n  {\n\n    if (_operatorAddress == _newOperatorAddress) {\n        revert CannotSetOperatorControllingAddressToSameAddress();\n    }\n+   if(getOperatorIdForAddress[_newOperatorAddress] != 0){\n+       revert CannotUpdateOperatorControllingAddressToAlreadyAssignedAddress();\n+   }\n\n    uint128 operatorId = _getOperatorIdSafe(_operatorAddress);\n\n    getOperatorIdForAddress[_newOperatorAddress] = operatorId;\n    getOperatorForOperatorId[operatorId]\n      .controllingAddress = _newOperatorAddress;\n\n    delete getOperatorIdForAddress[_operatorAddress];\n  }\n```\n\n**Swell:** Fixed in commit [55c7d5f](https://github.com/SwellNetwork/v3-contracts-lst/commit/55c7d5fba6d55c68558dcd15de016927e07e38fd).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 270,
      "end_line": 342,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`NodeOperatorRegistry::updateOperatorControllingAddress` allows to override `_newOperatorAddress` if its address is already assigned to an operator ID"
    },
    {
      "index": 9,
      "page_start": null,
      "heading": "Allowing anyone to finalize any withdrawal can lead to integration problems for smart contract allowed to receive ETH",
      "markdown": "### Allowing anyone to finalize any withdrawal can lead to integration problems for smart contract allowed to receive ETH\n\n**Description:** Current implementation of `swEXIT::finalizeWithdrawal` allows anyone to finalize any withdrawal request which is already processed. However this design decision make the strong assumption that an NFT owner always wants to finalize a withdrawal, which might not be always the case.\n\n**Impact:** Allowing anyone to finalize any withdrawal request already processed can lead to stuck ETH in some smart contracts\n\n**POC:**\nAssume a protocol which goals is facilitating NFT auctions, with auctions that can accept any token or ETH. Bidders has a record for the amount of tokens/ETH they are offering for an NFT, so the smart contract implement a `receive` function to accept ETH.\n\nEve initiate a withdrawal request, but given that she urge for ETH she decide to use this protocol to sell her NFT in an auction. To do this, she must transfer the NFT to the auction contract.\n\nAlice decide to bid for the NFT, and at the end of the auction she wins, now she has to claim the NFT (the auction contract is the owner of the NFT right now).\n\nThe swEXIT NFT is processed before Alice intend to claim it, Eve calls `finalizeWithdrawal` with the NFT in the auction contract, given that this contract is allowed to receive ETH and it is the NFT owner the transaction does not revert, and the ETH associated to the NFT now is stuck forever in the auction contract, Alice cannot claim nothing now.\n\n**Recommended Mitigation:** Only allowed the owner of the NFT to finalize a withdrawal\n\n```diff\n    function finalizeWithdrawal(uint256 tokenId) external override {\n        if (AccessControlManager.withdrawalsPaused()) {\n        revert WithdrawalsPaused();\n        }\n\n        address owner = _ownerOf(tokenId);\n\n-       if (owner == address(0)) {\n-           revert WithdrawalRequestDoesNotExist();\n+       if (owner == msg.sender) {\n+           revert WithdrawalRequestFinalizationOnlyAllowedForNFTOwner();\n        }\n```\n\n**Swell:** Fixed in commit [b5d7a19](https://github.com/SwellNetwork/v3-contracts-lst/commit/b5d7a19e2f6de5c0ae086c8deaac5166767cd3fd).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 342,
      "end_line": 380,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Allowing anyone to finalize any withdrawal can lead to integration problems for smart contract allowed to receive ETH"
    },
    {
      "index": 10,
      "page_start": null,
      "heading": "Multiple attack paths to force `swETH::reprice` to revert by increasing or decreasing swETH total supply",
      "markdown": "### Multiple attack paths to force `swETH::reprice` to revert by increasing or decreasing swETH total supply\n\n**Description:** The current total swETH supply is [used](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L268-L273) in `swETH::reprice` to enforce the maximum allowed total swETH supply difference during repricings. Total supply can decrease for 2 reasons:\n1. [Withdrawal being finalized](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L205)\n2. User calls [`swETH::burn`](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L350-L356) to burn their own swETH\n\nTotal supply can also increase by users calling `swETH::deposit`.\n\nThe closer the current supply difference is to the maximum tolerated difference percentage, the greater chance an attacker can front-run the repricing transaction causing it to revert by:\n1. Depositing a large enough amount of ETH via `swETH::deposit` to increase total supply\n2. Burning their own swETH to decrease total supply\n3. Finalizing one or more withdrawals (users can finalize others withdrawals) to decrease total supply\n\n**Recommended mitigation:**\nSome possible mitigations include:\n* Add a burner role and assigned it only to `swEXIT`, also add the corresponding modifier to check this role to `swETH::burn`\n* Only allow the owner of an NFT to finalize their owned withdrawal requests\n\nHowever these potential mitigations restrict functionality while still enabling an attacker to revert the reprice via the `swETH::deposit` route. Another option would be to have the bot perform the repricing transaction through a service such as [flashbots](https://www.flashbots.net/) such that the transaction can't be front-run; this would prevent all of the attack paths while still preserving the ability for users to burn their swETH and to finalize others withdrawals.\n\n**Swell:** Using flashbots to perform repricing transactions.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 380,
      "end_line": 403,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Multiple attack paths to force `swETH::reprice` to revert by increasing or decreasing swETH total supply"
    },
    {
      "index": 11,
      "page_start": null,
      "heading": "Rewards unable to be distributed when all active validators are deleted during repricing",
      "markdown": "### Rewards unable to be distributed when all active validators are deleted during repricing\n\n**Description:** Invariant fuzzing found an interesting edge-case during repricing if:\n\n1) there are rewards to distribute which were accrued in the last period,\n2) all the current active validators are being deleted in the repricing operation\n\nBecause the validators are [deleted first](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L114-L122) the reprice transaction reverts with `NoActiveValidators` [error](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L298-L300).\n\nNo repricings will be possible until new active validators are added, and when that occurs the new validators will receive the rewards that were generated by the old validators which were deleted. Additionally Aaron confirmed on TG: _it is theoretically possible for fees to be generated without any active validators as any ETH sent to the `DepositManager` is considered rewards and eligible for fees._\n\n**Recommended Mitigation:** During repricing if there are no active validators but rewards to be distributed, instead of reverting the rewards should go to the Swell treasury.\n\n**Swell:** Fixed in commit [5594e20](https://github.com/SwellNetwork/v3-contracts-lst/commit/5594e204083a8507e69f0c28f4d1d7162f9a20fd).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 403,
      "end_line": 422,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Rewards unable to be distributed when all active validators are deleted during repricing"
    },
    {
      "index": 12,
      "page_start": null,
      "heading": "Repricing with small rewards results in an invalid state where `ETH` reserves increase, `swETH to ETH` exchange rate increases, but no rewards are paid out to operators or treasury",
      "markdown": "### Repricing with small rewards results in an invalid state where `ETH` reserves increase, `swETH to ETH` exchange rate increases, but no rewards are paid out to operators or treasury\n\n**Description:** Invariant fuzzing used repricings with small rewards to reach an invalid state where `ETH` reserves increase, `swETH : ETH` exchange rate increases, but no rewards are paid out to operators or treasury.\n\n**Proof of Concept:** During repricing:\n1) there is no minimum value enforced by either `RepricingOracle` for [`_snapshot.rewardsPayableForFees`](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L227) or `swETH::reprice` for `_newETHRewards`\n2) in `swETH::reprice` there is no check for rounding down to zero precision loss when [calculating](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L239-L241) `rewardsInSwETH`\n\nThis results in the fuzzer reaching an invalid state where:\n1) by calling `RepricingOracle::submitSnapshotV2` with small values for `_snapshot.rewardsPayableForFees`, this results in `swETH::reprice` being called with small `_newETHRewards`\n2) inside `swETH::reprice` the small `_newETHRewards` triggers a rounding down to zero precision loss in the rewards calculation of `rewardsInSwETH` so [rewards are never distributed](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L278)\n3) however `swETH::reprice` does [update](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L337) `lastRepriceETHReserves` using the small positive `_newETHRewards` value and the transaction completes successfully.\n\nThis results in an invalid state where:\n\n1) `swETH::lastRepriceETHReserves` increases\n2) `swETH : ETH` exchange rate increases\n3) no rewards are being paid out to operators/treasury\n\nThis simplified PoC can be added to `reprice.test.ts`:\n```typescript\n    it(\"audit small rewards not distributed while reserves and exchange rate increasing\", async () => {\n      const swellTreasuryRewardPercentage = parseEther(\"0.1\");\n\n      await swETH_Deployer.setSwellTreasuryRewardPercentage(\n        swellTreasuryRewardPercentage\n      );\n\n      await swETH_Deployer.deposit({\n        value: parseEther(\"1000\"),\n      });\n      const preRewardETHReserves = parseEther(\"1100\");\n\n      const swETHSupply = parseEther(\"1000\");\n\n      const ethRewards = parseUnits(\"1\", \"wei\");\n\n      const swellTreasuryPre = await swETH_Deployer.balanceOf(SwellTreasury.address);\n      const ethReservesPre = await swETH_Deployer.lastRepriceETHReserves();\n      const rateBefore = await swETH_Deployer.swETHToETHRate();\n\n      swETH_Bot.reprice(\n          preRewardETHReserves,\n          ethRewards,\n          swETH_Deployer.totalSupply());\n\n      const swellTreasuryPost = await swETH_Deployer.balanceOf(SwellTreasury.address);\n      const ethReservesPost = await swETH_Deployer.lastRepriceETHReserves();\n      const rateAfter = await swETH_Deployer.swETHToETHRate();\n\n      // no rewards distributed to treasury\n      expect(swellTreasuryPre).eq(swellTreasuryPost);\n\n      // exchange rate increases\n      expect(rateBefore).lt(rateAfter);\n\n      // reserves increase\n      expect(ethReservesPre).lt(ethReservesPost);\n\n      // repricing using small `_newETHRewards` can lead to increasing reserves\n      // and increasing exchange rate without reward payouts\n    });\n```\n\nThis was not introduced in the new changes but is present in the current mainnet code [[1](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L264), [2](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L323-L325)].\n\n**Swell:** Acknowledged.\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 422,
      "end_line": 491,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Repricing with small rewards results in an invalid state where `ETH` reserves increase, `swETH to ETH` exchange rate increases, but no rewards are paid out to operators or treasury"
    },
    {
      "index": 13,
      "page_start": null,
      "heading": "Precision loss in `swETH::_deposit` from unnecessary hidden division before multiplication",
      "markdown": "### Precision loss in `swETH::_deposit` from unnecessary hidden division before multiplication\n\n**Description:** `swETH::_deposit` [L170](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L170) contains a hidden unnecessary [division before multiplication](https://dacian.me/precision-loss-errors#heading-division-before-multiplication) as the call to `_ethToSwETHRate` performs a division which then gets multiplied by `msg.value`:\n```solidity\nuint256 swETHAmount = wrap(msg.value).mul(_ethToSwETHRate()).unwrap();\n// @audit expanding this out\n// wrap(msg.value).mul(_ethToSwETHRate()).unwrap();\n// wrap(msg.value).mul(wrap(1 ether).div(_swETHToETHRate())).unwrap();\n```\n\nThis issue has not been introduced in the new changes but is in the mainnet [code](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L170).\n\n**Impact:** Slightly less `swETH` will be minted to depositors. While the amount by which individual depositors are short-changed is individually small, the effect is cumulative and increases as depositors and deposit size increase.\n\n**Proof of Concept:** This stand-alone stateless fuzz test can be run inside Foundry to prove this as well as provided hard-coded test cases:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {UD60x18, wrap} from \"@prb/math/src/UD60x18.sol\";\n\nimport \"forge-std/Test.sol\";\n\n// run from base project directory with:\n// (fuzz test) forge test --match-test FuzzMint -vvv\n// (hardcoded) forge test --match-test HardcodedMint -vvv\ncontract MintTest is Test {\n\n    uint256 private constant SWETH_ETH_RATE = 1050754209601187151; //as of 2024-02-15\n\n    function _mintOriginal(uint256 inputAmount) private pure returns(uint256) {\n        // hidden division before multiplication\n        // wrap(inputAmount).mul(_ethToSwETHRate()).unwrap();\n        // wrap(inputAmount).mul(wrap(1 ether).div(_swETHToETHRate())).unwrap()\n\n        return wrap(inputAmount).mul(wrap(1 ether).div(wrap(SWETH_ETH_RATE))).unwrap();\n    }\n\n    function _mintFixed(uint256 inputAmount) private pure returns(uint256) {\n        // refactor to perform multiplication before division\n        // wrap(inputAmount).mul(wrap(1 ether)).div(_swETHToETHRate()).unwrap();\n\n        return wrap(inputAmount).mul(wrap(1 ether)).div(wrap(SWETH_ETH_RATE)).unwrap();\n    }\n\n    function test_FuzzMint(uint256 inputAmount) public pure {\n        uint256 resultOriginal = _mintOriginal(inputAmount);\n        uint256 resultFixed    = _mintFixed(inputAmount);\n\n        assert(resultOriginal == resultFixed);\n    }\n\n    function test_HardcodedMint() public {\n        // found by fuzzer\n        console.log(_mintFixed(3656923177187149889) - _mintOriginal(3656923177187149889)); // 1\n\n        // 100 eth\n        console.log(_mintFixed(100 ether) - _mintOriginal(100 ether)); // 21\n\n        // 1000 eth\n        console.log(_mintFixed(1000 ether) - _mintOriginal(1000 ether)); // 215\n\n        // 10000 eth\n        console.log(_mintFixed(10000 ether) - _mintOriginal(10000 ether)); // 2159\n    }\n}\n```\n\n**Recommended Mitigation:** Refactor to perform multiplication before division:\n```solidity\nuint256 swETHAmount = wrap(msg.value).mul(wrap(1 ether)).div(_swETHToETHRate()).unwrap();\n```\n\n**Swell:** Fixed in commit [cb093ea](https://github.com/SwellNetwork/v3-contracts-lst/commit/cb093eac675e5248a3f736a01a3725d794dd177e).\n\n**Cyfrin:**\nVerified.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Low",
      "start_line": 491,
      "end_line": 570,
      "description": null,
      "metadata": {
        "Severity": "Low",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Precision loss in `swETH::_deposit` from unnecessary hidden division before multiplication"
    },
    {
      "index": 14,
      "page_start": null,
      "heading": "Emit `ETHSent` event when sending eth",
      "markdown": "### Emit `ETHSent` event when sending eth\n\n**Description:** `DepositManager::receive` emits an `ETHReceived` event when receiving eth, but `transferETHForWithdrawRequests` does not emit any events when sending eth; consider also emitting an `ETHSent` event when sending eth.\n\n**Swell:** Fixed in commit [c82dd3c](https://github.com/SwellNetwork/v3-contracts-lst/commit/c82dd3c8ca6853816dd9f1982ab0a5ef50d78cf2).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 573,
      "end_line": 583,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Emit `ETHSent` event when sending eth"
    },
    {
      "index": 15,
      "page_start": null,
      "heading": "Use Checks-Effects-Interactions pattern in `swEXIT::createWithdrawRequest`",
      "markdown": "### Use Checks-Effects-Interactions pattern in `swEXIT::createWithdrawRequest`\n\n**Description:** The current implementation uses [`_safeMint`](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L209) before modifying state variables:\n* `withdrawalRequests[tokenId] `\n* `exitingETH`\n* `_lastTokenIdCreated`\n\nThis allows possible re-entrancy where the receiver and access the non-updated state variables. While during the audit no meaningful permissionless attack vectors related to this issue were found, to follow best security practices it is advisable to move `_safeMint` to the end of the function:\n\n```diff\n  function createWithdrawRequest(\n    uint256 amount\n  ) external override checkWhitelist(msg.sender) {\n    if (AccessControlManager.withdrawalsPaused()) {\n      revert WithdrawalsPaused();\n    }\n\n    if (amount < withdrawRequestMinimum) {\n      revert WithdrawRequestTooSmall(amount, withdrawRequestMinimum);\n    }\n\n    if (amount > withdrawRequestMaximum) {\n      revert WithdrawRequestTooLarge(amount, withdrawRequestMaximum);\n    }\n\n    IswETH swETH = AccessControlManager.swETH();\n    swETH.transferFrom(msg.sender, address(this), amount);\n\n    // Burn the tokens first to prevent reentrancy and to validate they own the requested amount of swETH\n    swETH.burn(amount);\n\n-   uint256 tokenId = _lastTokenIdCreated + 1; // Start off at 1\n+   uint256 tokenId = ++_lastTokenIdCreated; // Starts off at 1\n\n-   _safeMint(msg.sender, tokenId);\n\n    uint256 lastTokenIdProcessed = getLastTokenIdProcessed();\n\n    uint256 rateWhenCreated = AccessControlManager.swETH().swETHToETHRate();\n\n    withdrawalRequests[tokenId] = WithdrawRequest({\n      amount: amount,\n      timestamp: block.timestamp,\n      lastTokenIdProcessed: lastTokenIdProcessed,\n      rateWhenCreated: rateWhenCreated\n    });\n\n    exitingETH += wrap(amount).mul(wrap(rateWhenCreated)).unwrap();\n-   _lastTokenIdCreated = tokenId;\n+   _safeMint(msg.sender, tokenId);\n\n    emit WithdrawRequestCreated(\n      tokenId,\n      amount,\n      block.timestamp,\n      lastTokenIdProcessed,\n      rateWhenCreated,\n      msg.sender\n    );\n\n  }\n```\n\n**Swell:** Fixed in commits [d13aa43](https://github.com/SwellNetwork/v3-contracts-lst/commit/d13aa4390bb75c4e491b9cd92b7f7561cbe4ec15), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/commit/3f85df3ba0e91b26e4234b15ad94f492fa6d46ec).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 583,
      "end_line": 652,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Use Checks-Effects-Interactions pattern in `swEXIT::createWithdrawRequest`"
    },
    {
      "index": 16,
      "page_start": null,
      "heading": "Missing events in `NodeOperatorRegistry` update methods",
      "markdown": "### Missing events in `NodeOperatorRegistry` update methods\n\n**Description:** The following functions in `NodeOperatorRegistry` update multiple storage locations but don't emit any events:\n* `updateOperatorControllingAddress`\n* `updateOperatorRewardAddress`\n* `updateOperatorName`\n\nConsider emitting events in these functions to reflect the updates made to storage.\n\n**Swell:** Fixed in commit [5849640](https://github.com/SwellNetwork/v3-contracts-lst/commit/584964072b1543128c02e3287fe7746a8a094226).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 652,
      "end_line": 667,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Missing events in `NodeOperatorRegistry` update methods"
    },
    {
      "index": 17,
      "page_start": null,
      "heading": "Refactor identical code in `NodeOperatorRegistry::getNextValidatorDetails`",
      "markdown": "### Refactor identical code in `NodeOperatorRegistry::getNextValidatorDetails`\n\n**Description:** The bodies of these two `else if` [branches](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/NodeOperatorRegistry.sol#L151-L162) are identical:\n\n```solidity\n} else if (foundOperatorId == 0) {\n  // If no operator has been found yet set the smallest operator active keys to the current operator\n  smallestOperatorActiveKeys = operatorActiveKeys;\n\n  foundOperatorId = operatorId;\n\n  // If the current operator has less keys than the smallest operator active keys, then we want to use this operator\n} else if (smallestOperatorActiveKeys > operatorActiveKeys) {\n  smallestOperatorActiveKeys = operatorActiveKeys;\n\n  foundOperatorId = operatorId;\n}\n```\n\nHence the code can be simplified to:\n```solidity\n// If no operator has been found yet set the smallest operator active keys to the current operator\n// If the current operator has less keys than the smallest operator active keys, then we want to use this operator\n} else if (foundOperatorId == 0 ||\n           smallestOperatorActiveKeys > operatorActiveKeys) {\n  smallestOperatorActiveKeys = operatorActiveKeys;\n  foundOperatorId = operatorId;\n}\n```\n\n**Swell:** Fixed in commit [d457d8d](https://github.com/SwellNetwork/v3-contracts-lst/commit/d457d8d109770f86b2b6ab3f785e1678ca341d6f).\n\n**Cyfrin:**\nVerified.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Informational",
      "start_line": 667,
      "end_line": 703,
      "description": null,
      "metadata": {
        "Severity": "Informational",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Refactor identical code in `NodeOperatorRegistry::getNextValidatorDetails`"
    },
    {
      "index": 18,
      "page_start": null,
      "heading": "Cache storage variables in memory when read multiple times without being changed",
      "markdown": "### Cache storage variables in memory when read multiple times without being changed\n\n**Description:** As reading from storage is considerably more expensive than reading from memory, cache storage variables in memory when read multiple times without being changed:\n\nFile: `NodeOperatorRegistry.sol`\n```solidity\n// @audit cache `numOperators` in memory from storage\n// to prevent reading same value multiple times\n113:    uint128[] memory operatorAssignedDetails = new uint128[](numOperators + 1);\n125:     for (uint128 operatorId = 1; operatorId <= numOperators; operatorId++) {\n\n// @audit save incremented value in memory\n// to prevent reading same value multiple times, eg:\n// uint128 newNumOperators = ++numOperators;\n305:    numOperators += 1;\n// then use `newNumOperators` in L314,315\n314:    getOperatorIdForAddress[_operatorAddress] = numOperators;\n315:    getOperatorForOperatorId[numOperators] = operator;\n// @audit `Operator` struct can also be initialized this way:\n// getOperatorForOperatorId[numOperators] = Operator(true, _rewardAddress, _operatorAddress, _name, 0);\n\n// @audit cache `getOperatorForOperatorId[operatorId].activeValidators`\n660:    if (getOperatorForOperatorId[operatorId].activeValidators == 0) {\n666:      getOperatorForOperatorId[operatorId].activeValidators - 1\n```\n\nFile: `RepricingOracle.sol`\n```solidity\n// @audit cache rate when checked after repricing and use\n// cached version when processing withdrawals since the rate\n// only changes during repricing which has already occurred\n125:    if (swETHToETHRate > AccessControlManager.swETH().swETHToETHRate()) {\n132:        AccessControlManager.swETH().swETHToETHRate() // The rate to use for processing withdrawals\n\n// @audit cache `upgradeableRepriceSnapshot.meta.blockNumber` in memory from storage\n// to prevent reading same value multiple times\n290:    bool useOldSnapshot = upgradeableRepriceSnapshot.meta.blockNumber == 0;\n294:      : upgradeableRepriceSnapshot.meta.blockNumber;\n\n// @audit cache `maximumRepriceBlockAtSnapshotStaleness` in memory from storage\n// to prevent reading same value multiple times\n317:    if (snapshotStalenessInBlocks > maximumRepriceBlockAtSnapshotStaleness) {\n320:        maximumRepriceBlockAtSnapshotStaleness\n```\n\nFile: `swETH.sol`\n```solidity\n// @audit cache `lastRepriceUNIX` in memory from storage\n// to prevent reading same value multiple times\n222:    uint256 timeSinceLastReprice = block.timestamp - lastRepriceUNIX;\n249:    if (lastRepriceUNIX != 0) {\n\n// @audit cache `minimumRepriceTime` in memory from storage\n// to prevent reading same value multiple times\n224:    if (timeSinceLastReprice < minimumRepriceTime) {\n226:        minimumRepriceTime - timeSinceLastReprice\n\n// @audit cache `nodeOperatorRewardPercentage` in memory from storage\n// to prevent reading same value multiple times\n233:      nodeOperatorRewardPercentage;\n281:      UD60x18 nodeOperatorRewardPortion = wrap(nodeOperatorRewardPercentage)\n\n// @audit cache `swETHToETHRateFixed` in memory from storage\n// to prevent reading same value multiple times\n253:        swETHToETHRateFixed\n256:      uint256 maximumRepriceDiff = wrap(swETHToETHRateFixed)\n\n// @audit no need to re-read storage values, use the in-memory variables\n// that storage locations were just updated from to eliminate redundant but\n// expensive storage reads\n337:    lastRepriceETHReserves = totalReserves;\n338:    lastRepriceUNIX = block.timestamp;\n339:    swETHToETHRateFixed = updatedSwETHToETHRateFixed;\n\n341:   emit Reprice(\n342:      lastRepriceETHReserves, // @audit use `totalReserves` instead\n343:       swETHToETHRateFixed,   // @audit use `updatedSwETHToETHRateFixed` instead\n344:       nodeOperatorRewards,\n345:       swellTreasuryRewards,\n346:       totalETHDeposited\n\n// @audit the first check will fail most of the time during regular usage so\n// `swETHToETHRateFixed` will be read twice from storage with the same value\n374:    if (swETHToETHRateFixed == 0) {\n375:    return wrap(swETHToETHRateFixed);\n```\n\nFile: `swEXIT.sol`\n```solidity\n// @audit consider caching `withdrawRequestMinimum` and `withdrawRequestMaximum`\n// in memory to avoid an extra storage read in the revert case\n193:    if (amount < withdrawRequestMinimum) {\n194:       revert WithdrawRequestTooSmall(amount, withdrawRequestMinimum);\n195:     }\n\n197:     if (amount > withdrawRequestMaximum) {\n198:      revert WithdrawRequestTooLarge(amount, withdrawRequestMaximum);\n199:     }\n```\n\n**Swell:** Fixed in commits [23be897](https://github.com/SwellNetwork/v3-contracts-lst/commit/23be89740b7659ab4d98435d6a924364635fb9ca), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/commit/3f85df3ba0e91b26e4234b15ad94f492fa6d46ec).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 706,
      "end_line": 812,
      "description": null,
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Cache storage variables in memory when read multiple times without being changed"
    },
    {
      "index": 19,
      "page_start": null,
      "heading": "Cache array length outside of loops and consider unchecked loop incrementing",
      "markdown": "### Cache array length outside of loops and consider unchecked loop incrementing\n\n**Description:** Cache array length outside of loops and consider using `unchecked {++i;}` if not compiling with `solc --ir-optimized --optimize`:\n\nFile: `DepositManager.sol`\n```solidity\n// @audit cache `validatorDetails.length`\n116:    for (uint256 i; i < validatorDetails.length; i++) {\n```\n\nFile: `NodeOperatorRegistry.sol`\n```solidity\n// @audit cache `numOperators`\n133:    uint128[] memory operatorAssignedDetails = new uint128[](numOperators + 1);\n125:      for (uint128 operatorId = 1; operatorId <= numOperators; operatorId++) {\n\n// @audit cache `_pubKeys.length`\n189:    validatorDetails = new ValidatorDetails[](_pubKeys.length);\n191:    for (uint256 i; i < _pubKeys.length; i++) {\n227:    numPendingValidators -= _pubKeys.length;\n\n// @audit cache `_validatorDetails.length`\n243:    if (_validatorDetails.length == 0) {\n257:        _validatorDetails.length >\n263:    for (uint128 i; i < _validatorDetails.length; i++) {\n282:    numPendingValidators += _validatorDetails.length;\n\n// @audit cache `_pubKeys.length`\n396:    for (uint128 i; i < _pubKeys.length; i++) {\n412:     numPendingValidators -= _pubKeys.length;\n\n// @audit cache `_pubKeys.length`\n425:     for (uint256 i; i < _pubKeys.length; i++) {\n\n// @audit cache `operatorIdToValidatorDetails[operatorId].length()`\n628:     if (operatorIdToValidatorDetails[operatorId].length() == 0) {\n634:      operatorIdToValidatorDetails[operatorId].length() - 1\n```\n\nFile: `swEXIT.sol`\n```solidity\n// @audit cache `requestsToProcess + 1`\n143:    for (uint256 i = 1; i < requestsToProcess + 1; ) {\n```\n\nFile: `Whitelist.sol`\n```solidity\n// @audit cache `_addresses.length`\n 84:    for (uint256 i; i < _addresses.length; ) {\n102:    for (uint256 i; i < _addresses.length; ) {\n```\n\n**Swell:** Fixed in commits [3c67e88](https://github.com/SwellNetwork/v3-contracts-lst/commit/3c67e88dbea1bb4cdf0bfeda27b40e71e494ef2c), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/commit/3f85df3ba0e91b26e4234b15ad94f492fa6d46ec).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 812,
      "end_line": 870,
      "description": null,
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Cache array length outside of loops and consider unchecked loop incrementing"
    },
    {
      "index": 20,
      "page_start": null,
      "heading": "`NodeOperatorRegistry::_parsePubKeyToString`: Use shift operations rather than division/multiplication when dividend/factor is a power of 2",
      "markdown": "### `NodeOperatorRegistry::_parsePubKeyToString`: Use shift operations rather than division/multiplication when dividend/factor is a power of 2\n\n**Description:** While `DIV` and `MUL` opcodes cost 5 gas unit each, shift operations cost 3 gas units. Therefore, `NodeOperatorRegistry::_parsePubKeyToString` can take advantage of them to save gas:\n\n```diff\n+   uint256 private SYMBOL_LENGTH = 16 // Because _SYMBOLS.length = 16\n    function _parsePubKeyToString(\n        bytes memory pubKey\n    ) internal pure returns (string memory) {\n        // Create the bytes that will hold the converted string\n-      bytes memory buffer = new bytes(pubKey.length * 2);\n+       // make sure that pubKey.length * 2 <= 2^256\n+      bytes memory buffer = new bytes(pubKey.length << 1);\n\n        bytes16 symbols = _SYMBOLS;\n+       uint256 symbolLength = symbols.length;\n+       uint256 index;\n        for (uint256 i; i < pubKey.length; i++) {\n-           buffer[i * 2] = symbols[uint8(pubKey[i]) / symbols.length];\n-           buffer[i * 2 + 1] = symbols[uint8(pubKey[i]) % symbols.length];\n+           index = i << 1; // i * 2\n+           buffer[index] = symbols[uint8(pubKey[i]) >> 4]; // SYMBOL_LENGTH = 2^4\n+           buffer[index + 1] = symbols[uint8(pubKey[i]) % SYMBOL_LENGTH];\n        }\n\n        return string(abi.encodePacked(\"0x\", buffer));\n    }\n```\n\nA more optimized version of this function looks like:\n```solidity\nbytes16 private constant _SYMBOLS = \"0123456789abcdef\";\nuint256 private constant SYMBOL_LENGTH = 16; // Because _SYMBOLS.length = 16\n\nfunction _parsePubKeyToString(bytes memory pubKey) internal pure returns (string memory) {\n    // Create the bytes that will hold the converted string\n    // make sure that pubKey.length * 2 <= 2^256\n    uint256 pubKeyLength  = pubKey.length;\n    bytes memory buffer   = new bytes(pubKeyLength << 1);\n\n    uint256 index;\n    for (uint256 i; i < pubKeyLength;) {\n        index             = i << 1; // i * 2\n        buffer[index]     = _SYMBOLS[uint8(pubKey[i]) >> 4]; // SYMBOL_LENGTH = 2^4\n        buffer[index + 1] = _SYMBOLS[uint8(pubKey[i]) % SYMBOL_LENGTH];\n\n        unchecked {++i;}\n    }\n\n    return string(abi.encodePacked(\"0x\", buffer));\n}\n```\n\nThe following stand-alone test using Foundry & [Halmos](https://github.com/a16z/halmos/) verifies that the optimized version returns the same output as the original:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"forge-std/Test.sol\";\n\n// run from base project directory with:\n// halmos --function test --match-contract ParseTest\ncontract ParseTest is Test {\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint256 private constant SYMBOL_LENGTH = 16; // Because _SYMBOLS.length = 16\n\n    function _parseOriginal(bytes memory pubKey) internal pure returns (string memory) {\n        // Create the bytes that will hold the converted string\n        bytes memory buffer = new bytes(pubKey.length * 2);\n\n        bytes16 symbols = _SYMBOLS;\n\n        // This conversion relies on taking the uint8 value of each byte, the first character in the byte is the uint8 value divided by 16 and the second character is modulo of the 16 division\n        for (uint256 i; i < pubKey.length; i++) {\n            buffer[i * 2] = symbols[uint8(pubKey[i]) / symbols.length];\n            buffer[i * 2 + 1] = symbols[uint8(pubKey[i]) % symbols.length];\n        }\n\n        return string(abi.encodePacked(\"0x\", buffer));\n    }\n\n    function _parseOptimized(bytes memory pubKey) internal pure returns (string memory) {\n        // Create the bytes that will hold the converted string\n        // make sure that pubKey.length * 2 <= 2^256\n        uint256 pubKeyLength  = pubKey.length;\n        bytes memory buffer   = new bytes(pubKeyLength << 1);\n\n        uint256 index;\n        for (uint256 i; i < pubKeyLength;) {\n            index             = i << 1; // i * 2\n            buffer[index]     = _SYMBOLS[uint8(pubKey[i]) >> 4]; // SYMBOL_LENGTH = 2^4\n            buffer[index + 1] = _SYMBOLS[uint8(pubKey[i]) % SYMBOL_LENGTH];\n\n            unchecked {++i;}\n        }\n\n        return string(abi.encodePacked(\"0x\", buffer));\n    }\n\n    function test_HalmosParse(bytes memory pubKey) public {\n        string memory resultOriginal  = _parseOriginal(pubKey);\n        string memory resultOptimized = _parseOptimized(pubKey);\n\n        assertEq(resultOriginal, resultOptimized);\n\n    }\n}\n```\n\n**Swell:** Fixed in commits [7db1874](https://github.com/SwellNetwork/v3-contracts-lst/commit/7db187409c7161d981b32d639e8b925fafc431a8), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/commit/3f85df3ba0e91b26e4234b15ad94f492fa6d46ec).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 870,
      "end_line": 987,
      "description": null,
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "`NodeOperatorRegistry::_parsePubKeyToString`: Use shift operations rather than division/multiplication when dividend/factor is a power of 2"
    },
    {
      "index": 21,
      "page_start": null,
      "heading": "Use `totalReserves - rewardsInETH.unwrap()` rather than `_preRewardETHReserves - rewardsInETH.unwrap() + _newETHRewards` in `swETH::reprice`",
      "markdown": "### Use `totalReserves - rewardsInETH.unwrap()` rather than `_preRewardETHReserves - rewardsInETH.unwrap() + _newETHRewards` in `swETH::reprice`\n\n**Description:** Both result in the same output but the first expression saves a `SUB` opcode. In addition the suggested modification results in simpler code which better reflects the intention of the invariant.\n\n```diff\n    // swETH::reprice\n    uint256 totalReserves = _preRewardETHReserves + _newETHRewards;\n\n    uint256 rewardPercentageTotal = swellTreasuryRewardPercentage +\n      nodeOperatorRewardPercentage;\n\n    UD60x18 rewardsInETH = wrap(_newETHRewards).mul(\n      wrap(rewardPercentageTotal)\n    );\n\n    UD60x18 rewardsInSwETH = wrap(_swETHTotalSupply).mul(rewardsInETH).div(\n-       wrap(_preRewardETHReserves - rewardsInETH.unwrap() + _newETHRewards)\n+       wrap(totalReserves - rewardsInETH.unwrap())\n    );\n```\n\n**Swell:** Fixed in commit [7db1874](https://github.com/SwellNetwork/v3-contracts-lst/commit/7db187409c7161d981b32d639e8b925fafc431a8).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 987,
      "end_line": 1014,
      "description": null,
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Use `totalReserves - rewardsInETH.unwrap()` rather than `_preRewardETHReserves - rewardsInETH.unwrap() + _newETHRewards` in `swETH::reprice`"
    },
    {
      "index": 22,
      "page_start": null,
      "heading": "Remove redundant pause checks",
      "markdown": "### Remove redundant pause checks\n\n**Description:** 1) Remove redundant `botMethodsPaused` [check](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L208-L210) in `swETH::reprice` as:\n\n* this function is only called by [`RepricingOracle::handleReprice`](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L233)\n* `RepricingOracle::handleReprice` can only be called by [`submitSnapshot`](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L89-L94) and [`submitSnapshotV2`](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L105-L112) which both already contain the `botMethodsPaused` check.\n\n2) Remove redundant `withdrawalsPaused` [check](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swEXIT.sol#L117-L119) in `swEXIT::processWithdrawals` as this function is only supposed to be callable by `RepricingOracle` which already [contains](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L129) the check.\n\n**Swell:** Fixed in commits [1fca965](https://github.com/SwellNetwork/v3-contracts-lst/commit/1fca965019facc4dcc79c35bfc45c8a711043196), [3f85df3](https://github.com/SwellNetwork/v3-contracts-lst/commit/3f85df3ba0e91b26e4234b15ad94f492fa6d46ec).\n\n**Cyfrin:**\nVerified.\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 1014,
      "end_line": 1029,
      "description": null,
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Remove redundant pause checks"
    },
    {
      "index": 23,
      "page_start": null,
      "heading": "Refactor `RepricingOracle::handleReprice`, `_assertRepricingSnapshotValidity` and `_repricingPeriodDeltas`",
      "markdown": "### Refactor `RepricingOracle::handleReprice`, `_assertRepricingSnapshotValidity` and `_repricingPeriodDeltas`\n\n**Description:** In `RepricingOracle::_assertRepricingSnapshotValidity` and `_repricingPeriodDeltas` there is a lot of logic around whether to use the old snapshot or not, based around if `upgradeableRepriceSnapshot.meta.blockNumber == 0`.\n\nIf the idea is that the first time repricing occurs after the upgrade the execution path is `useOldSnapshot = true` but after that every time it will be `useOldSnapshot = false`, then it may make more sense to create functions just for that first execution which will only run once, then have functions for all the normal cases which come afterwards. This would avoid the extra gas costs and also simplify the code for all the future normal cases after the first-time-call special case.\n\nGas costs can also be reduced by having `handleReprice` load the snapshot struct, cache `upgradeableRepriceSnapshot.meta.blockNumber`, calculate `useOldSnapshot` once then pass these in as inputs to `_assertRepricingSnapshotValidity` and `_repricingPeriodDeltas` eg:\n\n```solidity\n\n  function handleReprice(\n    UpgradeableRepriceSnapshot calldata _snapshot\n  ) internal {\n    // only call getSnapshotStruct() once\n    UpgradeableRepriceSnapshot\n      storage upgradeableRepriceSnapshot = getSnapshotStruct();\n\n    // only calculate these once and pass them as required\n    uint256 ursMetaBlockNumber = upgradeableRepriceSnapshot.meta.blockNumber;\n    bool useOldSnapshot = ursMetaBlockNumber == 0;\n\n    // validation\n    _assertRepricingSnapshotValidity(_snapshot, ursMetaBlockNumber, useOldSnapshot);\n\n    _repricingPeriodDeltas(\n          reserveAssets,\n          _snapshot.state,\n          _snapshot.withdrawState,\n          upgradeableRepriceSnapshot,\n          useOldSnapshot\n        );\n\n    // delete the call to getSnapshotStruct() near the end of handleReprice()\n```\n\n\n**Swell:** Acknowledged. Will be addressed in a future upgrade when the old snapshot is no longer relevant. Swell will continue to pay the excess gas costs in the meantime.\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 1029,
      "end_line": 1068,
      "description": null,
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Refactor `RepricingOracle::handleReprice`, `_assertRepricingSnapshotValidity` and `_repricingPeriodDeltas`"
    },
    {
      "index": 24,
      "page_start": null,
      "heading": "Use constant for unchanging deposit amount",
      "markdown": "### Use constant for unchanging deposit amount\n\n**Description:** In `DepositManager::setupValidators` there is no use in paying gas to declare then later read this variable which never changes:\n```solidity\nuint256 depositAmount = 32 ether;\n```\n\nRather simply define a constant:\n```solidity\nuint256 private constant DEPOSIT_AMOUNT = 32 ether;\n```\nAnd use that constant instead.\n\n**Swell:** Acknowledged.\n\n\\clearpage\n",
      "finding_id": null,
      "severity": "Gas",
      "start_line": 1068,
      "end_line": 1084,
      "description": null,
      "metadata": {
        "Severity": "Gas",
        "Difficulty": null,
        "Type": null,
        "Finding ID": null,
        "Target": null
      },
      "heading_cleaned": "Use constant for unchanging deposit amount"
    }
  ]
}