{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-001", "doc_id": "sigmaprime_dimo_review", "finding_index": 1, "page_start": 6, "title": "Removal of ERC20VotesUpgradeable Might Allow Double Voting", "short_summary": null, "description_md": "#### **Description**\n\nBecause it was not possible to run a governance propose/vote test, this vulnerability could not be further investigated, however it is a concern that OpenZeppelin's ERC20VotesUpgradeable contract was removed between this version of the token and its predecessor.\n\nTo quote OpenZeppelin's Documentation:\n\n*\"This extension will keep track of historical balances so that voting power is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.\"*\n", "full_markdown": "| DMO-01 | Removal of ERC20VotesUpgradeable Might Allow Double Voting |              |                    |\n|--------|------------------------------------------------------------|--------------|--------------------|\n| Asset  | DimoV2.sol                                                 |              |                    |\n| Status | Closed: See Resolution                                     |              |                    |\n| Rating | Severity: High                                             | Impact: High | Likelihood: Medium |\n\n#### **Description**\n\nBecause it was not possible to run a governance propose/vote test, this vulnerability could not be further investigated, however it is a concern that OpenZeppelin's ERC20VotesUpgradeable contract was removed between this version of the token and its predecessor.\n\nTo quote OpenZeppelin's Documentation:\n\n*\"This extension will keep track of historical balances so that voting power is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.\"*\n\n#### **Recommendations**\n\nBe aware of this issue and ensure that double vote counting is not possible with the protocol's new governance implementation.\n\n#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "sections": {"description_md": "#### **Description**\n\nBecause it was not possible to run a governance propose/vote test, this vulnerability could not be further investigated, however it is a concern that OpenZeppelin's ERC20VotesUpgradeable contract was removed between this version of the token and its predecessor.\n\nTo quote OpenZeppelin's Documentation:\n\n*\"This extension will keep track of historical balances so that voting power is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.\"*\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nBe aware of this issue and ensure that double vote counting is not possible with the protocol's new governance implementation.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "other_md": null, "full_markdown_body": "#### **Description**\n\nBecause it was not possible to run a governance propose/vote test, this vulnerability could not be further investigated, however it is a concern that OpenZeppelin's ERC20VotesUpgradeable contract was removed between this version of the token and its predecessor.\n\nTo quote OpenZeppelin's Documentation:\n\n*\"This extension will keep track of historical balances so that voting power is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.\"*\n\n#### **Recommendations**\n\nBe aware of this issue and ensure that double vote counting is not possible with the protocol's new governance implementation.\n\n#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "markdown_raw": "| DMO-01 | Removal of ERC20VotesUpgradeable Might Allow Double Voting |              |                    |\n|--------|------------------------------------------------------------|--------------|--------------------|\n| Asset  | DimoV2.sol                                                 |              |                    |\n| Status | Closed: See Resolution                                     |              |                    |\n| Rating | Severity: High                                             | Impact: High | Likelihood: Medium |\n\n#### **Description**\n\nBecause it was not possible to run a governance propose/vote test, this vulnerability could not be further investigated, however it is a concern that OpenZeppelin's ERC20VotesUpgradeable contract was removed between this version of the token and its predecessor.\n\nTo quote OpenZeppelin's Documentation:\n\n*\"This extension will keep track of historical balances so that voting power is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.\"*\n\n#### **Recommendations**\n\nBe aware of this issue and ensure that double vote counting is not possible with the protocol's new governance implementation.\n\n#### <span id=\"page-6-1\"></span>**Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n\n{7}------------------------------------------------\n\n<span id=\"page-7-0\"></span>\n"}, "severity": "High", "difficulty": null, "type": "Logic error", "finding_id": "DMO-01", "target": {"path": "DimoV2.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-token", "org": "DIMO-Network", "name": "dimo-token", "commit": "ea6729ec14ea13146242b6165c6d5eaf9fb95e0d", "branch": null, "relative_file": "DimoV2.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "Logic error", "Finding ID": "DMO-01", "Target": "DimoV2.sol", "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-002", "doc_id": "sigmaprime_dimo_review", "finding_index": 2, "page_start": 7, "title": "Token mint() Produces Conflicts Across Bridges", "short_summary": null, "description_md": "## **Description**\n\nThe Polygon child token contract (also called Dimo.sol ) has both a deposit() function for the Polygon bridge, but also a mint() function. As the main token is on the Ethereum blockchain, the purpose of this child token is to serve as a bridged representation of the Ethereum Mainnet token on Polygon.\n\nHowever, this function is incompatible due to the capacity to mint tokens on Polygon that do not correspond to tokens on the Ethereum Mainnet.\n\nConsider this simplified scenario involving a situation where no tokens have been bridged to Polygon:\n\n- 1. Alice uses the Polygon bridge to bridge 1,000 DIMO tokens to Polygon from the Ethereum Mainnet. She receives 1,000 child tokens and her original tokens are locked in the bridge.\n- 2. MINTER\\_ROLE is able to call mint() on the child token contract. He receives 1,000 child tokens on Polygon.\n- 3. MINTER\\_ROLE bridges his tokens back to Ethereum Mainnet, and receives the 1,000 DIMO tokens locked by Alice.\n- 4. Alice attempts to bridge back to Mainnet. There are no tokens available in the Polygon bridge resulting in a net deficit.\n", "full_markdown": "| DMO-02 | Token mint() Produces Conflicts Across Bridges |  |  |\n|--------|------------------------------------------------|--|--|\n| Asset  | Dimo.sol                                       |  |  |\n| Status | Resolved: See Resolution                       |  |  |\n| Rating | Informational                                  |  |  |\n\n## **Description**\n\nThe Polygon child token contract (also called Dimo.sol ) has both a deposit() function for the Polygon bridge, but also a mint() function. As the main token is on the Ethereum blockchain, the purpose of this child token is to serve as a bridged representation of the Ethereum Mainnet token on Polygon.\n\nHowever, this function is incompatible due to the capacity to mint tokens on Polygon that do not correspond to tokens on the Ethereum Mainnet.\n\nConsider this simplified scenario involving a situation where no tokens have been bridged to Polygon:\n\n- 1. Alice uses the Polygon bridge to bridge 1,000 DIMO tokens to Polygon from the Ethereum Mainnet. She receives 1,000 child tokens and her original tokens are locked in the bridge.\n- 2. MINTER\\_ROLE is able to call mint() on the child token contract. He receives 1,000 child tokens on Polygon.\n- 3. MINTER\\_ROLE bridges his tokens back to Ethereum Mainnet, and receives the 1,000 DIMO tokens locked by Alice.\n- 4. Alice attempts to bridge back to Mainnet. There are no tokens available in the Polygon bridge resulting in a net deficit.\n\n#### **Recommendations**\n\nRemove the function mint() from the child token.\n\n# **Resolution**\n\nAfter discussion with the development team, this issue has been deemed inapplicable/irrelevant as far as security risks are concerned. Polygon documentation references the requirement for mintable assets in their documentation [here.](https://wiki.polygon.technology/docs/develop/ethereum-polygon/mintable-assets/) We have lowered the severity to informational as total token supply is split across ethereum and polygon chains in a manner that might be confusing. With a solely ETH minted asset, its total supply would always be canonical.\n", "sections": {"description_md": "## **Description**\n\nThe Polygon child token contract (also called Dimo.sol ) has both a deposit() function for the Polygon bridge, but also a mint() function. As the main token is on the Ethereum blockchain, the purpose of this child token is to serve as a bridged representation of the Ethereum Mainnet token on Polygon.\n\nHowever, this function is incompatible due to the capacity to mint tokens on Polygon that do not correspond to tokens on the Ethereum Mainnet.\n\nConsider this simplified scenario involving a situation where no tokens have been bridged to Polygon:\n\n- 1. Alice uses the Polygon bridge to bridge 1,000 DIMO tokens to Polygon from the Ethereum Mainnet. She receives 1,000 child tokens and her original tokens are locked in the bridge.\n- 2. MINTER\\_ROLE is able to call mint() on the child token contract. He receives 1,000 child tokens on Polygon.\n- 3. MINTER\\_ROLE bridges his tokens back to Ethereum Mainnet, and receives the 1,000 DIMO tokens locked by Alice.\n- 4. Alice attempts to bridge back to Mainnet. There are no tokens available in the Polygon bridge resulting in a net deficit.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nRemove the function mint() from the child token.\n", "poc_md": null, "fix_status_md": "# **Resolution**\n\nAfter discussion with the development team, this issue has been deemed inapplicable/irrelevant as far as security risks are concerned. Polygon documentation references the requirement for mintable assets in their documentation [here.](https://wiki.polygon.technology/docs/develop/ethereum-polygon/mintable-assets/) We have lowered the severity to informational as total token supply is split across ethereum and polygon chains in a manner that might be confusing. With a solely ETH minted asset, its total supply would always be canonical.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nThe Polygon child token contract (also called Dimo.sol ) has both a deposit() function for the Polygon bridge, but also a mint() function. As the main token is on the Ethereum blockchain, the purpose of this child token is to serve as a bridged representation of the Ethereum Mainnet token on Polygon.\n\nHowever, this function is incompatible due to the capacity to mint tokens on Polygon that do not correspond to tokens on the Ethereum Mainnet.\n\nConsider this simplified scenario involving a situation where no tokens have been bridged to Polygon:\n\n- 1. Alice uses the Polygon bridge to bridge 1,000 DIMO tokens to Polygon from the Ethereum Mainnet. She receives 1,000 child tokens and her original tokens are locked in the bridge.\n- 2. MINTER\\_ROLE is able to call mint() on the child token contract. He receives 1,000 child tokens on Polygon.\n- 3. MINTER\\_ROLE bridges his tokens back to Ethereum Mainnet, and receives the 1,000 DIMO tokens locked by Alice.\n- 4. Alice attempts to bridge back to Mainnet. There are no tokens available in the Polygon bridge resulting in a net deficit.\n\n#### **Recommendations**\n\nRemove the function mint() from the child token.\n\n# **Resolution**\n\nAfter discussion with the development team, this issue has been deemed inapplicable/irrelevant as far as security risks are concerned. Polygon documentation references the requirement for mintable assets in their documentation [here.](https://wiki.polygon.technology/docs/develop/ethereum-polygon/mintable-assets/) We have lowered the severity to informational as total token supply is split across ethereum and polygon chains in a manner that might be confusing. With a solely ETH minted asset, its total supply would always be canonical.\n", "markdown_raw": "| DMO-02 | Token mint() Produces Conflicts Across Bridges |  |  |\n|--------|------------------------------------------------|--|--|\n| Asset  | Dimo.sol                                       |  |  |\n| Status | Resolved: See Resolution                       |  |  |\n| Rating | Informational                                  |  |  |\n\n## **Description**\n\nThe Polygon child token contract (also called Dimo.sol ) has both a deposit() function for the Polygon bridge, but also a mint() function. As the main token is on the Ethereum blockchain, the purpose of this child token is to serve as a bridged representation of the Ethereum Mainnet token on Polygon.\n\nHowever, this function is incompatible due to the capacity to mint tokens on Polygon that do not correspond to tokens on the Ethereum Mainnet.\n\nConsider this simplified scenario involving a situation where no tokens have been bridged to Polygon:\n\n- 1. Alice uses the Polygon bridge to bridge 1,000 DIMO tokens to Polygon from the Ethereum Mainnet. She receives 1,000 child tokens and her original tokens are locked in the bridge.\n- 2. MINTER\\_ROLE is able to call mint() on the child token contract. He receives 1,000 child tokens on Polygon.\n- 3. MINTER\\_ROLE bridges his tokens back to Ethereum Mainnet, and receives the 1,000 DIMO tokens locked by Alice.\n- 4. Alice attempts to bridge back to Mainnet. There are no tokens available in the Polygon bridge resulting in a net deficit.\n\n#### **Recommendations**\n\nRemove the function mint() from the child token.\n\n# <span id=\"page-7-1\"></span>**Resolution**\n\nAfter discussion with the development team, this issue has been deemed inapplicable/irrelevant as far as security risks are concerned. Polygon documentation references the requirement for mintable assets in their documentation [here.](https://wiki.polygon.technology/docs/develop/ethereum-polygon/mintable-assets/) We have lowered the severity to informational as total token supply is split across ethereum and polygon chains in a manner that might be confusing. With a solely ETH minted asset, its total supply would always be canonical.\n\n{8}------------------------------------------------\n\n<span id=\"page-8-0\"></span>\n"}, "severity": "Informational", "difficulty": null, "type": "Logic Error", "finding_id": "DMO-02", "target": {"path": "Dimo.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-token", "org": "DIMO-Network", "name": "dimo-token", "commit": "ea6729ec14ea13146242b6165c6d5eaf9fb95e0d", "branch": null, "relative_file": "Dimo.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "# **Resolution**\n\nAfter discussion with the development team, this issue has been deemed inapplicable/irrelevant as far as security risks are concerned. Polygon documentation references the requirement for mintable assets in their documentation [here.](https://wiki.polygon.technology/docs/develop/ethereum-polygon/mintable-assets/) We have lowered the severity to informational as total token supply is split across ethereum and polygon chains in a manner that might be confusing. With a solely ETH minted asset, its total supply would always be canonical.\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Informational", "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-02", "Target": "Dimo.sol", "Severity_normalized": "Informational"}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-003", "doc_id": "sigmaprime_dimo_review", "finding_index": 3, "page_start": 8, "title": "Voting Process Reverts", "short_summary": null, "description_md": "## **Description**\n\nBecause of the removal of OpenZeppelin's ERC20VotesUpgradeable contract from the Dimo token in DimoV2.sol , it is not possible to propose a governance vote.\n\nCalls to DimoGovernance.propose() revert because propose() calls token.getPastVotes(account, blockNumber) .\n", "full_markdown": "| DMO-03 | Voting Process Reverts       |                |                    |\n|--------|------------------------------|----------------|--------------------|\n| Asset  | DimoV2.sol, DimoGovernor.sol |                |                    |\n| Status | Closed: See Resolution       |                |                    |\n| Rating | Severity: Medium             | Impact: Medium | Likelihood: Medium |\n\n## **Description**\n\nBecause of the removal of OpenZeppelin's ERC20VotesUpgradeable contract from the Dimo token in DimoV2.sol , it is not possible to propose a governance vote.\n\nCalls to DimoGovernance.propose() revert because propose() calls token.getPastVotes(account, blockNumber) .\n\n## **Recommendations**\n\nModify DimoV2 to reimplement OpenZeppelin's ERC20VotesUpgradeable .\n\n#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "sections": {"description_md": "## **Description**\n\nBecause of the removal of OpenZeppelin's ERC20VotesUpgradeable contract from the Dimo token in DimoV2.sol , it is not possible to propose a governance vote.\n\nCalls to DimoGovernance.propose() revert because propose() calls token.getPastVotes(account, blockNumber) .\n", "impact_md": null, "recommendation_md": "## **Recommendations**\n\nModify DimoV2 to reimplement OpenZeppelin's ERC20VotesUpgradeable .\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nBecause of the removal of OpenZeppelin's ERC20VotesUpgradeable contract from the Dimo token in DimoV2.sol , it is not possible to propose a governance vote.\n\nCalls to DimoGovernance.propose() revert because propose() calls token.getPastVotes(account, blockNumber) .\n\n## **Recommendations**\n\nModify DimoV2 to reimplement OpenZeppelin's ERC20VotesUpgradeable .\n\n#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "markdown_raw": "| DMO-03 | Voting Process Reverts       |                |                    |\n|--------|------------------------------|----------------|--------------------|\n| Asset  | DimoV2.sol, DimoGovernor.sol |                |                    |\n| Status | Closed: See Resolution       |                |                    |\n| Rating | Severity: Medium             | Impact: Medium | Likelihood: Medium |\n\n## **Description**\n\nBecause of the removal of OpenZeppelin's ERC20VotesUpgradeable contract from the Dimo token in DimoV2.sol , it is not possible to propose a governance vote.\n\nCalls to DimoGovernance.propose() revert because propose() calls token.getPastVotes(account, blockNumber) .\n\n## **Recommendations**\n\nModify DimoV2 to reimplement OpenZeppelin's ERC20VotesUpgradeable .\n\n#### <span id=\"page-8-1\"></span>**Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n\n{9}------------------------------------------------\n\n<span id=\"page-9-0\"></span>\n"}, "severity": "Medium", "difficulty": null, "type": "Logic Error", "finding_id": "DMO-03", "target": {"path": "DimoV2.sol, DimoGovernor.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-token", "org": "DIMO-Network", "name": "dimo-token", "commit": "ea6729ec14ea13146242b6165c6d5eaf9fb95e0d", "branch": null, "relative_file": "DimoV2.sol, DimoGovernor.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nAfter communication with the development team, it has been determined that the governance functionality of the DIMO token is out of scope of this audit. This feature is in active development and therefore related issues have been closed. As the governance functionality is out of scope, the testing team cannot attest to the security of this system. The testing team acknowledges that the development team is still moving forward based on recommendations provided in this issue.\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-03", "Target": "DimoV2.sol, DimoGovernor.sol", "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-004", "doc_id": "sigmaprime_dimo_review", "finding_index": 4, "page_start": 9, "title": "Function Signature Collision Creates Inaccessible Codeblocks", "short_summary": null, "description_md": "#### **Description**\n\nWhen new modules are added in \\_addModule() , their function signatures are checked against s.implementations[selectors[i]] on line [**129**] to ensure that the same function signature is not added twice. However, there is no check against the existing function signatures of DIMORegistry .\n\nWith the selection of modules as per the installation script, this situation does occur and several functions in the modules are installed but inaccessible because they are blocked by function signatures already present in DIMORegistry :\n\n- Getter.ownerOf() is shadowed and blocked by ERC721Base.ownerOf() .\n- Getter.name() is shadowed and blocked by ERC721Metadata.name() .\n- Getter.symbol() is shadowed and blocked by ERC721Metadata.symbol() .\n- Getter.tokenURI() is shadowed and blocked by ERC721Metadata.tokenURI() .\n\nThese shadowed functions, and any future shadowed functions, are inaccessible. This may have security implications if the team develop functionality on the assumption that one version of a function is being called, when in fact it is another.\n\nThe risk increases as more modules are added and the complexity of the system grows.\n", "full_markdown": "| DMO-04 | Function Signature Collision Creates Inaccessible Codeblocks |                |                    |\n|--------|--------------------------------------------------------------|----------------|--------------------|\n| Asset  | DIMORegistry.sol                                             |                |                    |\n| Status | Resolved: See Resolution                                     |                |                    |\n| Rating | Severity: Medium                                             | Impact: Medium | Likelihood: Medium |\n\n#### **Description**\n\nWhen new modules are added in \\_addModule() , their function signatures are checked against s.implementations[selectors[i]] on line [**129**] to ensure that the same function signature is not added twice. However, there is no check against the existing function signatures of DIMORegistry .\n\nWith the selection of modules as per the installation script, this situation does occur and several functions in the modules are installed but inaccessible because they are blocked by function signatures already present in DIMORegistry :\n\n- Getter.ownerOf() is shadowed and blocked by ERC721Base.ownerOf() .\n- Getter.name() is shadowed and blocked by ERC721Metadata.name() .\n- Getter.symbol() is shadowed and blocked by ERC721Metadata.symbol() .\n- Getter.tokenURI() is shadowed and blocked by ERC721Metadata.tokenURI() .\n\nThese shadowed functions, and any future shadowed functions, are inaccessible. This may have security implications if the team develop functionality on the assumption that one version of a function is being called, when in fact it is another.\n\nThe risk increases as more modules are added and the complexity of the system grows.\n\n#### **Recommendations**\n\nThe development team might want to consider adding the DIMORegistry contract itself as a module, with all of its function signatures, simply to block potential collisions. If a tool such as hardhat is used to list all of a contract's selectors, then nothing will be missed.\n\nAlternatively, a require check could be added within \\_addModule with DIMORegistry 's function signatures. This would be more reliable as it could not be removed.\n\n#### **Resolution**\n\nThe testing team acknowledges that original issues regarding shadowing with internal modules has been resolved. The team have implemented the recommendation by adding DIMORegistry contract itself as a module. The fix can be found in the following commit: [4ddf1402](https://github.com/DIMO-Network/dimoidentity/commit/4ddf1402e81bb5d0f6ddaabfbd2f296721010c23).\n", "sections": {"description_md": "#### **Description**\n\nWhen new modules are added in \\_addModule() , their function signatures are checked against s.implementations[selectors[i]] on line [**129**] to ensure that the same function signature is not added twice. However, there is no check against the existing function signatures of DIMORegistry .\n\nWith the selection of modules as per the installation script, this situation does occur and several functions in the modules are installed but inaccessible because they are blocked by function signatures already present in DIMORegistry :\n\n- Getter.ownerOf() is shadowed and blocked by ERC721Base.ownerOf() .\n- Getter.name() is shadowed and blocked by ERC721Metadata.name() .\n- Getter.symbol() is shadowed and blocked by ERC721Metadata.symbol() .\n- Getter.tokenURI() is shadowed and blocked by ERC721Metadata.tokenURI() .\n\nThese shadowed functions, and any future shadowed functions, are inaccessible. This may have security implications if the team develop functionality on the assumption that one version of a function is being called, when in fact it is another.\n\nThe risk increases as more modules are added and the complexity of the system grows.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nThe development team might want to consider adding the DIMORegistry contract itself as a module, with all of its function signatures, simply to block potential collisions. If a tool such as hardhat is used to list all of a contract's selectors, then nothing will be missed.\n\nAlternatively, a require check could be added within \\_addModule with DIMORegistry 's function signatures. This would be more reliable as it could not be removed.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe testing team acknowledges that original issues regarding shadowing with internal modules has been resolved. The team have implemented the recommendation by adding DIMORegistry contract itself as a module. The fix can be found in the following commit: [4ddf1402](https://github.com/DIMO-Network/dimoidentity/commit/4ddf1402e81bb5d0f6ddaabfbd2f296721010c23).\n", "other_md": null, "full_markdown_body": "#### **Description**\n\nWhen new modules are added in \\_addModule() , their function signatures are checked against s.implementations[selectors[i]] on line [**129**] to ensure that the same function signature is not added twice. However, there is no check against the existing function signatures of DIMORegistry .\n\nWith the selection of modules as per the installation script, this situation does occur and several functions in the modules are installed but inaccessible because they are blocked by function signatures already present in DIMORegistry :\n\n- Getter.ownerOf() is shadowed and blocked by ERC721Base.ownerOf() .\n- Getter.name() is shadowed and blocked by ERC721Metadata.name() .\n- Getter.symbol() is shadowed and blocked by ERC721Metadata.symbol() .\n- Getter.tokenURI() is shadowed and blocked by ERC721Metadata.tokenURI() .\n\nThese shadowed functions, and any future shadowed functions, are inaccessible. This may have security implications if the team develop functionality on the assumption that one version of a function is being called, when in fact it is another.\n\nThe risk increases as more modules are added and the complexity of the system grows.\n\n#### **Recommendations**\n\nThe development team might want to consider adding the DIMORegistry contract itself as a module, with all of its function signatures, simply to block potential collisions. If a tool such as hardhat is used to list all of a contract's selectors, then nothing will be missed.\n\nAlternatively, a require check could be added within \\_addModule with DIMORegistry 's function signatures. This would be more reliable as it could not be removed.\n\n#### **Resolution**\n\nThe testing team acknowledges that original issues regarding shadowing with internal modules has been resolved. The team have implemented the recommendation by adding DIMORegistry contract itself as a module. The fix can be found in the following commit: [4ddf1402](https://github.com/DIMO-Network/dimoidentity/commit/4ddf1402e81bb5d0f6ddaabfbd2f296721010c23).\n", "markdown_raw": "| DMO-04 | Function Signature Collision Creates Inaccessible Codeblocks |                |                    |\n|--------|--------------------------------------------------------------|----------------|--------------------|\n| Asset  | DIMORegistry.sol                                             |                |                    |\n| Status | Resolved: See Resolution                                     |                |                    |\n| Rating | Severity: Medium                                             | Impact: Medium | Likelihood: Medium |\n\n#### **Description**\n\nWhen new modules are added in \\_addModule() , their function signatures are checked against s.implementations[selectors[i]] on line [**129**] to ensure that the same function signature is not added twice. However, there is no check against the existing function signatures of DIMORegistry .\n\nWith the selection of modules as per the installation script, this situation does occur and several functions in the modules are installed but inaccessible because they are blocked by function signatures already present in DIMORegistry :\n\n- Getter.ownerOf() is shadowed and blocked by ERC721Base.ownerOf() .\n- Getter.name() is shadowed and blocked by ERC721Metadata.name() .\n- Getter.symbol() is shadowed and blocked by ERC721Metadata.symbol() .\n- Getter.tokenURI() is shadowed and blocked by ERC721Metadata.tokenURI() .\n\nThese shadowed functions, and any future shadowed functions, are inaccessible. This may have security implications if the team develop functionality on the assumption that one version of a function is being called, when in fact it is another.\n\nThe risk increases as more modules are added and the complexity of the system grows.\n\n#### **Recommendations**\n\nThe development team might want to consider adding the DIMORegistry contract itself as a module, with all of its function signatures, simply to block potential collisions. If a tool such as hardhat is used to list all of a contract's selectors, then nothing will be missed.\n\nAlternatively, a require check could be added within \\_addModule with DIMORegistry 's function signatures. This would be more reliable as it could not be removed.\n\n#### <span id=\"page-9-1\"></span>**Resolution**\n\nThe testing team acknowledges that original issues regarding shadowing with internal modules has been resolved. The team have implemented the recommendation by adding DIMORegistry contract itself as a module. The fix can be found in the following commit: [4ddf1402](https://github.com/DIMO-Network/dimoidentity/commit/4ddf1402e81bb5d0f6ddaabfbd2f296721010c23).\n\n{10}------------------------------------------------\n\n<span id=\"page-10-0\"></span>\n"}, "severity": "Medium", "difficulty": null, "type": "Logic Error", "finding_id": "DMO-04", "target": {"path": "DIMORegistry.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimoidentity", "org": "DIMO-Network", "name": "dimoidentity", "commit": "4ddf1402e81bb5d0f6ddaabfbd2f296721010c23", "branch": null, "relative_file": "DIMORegistry.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe testing team acknowledges that original issues regarding shadowing with internal modules has been resolved. The team have implemented the recommendation by adding DIMORegistry contract itself as a module. The fix can be found in the following commit: [4ddf1402](https://github.com/DIMO-Network/dimoidentity/commit/4ddf1402e81bb5d0f6ddaabfbd2f296721010c23).\n", "fixed_in_commit": "4ddf1402", "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-04", "Target": "DIMORegistry.sol", "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-005", "doc_id": "sigmaprime_dimo_review", "finding_index": 5, "page_start": 10, "title": "Ownership Functionality Can Be Lost Through One Step Transfers", "short_summary": null, "description_md": "## **Description**\n\nDIMOVesting.sol inherits from OpenZeppelin's Ownable . There are two potential issues in this contract which can allow ownership to be lost entirely:\n\n- 1. As ownership transfer in transferOwnership() is unilateral, ownership can be accidentally transferred to an uncontrolled address.\n- 2. An accidental call to renounceOwnership() transfers ownership to the zero address, effectively destroying all ownership functionality permanently.\n", "full_markdown": "| DMO-05 | Ownership Functionality Can Be Lost Through One Step Transfers |             |                 |\n|--------|----------------------------------------------------------------|-------------|-----------------|\n| Asset  | DIMOVesting.sol                                                |             |                 |\n| Status | Resolved: See Resolution                                       |             |                 |\n| Rating | Severity: Low                                                  | Impact: Low | Likelihood: Low |\n\n## **Description**\n\nDIMOVesting.sol inherits from OpenZeppelin's Ownable . There are two potential issues in this contract which can allow ownership to be lost entirely:\n\n- 1. As ownership transfer in transferOwnership() is unilateral, ownership can be accidentally transferred to an uncontrolled address.\n- 2. An accidental call to renounceOwnership() transfers ownership to the zero address, effectively destroying all ownership functionality permanently.\n\n#### **Recommendations**\n\nChange ownership transfer to a propose/accept model and block or remove the renounceOwnership() function.\n\nOne convenient way to do this is to replace OpenZeppelin's Ownable with Chainlink's [ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol)\n\n#### **Resolution**\n\nThe issue has been fixed in [commit d13151c2.](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/d13151c2263c8d2dedd7bbca0aa496a98fc9ecad) Chainlink's ConfirmedOwnerWithProposal was used to allow for a propose-accept pattern for owner transfers.\n", "sections": {"description_md": "## **Description**\n\nDIMOVesting.sol inherits from OpenZeppelin's Ownable . There are two potential issues in this contract which can allow ownership to be lost entirely:\n\n- 1. As ownership transfer in transferOwnership() is unilateral, ownership can be accidentally transferred to an uncontrolled address.\n- 2. An accidental call to renounceOwnership() transfers ownership to the zero address, effectively destroying all ownership functionality permanently.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nChange ownership transfer to a propose/accept model and block or remove the renounceOwnership() function.\n\nOne convenient way to do this is to replace OpenZeppelin's Ownable with Chainlink's [ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol)\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe issue has been fixed in [commit d13151c2.](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/d13151c2263c8d2dedd7bbca0aa496a98fc9ecad) Chainlink's ConfirmedOwnerWithProposal was used to allow for a propose-accept pattern for owner transfers.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nDIMOVesting.sol inherits from OpenZeppelin's Ownable . There are two potential issues in this contract which can allow ownership to be lost entirely:\n\n- 1. As ownership transfer in transferOwnership() is unilateral, ownership can be accidentally transferred to an uncontrolled address.\n- 2. An accidental call to renounceOwnership() transfers ownership to the zero address, effectively destroying all ownership functionality permanently.\n\n#### **Recommendations**\n\nChange ownership transfer to a propose/accept model and block or remove the renounceOwnership() function.\n\nOne convenient way to do this is to replace OpenZeppelin's Ownable with Chainlink's [ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol)\n\n#### **Resolution**\n\nThe issue has been fixed in [commit d13151c2.](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/d13151c2263c8d2dedd7bbca0aa496a98fc9ecad) Chainlink's ConfirmedOwnerWithProposal was used to allow for a propose-accept pattern for owner transfers.\n", "markdown_raw": "| DMO-05 | Ownership Functionality Can Be Lost Through One Step Transfers |             |                 |\n|--------|----------------------------------------------------------------|-------------|-----------------|\n| Asset  | DIMOVesting.sol                                                |             |                 |\n| Status | Resolved: See Resolution                                       |             |                 |\n| Rating | Severity: Low                                                  | Impact: Low | Likelihood: Low |\n\n## **Description**\n\nDIMOVesting.sol inherits from OpenZeppelin's Ownable . There are two potential issues in this contract which can allow ownership to be lost entirely:\n\n- 1. As ownership transfer in transferOwnership() is unilateral, ownership can be accidentally transferred to an uncontrolled address.\n- 2. An accidental call to renounceOwnership() transfers ownership to the zero address, effectively destroying all ownership functionality permanently.\n\n#### **Recommendations**\n\nChange ownership transfer to a propose/accept model and block or remove the renounceOwnership() function.\n\nOne convenient way to do this is to replace OpenZeppelin's Ownable with Chainlink's [ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol)\n\n#### <span id=\"page-10-1\"></span>**Resolution**\n\nThe issue has been fixed in [commit d13151c2.](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/d13151c2263c8d2dedd7bbca0aa496a98fc9ecad) Chainlink's ConfirmedOwnerWithProposal was used to allow for a propose-accept pattern for owner transfers.\n\n{11}------------------------------------------------\n\n<span id=\"page-11-0\"></span>\n"}, "severity": "Low", "difficulty": null, "type": "Access control", "finding_id": "DMO-05", "target": {"path": "DIMOVesting.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimoidentity", "org": "DIMO-Network", "name": "dimoidentity", "commit": "4ddf1402e81bb5d0f6ddaabfbd2f296721010c23", "branch": null, "relative_file": "DIMOVesting.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe issue has been fixed in [commit d13151c2.](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/d13151c2263c8d2dedd7bbca0aa496a98fc9ecad) Chainlink's ConfirmedOwnerWithProposal was used to allow for a propose-accept pattern for owner transfers.\n", "fixed_in_commit": "d13151c2", "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Low", "Difficulty": null, "Type": "Access control", "Finding ID": "DMO-05", "Target": "DIMOVesting.sol", "Severity_normalized": "Low"}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-006", "doc_id": "sigmaprime_dimo_review", "finding_index": 6, "page_start": 11, "title": "Ineffective Vesting Transfer Mechanism", "short_summary": null, "description_md": "## **Description**\n\nThe DIMOVesting contract expects transfers to be made before creating a vesting schedule using createVestingSchedule() . As a result, there are checks to ensure that funds are sufficient.\n\nHowever, if a user accidentally transfers funds to the vesting contract and the owner creates the vesting schedule without transferring, this will lock funds that did not belong to the owner.\n\nReversing this process is unnecessarily challenging. The owner will need to revoke the schedule, transfer the funds back to the user and then transfer new funds to the vesting schedule, whilst accounting for any potentially released funds, then creating the vesting schedule again.\n\nThis lengthy correction process is unnecessary and introduces potential for human error.\n", "full_markdown": "| DMO-06 | Ineffective Vesting Transfer Mechanism |  |\n|--------|----------------------------------------|--|\n| Asset  | DIMOVesting.sol                        |  |\n| Status | Closed: See Resolution                 |  |\n| Rating | Informational                          |  |\n\n## **Description**\n\nThe DIMOVesting contract expects transfers to be made before creating a vesting schedule using createVestingSchedule() . As a result, there are checks to ensure that funds are sufficient.\n\nHowever, if a user accidentally transfers funds to the vesting contract and the owner creates the vesting schedule without transferring, this will lock funds that did not belong to the owner.\n\nReversing this process is unnecessarily challenging. The owner will need to revoke the schedule, transfer the funds back to the user and then transfer new funds to the vesting schedule, whilst accounting for any potentially released funds, then creating the vesting schedule again.\n\nThis lengthy correction process is unnecessary and introduces potential for human error.\n\n## **Recommendations**\n\nEnsure this behaviour is understood, if this behaviour isn't intentional consider forcing the user to transfer funds when they interact with createVestingSchedule\n\n## **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "sections": {"description_md": "## **Description**\n\nThe DIMOVesting contract expects transfers to be made before creating a vesting schedule using createVestingSchedule() . As a result, there are checks to ensure that funds are sufficient.\n\nHowever, if a user accidentally transfers funds to the vesting contract and the owner creates the vesting schedule without transferring, this will lock funds that did not belong to the owner.\n\nReversing this process is unnecessarily challenging. The owner will need to revoke the schedule, transfer the funds back to the user and then transfer new funds to the vesting schedule, whilst accounting for any potentially released funds, then creating the vesting schedule again.\n\nThis lengthy correction process is unnecessary and introduces potential for human error.\n", "impact_md": null, "recommendation_md": "## **Recommendations**\n\nEnsure this behaviour is understood, if this behaviour isn't intentional consider forcing the user to transfer funds when they interact with createVestingSchedule\n", "poc_md": null, "fix_status_md": "## **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "other_md": null, "full_markdown_body": "## **Description**\n\nThe DIMOVesting contract expects transfers to be made before creating a vesting schedule using createVestingSchedule() . As a result, there are checks to ensure that funds are sufficient.\n\nHowever, if a user accidentally transfers funds to the vesting contract and the owner creates the vesting schedule without transferring, this will lock funds that did not belong to the owner.\n\nReversing this process is unnecessarily challenging. The owner will need to revoke the schedule, transfer the funds back to the user and then transfer new funds to the vesting schedule, whilst accounting for any potentially released funds, then creating the vesting schedule again.\n\nThis lengthy correction process is unnecessary and introduces potential for human error.\n\n## **Recommendations**\n\nEnsure this behaviour is understood, if this behaviour isn't intentional consider forcing the user to transfer funds when they interact with createVestingSchedule\n\n## **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "markdown_raw": "| DMO-06 | Ineffective Vesting Transfer Mechanism |  |\n|--------|----------------------------------------|--|\n| Asset  | DIMOVesting.sol                        |  |\n| Status | Closed: See Resolution                 |  |\n| Rating | Informational                          |  |\n\n## **Description**\n\nThe DIMOVesting contract expects transfers to be made before creating a vesting schedule using createVestingSchedule() . As a result, there are checks to ensure that funds are sufficient.\n\nHowever, if a user accidentally transfers funds to the vesting contract and the owner creates the vesting schedule without transferring, this will lock funds that did not belong to the owner.\n\nReversing this process is unnecessarily challenging. The owner will need to revoke the schedule, transfer the funds back to the user and then transfer new funds to the vesting schedule, whilst accounting for any potentially released funds, then creating the vesting schedule again.\n\nThis lengthy correction process is unnecessary and introduces potential for human error.\n\n## **Recommendations**\n\nEnsure this behaviour is understood, if this behaviour isn't intentional consider forcing the user to transfer funds when they interact with createVestingSchedule\n\n## <span id=\"page-11-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n\n{12}------------------------------------------------\n\n<span id=\"page-12-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Logic Error", "finding_id": "DMO-06", "target": {"path": "DIMOVesting.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimoidentity", "org": "DIMO-Network", "name": "dimoidentity", "commit": "4ddf1402e81bb5d0f6ddaabfbd2f296721010c23", "branch": null, "relative_file": "DIMOVesting.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "## **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-06", "Target": "DIMOVesting.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-007", "doc_id": "sigmaprime_dimo_review", "finding_index": 7, "page_start": 12, "title": "Token Upgradeability May Lead to Denial-of-Service", "short_summary": null, "description_md": "## **Description**\n\nThe Dimo token uses the EIP-1967 transparent proxy pattern to allow upgradeability, as has been used to upgrade from version 1. Whilst upgradeability adds flexibility, its downside is potential uncertainty: any upgradeable contract can be modified to any functionality.\n\nFor many contracts, the flexibility advantages are regarded as balancing the risks of upgradeability. In the case of tokens, however, as the functionality is simple, well established, and successfully implemented in many other instances, upgradeability is often viewed as an unacceptable risk by users.\n", "full_markdown": "| DMO-07 | Token Upgradeability May Lead to Denial-of-Service |  |  |\n|--------|----------------------------------------------------|--|--|\n| Asset  | DimoV2.sol                                         |  |  |\n| Status | Closed: See Resolution                             |  |  |\n| Rating | Informational                                      |  |  |\n\n## **Description**\n\nThe Dimo token uses the EIP-1967 transparent proxy pattern to allow upgradeability, as has been used to upgrade from version 1. Whilst upgradeability adds flexibility, its downside is potential uncertainty: any upgradeable contract can be modified to any functionality.\n\nFor many contracts, the flexibility advantages are regarded as balancing the risks of upgradeability. In the case of tokens, however, as the functionality is simple, well established, and successfully implemented in many other instances, upgradeability is often viewed as an unacceptable risk by users.\n\n#### **Recommendations**\n\nBe aware of the potential and perceived potential for the token contract's proxy admin to do anything it wants to the token supply.\n\nUnfortunately, the only way to convert an upgradeable proxy token to a standard token is to create a new contract and allow the tokens to be swapped for each other.\n\nNevertheless, transitioning to a static contract for a token is recommended for the benefits in stability and reliability it would provide.\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" and that \"token upgradability is likely to be temporary\". These comments can be found in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "sections": {"description_md": "## **Description**\n\nThe Dimo token uses the EIP-1967 transparent proxy pattern to allow upgradeability, as has been used to upgrade from version 1. Whilst upgradeability adds flexibility, its downside is potential uncertainty: any upgradeable contract can be modified to any functionality.\n\nFor many contracts, the flexibility advantages are regarded as balancing the risks of upgradeability. In the case of tokens, however, as the functionality is simple, well established, and successfully implemented in many other instances, upgradeability is often viewed as an unacceptable risk by users.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nBe aware of the potential and perceived potential for the token contract's proxy admin to do anything it wants to the token supply.\n\nUnfortunately, the only way to convert an upgradeable proxy token to a standard token is to create a new contract and allow the tokens to be swapped for each other.\n\nNevertheless, transitioning to a static contract for a token is recommended for the benefits in stability and reliability it would provide.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" and that \"token upgradability is likely to be temporary\". These comments can be found in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "other_md": null, "full_markdown_body": "## **Description**\n\nThe Dimo token uses the EIP-1967 transparent proxy pattern to allow upgradeability, as has been used to upgrade from version 1. Whilst upgradeability adds flexibility, its downside is potential uncertainty: any upgradeable contract can be modified to any functionality.\n\nFor many contracts, the flexibility advantages are regarded as balancing the risks of upgradeability. In the case of tokens, however, as the functionality is simple, well established, and successfully implemented in many other instances, upgradeability is often viewed as an unacceptable risk by users.\n\n#### **Recommendations**\n\nBe aware of the potential and perceived potential for the token contract's proxy admin to do anything it wants to the token supply.\n\nUnfortunately, the only way to convert an upgradeable proxy token to a standard token is to create a new contract and allow the tokens to be swapped for each other.\n\nNevertheless, transitioning to a static contract for a token is recommended for the benefits in stability and reliability it would provide.\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" and that \"token upgradability is likely to be temporary\". These comments can be found in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "markdown_raw": "| DMO-07 | Token Upgradeability May Lead to Denial-of-Service |  |  |\n|--------|----------------------------------------------------|--|--|\n| Asset  | DimoV2.sol                                         |  |  |\n| Status | Closed: See Resolution                             |  |  |\n| Rating | Informational                                      |  |  |\n\n## **Description**\n\nThe Dimo token uses the EIP-1967 transparent proxy pattern to allow upgradeability, as has been used to upgrade from version 1. Whilst upgradeability adds flexibility, its downside is potential uncertainty: any upgradeable contract can be modified to any functionality.\n\nFor many contracts, the flexibility advantages are regarded as balancing the risks of upgradeability. In the case of tokens, however, as the functionality is simple, well established, and successfully implemented in many other instances, upgradeability is often viewed as an unacceptable risk by users.\n\n#### **Recommendations**\n\nBe aware of the potential and perceived potential for the token contract's proxy admin to do anything it wants to the token supply.\n\nUnfortunately, the only way to convert an upgradeable proxy token to a standard token is to create a new contract and allow the tokens to be swapped for each other.\n\nNevertheless, transitioning to a static contract for a token is recommended for the benefits in stability and reliability it would provide.\n\n#### <span id=\"page-12-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood\" and that \"token upgradability is likely to be temporary\". These comments can be found in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n\n{13}------------------------------------------------\n\n<span id=\"page-13-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Upgradeability", "finding_id": "DMO-07", "target": {"path": "DimoV2.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimoidentity", "org": "DIMO-Network", "name": "dimoidentity", "commit": "4ddf1402e81bb5d0f6ddaabfbd2f296721010c23", "branch": null, "relative_file": "DimoV2.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" and that \"token upgradability is likely to be temporary\". These comments can be found in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Upgradeability", "Finding ID": "DMO-07", "Target": "DimoV2.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-008", "doc_id": "sigmaprime_dimo_review", "finding_index": 8, "page_start": 13, "title": "No initialize() Function on Proxy Implementation", "short_summary": null, "description_md": "## **Description**\n\nAn initialize() function in a proxy implementation is used to set the initial values within the storage space of the proxy contract. DimoV2 lacks such a function, and the reason for that seems to be that these values were already set within the first version of the Dimo token contract.\n\nSo long as the contract DimoV2 is only used to upgrade from a successfully initialised first version Dimo token contract, this does not cause any problems. However, if any token were ever deployed with DimoV2 as its first implementation contact, it would lack the values set in its initialize() function.\n", "full_markdown": "| DMO-08 | No initialize() Function on Proxy Implementation |  |\n|--------|--------------------------------------------------|--|\n| Asset  | DimoV2.sol                                       |  |\n| Status | Resolved: See Resolution                         |  |\n| Rating | Informational                                    |  |\n\n## **Description**\n\nAn initialize() function in a proxy implementation is used to set the initial values within the storage space of the proxy contract. DimoV2 lacks such a function, and the reason for that seems to be that these values were already set within the first version of the Dimo token contract.\n\nSo long as the contract DimoV2 is only used to upgrade from a successfully initialised first version Dimo token contract, this does not cause any problems. However, if any token were ever deployed with DimoV2 as its first implementation contact, it would lack the values set in its initialize() function.\n\n## **Recommendations**\n\nThe team should acknowledge the issue and remain aware of it should they ever wish to deploy DimoV2 . Alternatively, DimoV2 could have an initialize() function added.\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2) The reason to not have an initialize() function is that all variables were already initialized in the first version.\n", "sections": {"description_md": "## **Description**\n\nAn initialize() function in a proxy implementation is used to set the initial values within the storage space of the proxy contract. DimoV2 lacks such a function, and the reason for that seems to be that these values were already set within the first version of the Dimo token contract.\n\nSo long as the contract DimoV2 is only used to upgrade from a successfully initialised first version Dimo token contract, this does not cause any problems. However, if any token were ever deployed with DimoV2 as its first implementation contact, it would lack the values set in its initialize() function.\n", "impact_md": null, "recommendation_md": "## **Recommendations**\n\nThe team should acknowledge the issue and remain aware of it should they ever wish to deploy DimoV2 . Alternatively, DimoV2 could have an initialize() function added.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2) The reason to not have an initialize() function is that all variables were already initialized in the first version.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nAn initialize() function in a proxy implementation is used to set the initial values within the storage space of the proxy contract. DimoV2 lacks such a function, and the reason for that seems to be that these values were already set within the first version of the Dimo token contract.\n\nSo long as the contract DimoV2 is only used to upgrade from a successfully initialised first version Dimo token contract, this does not cause any problems. However, if any token were ever deployed with DimoV2 as its first implementation contact, it would lack the values set in its initialize() function.\n\n## **Recommendations**\n\nThe team should acknowledge the issue and remain aware of it should they ever wish to deploy DimoV2 . Alternatively, DimoV2 could have an initialize() function added.\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2) The reason to not have an initialize() function is that all variables were already initialized in the first version.\n", "markdown_raw": "| DMO-08 | No initialize() Function on Proxy Implementation |  |\n|--------|--------------------------------------------------|--|\n| Asset  | DimoV2.sol                                       |  |\n| Status | Resolved: See Resolution                         |  |\n| Rating | Informational                                    |  |\n\n## **Description**\n\nAn initialize() function in a proxy implementation is used to set the initial values within the storage space of the proxy contract. DimoV2 lacks such a function, and the reason for that seems to be that these values were already set within the first version of the Dimo token contract.\n\nSo long as the contract DimoV2 is only used to upgrade from a successfully initialised first version Dimo token contract, this does not cause any problems. However, if any token were ever deployed with DimoV2 as its first implementation contact, it would lack the values set in its initialize() function.\n\n## **Recommendations**\n\nThe team should acknowledge the issue and remain aware of it should they ever wish to deploy DimoV2 . Alternatively, DimoV2 could have an initialize() function added.\n\n#### <span id=\"page-13-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2) The reason to not have an initialize() function is that all variables were already initialized in the first version.\n\n{14}------------------------------------------------\n\n<span id=\"page-14-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Logic Error", "finding_id": "DMO-08", "target": {"path": "DimoV2.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimoidentity", "org": "DIMO-Network", "name": "dimoidentity", "commit": "4ddf1402e81bb5d0f6ddaabfbd2f296721010c23", "branch": null, "relative_file": "DimoV2.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2) The reason to not have an initialize() function is that all variables were already initialized in the first version.\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-08", "Target": "DimoV2.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-009", "doc_id": "sigmaprime_dimo_review", "finding_index": 9, "page_start": 14, "title": "Potentially Unsafe Use of delegatecall() Opcode", "short_summary": null, "description_md": "## **Description**\n\nThe functionality of DIMORegistry relies on delegatecall . However, this design decision may present significant risks in the future.\n\nIndeed, any module that is added to DIMORegistry can potentially access and modify any part of the storage of DIMORegistry . That means it can grant any role, change any token allocation, or add other modules. The greatest danger is that a module is added which in some way ends up making a call to selfdestruct . This would cause DIMORegistry itself to delete its own code and result in a denial of service for any dependency contracts.\n", "full_markdown": "| DMO-09 | Potentially Unsafe Use of delegatecall() Opcode |  |\n|--------|-------------------------------------------------|--|\n| Asset  | DIMORegistry.sol                                |  |\n| Status | Closed: See Resolution                          |  |\n| Rating | Informational                                   |  |\n\n## **Description**\n\nThe functionality of DIMORegistry relies on delegatecall . However, this design decision may present significant risks in the future.\n\nIndeed, any module that is added to DIMORegistry can potentially access and modify any part of the storage of DIMORegistry . That means it can grant any role, change any token allocation, or add other modules. The greatest danger is that a module is added which in some way ends up making a call to selfdestruct . This would cause DIMORegistry itself to delete its own code and result in a denial of service for any dependency contracts.\n\n#### **Recommendations**\n\nAfter discussion with the development team, and careful evaluation of the design, the testing team acknowledges this issue as an informational. Notwithstanding the informational status of this finding, the development team should place a high priority on ensuring that all modules added to DIMORegistry are reviewed for security. These reviews should not be performed in isolation, but rather ensure that the interactions with other existing modules are sound. Specific weight should be placed on ensuring storage collisions do not occur.\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system.\n", "sections": {"description_md": "## **Description**\n\nThe functionality of DIMORegistry relies on delegatecall . However, this design decision may present significant risks in the future.\n\nIndeed, any module that is added to DIMORegistry can potentially access and modify any part of the storage of DIMORegistry . That means it can grant any role, change any token allocation, or add other modules. The greatest danger is that a module is added which in some way ends up making a call to selfdestruct . This would cause DIMORegistry itself to delete its own code and result in a denial of service for any dependency contracts.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nAfter discussion with the development team, and careful evaluation of the design, the testing team acknowledges this issue as an informational. Notwithstanding the informational status of this finding, the development team should place a high priority on ensuring that all modules added to DIMORegistry are reviewed for security. These reviews should not be performed in isolation, but rather ensure that the interactions with other existing modules are sound. Specific weight should be placed on ensuring storage collisions do not occur.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nThe functionality of DIMORegistry relies on delegatecall . However, this design decision may present significant risks in the future.\n\nIndeed, any module that is added to DIMORegistry can potentially access and modify any part of the storage of DIMORegistry . That means it can grant any role, change any token allocation, or add other modules. The greatest danger is that a module is added which in some way ends up making a call to selfdestruct . This would cause DIMORegistry itself to delete its own code and result in a denial of service for any dependency contracts.\n\n#### **Recommendations**\n\nAfter discussion with the development team, and careful evaluation of the design, the testing team acknowledges this issue as an informational. Notwithstanding the informational status of this finding, the development team should place a high priority on ensuring that all modules added to DIMORegistry are reviewed for security. These reviews should not be performed in isolation, but rather ensure that the interactions with other existing modules are sound. Specific weight should be placed on ensuring storage collisions do not occur.\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system.\n", "markdown_raw": "| DMO-09 | Potentially Unsafe Use of delegatecall() Opcode |  |\n|--------|-------------------------------------------------|--|\n| Asset  | DIMORegistry.sol                                |  |\n| Status | Closed: See Resolution                          |  |\n| Rating | Informational                                   |  |\n\n## **Description**\n\nThe functionality of DIMORegistry relies on delegatecall . However, this design decision may present significant risks in the future.\n\nIndeed, any module that is added to DIMORegistry can potentially access and modify any part of the storage of DIMORegistry . That means it can grant any role, change any token allocation, or add other modules. The greatest danger is that a module is added which in some way ends up making a call to selfdestruct . This would cause DIMORegistry itself to delete its own code and result in a denial of service for any dependency contracts.\n\n#### **Recommendations**\n\nAfter discussion with the development team, and careful evaluation of the design, the testing team acknowledges this issue as an informational. Notwithstanding the informational status of this finding, the development team should place a high priority on ensuring that all modules added to DIMORegistry are reviewed for security. These reviews should not be performed in isolation, but rather ensure that the interactions with other existing modules are sound. Specific weight should be placed on ensuring storage collisions do not occur.\n\n#### <span id=\"page-14-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system.\n\n{15}------------------------------------------------\n\n<span id=\"page-15-0\"></span>\n"}, "severity": "Informational", "difficulty": null, "type": "Logic Error", "finding_id": "DMO-09", "target": {"path": "DIMORegistry.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimoidentity", "org": "DIMO-Network", "name": "dimoidentity", "commit": "4ddf1402e81bb5d0f6ddaabfbd2f296721010c23", "branch": null, "relative_file": "DIMORegistry.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system.\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Informational", "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-09", "Target": "DIMORegistry.sol", "Severity_normalized": "Informational"}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-010", "doc_id": "sigmaprime_dimo_review", "finding_index": 10, "page_start": 15, "title": "Ineffective Function Signature Registry Change Process", "short_summary": null, "description_md": "## **Description**\n\nBecause of the check on line [**129**] of DIMORegistry.sol , it is not possible to add additional selectors from an implementation contract once any selectors at all have been added. This is because selectorsHash[implementation] will be set on module addition at line [**141**] and this value is never modified.\n\nThis may be present a risk if an implementation contract is removed, and then the protocol wishes to add it back to the registry again, or if the protocol wishes to add more function signatures from an already registered implementation contract.\n\nIn either case, the implementation contract in question would need to be redeployed.\n", "full_markdown": "| DMO-10 | Ineffective Function Signature Registry Change Process |  |  |\n|--------|--------------------------------------------------------|--|--|\n| Asset  | DIMORegistry.sol                                       |  |  |\n| Status | Resolved: See Resolution                               |  |  |\n| Rating | Informational                                          |  |  |\n\n## **Description**\n\nBecause of the check on line [**129**] of DIMORegistry.sol , it is not possible to add additional selectors from an implementation contract once any selectors at all have been added. This is because selectorsHash[implementation] will be set on module addition at line [**141**] and this value is never modified.\n\nThis may be present a risk if an implementation contract is removed, and then the protocol wishes to add it back to the registry again, or if the protocol wishes to add more function signatures from an already registered implementation contract.\n\nIn either case, the implementation contract in question would need to be redeployed.\n\n## **Recommendations**\n\nMake sure this behaviour is understood and expected.\n\nThe development team may want to consider adding s.selectorsHash[implementation] = 0x0 at line [**165**], at the end of \\_removeModule() , so that once a module has been removed, it could be added back if desired.\n\n# **Resolution**\n\nThe development team indicated that \"the behavior is understood and expected\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) However, they also implemented requested changes [here.](https://github.com/DIMO-Network/dimo-identity/commit/744a2415da3a6ed5b74b3fc31cee5a35434e9681) Modules can now be added back to the system after removal.\n", "sections": {"description_md": "## **Description**\n\nBecause of the check on line [**129**] of DIMORegistry.sol , it is not possible to add additional selectors from an implementation contract once any selectors at all have been added. This is because selectorsHash[implementation] will be set on module addition at line [**141**] and this value is never modified.\n\nThis may be present a risk if an implementation contract is removed, and then the protocol wishes to add it back to the registry again, or if the protocol wishes to add more function signatures from an already registered implementation contract.\n\nIn either case, the implementation contract in question would need to be redeployed.\n", "impact_md": null, "recommendation_md": "## **Recommendations**\n\nMake sure this behaviour is understood and expected.\n\nThe development team may want to consider adding s.selectorsHash[implementation] = 0x0 at line [**165**], at the end of \\_removeModule() , so that once a module has been removed, it could be added back if desired.\n", "poc_md": null, "fix_status_md": "# **Resolution**\n\nThe development team indicated that \"the behavior is understood and expected\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) However, they also implemented requested changes [here.](https://github.com/DIMO-Network/dimo-identity/commit/744a2415da3a6ed5b74b3fc31cee5a35434e9681) Modules can now be added back to the system after removal.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nBecause of the check on line [**129**] of DIMORegistry.sol , it is not possible to add additional selectors from an implementation contract once any selectors at all have been added. This is because selectorsHash[implementation] will be set on module addition at line [**141**] and this value is never modified.\n\nThis may be present a risk if an implementation contract is removed, and then the protocol wishes to add it back to the registry again, or if the protocol wishes to add more function signatures from an already registered implementation contract.\n\nIn either case, the implementation contract in question would need to be redeployed.\n\n## **Recommendations**\n\nMake sure this behaviour is understood and expected.\n\nThe development team may want to consider adding s.selectorsHash[implementation] = 0x0 at line [**165**], at the end of \\_removeModule() , so that once a module has been removed, it could be added back if desired.\n\n# **Resolution**\n\nThe development team indicated that \"the behavior is understood and expected\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) However, they also implemented requested changes [here.](https://github.com/DIMO-Network/dimo-identity/commit/744a2415da3a6ed5b74b3fc31cee5a35434e9681) Modules can now be added back to the system after removal.\n", "markdown_raw": "| DMO-10 | Ineffective Function Signature Registry Change Process |  |  |\n|--------|--------------------------------------------------------|--|--|\n| Asset  | DIMORegistry.sol                                       |  |  |\n| Status | Resolved: See Resolution                               |  |  |\n| Rating | Informational                                          |  |  |\n\n## **Description**\n\nBecause of the check on line [**129**] of DIMORegistry.sol , it is not possible to add additional selectors from an implementation contract once any selectors at all have been added. This is because selectorsHash[implementation] will be set on module addition at line [**141**] and this value is never modified.\n\nThis may be present a risk if an implementation contract is removed, and then the protocol wishes to add it back to the registry again, or if the protocol wishes to add more function signatures from an already registered implementation contract.\n\nIn either case, the implementation contract in question would need to be redeployed.\n\n## **Recommendations**\n\nMake sure this behaviour is understood and expected.\n\nThe development team may want to consider adding s.selectorsHash[implementation] = 0x0 at line [**165**], at the end of \\_removeModule() , so that once a module has been removed, it could be added back if desired.\n\n# <span id=\"page-15-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood and expected\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) However, they also implemented requested changes [here.](https://github.com/DIMO-Network/dimo-identity/commit/744a2415da3a6ed5b74b3fc31cee5a35434e9681) Modules can now be added back to the system after removal.\n\n{16}------------------------------------------------\n\n<span id=\"page-16-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Logic Error", "finding_id": "DMO-10", "target": {"path": "DIMORegistry.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "744a2415da3a6ed5b74b3fc31cee5a35434e9681", "branch": null, "relative_file": "DIMORegistry.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "# **Resolution**\n\nThe development team indicated that \"the behavior is understood and expected\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) However, they also implemented requested changes [here.](https://github.com/DIMO-Network/dimo-identity/commit/744a2415da3a6ed5b74b3fc31cee5a35434e9681) Modules can now be added back to the system after removal.\n", "fixed_in_commit": "744a2415da3a6ed5b74b3fc31cee5a35434e9681", "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-10", "Target": "DIMORegistry.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-011", "doc_id": "sigmaprime_dimo_review", "finding_index": 11, "page_start": 16, "title": "fallback Function Could Potentially Cause Unintended Side-Effects", "short_summary": null, "description_md": "## **Description**\n\nThe \\_addModule() function will add any function signature, even if it is not present on a module contract. If a module contract is added which contains a fallback function, that is what will be called when the nonexistant function signature is called on the registry contract.\n\nThere is no particular exploit scenario present in the current contracts, but this does suggest itself as either a way to hide attack code, or a possible unexpected scenario that might result from a deployment error (if a function signature is entered incorrectly, for example).\n", "full_markdown": "| DMO-11 | fallback Function Could Potentially Cause Unintended Side-Effects |  |  |\n|--------|-------------------------------------------------------------------|--|--|\n| Asset  | DIMORegistry.sol                                                  |  |  |\n| Status | Resolved: See Resolution                                          |  |  |\n| Rating | Informational                                                     |  |  |\n\n## **Description**\n\nThe \\_addModule() function will add any function signature, even if it is not present on a module contract. If a module contract is added which contains a fallback function, that is what will be called when the nonexistant function signature is called on the registry contract.\n\nThere is no particular exploit scenario present in the current contracts, but this does suggest itself as either a way to hide attack code, or a possible unexpected scenario that might result from a deployment error (if a function signature is entered incorrectly, for example).\n\n## **Recommendations**\n\nBe aware of this issue and avoid module contracts that implement a fallback .\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system. In doing so they will ensure no fallback functions are present in added modules.\n", "sections": {"description_md": "## **Description**\n\nThe \\_addModule() function will add any function signature, even if it is not present on a module contract. If a module contract is added which contains a fallback function, that is what will be called when the nonexistant function signature is called on the registry contract.\n\nThere is no particular exploit scenario present in the current contracts, but this does suggest itself as either a way to hide attack code, or a possible unexpected scenario that might result from a deployment error (if a function signature is entered incorrectly, for example).\n", "impact_md": null, "recommendation_md": "## **Recommendations**\n\nBe aware of this issue and avoid module contracts that implement a fallback .\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system. In doing so they will ensure no fallback functions are present in added modules.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nThe \\_addModule() function will add any function signature, even if it is not present on a module contract. If a module contract is added which contains a fallback function, that is what will be called when the nonexistant function signature is called on the registry contract.\n\nThere is no particular exploit scenario present in the current contracts, but this does suggest itself as either a way to hide attack code, or a possible unexpected scenario that might result from a deployment error (if a function signature is entered incorrectly, for example).\n\n## **Recommendations**\n\nBe aware of this issue and avoid module contracts that implement a fallback .\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system. In doing so they will ensure no fallback functions are present in added modules.\n", "markdown_raw": "| DMO-11 | fallback Function Could Potentially Cause Unintended Side-Effects |  |  |\n|--------|-------------------------------------------------------------------|--|--|\n| Asset  | DIMORegistry.sol                                                  |  |  |\n| Status | Resolved: See Resolution                                          |  |  |\n| Rating | Informational                                                     |  |  |\n\n## **Description**\n\nThe \\_addModule() function will add any function signature, even if it is not present on a module contract. If a module contract is added which contains a fallback function, that is what will be called when the nonexistant function signature is called on the registry contract.\n\nThere is no particular exploit scenario present in the current contracts, but this does suggest itself as either a way to hide attack code, or a possible unexpected scenario that might result from a deployment error (if a function signature is entered incorrectly, for example).\n\n## **Recommendations**\n\nBe aware of this issue and avoid module contracts that implement a fallback .\n\n#### <span id=\"page-16-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system. In doing so they will ensure no fallback functions are present in added modules.\n\n{17}------------------------------------------------\n\n<span id=\"page-17-0\"></span>\n"}, "severity": "Informational", "difficulty": null, "type": "Logic Error", "finding_id": "DMO-11", "target": {"path": "DIMORegistry.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "744a2415da3a6ed5b74b3fc31cee5a35434e9681", "branch": null, "relative_file": "DIMORegistry.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as shown in [PR#25.](https://github.com/DIMO-Network/dimo-identity/pull/25) They intend to conduct a security review on all modules added to the system. In doing so they will ensure no fallback functions are present in added modules.\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Informational", "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-11", "Target": "DIMORegistry.sol", "Severity_normalized": "Informational"}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-012", "doc_id": "sigmaprime_dimo_review", "finding_index": 12, "page_start": 17, "title": "Bypassable Limitations on NFT Minting", "short_summary": null, "description_md": "## **Description**\n\nRoot.mintRoot() contains a system based on the value s.controllers[\\_owner].rootMinted which only allows on root NFT to be minted to any given address. As clarified by the development team, the purpose of this check is to avoid one address holding multiple root NFTs.\n\nHowever, as the NFTs are transferable, it would be easy for their owners to move them around and place many on a single address. In effect, therefore, the restriction imposed by s.controllers[\\_owner].rootMinted only really limits the minting powers of DIMO.\n", "full_markdown": "| DMO-12 | Bypassable Limitations on NFT Minting |  |\n|--------|---------------------------------------|--|\n| Asset  | Root.sol                              |  |\n| Status | Resolved: See Resolution              |  |\n| Rating | Informational                         |  |\n\n## **Description**\n\nRoot.mintRoot() contains a system based on the value s.controllers[\\_owner].rootMinted which only allows on root NFT to be minted to any given address. As clarified by the development team, the purpose of this check is to avoid one address holding multiple root NFTs.\n\nHowever, as the NFTs are transferable, it would be easy for their owners to move them around and place many on a single address. In effect, therefore, the restriction imposed by s.controllers[\\_owner].rootMinted only really limits the minting powers of DIMO.\n\n#### **Recommendations**\n\nThe team may wish to make the NFTs non-transferable or transferable only by the DIMO team. It would be possible to modify the NFT contracts to cause a transfer to revert if the new owner already owns a root NFT.\n\nAlternatively, s.controllers[\\_owner].rootMinted and its associated checks and restrictions could simply be removed.\n\n#### **Resolution**\n\nThis issue was fixed in the following [commit #bc5efdf3.](https://github.com/DIMO-Network/dimo-identity/commit/bc5efdf39a514c003f86f1051d83fac516a170de) Token transfers are no longer possible.\n", "sections": {"description_md": "## **Description**\n\nRoot.mintRoot() contains a system based on the value s.controllers[\\_owner].rootMinted which only allows on root NFT to be minted to any given address. As clarified by the development team, the purpose of this check is to avoid one address holding multiple root NFTs.\n\nHowever, as the NFTs are transferable, it would be easy for their owners to move them around and place many on a single address. In effect, therefore, the restriction imposed by s.controllers[\\_owner].rootMinted only really limits the minting powers of DIMO.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nThe team may wish to make the NFTs non-transferable or transferable only by the DIMO team. It would be possible to modify the NFT contracts to cause a transfer to revert if the new owner already owns a root NFT.\n\nAlternatively, s.controllers[\\_owner].rootMinted and its associated checks and restrictions could simply be removed.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThis issue was fixed in the following [commit #bc5efdf3.](https://github.com/DIMO-Network/dimo-identity/commit/bc5efdf39a514c003f86f1051d83fac516a170de) Token transfers are no longer possible.\n", "other_md": null, "full_markdown_body": "## **Description**\n\nRoot.mintRoot() contains a system based on the value s.controllers[\\_owner].rootMinted which only allows on root NFT to be minted to any given address. As clarified by the development team, the purpose of this check is to avoid one address holding multiple root NFTs.\n\nHowever, as the NFTs are transferable, it would be easy for their owners to move them around and place many on a single address. In effect, therefore, the restriction imposed by s.controllers[\\_owner].rootMinted only really limits the minting powers of DIMO.\n\n#### **Recommendations**\n\nThe team may wish to make the NFTs non-transferable or transferable only by the DIMO team. It would be possible to modify the NFT contracts to cause a transfer to revert if the new owner already owns a root NFT.\n\nAlternatively, s.controllers[\\_owner].rootMinted and its associated checks and restrictions could simply be removed.\n\n#### **Resolution**\n\nThis issue was fixed in the following [commit #bc5efdf3.](https://github.com/DIMO-Network/dimo-identity/commit/bc5efdf39a514c003f86f1051d83fac516a170de) Token transfers are no longer possible.\n", "markdown_raw": "| DMO-12 | Bypassable Limitations on NFT Minting |  |\n|--------|---------------------------------------|--|\n| Asset  | Root.sol                              |  |\n| Status | Resolved: See Resolution              |  |\n| Rating | Informational                         |  |\n\n## **Description**\n\nRoot.mintRoot() contains a system based on the value s.controllers[\\_owner].rootMinted which only allows on root NFT to be minted to any given address. As clarified by the development team, the purpose of this check is to avoid one address holding multiple root NFTs.\n\nHowever, as the NFTs are transferable, it would be easy for their owners to move them around and place many on a single address. In effect, therefore, the restriction imposed by s.controllers[\\_owner].rootMinted only really limits the minting powers of DIMO.\n\n#### **Recommendations**\n\nThe team may wish to make the NFTs non-transferable or transferable only by the DIMO team. It would be possible to modify the NFT contracts to cause a transfer to revert if the new owner already owns a root NFT.\n\nAlternatively, s.controllers[\\_owner].rootMinted and its associated checks and restrictions could simply be removed.\n\n#### <span id=\"page-17-1\"></span>**Resolution**\n\nThis issue was fixed in the following [commit #bc5efdf3.](https://github.com/DIMO-Network/dimo-identity/commit/bc5efdf39a514c003f86f1051d83fac516a170de) Token transfers are no longer possible.\n\n{18}------------------------------------------------\n\n<span id=\"page-18-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Access control", "finding_id": "DMO-12", "target": {"path": "Root.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "744a2415da3a6ed5b74b3fc31cee5a35434e9681", "branch": null, "relative_file": "Root.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThis issue was fixed in the following [commit #bc5efdf3.](https://github.com/DIMO-Network/dimo-identity/commit/bc5efdf39a514c003f86f1051d83fac516a170de) Token transfers are no longer possible.\n", "fixed_in_commit": "bc5efdf3", "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Access control", "Finding ID": "DMO-12", "Target": "Root.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-013", "doc_id": "sigmaprime_dimo_review", "finding_index": 13, "page_start": 18, "title": "Releasable Funds Can Be Revoked", "short_summary": null, "description_md": "#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has expired. Tokens can be released after the cliff period, with all tokens becoming redeemable after the vesting duration has expired.\n\nVesting contracts are generally transparent contracts that handle how funds are released and when. However, Dimo reserves the ability to revoke() vesting positions at any time. In some circumstances revoking is necessary, however, if users already have a redeemable amount of tokens, the owner of the vesting contract can revoke the redeemable amount.\n\nThe contract will only validate the total previously released amount, and any unreleased amount will also be sent back to the vesting owner . This logic is described in the code snippet below:\n\n```\nuint256 unreleased = vestingSchedule.amountTotal -\nvestingSchedule.released;\n    if (unreleased > 0) {\n        _token.safeTransfer(owner(), unreleased);\n    }\n```\n", "full_markdown": "| DMO-13 | Releasable Funds Can Be Revoked |\n|--------|---------------------------------|\n| Asset  | DIMOVesting.sol                 |\n| Status | Closed: See Resolution          |\n| Rating | Informational                   |\n\n#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has expired. Tokens can be released after the cliff period, with all tokens becoming redeemable after the vesting duration has expired.\n\nVesting contracts are generally transparent contracts that handle how funds are released and when. However, Dimo reserves the ability to revoke() vesting positions at any time. In some circumstances revoking is necessary, however, if users already have a redeemable amount of tokens, the owner of the vesting contract can revoke the redeemable amount.\n\nThe contract will only validate the total previously released amount, and any unreleased amount will also be sent back to the vesting owner . This logic is described in the code snippet below:\n\n```\nuint256 unreleased = vestingSchedule.amountTotal -\nvestingSchedule.released;\n    if (unreleased > 0) {\n        _token.safeTransfer(owner(), unreleased);\n    }\n```\n\n#### **Recommendations**\n\nMake sure this behaviour is understood and intended, and consider mentioning this explicitly in any relevant documentation.\n\nIf this behaviour is not intended, modification of DIMOVesting might include calculations of releasable token amounts and excluding these from the unreleased variable on line [**100**].\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "sections": {"description_md": "#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has expired. Tokens can be released after the cliff period, with all tokens becoming redeemable after the vesting duration has expired.\n\nVesting contracts are generally transparent contracts that handle how funds are released and when. However, Dimo reserves the ability to revoke() vesting positions at any time. In some circumstances revoking is necessary, however, if users already have a redeemable amount of tokens, the owner of the vesting contract can revoke the redeemable amount.\n\nThe contract will only validate the total previously released amount, and any unreleased amount will also be sent back to the vesting owner . This logic is described in the code snippet below:\n\n```\nuint256 unreleased = vestingSchedule.amountTotal -\nvestingSchedule.released;\n    if (unreleased > 0) {\n        _token.safeTransfer(owner(), unreleased);\n    }\n```\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nMake sure this behaviour is understood and intended, and consider mentioning this explicitly in any relevant documentation.\n\nIf this behaviour is not intended, modification of DIMOVesting might include calculations of releasable token amounts and excluding these from the unreleased variable on line [**100**].\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "other_md": null, "full_markdown_body": "#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has expired. Tokens can be released after the cliff period, with all tokens becoming redeemable after the vesting duration has expired.\n\nVesting contracts are generally transparent contracts that handle how funds are released and when. However, Dimo reserves the ability to revoke() vesting positions at any time. In some circumstances revoking is necessary, however, if users already have a redeemable amount of tokens, the owner of the vesting contract can revoke the redeemable amount.\n\nThe contract will only validate the total previously released amount, and any unreleased amount will also be sent back to the vesting owner . This logic is described in the code snippet below:\n\n```\nuint256 unreleased = vestingSchedule.amountTotal -\nvestingSchedule.released;\n    if (unreleased > 0) {\n        _token.safeTransfer(owner(), unreleased);\n    }\n```\n\n#### **Recommendations**\n\nMake sure this behaviour is understood and intended, and consider mentioning this explicitly in any relevant documentation.\n\nIf this behaviour is not intended, modification of DIMOVesting might include calculations of releasable token amounts and excluding these from the unreleased variable on line [**100**].\n\n#### **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "markdown_raw": "| DMO-13 | Releasable Funds Can Be Revoked |\n|--------|---------------------------------|\n| Asset  | DIMOVesting.sol                 |\n| Status | Closed: See Resolution          |\n| Rating | Informational                   |\n\n#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has expired. Tokens can be released after the cliff period, with all tokens becoming redeemable after the vesting duration has expired.\n\nVesting contracts are generally transparent contracts that handle how funds are released and when. However, Dimo reserves the ability to revoke() vesting positions at any time. In some circumstances revoking is necessary, however, if users already have a redeemable amount of tokens, the owner of the vesting contract can revoke the redeemable amount.\n\nThe contract will only validate the total previously released amount, and any unreleased amount will also be sent back to the vesting owner . This logic is described in the code snippet below:\n\n```\nuint256 unreleased = vestingSchedule.amountTotal -\nvestingSchedule.released;\n    if (unreleased > 0) {\n        _token.safeTransfer(owner(), unreleased);\n    }\n```\n\n#### **Recommendations**\n\nMake sure this behaviour is understood and intended, and consider mentioning this explicitly in any relevant documentation.\n\nIf this behaviour is not intended, modification of DIMOVesting might include calculations of releasable token amounts and excluding these from the unreleased variable on line [**100**].\n\n#### <span id=\"page-18-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n\n{19}------------------------------------------------\n\n<span id=\"page-19-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Access Control", "finding_id": "DMO-13", "target": {"path": "DIMOVesting.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "744a2415da3a6ed5b74b3fc31cee5a35434e9681", "branch": null, "relative_file": "DIMOVesting.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Access Control", "Finding ID": "DMO-13", "Target": "DIMOVesting.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-014", "doc_id": "sigmaprime_dimo_review", "finding_index": 14, "page_start": 19, "title": "Possible Reentrancy by Permissioned owner Account", "short_summary": null, "description_md": "#### **Description**\n\nThe token transfer on line [**103**] of DIMOVesting.sol is an external call. If owner can regain execution control during that call, they could potentially call revoke() for the same vest and keep draining out tokens.\n\nThe impact of this issue is mitigated heavily by [DMO-13,](#page-18-0) which already gives owner the ability to withdraw all the tokens in the vesting contract by calling revoke on all open vests. This issue would become a lot more significant if that issue were resolved.\n", "full_markdown": "| DMO-14 | Possible Reentrancy by Permissioned owner Account |\n|--------|---------------------------------------------------|\n| Asset  | DIMOVesting.sol                                   |\n| Status | Resolved: See Resolution                          |\n| Rating | Informational                                     |\n\n#### **Description**\n\nThe token transfer on line [**103**] of DIMOVesting.sol is an external call. If owner can regain execution control during that call, they could potentially call revoke() for the same vest and keep draining out tokens.\n\nThe impact of this issue is mitigated heavily by [DMO-13,](#page-18-0) which already gives owner the ability to withdraw all the tokens in the vesting contract by calling revoke on all open vests. This issue would become a lot more significant if that issue were resolved.\n\n#### **Recommendations**\n\nConsider moving the token transfer to the end of the revoke() function, after all the state variable updates.\n\n#### **Resolution**\n\nThe issue has been fixed in [commit 6a04cbf8.](https://github.com/DIMO-Network/DIMO-vesting/commit/6a04cbf8b2af74d8be58b32a2710df68ddb7aa04) Check-effects pattern was implemented, preventing re-entrancy from impacting accountancy variables.\n", "sections": {"description_md": "#### **Description**\n\nThe token transfer on line [**103**] of DIMOVesting.sol is an external call. If owner can regain execution control during that call, they could potentially call revoke() for the same vest and keep draining out tokens.\n\nThe impact of this issue is mitigated heavily by [DMO-13,](#page-18-0) which already gives owner the ability to withdraw all the tokens in the vesting contract by calling revoke on all open vests. This issue would become a lot more significant if that issue were resolved.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nConsider moving the token transfer to the end of the revoke() function, after all the state variable updates.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nThe issue has been fixed in [commit 6a04cbf8.](https://github.com/DIMO-Network/DIMO-vesting/commit/6a04cbf8b2af74d8be58b32a2710df68ddb7aa04) Check-effects pattern was implemented, preventing re-entrancy from impacting accountancy variables.\n", "other_md": null, "full_markdown_body": "#### **Description**\n\nThe token transfer on line [**103**] of DIMOVesting.sol is an external call. If owner can regain execution control during that call, they could potentially call revoke() for the same vest and keep draining out tokens.\n\nThe impact of this issue is mitigated heavily by [DMO-13,](#page-18-0) which already gives owner the ability to withdraw all the tokens in the vesting contract by calling revoke on all open vests. This issue would become a lot more significant if that issue were resolved.\n\n#### **Recommendations**\n\nConsider moving the token transfer to the end of the revoke() function, after all the state variable updates.\n\n#### **Resolution**\n\nThe issue has been fixed in [commit 6a04cbf8.](https://github.com/DIMO-Network/DIMO-vesting/commit/6a04cbf8b2af74d8be58b32a2710df68ddb7aa04) Check-effects pattern was implemented, preventing re-entrancy from impacting accountancy variables.\n", "markdown_raw": "| DMO-14 | Possible Reentrancy by Permissioned owner Account |\n|--------|---------------------------------------------------|\n| Asset  | DIMOVesting.sol                                   |\n| Status | Resolved: See Resolution                          |\n| Rating | Informational                                     |\n\n#### **Description**\n\nThe token transfer on line [**103**] of DIMOVesting.sol is an external call. If owner can regain execution control during that call, they could potentially call revoke() for the same vest and keep draining out tokens.\n\nThe impact of this issue is mitigated heavily by [DMO-13,](#page-18-0) which already gives owner the ability to withdraw all the tokens in the vesting contract by calling revoke on all open vests. This issue would become a lot more significant if that issue were resolved.\n\n#### **Recommendations**\n\nConsider moving the token transfer to the end of the revoke() function, after all the state variable updates.\n\n#### <span id=\"page-19-1\"></span>**Resolution**\n\nThe issue has been fixed in [commit 6a04cbf8.](https://github.com/DIMO-Network/DIMO-vesting/commit/6a04cbf8b2af74d8be58b32a2710df68ddb7aa04) Check-effects pattern was implemented, preventing re-entrancy from impacting accountancy variables.\n\n{20}------------------------------------------------\n\n<span id=\"page-20-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Reentrancy", "finding_id": "DMO-14", "target": {"path": "DIMOVesting.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "744a2415da3a6ed5b74b3fc31cee5a35434e9681", "branch": null, "relative_file": "DIMOVesting.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nThe issue has been fixed in [commit 6a04cbf8.](https://github.com/DIMO-Network/DIMO-vesting/commit/6a04cbf8b2af74d8be58b32a2710df68ddb7aa04) Check-effects pattern was implemented, preventing re-entrancy from impacting accountancy variables.\n", "fixed_in_commit": "6a04cbf8", "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Reentrancy", "Finding ID": "DMO-14", "Target": "DIMOVesting.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-015", "doc_id": "sigmaprime_dimo_review", "finding_index": 15, "page_start": 20, "title": "Lack of Validation on Vesting Start Time", "short_summary": null, "description_md": "#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has elapsed. Vesting relies on a function \\_computeReleasableAmount() to calculate the amount to release. This function will only compute after a set start time has elapsed.\n\nIf owner() sets the start time to 0 (or any equivalent early epoch), vesting beneficiaries can instantly redeem the full amount.\n", "full_markdown": "| DMO-15 | Lack of Validation on Vesting Start Time |\n|--------|------------------------------------------|\n| Asset  | DIMOVesting.sol                          |\n| Status | Closed: See Resolution                   |\n| Rating | Informational                            |\n\n#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has elapsed. Vesting relies on a function \\_computeReleasableAmount() to calculate the amount to release. This function will only compute after a set start time has elapsed.\n\nIf owner() sets the start time to 0 (or any equivalent early epoch), vesting beneficiaries can instantly redeem the full amount.\n\n#### **Recommendations**\n\nEnsure this behaviour is understood and consider adding checks for the \\_start variable to be within valid bounds (for example restricting start time to at least the current epoch).\n\n# **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "sections": {"description_md": "#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has elapsed. Vesting relies on a function \\_computeReleasableAmount() to calculate the amount to release. This function will only compute after a set start time has elapsed.\n\nIf owner() sets the start time to 0 (or any equivalent early epoch), vesting beneficiaries can instantly redeem the full amount.\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nEnsure this behaviour is understood and consider adding checks for the \\_start variable to be within valid bounds (for example restricting start time to at least the current epoch).\n", "poc_md": null, "fix_status_md": "# **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "other_md": null, "full_markdown_body": "#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has elapsed. Vesting relies on a function \\_computeReleasableAmount() to calculate the amount to release. This function will only compute after a set start time has elapsed.\n\nIf owner() sets the start time to 0 (or any equivalent early epoch), vesting beneficiaries can instantly redeem the full amount.\n\n#### **Recommendations**\n\nEnsure this behaviour is understood and consider adding checks for the \\_start variable to be within valid bounds (for example restricting start time to at least the current epoch).\n\n# **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "markdown_raw": "| DMO-15 | Lack of Validation on Vesting Start Time |\n|--------|------------------------------------------|\n| Asset  | DIMOVesting.sol                          |\n| Status | Closed: See Resolution                   |\n| Rating | Informational                            |\n\n#### **Description**\n\nThe DIMOVesting contract handles vesting of tokens in order to guarantee release after a certain period of time has elapsed. Vesting relies on a function \\_computeReleasableAmount() to calculate the amount to release. This function will only compute after a set start time has elapsed.\n\nIf owner() sets the start time to 0 (or any equivalent early epoch), vesting beneficiaries can instantly redeem the full amount.\n\n#### **Recommendations**\n\nEnsure this behaviour is understood and consider adding checks for the \\_start variable to be within valid bounds (for example restricting start time to at least the current epoch).\n\n# <span id=\"page-20-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n\n{21}------------------------------------------------\n\n<span id=\"page-21-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Logic Error", "finding_id": "DMO-15", "target": {"path": "DIMOVesting.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "744a2415da3a6ed5b74b3fc31cee5a35434e9681", "branch": null, "relative_file": "DIMOVesting.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "# **Resolution**\n\nThe development team indicated that \"the behavior is understood and intended\" as shown in [PR#1.](https://github.com/DIMO-Network/DIMO-vesting/pull/1)\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Logic Error", "Finding ID": "DMO-15", "Target": "DIMOVesting.sol", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-016", "doc_id": "sigmaprime_dimo_review", "finding_index": 16, "page_start": 21, "title": "Token Deployment Script Conflicts with UUPS Recommendations", "short_summary": null, "description_md": "## **Description**\n\nDimoToken inherits the UUPS upgradeable logic, implying the use of this type of proxy is desired. The development team has confirmed this intention. However, deployment scripts and mainnet deployed V2 token appear to ignore UUPS design decisions and leverage the use of ERC1967 proxy.\n\nThe error can be seen in the the code block below:\n\n```\n const Dimo = await ethers.getContractFactory(\"Dimo\");\n     console.log(\"Deploying proxy and implementation.\");\n const dimo = await upgrades.deployProxy(Dimo);\n     await dimo.deployed();\n```\n\nline [**17**] shows the use of OpenZeppelin Hardhat upgrades plugin. This plugin requires the explicit declaration of the proxy type as follows: upgrades.deployProxy(Dimo, {kind: 'UUPS'}) . In the implementation, the kind of proxy is missing. OZ documentation states that use of function deployProxy() that is missing a value for proxy type will deploy as Transparent proxy.\n\nIn practice, the default behaviour of the proxy types were being altered at the time of deployment, which explains the behaviour of the contract deployments on mainnet. On mainnet, TokenV1 was deployed as an ERC1967 proxy. During the upgrade to V2, logic was included to ensure UUPS implementations were inherited and valid \\_authorizeUpgrade overrides prevented arbitrary users from upgrading the token. The mainnet TokenV2 contains logic to ensure only UPGRADER\\_ROLE is able to upgrade, which effectively mitigates the issue in the deployment script logic.\n\nIt is worth mentioning that the current UPGRADER\\_ROLE is held by the GNOSIS SAFE Proxy contract with address 84ae2025b9620fd926d4e60673fcea2385c79d8a .\n", "full_markdown": "| DMO-16 | Token Deployment Script Conflicts with UUPS Recommendations |\n|--------|-------------------------------------------------------------|\n| Asset  | scripts/deploy.js                                           |\n| Status | Closed: See Resolution                                      |\n| Rating | Informational                                               |\n\n## **Description**\n\nDimoToken inherits the UUPS upgradeable logic, implying the use of this type of proxy is desired. The development team has confirmed this intention. However, deployment scripts and mainnet deployed V2 token appear to ignore UUPS design decisions and leverage the use of ERC1967 proxy.\n\nThe error can be seen in the the code block below:\n\n```\n const Dimo = await ethers.getContractFactory(\"Dimo\");\n     console.log(\"Deploying proxy and implementation.\");\n const dimo = await upgrades.deployProxy(Dimo);\n     await dimo.deployed();\n```\n\nline [**17**] shows the use of OpenZeppelin Hardhat upgrades plugin. This plugin requires the explicit declaration of the proxy type as follows: upgrades.deployProxy(Dimo, {kind: 'UUPS'}) . In the implementation, the kind of proxy is missing. OZ documentation states that use of function deployProxy() that is missing a value for proxy type will deploy as Transparent proxy.\n\nIn practice, the default behaviour of the proxy types were being altered at the time of deployment, which explains the behaviour of the contract deployments on mainnet. On mainnet, TokenV1 was deployed as an ERC1967 proxy. During the upgrade to V2, logic was included to ensure UUPS implementations were inherited and valid \\_authorizeUpgrade overrides prevented arbitrary users from upgrading the token. The mainnet TokenV2 contains logic to ensure only UPGRADER\\_ROLE is able to upgrade, which effectively mitigates the issue in the deployment script logic.\n\nIt is worth mentioning that the current UPGRADER\\_ROLE is held by the GNOSIS SAFE Proxy contract with address 84ae2025b9620fd926d4e60673fcea2385c79d8a .\n\n#### **Recommendations**\n\nMake sure this behaviour is understood and acknowledged.\n\n# **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "sections": {"description_md": "## **Description**\n\nDimoToken inherits the UUPS upgradeable logic, implying the use of this type of proxy is desired. The development team has confirmed this intention. However, deployment scripts and mainnet deployed V2 token appear to ignore UUPS design decisions and leverage the use of ERC1967 proxy.\n\nThe error can be seen in the the code block below:\n\n```\n const Dimo = await ethers.getContractFactory(\"Dimo\");\n     console.log(\"Deploying proxy and implementation.\");\n const dimo = await upgrades.deployProxy(Dimo);\n     await dimo.deployed();\n```\n\nline [**17**] shows the use of OpenZeppelin Hardhat upgrades plugin. This plugin requires the explicit declaration of the proxy type as follows: upgrades.deployProxy(Dimo, {kind: 'UUPS'}) . In the implementation, the kind of proxy is missing. OZ documentation states that use of function deployProxy() that is missing a value for proxy type will deploy as Transparent proxy.\n\nIn practice, the default behaviour of the proxy types were being altered at the time of deployment, which explains the behaviour of the contract deployments on mainnet. On mainnet, TokenV1 was deployed as an ERC1967 proxy. During the upgrade to V2, logic was included to ensure UUPS implementations were inherited and valid \\_authorizeUpgrade overrides prevented arbitrary users from upgrading the token. The mainnet TokenV2 contains logic to ensure only UPGRADER\\_ROLE is able to upgrade, which effectively mitigates the issue in the deployment script logic.\n\nIt is worth mentioning that the current UPGRADER\\_ROLE is held by the GNOSIS SAFE Proxy contract with address 84ae2025b9620fd926d4e60673fcea2385c79d8a .\n", "impact_md": null, "recommendation_md": "#### **Recommendations**\n\nMake sure this behaviour is understood and acknowledged.\n", "poc_md": null, "fix_status_md": "# **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "other_md": null, "full_markdown_body": "## **Description**\n\nDimoToken inherits the UUPS upgradeable logic, implying the use of this type of proxy is desired. The development team has confirmed this intention. However, deployment scripts and mainnet deployed V2 token appear to ignore UUPS design decisions and leverage the use of ERC1967 proxy.\n\nThe error can be seen in the the code block below:\n\n```\n const Dimo = await ethers.getContractFactory(\"Dimo\");\n     console.log(\"Deploying proxy and implementation.\");\n const dimo = await upgrades.deployProxy(Dimo);\n     await dimo.deployed();\n```\n\nline [**17**] shows the use of OpenZeppelin Hardhat upgrades plugin. This plugin requires the explicit declaration of the proxy type as follows: upgrades.deployProxy(Dimo, {kind: 'UUPS'}) . In the implementation, the kind of proxy is missing. OZ documentation states that use of function deployProxy() that is missing a value for proxy type will deploy as Transparent proxy.\n\nIn practice, the default behaviour of the proxy types were being altered at the time of deployment, which explains the behaviour of the contract deployments on mainnet. On mainnet, TokenV1 was deployed as an ERC1967 proxy. During the upgrade to V2, logic was included to ensure UUPS implementations were inherited and valid \\_authorizeUpgrade overrides prevented arbitrary users from upgrading the token. The mainnet TokenV2 contains logic to ensure only UPGRADER\\_ROLE is able to upgrade, which effectively mitigates the issue in the deployment script logic.\n\nIt is worth mentioning that the current UPGRADER\\_ROLE is held by the GNOSIS SAFE Proxy contract with address 84ae2025b9620fd926d4e60673fcea2385c79d8a .\n\n#### **Recommendations**\n\nMake sure this behaviour is understood and acknowledged.\n\n# **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "markdown_raw": "| DMO-16 | Token Deployment Script Conflicts with UUPS Recommendations |\n|--------|-------------------------------------------------------------|\n| Asset  | scripts/deploy.js                                           |\n| Status | Closed: See Resolution                                      |\n| Rating | Informational                                               |\n\n## **Description**\n\nDimoToken inherits the UUPS upgradeable logic, implying the use of this type of proxy is desired. The development team has confirmed this intention. However, deployment scripts and mainnet deployed V2 token appear to ignore UUPS design decisions and leverage the use of ERC1967 proxy.\n\nThe error can be seen in the the code block below:\n\n```\n const Dimo = await ethers.getContractFactory(\"Dimo\");\n     console.log(\"Deploying proxy and implementation.\");\n const dimo = await upgrades.deployProxy(Dimo);\n     await dimo.deployed();\n```\n\nline [**17**] shows the use of OpenZeppelin Hardhat upgrades plugin. This plugin requires the explicit declaration of the proxy type as follows: upgrades.deployProxy(Dimo, {kind: 'UUPS'}) . In the implementation, the kind of proxy is missing. OZ documentation states that use of function deployProxy() that is missing a value for proxy type will deploy as Transparent proxy.\n\nIn practice, the default behaviour of the proxy types were being altered at the time of deployment, which explains the behaviour of the contract deployments on mainnet. On mainnet, TokenV1 was deployed as an ERC1967 proxy. During the upgrade to V2, logic was included to ensure UUPS implementations were inherited and valid \\_authorizeUpgrade overrides prevented arbitrary users from upgrading the token. The mainnet TokenV2 contains logic to ensure only UPGRADER\\_ROLE is able to upgrade, which effectively mitigates the issue in the deployment script logic.\n\nIt is worth mentioning that the current UPGRADER\\_ROLE is held by the GNOSIS SAFE Proxy contract with address 84ae2025b9620fd926d4e60673fcea2385c79d8a .\n\n#### **Recommendations**\n\nMake sure this behaviour is understood and acknowledged.\n\n# <span id=\"page-21-1\"></span>**Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n\n{22}------------------------------------------------\n\n<span id=\"page-22-0\"></span>\n"}, "severity": null, "difficulty": null, "type": "Deployment Issue", "finding_id": "DMO-16", "target": {"path": "scripts/deploy.js", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "bc5efdf39a514c003f86f1051d83fac516a170de", "branch": null, "relative_file": "scripts/deploy.js", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "# **Resolution**\n\nThe development team indicated that \"the behavior is understood\" as seen in [PR#2.](https://github.com/DIMO-Network/dimo-token/pull/2)\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Deployment Issue", "Finding ID": "DMO-16", "Target": "scripts/deploy.js", "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-sigmaprime_dimo_review-017", "doc_id": "sigmaprime_dimo_review", "finding_index": 17, "page_start": 22, "title": "Miscellaneous General Comments", "short_summary": null, "description_md": "#### **Description**\n\nThis section details miscellaneous findings in the Dimo contracts.\n\n#### 1. **Minimise Function Access:**\n\nIt is best practice to use the minimum visibility for a function, for gas saving purposes:\n\n- DimoV2.pause() should be declared external.\n- DimoV2.unpause() should be declared external.\n- DimoV2.mint() should be declared external.\n\n#### 2. **Checks Effects Interactions:**\n\nIt is best practice to structure code in the order of making checks then updating variables and lastly interacting externally. This is to prevent reentrancy. Although there was no specific exploitable reentrancy occurrence detected (apart from [DMO-14\\)](#page-19-0), it is nonetheless recommended to reorder code to follow the *\"Checks-Effects-Interactions\"* pattern.\n\n- In Root,sol, \\_safeMint() should be moved from line [**112**] to line [**116**], below the state variable updates.\n- In Root,sol, \\_safeMint() should be moved from line [**84**] to line [**88**], below the state variable updates.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n- DimoChildToken.deposit.depositData\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller\n- Root.mintRootBatch.\\_owner\n- Root.mintRoot.\\_owner\n- Vehicle.mintVehicle.\\_owner ( Vehicle.mintVehicleSign.\\_owner is not necessary because of the signature)\n- Root.mintRootBatch.\\_owner\n\n#### 4. **Comment Issues:**\n\n DIMORegistry line [**108**] and line [**144**] comments describe the add functionality, not remove.\n\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\nDIMORegistry line [**161**] states that a selector is unregistered. By the logic of this contract, this check should always pass, as execution can only reach this point if the check on line [**153**] established that s.selectorsHash[implementation] is equal to a hash that contains the selector in question. Nevertheless, it could be modified by a module. In that case, the comment could be incorrect: a selector that is registered to a different implementation would also fail this check.\n\n#### 6. **Registry Function Signature Collisions:**\n\nDIMORegistry does not allow modules to be added if s.implementations[selectors[i]] != address(0) , therefore registered function selectors cannot be duplicated across modules. This provides some security benefits, however, function signatures can collide. For example withdraw(uint256) and OwnerTransferV7b711143(uint256) unexpectedly produce a single function signature of 2e1a7d4d . All modules should therefore be checked for any potential function signature collisions with other modules.\n\n#### 7. **Possible Specification Problem:**\n\nRoot.mintRootBatch() can be successfully called whether 'name' attribute is whitelisted in advance or not. Note this in relation to the comment on line [**66**] which says *It is assumed the 'name' attribute is whitelisted in advance*.\n\n#### 8. **Vehicle without Root:**\n\nVehicle.addRootAttribute() and Vehicle.mintRoot() are both callable if no vehicle nodeType is set in the VehicleStorage .\n\n#### 9. **Error Message Wording:**\n\nThe error string on line [**128**] of DIMOVesting.sol refers to \"vested\" tokens, when it means \"releasable\" tokens. It might be clearer to rephrase the entire message as, \"amount is too high\".\n\n#### 10. **Uninitialised Roles:**\n\nDimo Token V1 initially grants all roles to the admin address in its initializer. Dimo Token V2 does not have an initializer and so the role BURNER\\_ROLE is not initially granted to any address.\n\nThis role can however be granted directly through the function grantRole() .\n", "full_markdown": "| DMO-17 | Miscellaneous General Comments |\n|--------|--------------------------------|\n| Asset  | *.sol                          |\n| Status | Closed: See Resolution         |\n| Rating | Informational                  |\n\n#### **Description**\n\nThis section details miscellaneous findings in the Dimo contracts.\n\n#### 1. **Minimise Function Access:**\n\nIt is best practice to use the minimum visibility for a function, for gas saving purposes:\n\n- DimoV2.pause() should be declared external.\n- DimoV2.unpause() should be declared external.\n- DimoV2.mint() should be declared external.\n\n#### 2. **Checks Effects Interactions:**\n\nIt is best practice to structure code in the order of making checks then updating variables and lastly interacting externally. This is to prevent reentrancy. Although there was no specific exploitable reentrancy occurrence detected (apart from [DMO-14\\)](#page-19-0), it is nonetheless recommended to reorder code to follow the *\"Checks-Effects-Interactions\"* pattern.\n\n- In Root,sol, \\_safeMint() should be moved from line [**112**] to line [**116**], below the state variable updates.\n- In Root,sol, \\_safeMint() should be moved from line [**84**] to line [**88**], below the state variable updates.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n- DimoChildToken.deposit.depositData\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller\n- Root.mintRootBatch.\\_owner\n- Root.mintRoot.\\_owner\n- Vehicle.mintVehicle.\\_owner ( Vehicle.mintVehicleSign.\\_owner is not necessary because of the signature)\n- Root.mintRootBatch.\\_owner\n\n#### 4. **Comment Issues:**\n\n DIMORegistry line [**108**] and line [**144**] comments describe the add functionality, not remove.\n\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\nDIMORegistry line [**161**] states that a selector is unregistered. By the logic of this contract, this check should always pass, as execution can only reach this point if the check on line [**153**] established that s.selectorsHash[implementation] is equal to a hash that contains the selector in question. Nevertheless, it could be modified by a module. In that case, the comment could be incorrect: a selector that is registered to a different implementation would also fail this check.\n\n#### 6. **Registry Function Signature Collisions:**\n\nDIMORegistry does not allow modules to be added if s.implementations[selectors[i]] != address(0) , therefore registered function selectors cannot be duplicated across modules. This provides some security benefits, however, function signatures can collide. For example withdraw(uint256) and OwnerTransferV7b711143(uint256) unexpectedly produce a single function signature of 2e1a7d4d . All modules should therefore be checked for any potential function signature collisions with other modules.\n\n#### 7. **Possible Specification Problem:**\n\nRoot.mintRootBatch() can be successfully called whether 'name' attribute is whitelisted in advance or not. Note this in relation to the comment on line [**66**] which says *It is assumed the 'name' attribute is whitelisted in advance*.\n\n#### 8. **Vehicle without Root:**\n\nVehicle.addRootAttribute() and Vehicle.mintRoot() are both callable if no vehicle nodeType is set in the VehicleStorage .\n\n#### 9. **Error Message Wording:**\n\nThe error string on line [**128**] of DIMOVesting.sol refers to \"vested\" tokens, when it means \"releasable\" tokens. It might be clearer to rephrase the entire message as, \"amount is too high\".\n\n#### 10. **Uninitialised Roles:**\n\nDimo Token V1 initially grants all roles to the admin address in its initializer. Dimo Token V2 does not have an initializer and so the role BURNER\\_ROLE is not initially granted to any address.\n\nThis role can however be granted directly through the function grantRole() .\n\n# **Recommendations**\n\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.\n\n#### **Resolution**\n\nhe issues were addressed in three separate pull requests across three repositories. Those include [DIMO token PR#2,](https://github.com/DIMO-Network/dimo-token/pull/2) .\n\n#### 1. **Minimise Function Access:**\n\n1a) Fixed in [commit #9b97f8ed](https://github.com/DIMO-Network/dimo-token/commit/9b97f8ed39cff21bb3e3c5f896d595dfea592f9d)\n\n#### 2. **Checks Effects Interactions:**\n\n2a) Fixed in commit #https://github.com/DIMO-Network/dimo-identity/commit/ade7190314582a87df0083dfb139bef2652b104c.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n DimoChildToken.deposit.depositData\n\n\n\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller : Fixed in [commit #bd4b17ab](https://github.com/DIMO-Network/dimo-identity/commit/bd4b17ab2a9da9e890ead5227413e16f50e3b18d)\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRoot.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Vehicle.mintVehicle.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n\n#### 4. **Comment Issues:**\n\n(a) Fixed in [commit #46e2dc51](https://github.com/DIMO-Network/dimo-identity/commit/46e2dc51cb9940f5c5d6497fe5c84a7af42b581b)\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\n(a) Fixed in [commit #7456c0c3](https://github.com/DIMO-Network/dimo-identity/commit/7456c0c3ff7e8475a7c2b6b96595a6dd6e00953c)\n\n#### 6. **Registry Function Signature Collisions:**\n\n(a) Behaviour is understood and accepted\n\n#### 7. **Possible Specification Problem:**\n\n(a) Behaviour is understood and accepted\n\n## 8. **Vehicle without Root:**\n\n(a) Behaviour is understood and accepted. They will set the nodeType right after the module is added.\n\n#### 9. **Error Message Wording:**\n\n(a) Fixed in [commit #b835a7e3](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/b835a7e39efb0552cea6b1473d26b988e0b82ab8)\n\n#### 10. **Uninitialised Roles:**\n\n10a) Behaviour is accepted and intended\n\n\nDimo Smart Contracts Test Suite\n", "sections": {"description_md": "#### **Description**\n\nThis section details miscellaneous findings in the Dimo contracts.\n\n#### 1. **Minimise Function Access:**\n\nIt is best practice to use the minimum visibility for a function, for gas saving purposes:\n\n- DimoV2.pause() should be declared external.\n- DimoV2.unpause() should be declared external.\n- DimoV2.mint() should be declared external.\n\n#### 2. **Checks Effects Interactions:**\n\nIt is best practice to structure code in the order of making checks then updating variables and lastly interacting externally. This is to prevent reentrancy. Although there was no specific exploitable reentrancy occurrence detected (apart from [DMO-14\\)](#page-19-0), it is nonetheless recommended to reorder code to follow the *\"Checks-Effects-Interactions\"* pattern.\n\n- In Root,sol, \\_safeMint() should be moved from line [**112**] to line [**116**], below the state variable updates.\n- In Root,sol, \\_safeMint() should be moved from line [**84**] to line [**88**], below the state variable updates.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n- DimoChildToken.deposit.depositData\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller\n- Root.mintRootBatch.\\_owner\n- Root.mintRoot.\\_owner\n- Vehicle.mintVehicle.\\_owner ( Vehicle.mintVehicleSign.\\_owner is not necessary because of the signature)\n- Root.mintRootBatch.\\_owner\n\n#### 4. **Comment Issues:**\n\n DIMORegistry line [**108**] and line [**144**] comments describe the add functionality, not remove.\n\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\nDIMORegistry line [**161**] states that a selector is unregistered. By the logic of this contract, this check should always pass, as execution can only reach this point if the check on line [**153**] established that s.selectorsHash[implementation] is equal to a hash that contains the selector in question. Nevertheless, it could be modified by a module. In that case, the comment could be incorrect: a selector that is registered to a different implementation would also fail this check.\n\n#### 6. **Registry Function Signature Collisions:**\n\nDIMORegistry does not allow modules to be added if s.implementations[selectors[i]] != address(0) , therefore registered function selectors cannot be duplicated across modules. This provides some security benefits, however, function signatures can collide. For example withdraw(uint256) and OwnerTransferV7b711143(uint256) unexpectedly produce a single function signature of 2e1a7d4d . All modules should therefore be checked for any potential function signature collisions with other modules.\n\n#### 7. **Possible Specification Problem:**\n\nRoot.mintRootBatch() can be successfully called whether 'name' attribute is whitelisted in advance or not. Note this in relation to the comment on line [**66**] which says *It is assumed the 'name' attribute is whitelisted in advance*.\n\n#### 8. **Vehicle without Root:**\n\nVehicle.addRootAttribute() and Vehicle.mintRoot() are both callable if no vehicle nodeType is set in the VehicleStorage .\n\n#### 9. **Error Message Wording:**\n\nThe error string on line [**128**] of DIMOVesting.sol refers to \"vested\" tokens, when it means \"releasable\" tokens. It might be clearer to rephrase the entire message as, \"amount is too high\".\n\n#### 10. **Uninitialised Roles:**\n\nDimo Token V1 initially grants all roles to the admin address in its initializer. Dimo Token V2 does not have an initializer and so the role BURNER\\_ROLE is not initially granted to any address.\n\nThis role can however be granted directly through the function grantRole() .\n", "impact_md": null, "recommendation_md": "# **Recommendations**\n\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.\n", "poc_md": null, "fix_status_md": "#### **Resolution**\n\nhe issues were addressed in three separate pull requests across three repositories. Those include [DIMO token PR#2,](https://github.com/DIMO-Network/dimo-token/pull/2) .\n\n#### 1. **Minimise Function Access:**\n\n1a) Fixed in [commit #9b97f8ed](https://github.com/DIMO-Network/dimo-token/commit/9b97f8ed39cff21bb3e3c5f896d595dfea592f9d)\n\n#### 2. **Checks Effects Interactions:**\n\n2a) Fixed in commit #https://github.com/DIMO-Network/dimo-identity/commit/ade7190314582a87df0083dfb139bef2652b104c.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n DimoChildToken.deposit.depositData\n\n\n\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller : Fixed in [commit #bd4b17ab](https://github.com/DIMO-Network/dimo-identity/commit/bd4b17ab2a9da9e890ead5227413e16f50e3b18d)\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRoot.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Vehicle.mintVehicle.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n\n#### 4. **Comment Issues:**\n\n(a) Fixed in [commit #46e2dc51](https://github.com/DIMO-Network/dimo-identity/commit/46e2dc51cb9940f5c5d6497fe5c84a7af42b581b)\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\n(a) Fixed in [commit #7456c0c3](https://github.com/DIMO-Network/dimo-identity/commit/7456c0c3ff7e8475a7c2b6b96595a6dd6e00953c)\n\n#### 6. **Registry Function Signature Collisions:**\n\n(a) Behaviour is understood and accepted\n\n#### 7. **Possible Specification Problem:**\n\n(a) Behaviour is understood and accepted\n\n## 8. **Vehicle without Root:**\n\n(a) Behaviour is understood and accepted. They will set the nodeType right after the module is added.\n\n#### 9. **Error Message Wording:**\n\n(a) Fixed in [commit #b835a7e3](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/b835a7e39efb0552cea6b1473d26b988e0b82ab8)\n\n#### 10. **Uninitialised Roles:**\n\n10a) Behaviour is accepted and intended\n\n\nDimo Smart Contracts Test Suite\n", "other_md": null, "full_markdown_body": "#### **Description**\n\nThis section details miscellaneous findings in the Dimo contracts.\n\n#### 1. **Minimise Function Access:**\n\nIt is best practice to use the minimum visibility for a function, for gas saving purposes:\n\n- DimoV2.pause() should be declared external.\n- DimoV2.unpause() should be declared external.\n- DimoV2.mint() should be declared external.\n\n#### 2. **Checks Effects Interactions:**\n\nIt is best practice to structure code in the order of making checks then updating variables and lastly interacting externally. This is to prevent reentrancy. Although there was no specific exploitable reentrancy occurrence detected (apart from [DMO-14\\)](#page-19-0), it is nonetheless recommended to reorder code to follow the *\"Checks-Effects-Interactions\"* pattern.\n\n- In Root,sol, \\_safeMint() should be moved from line [**112**] to line [**116**], below the state variable updates.\n- In Root,sol, \\_safeMint() should be moved from line [**84**] to line [**88**], below the state variable updates.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n- DimoChildToken.deposit.depositData\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller\n- Root.mintRootBatch.\\_owner\n- Root.mintRoot.\\_owner\n- Vehicle.mintVehicle.\\_owner ( Vehicle.mintVehicleSign.\\_owner is not necessary because of the signature)\n- Root.mintRootBatch.\\_owner\n\n#### 4. **Comment Issues:**\n\n DIMORegistry line [**108**] and line [**144**] comments describe the add functionality, not remove.\n\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\nDIMORegistry line [**161**] states that a selector is unregistered. By the logic of this contract, this check should always pass, as execution can only reach this point if the check on line [**153**] established that s.selectorsHash[implementation] is equal to a hash that contains the selector in question. Nevertheless, it could be modified by a module. In that case, the comment could be incorrect: a selector that is registered to a different implementation would also fail this check.\n\n#### 6. **Registry Function Signature Collisions:**\n\nDIMORegistry does not allow modules to be added if s.implementations[selectors[i]] != address(0) , therefore registered function selectors cannot be duplicated across modules. This provides some security benefits, however, function signatures can collide. For example withdraw(uint256) and OwnerTransferV7b711143(uint256) unexpectedly produce a single function signature of 2e1a7d4d . All modules should therefore be checked for any potential function signature collisions with other modules.\n\n#### 7. **Possible Specification Problem:**\n\nRoot.mintRootBatch() can be successfully called whether 'name' attribute is whitelisted in advance or not. Note this in relation to the comment on line [**66**] which says *It is assumed the 'name' attribute is whitelisted in advance*.\n\n#### 8. **Vehicle without Root:**\n\nVehicle.addRootAttribute() and Vehicle.mintRoot() are both callable if no vehicle nodeType is set in the VehicleStorage .\n\n#### 9. **Error Message Wording:**\n\nThe error string on line [**128**] of DIMOVesting.sol refers to \"vested\" tokens, when it means \"releasable\" tokens. It might be clearer to rephrase the entire message as, \"amount is too high\".\n\n#### 10. **Uninitialised Roles:**\n\nDimo Token V1 initially grants all roles to the admin address in its initializer. Dimo Token V2 does not have an initializer and so the role BURNER\\_ROLE is not initially granted to any address.\n\nThis role can however be granted directly through the function grantRole() .\n\n# **Recommendations**\n\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.\n\n#### **Resolution**\n\nhe issues were addressed in three separate pull requests across three repositories. Those include [DIMO token PR#2,](https://github.com/DIMO-Network/dimo-token/pull/2) .\n\n#### 1. **Minimise Function Access:**\n\n1a) Fixed in [commit #9b97f8ed](https://github.com/DIMO-Network/dimo-token/commit/9b97f8ed39cff21bb3e3c5f896d595dfea592f9d)\n\n#### 2. **Checks Effects Interactions:**\n\n2a) Fixed in commit #https://github.com/DIMO-Network/dimo-identity/commit/ade7190314582a87df0083dfb139bef2652b104c.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n DimoChildToken.deposit.depositData\n\n\n\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller : Fixed in [commit #bd4b17ab](https://github.com/DIMO-Network/dimo-identity/commit/bd4b17ab2a9da9e890ead5227413e16f50e3b18d)\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRoot.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Vehicle.mintVehicle.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n\n#### 4. **Comment Issues:**\n\n(a) Fixed in [commit #46e2dc51](https://github.com/DIMO-Network/dimo-identity/commit/46e2dc51cb9940f5c5d6497fe5c84a7af42b581b)\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\n(a) Fixed in [commit #7456c0c3](https://github.com/DIMO-Network/dimo-identity/commit/7456c0c3ff7e8475a7c2b6b96595a6dd6e00953c)\n\n#### 6. **Registry Function Signature Collisions:**\n\n(a) Behaviour is understood and accepted\n\n#### 7. **Possible Specification Problem:**\n\n(a) Behaviour is understood and accepted\n\n## 8. **Vehicle without Root:**\n\n(a) Behaviour is understood and accepted. They will set the nodeType right after the module is added.\n\n#### 9. **Error Message Wording:**\n\n(a) Fixed in [commit #b835a7e3](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/b835a7e39efb0552cea6b1473d26b988e0b82ab8)\n\n#### 10. **Uninitialised Roles:**\n\n10a) Behaviour is accepted and intended\n\n\nDimo Smart Contracts Test Suite\n", "markdown_raw": "| DMO-17 | Miscellaneous General Comments |\n|--------|--------------------------------|\n| Asset  | *.sol                          |\n| Status | Closed: See Resolution         |\n| Rating | Informational                  |\n\n#### **Description**\n\nThis section details miscellaneous findings in the Dimo contracts.\n\n#### 1. **Minimise Function Access:**\n\nIt is best practice to use the minimum visibility for a function, for gas saving purposes:\n\n- DimoV2.pause() should be declared external.\n- DimoV2.unpause() should be declared external.\n- DimoV2.mint() should be declared external.\n\n#### 2. **Checks Effects Interactions:**\n\nIt is best practice to structure code in the order of making checks then updating variables and lastly interacting externally. This is to prevent reentrancy. Although there was no specific exploitable reentrancy occurrence detected (apart from [DMO-14\\)](#page-19-0), it is nonetheless recommended to reorder code to follow the *\"Checks-Effects-Interactions\"* pattern.\n\n- In Root,sol, \\_safeMint() should be moved from line [**112**] to line [**116**], below the state variable updates.\n- In Root,sol, \\_safeMint() should be moved from line [**84**] to line [**88**], below the state variable updates.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n- DimoChildToken.deposit.depositData\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller\n- Root.mintRootBatch.\\_owner\n- Root.mintRoot.\\_owner\n- Vehicle.mintVehicle.\\_owner ( Vehicle.mintVehicleSign.\\_owner is not necessary because of the signature)\n- Root.mintRootBatch.\\_owner\n\n#### 4. **Comment Issues:**\n\n DIMORegistry line [**108**] and line [**144**] comments describe the add functionality, not remove.\n\n{23}------------------------------------------------\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\nDIMORegistry line [**161**] states that a selector is unregistered. By the logic of this contract, this check should always pass, as execution can only reach this point if the check on line [**153**] established that s.selectorsHash[implementation] is equal to a hash that contains the selector in question. Nevertheless, it could be modified by a module. In that case, the comment could be incorrect: a selector that is registered to a different implementation would also fail this check.\n\n#### 6. **Registry Function Signature Collisions:**\n\nDIMORegistry does not allow modules to be added if s.implementations[selectors[i]] != address(0) , therefore registered function selectors cannot be duplicated across modules. This provides some security benefits, however, function signatures can collide. For example withdraw(uint256) and OwnerTransferV7b711143(uint256) unexpectedly produce a single function signature of 2e1a7d4d . All modules should therefore be checked for any potential function signature collisions with other modules.\n\n#### 7. **Possible Specification Problem:**\n\nRoot.mintRootBatch() can be successfully called whether 'name' attribute is whitelisted in advance or not. Note this in relation to the comment on line [**66**] which says *It is assumed the 'name' attribute is whitelisted in advance*.\n\n#### 8. **Vehicle without Root:**\n\nVehicle.addRootAttribute() and Vehicle.mintRoot() are both callable if no vehicle nodeType is set in the VehicleStorage .\n\n#### 9. **Error Message Wording:**\n\nThe error string on line [**128**] of DIMOVesting.sol refers to \"vested\" tokens, when it means \"releasable\" tokens. It might be clearer to rephrase the entire message as, \"amount is too high\".\n\n#### 10. **Uninitialised Roles:**\n\nDimo Token V1 initially grants all roles to the admin address in its initializer. Dimo Token V2 does not have an initializer and so the role BURNER\\_ROLE is not initially granted to any address.\n\nThis role can however be granted directly through the function grantRole() .\n\n# **Recommendations**\n\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.\n\n#### <span id=\"page-23-0\"></span>**Resolution**\n\nhe issues were addressed in three separate pull requests across three repositories. Those include [DIMO token PR#2,](https://github.com/DIMO-Network/dimo-token/pull/2) .\n\n#### 1. **Minimise Function Access:**\n\n1a) Fixed in [commit #9b97f8ed](https://github.com/DIMO-Network/dimo-token/commit/9b97f8ed39cff21bb3e3c5f896d595dfea592f9d)\n\n#### 2. **Checks Effects Interactions:**\n\n2a) Fixed in commit #https://github.com/DIMO-Network/dimo-identity/commit/ade7190314582a87df0083dfb139bef2652b104c.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n DimoChildToken.deposit.depositData\n\n![](_page_23_Picture_25.jpeg)\n\n{24}------------------------------------------------\n\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller : Fixed in [commit #bd4b17ab](https://github.com/DIMO-Network/dimo-identity/commit/bd4b17ab2a9da9e890ead5227413e16f50e3b18d)\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRoot.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Vehicle.mintVehicle.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n\n#### 4. **Comment Issues:**\n\n(a) Fixed in [commit #46e2dc51](https://github.com/DIMO-Network/dimo-identity/commit/46e2dc51cb9940f5c5d6497fe5c84a7af42b581b)\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\n(a) Fixed in [commit #7456c0c3](https://github.com/DIMO-Network/dimo-identity/commit/7456c0c3ff7e8475a7c2b6b96595a6dd6e00953c)\n\n#### 6. **Registry Function Signature Collisions:**\n\n(a) Behaviour is understood and accepted\n\n#### 7. **Possible Specification Problem:**\n\n(a) Behaviour is understood and accepted\n\n## 8. **Vehicle without Root:**\n\n(a) Behaviour is understood and accepted. They will set the nodeType right after the module is added.\n\n#### 9. **Error Message Wording:**\n\n(a) Fixed in [commit #b835a7e3](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/b835a7e39efb0552cea6b1473d26b988e0b82ab8)\n\n#### 10. **Uninitialised Roles:**\n\n10a) Behaviour is accepted and intended\n\n{25}------------------------------------------------\n\nDimo Smart Contracts Test Suite\n"}, "severity": null, "difficulty": null, "type": "Miscellaneous", "finding_id": "DMO-17", "target": {"path": "*.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/DIMO-Network/dimo-identity", "org": "DIMO-Network", "name": "dimo-identity", "commit": "bc5efdf39a514c003f86f1051d83fac516a170de", "branch": null, "relative_file": "*.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "#### **Resolution**\n\nhe issues were addressed in three separate pull requests across three repositories. Those include [DIMO token PR#2,](https://github.com/DIMO-Network/dimo-token/pull/2) .\n\n#### 1. **Minimise Function Access:**\n\n1a) Fixed in [commit #9b97f8ed](https://github.com/DIMO-Network/dimo-token/commit/9b97f8ed39cff21bb3e3c5f896d595dfea592f9d)\n\n#### 2. **Checks Effects Interactions:**\n\n2a) Fixed in commit #https://github.com/DIMO-Network/dimo-identity/commit/ade7190314582a87df0083dfb139bef2652b104c.\n\n#### 3. **Zero Value Checks:**\n\nThe zero value checks should be considered for the following parameters:\n\n DimoChildToken.deposit.depositData\n\n\n\n- DimoChildToken.withdraw.amount\n- DimoChildToken.mint.amount\n- Dimo.mint.amount\n- DimoV2.mint.amount\n- Root.setController.\\_controller : Fixed in [commit #bd4b17ab](https://github.com/DIMO-Network/dimo-identity/commit/bd4b17ab2a9da9e890ead5227413e16f50e3b18d)\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRoot.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Vehicle.mintVehicle.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n- Root.mintRootBatch.\\_owner : Not fixed, accepted as unnecessary due to checks elswhere\n\n#### 4. **Comment Issues:**\n\n(a) Fixed in [commit #46e2dc51](https://github.com/DIMO-Network/dimo-identity/commit/46e2dc51cb9940f5c5d6497fe5c84a7af42b581b)\n\n#### 5. **Incorrect Error Message/Unreachable Code:**\n\n(a) Fixed in [commit #7456c0c3](https://github.com/DIMO-Network/dimo-identity/commit/7456c0c3ff7e8475a7c2b6b96595a6dd6e00953c)\n\n#### 6. **Registry Function Signature Collisions:**\n\n(a) Behaviour is understood and accepted\n\n#### 7. **Possible Specification Problem:**\n\n(a) Behaviour is understood and accepted\n\n## 8. **Vehicle without Root:**\n\n(a) Behaviour is understood and accepted. They will set the nodeType right after the module is added.\n\n#### 9. **Error Message Wording:**\n\n(a) Fixed in [commit #b835a7e3](https://github.com/DIMO-Network/DIMO-vesting/pull/1/commits/b835a7e39efb0552cea6b1473d26b988e0b82ab8)\n\n#### 10. **Uninitialised Roles:**\n\n10a) Behaviour is accepted and intended\n\n\nDimo Smart Contracts Test Suite\n", "fixed_in_commit": "9b97f8ed", "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "review.pdf", "source_mtime": "2025-11-10T12:08:24+00:00", "report_extracted_at": "2025-11-16T22:14:02.861533+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-16T22:14:02.866305+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "Miscellaneous", "Finding ID": "DMO-17", "Target": "*.sol", "Severity_normalized": null}}
