{"schema_version": "0.1", "scvd_id": "SCVD-trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview-001", "doc_id": "trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview", "finding_index": 1, "page_start": 9, "title": "Lack of safeTransfer usage for ERC20", "short_summary": null, "description_md": "#### Description\n\nThe applyState function in the ERC20LockingConnectorLogic contract uses the transfer function instead of the safeTransfer function provided by the SafeERC20 library. This can cause tokens whose transfer function does not conform to the ERC20 specification to behave incorrectly. In particular, it could result in no tokens being transferred to a recipient while the contract behaves as though the tokens did get transferred and does not revert, leading to loss of funds.\n\n```\n22 function applyState(bytes calldata _state) public virtual override onlyBridge\n{\n23 Transfer[] memory transfers = decodeTransfers(_state);\n24 uint256 transfersLength = transfers.length;\n25 for (uint256 i = 0; i < transfersLength;) {\n26 IERC20(token).transfer(transfers[i].account, transfers[i].amount);\n27 unchecked {\n28 ++i;\n29 }\n30 }\n31 }\n```\n\n*Figure 1.1: The use of the ERC20 transfer function in [ERC20LockingConnectorLogic.sol#L22-L31](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/ERC20LockingConnectorLogic.sol#L22-L31)*\n", "full_markdown": "| 1. Lack of safeTransfer usage for ERC20       |                              |  |\n|-----------------------------------------------------------------|------------------------------|--|\n| Severity: High                                               | Diffi culty: Medium    |  |\n| Type: Data Validation                                     | Finding ID: TOB-TARA-1 |  |\n| Target: bridge/src/connectors/ERC20LockingConnectorLogic.sol |                              |  |\n\n#### Description\n\nThe applyState function in the ERC20LockingConnectorLogic contract uses the transfer function instead of the safeTransfer function provided by the SafeERC20 library. This can cause tokens whose transfer function does not conform to the ERC20 specification to behave incorrectly. In particular, it could result in no tokens being transferred to a recipient while the contract behaves as though the tokens did get transferred and does not revert, leading to loss of funds.\n\n```\n22 function applyState(bytes calldata _state) public virtual override onlyBridge\n{\n23 Transfer[] memory transfers = decodeTransfers(_state);\n24 uint256 transfersLength = transfers.length;\n25 for (uint256 i = 0; i < transfersLength;) {\n26 IERC20(token).transfer(transfers[i].account, transfers[i].amount);\n27 unchecked {\n28 ++i;\n29 }\n30 }\n31 }\n```\n\n*Figure 1.1: The use of the ERC20 transfer function in [ERC20LockingConnectorLogic.sol#L22-L31](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/ERC20LockingConnectorLogic.sol#L22-L31)*\n\n#### Exploit Scenario\n\nAlice, a user of the Taraxa bridge, wants to transfer her USDT to the Taraxa chain. However, the transfer unexpectedly reverts. Because the error is uncaught, Alice loses her USDT tokens.\n\n#### Recommendations\n\nShort term, use the safeTransfer function of the SafeERC20 library.\n\nLong term, keep up to date with the usage of third-party libraries and ensure that they are used appropriately throughout the codebase.\n", "sections": {"description_md": "#### Description\n\nThe applyState function in the ERC20LockingConnectorLogic contract uses the transfer function instead of the safeTransfer function provided by the SafeERC20 library. This can cause tokens whose transfer function does not conform to the ERC20 specification to behave incorrectly. In particular, it could result in no tokens being transferred to a recipient while the contract behaves as though the tokens did get transferred and does not revert, leading to loss of funds.\n\n```\n22 function applyState(bytes calldata _state) public virtual override onlyBridge\n{\n23 Transfer[] memory transfers = decodeTransfers(_state);\n24 uint256 transfersLength = transfers.length;\n25 for (uint256 i = 0; i < transfersLength;) {\n26 IERC20(token).transfer(transfers[i].account, transfers[i].amount);\n27 unchecked {\n28 ++i;\n29 }\n30 }\n31 }\n```\n\n*Figure 1.1: The use of the ERC20 transfer function in [ERC20LockingConnectorLogic.sol#L22-L31](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/ERC20LockingConnectorLogic.sol#L22-L31)*\n", "impact_md": null, "recommendation_md": "#### Recommendations\n\nShort term, use the safeTransfer function of the SafeERC20 library.\n\nLong term, keep up to date with the usage of third-party libraries and ensure that they are used appropriately throughout the codebase.\n", "poc_md": "#### Exploit Scenario\n\nAlice, a user of the Taraxa bridge, wants to transfer her USDT to the Taraxa chain. However, the transfer unexpectedly reverts. Because the error is uncaught, Alice loses her USDT tokens.\n", "fix_status_md": null, "other_md": null, "full_markdown_body": "| 1. Lack of safeTransfer usage for ERC20       |                              |  |\n|-----------------------------------------------------------------|------------------------------|--|\n| Severity: High                                               | Diffi culty: Medium    |  |\n| Type: Data Validation                                     | Finding ID: TOB-TARA-1 |  |\n| Target: bridge/src/connectors/ERC20LockingConnectorLogic.sol |                              |  |\n\n#### Description\n\nThe applyState function in the ERC20LockingConnectorLogic contract uses the transfer function instead of the safeTransfer function provided by the SafeERC20 library. This can cause tokens whose transfer function does not conform to the ERC20 specification to behave incorrectly. In particular, it could result in no tokens being transferred to a recipient while the contract behaves as though the tokens did get transferred and does not revert, leading to loss of funds.\n\n```\n22 function applyState(bytes calldata _state) public virtual override onlyBridge\n{\n23 Transfer[] memory transfers = decodeTransfers(_state);\n24 uint256 transfersLength = transfers.length;\n25 for (uint256 i = 0; i < transfersLength;) {\n26 IERC20(token).transfer(transfers[i].account, transfers[i].amount);\n27 unchecked {\n28 ++i;\n29 }\n30 }\n31 }\n```\n\n*Figure 1.1: The use of the ERC20 transfer function in [ERC20LockingConnectorLogic.sol#L22-L31](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/ERC20LockingConnectorLogic.sol#L22-L31)*\n\n#### Exploit Scenario\n\nAlice, a user of the Taraxa bridge, wants to transfer her USDT to the Taraxa chain. However, the transfer unexpectedly reverts. Because the error is uncaught, Alice loses her USDT tokens.\n\n#### Recommendations\n\nShort term, use the safeTransfer function of the SafeERC20 library.\n\nLong term, keep up to date with the usage of third-party libraries and ensure that they are used appropriately throughout the codebase.\n", "markdown_raw": "<span id=\"page-9-1\"></span>\n\n| 1.<br>Lack<br>of<br>safeTransfer<br>usage<br>for<br>ERC20       |                              |  |\n|-----------------------------------------------------------------|------------------------------|--|\n| Severity:<br>High                                               | Diffi<br>culty:<br>Medium    |  |\n| Type:<br>Data<br>Validation                                     | Finding<br>ID:<br>TOB-TARA-1 |  |\n| Target:<br>bridge/src/connectors/ERC20LockingConnectorLogic.sol |                              |  |\n\n#### Description\n\nThe applyState function in the ERC20LockingConnectorLogic contract uses the transfer function instead of the safeTransfer function provided by the SafeERC20 library. This can cause tokens whose transfer function does not conform to the ERC20 specification to behave incorrectly. In particular, it could result in no tokens being transferred to a recipient while the contract behaves as though the tokens did get transferred and does not revert, leading to loss of funds.\n\n```\n22 function applyState(bytes calldata _state) public virtual override onlyBridge\n{\n23 Transfer[] memory transfers = decodeTransfers(_state);\n24 uint256 transfersLength = transfers.length;\n25 for (uint256 i = 0; i < transfersLength;) {\n26 IERC20(token).transfer(transfers[i].account, transfers[i].amount);\n27 unchecked {\n28 ++i;\n29 }\n30 }\n31 }\n```\n\n*Figure 1.1: The use of the ERC20 transfer function in [ERC20LockingConnectorLogic.sol#L22-L31](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/ERC20LockingConnectorLogic.sol#L22-L31)*\n\n#### Exploit Scenario\n\nAlice, a user of the Taraxa bridge, wants to transfer her USDT to the Taraxa chain. However, the transfer unexpectedly reverts. Because the error is uncaught, Alice loses her USDT tokens.\n\n#### Recommendations\n\nShort term, use the safeTransfer function of the SafeERC20 library.\n\nLong term, keep up to date with the usage of third-party libraries and ensure that they are used appropriately throughout the codebase.\n\n![](_page_9_Picture_11.jpeg)\n\n{10}------------------------------------------------\n"}, "severity": "High", "difficulty": "Medium", "type": "Data Validation", "finding_id": "TOB-TARA-1", "target": {"path": "bridge/src/connectors/ERC20LockingConnectorLogic.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/Taraxa-project/bridge", "org": "Taraxa-project", "name": "bridge", "commit": "f82dd87c7e23358c74f7dc37451ca61110b60942", "branch": null, "relative_file": "bridge/src/connectors/ERC20LockingConnectorLogic.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "2024-07-taraxa-bridge-smart-contracts-v2-securityreview.pdf", "source_mtime": "2025-11-01T20:47:29.319395+00:00", "report_extracted_at": "2025-11-19T09:04:32.938539+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T09:04:32.941583+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": "Medium", "Type": "Data Validation", "Finding ID": "TOB-TARA-1", "Target": "bridge/src/connectors/ERC20LockingConnectorLogic.sol", "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview-002", "doc_id": "trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview", "finding_index": 2, "page_start": 10, "title": "The add function can revert", "short_summary": null, "description_md": "#### Description\n\nThe add function in the Maths library fails to account for an arithmetic edge case involving the negation of a signed integer. In particular, the negation of int256.min will revert, as it does not have an appropriate two's complement representation.\n\n```\n5 function add(uint256 a, int256 b) internal pure returns (uint256) {\n6 if (b < 0) {\n7 return a - uint256(-b);\n8 }\n9 return a + uint256(b);\n10 }\n```\n\n*Figure 2.1: The add function in [Maths.sol#L5-L10](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/Maths.sol#L5-L10)*\n", "full_markdown": "# 2. The add function can revert Severity: **Informational** Difficulty: **High** Type: Denial of Service Finding ID: TOB-TARA-2 Target: lib/Maths.sol\n\n#### Description\n\nThe add function in the Maths library fails to account for an arithmetic edge case involving the negation of a signed integer. In particular, the negation of int256.min will revert, as it does not have an appropriate two's complement representation.\n\n```\n5 function add(uint256 a, int256 b) internal pure returns (uint256) {\n6 if (b < 0) {\n7 return a - uint256(-b);\n8 }\n9 return a + uint256(b);\n10 }\n```\n\n*Figure 2.1: The add function in [Maths.sol#L5-L10](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/Maths.sol#L5-L10)*\n\n### Recommendations\n\nShort term, ensure that the edge case in the library is handled appropriately by using an unchecked block for a b value of int256.min.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n", "sections": {"description_md": "#### Description\n\nThe add function in the Maths library fails to account for an arithmetic edge case involving the negation of a signed integer. In particular, the negation of int256.min will revert, as it does not have an appropriate two's complement representation.\n\n```\n5 function add(uint256 a, int256 b) internal pure returns (uint256) {\n6 if (b < 0) {\n7 return a - uint256(-b);\n8 }\n9 return a + uint256(b);\n10 }\n```\n\n*Figure 2.1: The add function in [Maths.sol#L5-L10](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/Maths.sol#L5-L10)*\n", "impact_md": null, "recommendation_md": "### Recommendations\n\nShort term, ensure that the edge case in the library is handled appropriately by using an unchecked block for a b value of int256.min.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n", "poc_md": null, "fix_status_md": null, "other_md": null, "full_markdown_body": "#### Description\n\nThe add function in the Maths library fails to account for an arithmetic edge case involving the negation of a signed integer. In particular, the negation of int256.min will revert, as it does not have an appropriate two's complement representation.\n\n```\n5 function add(uint256 a, int256 b) internal pure returns (uint256) {\n6 if (b < 0) {\n7 return a - uint256(-b);\n8 }\n9 return a + uint256(b);\n10 }\n```\n\n*Figure 2.1: The add function in [Maths.sol#L5-L10](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/Maths.sol#L5-L10)*\n\n### Recommendations\n\nShort term, ensure that the edge case in the library is handled appropriately by using an unchecked block for a b value of int256.min.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n", "markdown_raw": "# <span id=\"page-10-0\"></span>2. The add function can revert Severity: **Informational** Difficulty: **High** Type: Denial of Service Finding ID: TOB-TARA-2 Target: lib/Maths.sol\n\n#### Description\n\nThe add function in the Maths library fails to account for an arithmetic edge case involving the negation of a signed integer. In particular, the negation of int256.min will revert, as it does not have an appropriate two's complement representation.\n\n```\n5 function add(uint256 a, int256 b) internal pure returns (uint256) {\n6 if (b < 0) {\n7 return a - uint256(-b);\n8 }\n9 return a + uint256(b);\n10 }\n```\n\n*Figure 2.1: The add function in [Maths.sol#L5-L10](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/Maths.sol#L5-L10)*\n\n### Recommendations\n\nShort term, ensure that the edge case in the library is handled appropriately by using an unchecked block for a b value of int256.min.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n\n{11}------------------------------------------------\n"}, "severity": "Informational", "difficulty": "High", "type": "Denial of Service", "finding_id": "TOB-TARA-2", "target": {"path": "lib/Maths.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/Taraxa-project/bridge", "org": "Taraxa-project", "name": "bridge", "commit": "f82dd87c7e23358c74f7dc37451ca61110b60942", "branch": null, "relative_file": "lib/Maths.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "2024-07-taraxa-bridge-smart-contracts-v2-securityreview.pdf", "source_mtime": "2025-11-01T20:47:29.319395+00:00", "report_extracted_at": "2025-11-19T09:04:32.938539+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T09:04:32.941583+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Informational", "Difficulty": "High", "Type": "Denial of Service", "Finding ID": "TOB-TARA-2", "Target": "lib/Maths.sol", "Severity_normalized": "Informational"}}
{"schema_version": "0.1", "scvd_id": "SCVD-trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview-003", "doc_id": "trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview", "finding_index": 3, "page_start": 11, "title": "G1 and G2 from method lack field point validation", "short_summary": null, "description_md": "#### Description\n\nBoth the G1.sol and G2.sol files' from method lack validation that the BLS12Fp points used to create G1 and G2 subgroup elements are valid field elements. In particular, they do not check that each of the BLS12Fp field elements fit into the modulus. This could lead to multiple issues and undefined behavior downstream when using various elliptic curve point functionalities, including pairings.\n\n```\n93 /// @dev Derive Bls12G1 from uint256[4].\n94 /// @param x uint256[4].\n95 /// @return Bls12G1.\n96 function from(uint256[4] memory x) internal pure returns (Bls12G1 memory) {\n97 return Bls12G1(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3]));\n98 }\n```\n\n*Figure 3.1: The from method in [G1.sol#L93-L](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G1.sol#L93-L98)98*\n\n```\n120 /// @dev Derive Bls12G1 from uint256[8].\n121 /// @param x uint256[4].\n122 /// @return Bls12G2.\n123 function from(uint256[8] memory x) internal pure returns (Bls12G2 memory) {\n124 return Bls12G2(\n125 Bls12Fp2(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3])),\nBls12Fp2(Bls12Fp(x[4], x[5]), Bls12Fp(x[6], x[7]))\n126 );\n127 }\n```\n\n*Figure 3.2: The from method in [G2.sol#L120-L127](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G2.sol#L120-L127)*\n", "full_markdown": "# 3. G1 and G2 from method lack field point validation Severity: **Informational** Difficulty: **Low** Type: Data Validation Finding ID: TOB-TARA-3 Target: beacon-light-client/src/bls12381/{G1,G2}.sol\n\n#### Description\n\nBoth the G1.sol and G2.sol files' from method lack validation that the BLS12Fp points used to create G1 and G2 subgroup elements are valid field elements. In particular, they do not check that each of the BLS12Fp field elements fit into the modulus. This could lead to multiple issues and undefined behavior downstream when using various elliptic curve point functionalities, including pairings.\n\n```\n93 /// @dev Derive Bls12G1 from uint256[4].\n94 /// @param x uint256[4].\n95 /// @return Bls12G1.\n96 function from(uint256[4] memory x) internal pure returns (Bls12G1 memory) {\n97 return Bls12G1(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3]));\n98 }\n```\n\n*Figure 3.1: The from method in [G1.sol#L93-L](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G1.sol#L93-L98)98*\n\n```\n120 /// @dev Derive Bls12G1 from uint256[8].\n121 /// @param x uint256[4].\n122 /// @return Bls12G2.\n123 function from(uint256[8] memory x) internal pure returns (Bls12G2 memory) {\n124 return Bls12G2(\n125 Bls12Fp2(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3])),\nBls12Fp2(Bls12Fp(x[4], x[5]), Bls12Fp(x[6], x[7]))\n126 );\n127 }\n```\n\n*Figure 3.2: The from method in [G2.sol#L120-L127](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G2.sol#L120-L127)*\n\n#### Recommendations\n\nShort term, call is\\_valid on each of the BLS12Fp points used to create G1 and G2 group elements.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n", "sections": {"description_md": "#### Description\n\nBoth the G1.sol and G2.sol files' from method lack validation that the BLS12Fp points used to create G1 and G2 subgroup elements are valid field elements. In particular, they do not check that each of the BLS12Fp field elements fit into the modulus. This could lead to multiple issues and undefined behavior downstream when using various elliptic curve point functionalities, including pairings.\n\n```\n93 /// @dev Derive Bls12G1 from uint256[4].\n94 /// @param x uint256[4].\n95 /// @return Bls12G1.\n96 function from(uint256[4] memory x) internal pure returns (Bls12G1 memory) {\n97 return Bls12G1(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3]));\n98 }\n```\n\n*Figure 3.1: The from method in [G1.sol#L93-L](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G1.sol#L93-L98)98*\n\n```\n120 /// @dev Derive Bls12G1 from uint256[8].\n121 /// @param x uint256[4].\n122 /// @return Bls12G2.\n123 function from(uint256[8] memory x) internal pure returns (Bls12G2 memory) {\n124 return Bls12G2(\n125 Bls12Fp2(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3])),\nBls12Fp2(Bls12Fp(x[4], x[5]), Bls12Fp(x[6], x[7]))\n126 );\n127 }\n```\n\n*Figure 3.2: The from method in [G2.sol#L120-L127](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G2.sol#L120-L127)*\n", "impact_md": null, "recommendation_md": "#### Recommendations\n\nShort term, call is\\_valid on each of the BLS12Fp points used to create G1 and G2 group elements.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n", "poc_md": null, "fix_status_md": null, "other_md": null, "full_markdown_body": "#### Description\n\nBoth the G1.sol and G2.sol files' from method lack validation that the BLS12Fp points used to create G1 and G2 subgroup elements are valid field elements. In particular, they do not check that each of the BLS12Fp field elements fit into the modulus. This could lead to multiple issues and undefined behavior downstream when using various elliptic curve point functionalities, including pairings.\n\n```\n93 /// @dev Derive Bls12G1 from uint256[4].\n94 /// @param x uint256[4].\n95 /// @return Bls12G1.\n96 function from(uint256[4] memory x) internal pure returns (Bls12G1 memory) {\n97 return Bls12G1(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3]));\n98 }\n```\n\n*Figure 3.1: The from method in [G1.sol#L93-L](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G1.sol#L93-L98)98*\n\n```\n120 /// @dev Derive Bls12G1 from uint256[8].\n121 /// @param x uint256[4].\n122 /// @return Bls12G2.\n123 function from(uint256[8] memory x) internal pure returns (Bls12G2 memory) {\n124 return Bls12G2(\n125 Bls12Fp2(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3])),\nBls12Fp2(Bls12Fp(x[4], x[5]), Bls12Fp(x[6], x[7]))\n126 );\n127 }\n```\n\n*Figure 3.2: The from method in [G2.sol#L120-L127](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G2.sol#L120-L127)*\n\n#### Recommendations\n\nShort term, call is\\_valid on each of the BLS12Fp points used to create G1 and G2 group elements.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n", "markdown_raw": "# <span id=\"page-11-0\"></span>3. G1 and G2 from method lack field point validation Severity: **Informational** Difficulty: **Low** Type: Data Validation Finding ID: TOB-TARA-3 Target: beacon-light-client/src/bls12381/{G1,G2}.sol\n\n#### Description\n\nBoth the G1.sol and G2.sol files' from method lack validation that the BLS12Fp points used to create G1 and G2 subgroup elements are valid field elements. In particular, they do not check that each of the BLS12Fp field elements fit into the modulus. This could lead to multiple issues and undefined behavior downstream when using various elliptic curve point functionalities, including pairings.\n\n```\n93 /// @dev Derive Bls12G1 from uint256[4].\n94 /// @param x uint256[4].\n95 /// @return Bls12G1.\n96 function from(uint256[4] memory x) internal pure returns (Bls12G1 memory) {\n97 return Bls12G1(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3]));\n98 }\n```\n\n*Figure 3.1: The from method in [G1.sol#L93-L](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G1.sol#L93-L98)98*\n\n```\n120 /// @dev Derive Bls12G1 from uint256[8].\n121 /// @param x uint256[4].\n122 /// @return Bls12G2.\n123 function from(uint256[8] memory x) internal pure returns (Bls12G2 memory) {\n124 return Bls12G2(\n125 Bls12Fp2(Bls12Fp(x[0], x[1]), Bls12Fp(x[2], x[3])),\nBls12Fp2(Bls12Fp(x[4], x[5]), Bls12Fp(x[6], x[7]))\n126 );\n127 }\n```\n\n*Figure 3.2: The from method in [G2.sol#L120-L127](https://github.com/Taraxa-project/beacon-light-client/blob/b2eafadf37e466f7cbed3c5b1ca0a917f152137a/src/bls12381/G2.sol#L120-L127)*\n\n#### Recommendations\n\nShort term, call is\\_valid on each of the BLS12Fp points used to create G1 and G2 group elements.\n\nLong term, improve unit testing to uncover edge cases and ensure intended behavior throughout the system.\n\n![](_page_11_Picture_10.jpeg)\n\n{12}------------------------------------------------\n"}, "severity": "Informational", "difficulty": "Low", "type": "Data Validation", "finding_id": "TOB-TARA-3", "target": {"path": "beacon-light-client/src/bls12381/{G1,G2}.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/crytic/slither", "org": "crytic", "name": "slither", "commit": null, "branch": null, "relative_file": "beacon-light-client/src/bls12381/{G1,G2}.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "2024-07-taraxa-bridge-smart-contracts-v2-securityreview.pdf", "source_mtime": "2025-11-01T20:47:29.319395+00:00", "report_extracted_at": "2025-11-19T09:04:32.938539+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T09:04:32.941583+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Informational", "Difficulty": "Low", "Type": "Data Validation", "Finding ID": "TOB-TARA-3", "Target": "beacon-light-client/src/bls12381/{G1,G2}.sol", "Severity_normalized": "Informational"}}
{"schema_version": "0.1", "scvd_id": "SCVD-trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview-004", "doc_id": "trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview", "finding_index": 4, "page_start": 12, "title": "Missing validation allows signatures to be duplicated to finalize any PillarBlock", "short_summary": null, "description_md": "#### Description\n\nThe finalizeBlocks function lacks proper validation of the lastBlockSigs argument and therefore allows any caller to arbitrarily inflate the number of signatures by duplicating the same signature in lastBlockSigs. This allows a PillarBlock that did not gain the required amount of validator votes to pass and be accepted as valid.\n\nFigure 4.1 shows that the lastBlockSigs argument is not validated and passed into the getSignaturesWeight function.\n\n```\n81 function finalizeBlocks(PillarBlock.WithChanges[] memory blocks,\nCompactSignature[] memory lastBlockSigs) public {\n 82 uint256 blocksLength = blocks.length;\n 83 uint256 weightThreshold = totalWeight / 2 + 1;\n 84 for (uint256 i = 0; i < blocksLength;) {\n...\n102 // skip verification for the first(genesis) block. And verify\nsignatures only for the last block in the batch\n103 if (finalized.block.period != 0 && i == (blocks.length - 1)) {\n104 uint256 weight =\n105\ngetSignaturesWeight(PillarBlock.getVoteHash(blocks[i].block.period, pbh),\nlastBlockSigs);\n106 if (weight < weightThreshold) {\n107 revert ThresholdNotMet({threshold: weightThreshold, weight:\nweight});\n108 }\n109 }\n...\n117 }\n118 }\n```\n\n*Figure 4.1: The finalizeBlocks function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\nFigure 4.2 shows the getSignaturesWeight function. This function does not in any way prevent duplicate signatures in the list to cause a revert. As long as the signature signed the PillarBlock hash (pbh variable), it is deemed valid, and the accompanying signer's\n\n\n(=validator) vote count is added to the weight variable. This weight variable is returned to finalizeBlocks after all signatures have been processed. The finalizeBlocks function will then continue with validating that this weight is at least weightThreshold (highlighted in red in figure 4.1). By inflating the amount of signatures due to duplicate signatures, a malicious user can circumvent this check for PillarBlocks that lack the required amount of votes.\n\n```\n126 function getSignaturesWeight(bytes32 h, CompactSignature[] memory\nsignatures)\n127 public\n128 view\n129 returns (uint256 weight)\n130 {\n131 uint256 signaturesLength = signatures.length;\n132 for (uint256 i = 0; i < signaturesLength; i++) {\n133 address signer = ECDSA.recover(h, signatures[i].r,\nsignatures[i].vs);\n134 weight += validatorVoteCounts[signer];\n135 }\n136 }\n```\n\n*Figure 4.2: The getSignaturesWeight function in [TaraClient.sol#L126-L136](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L126-L136)*\n", "full_markdown": "## 4. Missing validation allows signatures to be duplicated to finalize any PillarBlock\n\n| Severity: High                        | Diffi culty: Low       |  |\n|------------------------------------------|------------------------------|--|\n| Type: Data Validation              | Finding ID: TOB-TARA-4 |  |\n| bridge/src/eth/TaraClient.sol Target: |                              |  |\n\n#### Description\n\nThe finalizeBlocks function lacks proper validation of the lastBlockSigs argument and therefore allows any caller to arbitrarily inflate the number of signatures by duplicating the same signature in lastBlockSigs. This allows a PillarBlock that did not gain the required amount of validator votes to pass and be accepted as valid.\n\nFigure 4.1 shows that the lastBlockSigs argument is not validated and passed into the getSignaturesWeight function.\n\n```\n81 function finalizeBlocks(PillarBlock.WithChanges[] memory blocks,\nCompactSignature[] memory lastBlockSigs) public {\n 82 uint256 blocksLength = blocks.length;\n 83 uint256 weightThreshold = totalWeight / 2 + 1;\n 84 for (uint256 i = 0; i < blocksLength;) {\n...\n102 // skip verification for the first(genesis) block. And verify\nsignatures only for the last block in the batch\n103 if (finalized.block.period != 0 && i == (blocks.length - 1)) {\n104 uint256 weight =\n105\ngetSignaturesWeight(PillarBlock.getVoteHash(blocks[i].block.period, pbh),\nlastBlockSigs);\n106 if (weight < weightThreshold) {\n107 revert ThresholdNotMet({threshold: weightThreshold, weight:\nweight});\n108 }\n109 }\n...\n117 }\n118 }\n```\n\n*Figure 4.1: The finalizeBlocks function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\nFigure 4.2 shows the getSignaturesWeight function. This function does not in any way prevent duplicate signatures in the list to cause a revert. As long as the signature signed the PillarBlock hash (pbh variable), it is deemed valid, and the accompanying signer's\n\n\n(=validator) vote count is added to the weight variable. This weight variable is returned to finalizeBlocks after all signatures have been processed. The finalizeBlocks function will then continue with validating that this weight is at least weightThreshold (highlighted in red in figure 4.1). By inflating the amount of signatures due to duplicate signatures, a malicious user can circumvent this check for PillarBlocks that lack the required amount of votes.\n\n```\n126 function getSignaturesWeight(bytes32 h, CompactSignature[] memory\nsignatures)\n127 public\n128 view\n129 returns (uint256 weight)\n130 {\n131 uint256 signaturesLength = signatures.length;\n132 for (uint256 i = 0; i < signaturesLength; i++) {\n133 address signer = ECDSA.recover(h, signatures[i].r,\nsignatures[i].vs);\n134 weight += validatorVoteCounts[signer];\n135 }\n136 }\n```\n\n*Figure 4.2: The getSignaturesWeight function in [TaraClient.sol#L126-L136](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L126-L136)*\n\n#### Exploit Scenario\n\nEve calls the finalizeBlocks function with a PillarBlock whose last block has some votes, but not enough votes. Eve duplicates one of the signatures so many times as to pass the weightThreshold. The call succeeds, and a PillarBlock without enough votes was deemed valid and finalized.\n\n#### Recommendations\n\nShort term, prevent duplicate signatures from being accepted inside the getSignaturesWeight function, and instead trigger a revert in case of duplicate signatures.\n\nLong term, always validate inputs as much as possible. Also think of and handle edge cases such as duplicating values, passing zero values, and other ways of invalid input.\n", "sections": {"description_md": "#### Description\n\nThe finalizeBlocks function lacks proper validation of the lastBlockSigs argument and therefore allows any caller to arbitrarily inflate the number of signatures by duplicating the same signature in lastBlockSigs. This allows a PillarBlock that did not gain the required amount of validator votes to pass and be accepted as valid.\n\nFigure 4.1 shows that the lastBlockSigs argument is not validated and passed into the getSignaturesWeight function.\n\n```\n81 function finalizeBlocks(PillarBlock.WithChanges[] memory blocks,\nCompactSignature[] memory lastBlockSigs) public {\n 82 uint256 blocksLength = blocks.length;\n 83 uint256 weightThreshold = totalWeight / 2 + 1;\n 84 for (uint256 i = 0; i < blocksLength;) {\n...\n102 // skip verification for the first(genesis) block. And verify\nsignatures only for the last block in the batch\n103 if (finalized.block.period != 0 && i == (blocks.length - 1)) {\n104 uint256 weight =\n105\ngetSignaturesWeight(PillarBlock.getVoteHash(blocks[i].block.period, pbh),\nlastBlockSigs);\n106 if (weight < weightThreshold) {\n107 revert ThresholdNotMet({threshold: weightThreshold, weight:\nweight});\n108 }\n109 }\n...\n117 }\n118 }\n```\n\n*Figure 4.1: The finalizeBlocks function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\nFigure 4.2 shows the getSignaturesWeight function. This function does not in any way prevent duplicate signatures in the list to cause a revert. As long as the signature signed the PillarBlock hash (pbh variable), it is deemed valid, and the accompanying signer's\n\n\n(=validator) vote count is added to the weight variable. This weight variable is returned to finalizeBlocks after all signatures have been processed. The finalizeBlocks function will then continue with validating that this weight is at least weightThreshold (highlighted in red in figure 4.1). By inflating the amount of signatures due to duplicate signatures, a malicious user can circumvent this check for PillarBlocks that lack the required amount of votes.\n\n```\n126 function getSignaturesWeight(bytes32 h, CompactSignature[] memory\nsignatures)\n127 public\n128 view\n129 returns (uint256 weight)\n130 {\n131 uint256 signaturesLength = signatures.length;\n132 for (uint256 i = 0; i < signaturesLength; i++) {\n133 address signer = ECDSA.recover(h, signatures[i].r,\nsignatures[i].vs);\n134 weight += validatorVoteCounts[signer];\n135 }\n136 }\n```\n\n*Figure 4.2: The getSignaturesWeight function in [TaraClient.sol#L126-L136](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L126-L136)*\n", "impact_md": null, "recommendation_md": "#### Recommendations\n\nShort term, prevent duplicate signatures from being accepted inside the getSignaturesWeight function, and instead trigger a revert in case of duplicate signatures.\n\nLong term, always validate inputs as much as possible. Also think of and handle edge cases such as duplicating values, passing zero values, and other ways of invalid input.\n", "poc_md": "#### Exploit Scenario\n\nEve calls the finalizeBlocks function with a PillarBlock whose last block has some votes, but not enough votes. Eve duplicates one of the signatures so many times as to pass the weightThreshold. The call succeeds, and a PillarBlock without enough votes was deemed valid and finalized.\n", "fix_status_md": null, "other_md": null, "full_markdown_body": "| Severity: High                        | Diffi culty: Low       |  |\n|------------------------------------------|------------------------------|--|\n| Type: Data Validation              | Finding ID: TOB-TARA-4 |  |\n| bridge/src/eth/TaraClient.sol Target: |                              |  |\n\n#### Description\n\nThe finalizeBlocks function lacks proper validation of the lastBlockSigs argument and therefore allows any caller to arbitrarily inflate the number of signatures by duplicating the same signature in lastBlockSigs. This allows a PillarBlock that did not gain the required amount of validator votes to pass and be accepted as valid.\n\nFigure 4.1 shows that the lastBlockSigs argument is not validated and passed into the getSignaturesWeight function.\n\n```\n81 function finalizeBlocks(PillarBlock.WithChanges[] memory blocks,\nCompactSignature[] memory lastBlockSigs) public {\n 82 uint256 blocksLength = blocks.length;\n 83 uint256 weightThreshold = totalWeight / 2 + 1;\n 84 for (uint256 i = 0; i < blocksLength;) {\n...\n102 // skip verification for the first(genesis) block. And verify\nsignatures only for the last block in the batch\n103 if (finalized.block.period != 0 && i == (blocks.length - 1)) {\n104 uint256 weight =\n105\ngetSignaturesWeight(PillarBlock.getVoteHash(blocks[i].block.period, pbh),\nlastBlockSigs);\n106 if (weight < weightThreshold) {\n107 revert ThresholdNotMet({threshold: weightThreshold, weight:\nweight});\n108 }\n109 }\n...\n117 }\n118 }\n```\n\n*Figure 4.1: The finalizeBlocks function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\nFigure 4.2 shows the getSignaturesWeight function. This function does not in any way prevent duplicate signatures in the list to cause a revert. As long as the signature signed the PillarBlock hash (pbh variable), it is deemed valid, and the accompanying signer's\n\n\n(=validator) vote count is added to the weight variable. This weight variable is returned to finalizeBlocks after all signatures have been processed. The finalizeBlocks function will then continue with validating that this weight is at least weightThreshold (highlighted in red in figure 4.1). By inflating the amount of signatures due to duplicate signatures, a malicious user can circumvent this check for PillarBlocks that lack the required amount of votes.\n\n```\n126 function getSignaturesWeight(bytes32 h, CompactSignature[] memory\nsignatures)\n127 public\n128 view\n129 returns (uint256 weight)\n130 {\n131 uint256 signaturesLength = signatures.length;\n132 for (uint256 i = 0; i < signaturesLength; i++) {\n133 address signer = ECDSA.recover(h, signatures[i].r,\nsignatures[i].vs);\n134 weight += validatorVoteCounts[signer];\n135 }\n136 }\n```\n\n*Figure 4.2: The getSignaturesWeight function in [TaraClient.sol#L126-L136](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L126-L136)*\n\n#### Exploit Scenario\n\nEve calls the finalizeBlocks function with a PillarBlock whose last block has some votes, but not enough votes. Eve duplicates one of the signatures so many times as to pass the weightThreshold. The call succeeds, and a PillarBlock without enough votes was deemed valid and finalized.\n\n#### Recommendations\n\nShort term, prevent duplicate signatures from being accepted inside the getSignaturesWeight function, and instead trigger a revert in case of duplicate signatures.\n\nLong term, always validate inputs as much as possible. Also think of and handle edge cases such as duplicating values, passing zero values, and other ways of invalid input.\n", "markdown_raw": "## <span id=\"page-12-0\"></span>4. Missing validation allows signatures to be duplicated to finalize any PillarBlock\n\n| Severity:<br>High                        | Diffi<br>culty:<br>Low       |  |\n|------------------------------------------|------------------------------|--|\n| Type:<br>Data<br>Validation              | Finding<br>ID:<br>TOB-TARA-4 |  |\n| bridge/src/eth/TaraClient.sol<br>Target: |                              |  |\n\n#### Description\n\nThe finalizeBlocks function lacks proper validation of the lastBlockSigs argument and therefore allows any caller to arbitrarily inflate the number of signatures by duplicating the same signature in lastBlockSigs. This allows a PillarBlock that did not gain the required amount of validator votes to pass and be accepted as valid.\n\nFigure 4.1 shows that the lastBlockSigs argument is not validated and passed into the getSignaturesWeight function.\n\n```\n81 function finalizeBlocks(PillarBlock.WithChanges[] memory blocks,\nCompactSignature[] memory lastBlockSigs) public {\n 82 uint256 blocksLength = blocks.length;\n 83 uint256 weightThreshold = totalWeight / 2 + 1;\n 84 for (uint256 i = 0; i < blocksLength;) {\n...\n102 // skip verification for the first(genesis) block. And verify\nsignatures only for the last block in the batch\n103 if (finalized.block.period != 0 && i == (blocks.length - 1)) {\n104 uint256 weight =\n105\ngetSignaturesWeight(PillarBlock.getVoteHash(blocks[i].block.period, pbh),\nlastBlockSigs);\n106 if (weight < weightThreshold) {\n107 revert ThresholdNotMet({threshold: weightThreshold, weight:\nweight});\n108 }\n109 }\n...\n117 }\n118 }\n```\n\n*Figure 4.1: The finalizeBlocks function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\nFigure 4.2 shows the getSignaturesWeight function. This function does not in any way prevent duplicate signatures in the list to cause a revert. As long as the signature signed the PillarBlock hash (pbh variable), it is deemed valid, and the accompanying signer's\n\n{13}------------------------------------------------\n\n(=validator) vote count is added to the weight variable. This weight variable is returned to finalizeBlocks after all signatures have been processed. The finalizeBlocks function will then continue with validating that this weight is at least weightThreshold (highlighted in red in figure 4.1). By inflating the amount of signatures due to duplicate signatures, a malicious user can circumvent this check for PillarBlocks that lack the required amount of votes.\n\n```\n126 function getSignaturesWeight(bytes32 h, CompactSignature[] memory\nsignatures)\n127 public\n128 view\n129 returns (uint256 weight)\n130 {\n131 uint256 signaturesLength = signatures.length;\n132 for (uint256 i = 0; i < signaturesLength; i++) {\n133 address signer = ECDSA.recover(h, signatures[i].r,\nsignatures[i].vs);\n134 weight += validatorVoteCounts[signer];\n135 }\n136 }\n```\n\n*Figure 4.2: The getSignaturesWeight function in [TaraClient.sol#L126-L136](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L126-L136)*\n\n#### Exploit Scenario\n\nEve calls the finalizeBlocks function with a PillarBlock whose last block has some votes, but not enough votes. Eve duplicates one of the signatures so many times as to pass the weightThreshold. The call succeeds, and a PillarBlock without enough votes was deemed valid and finalized.\n\n#### Recommendations\n\nShort term, prevent duplicate signatures from being accepted inside the getSignaturesWeight function, and instead trigger a revert in case of duplicate signatures.\n\nLong term, always validate inputs as much as possible. Also think of and handle edge cases such as duplicating values, passing zero values, and other ways of invalid input.\n\n{14}------------------------------------------------\n"}, "severity": "High", "difficulty": "Low", "type": "Data Validation", "finding_id": "TOB-TARA-4", "target": {"path": "bridge/src/eth/TaraClient.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/Taraxa-project/bridge", "org": "Taraxa-project", "name": "bridge", "commit": "f82dd87c7e23358c74f7dc37451ca61110b60942", "branch": null, "relative_file": "bridge/src/eth/TaraClient.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "2024-07-taraxa-bridge-smart-contracts-v2-securityreview.pdf", "source_mtime": "2025-11-01T20:47:29.319395+00:00", "report_extracted_at": "2025-11-19T09:04:32.938539+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T09:04:32.941583+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": "Low", "Type": "Data Validation", "Finding ID": "TOB-TARA-4", "Target": "bridge/src/eth/TaraClient.sol", "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview-005", "doc_id": "trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview", "finding_index": 5, "page_start": 14, "title": "Incorrect mapping key used in validation inside registerContract", "short_summary": null, "description_md": "#### Description\n\nA check inside the registerContract function uses the wrong value for the key into the connectors mapping, which will likely result in this check always passing. In terms of the check itself, this does not currently pose a problem due to the other validations, one of which uses the right value for this same mapping to perform the same check a couple lines further down.\n\nThe connectors mapping is used to look up which connector should be used for a specific source contract. As such, the mapping's key is a source contract address, and the value is a connector address. At the end of figure 5.1 a line is highlighted in orange, which shows the correct setting of a value in this mapping where the key is the srcContract address and the value is a connector address.\n\nFigure 5.1 shows that the wrong value is used for the key in the connectors mapping (highlighted in yellow). However, a couple of lines down, the same check is performed with the right value for the key (highlighted in blue), so this important validation is performed.\n\n```\n142 function registerContract(IBridgeConnector connector) public payable {\n143 if (msg.value < registrationFee) {\n144 revert InsufficientFunds(registrationFee, msg.value);\n145 }\n146\n147 address srcContract = connector.getSourceContract();\n148 address dstContract = connector.getDestinationContract();\n149\n150 if (connectors[address(connector)] != IBridgeConnector(address(0))) {\n151 return;\n152 }\n153 if (srcContract == address(0)) {\n154 revert ZeroAddressCannotBeRegistered();\n155 }\n156 if (localAddress[dstContract] != address(0) ||\naddress(connectors[srcContract]) != address(0)) {\n157 revert ConnectorAlreadyRegistered({connector: address(connector),\ntoken: srcContract});\n```\n\n\n```\n158 }\n159\n160 address owner = OwnableUpgradeable(address(connector)).owner();\n161 if (owner != address(this)) {\n162 revert IncorrectOwner(owner, address(this));\n163 }\n164\n165 connectors[srcContract] = connector;\n166 localAddress[dstContract] = srcContract;\n167 tokenAddresses.push(srcContract);\n168 emit ConnectorRegistered(address(connector), srcContract, dstContract);\n169 }\n```\n\n*Figure 5.1: The registerContract function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n", "full_markdown": "# 5. Incorrect mapping key used in validation inside registerContract Severity: **Informational** Difficulty: **Low** Type: Undefined Behavior Finding ID: TOB-TARA-5 Target: bridge/src/lib/BridgeBase.sol\n\n#### Description\n\nA check inside the registerContract function uses the wrong value for the key into the connectors mapping, which will likely result in this check always passing. In terms of the check itself, this does not currently pose a problem due to the other validations, one of which uses the right value for this same mapping to perform the same check a couple lines further down.\n\nThe connectors mapping is used to look up which connector should be used for a specific source contract. As such, the mapping's key is a source contract address, and the value is a connector address. At the end of figure 5.1 a line is highlighted in orange, which shows the correct setting of a value in this mapping where the key is the srcContract address and the value is a connector address.\n\nFigure 5.1 shows that the wrong value is used for the key in the connectors mapping (highlighted in yellow). However, a couple of lines down, the same check is performed with the right value for the key (highlighted in blue), so this important validation is performed.\n\n```\n142 function registerContract(IBridgeConnector connector) public payable {\n143 if (msg.value < registrationFee) {\n144 revert InsufficientFunds(registrationFee, msg.value);\n145 }\n146\n147 address srcContract = connector.getSourceContract();\n148 address dstContract = connector.getDestinationContract();\n149\n150 if (connectors[address(connector)] != IBridgeConnector(address(0))) {\n151 return;\n152 }\n153 if (srcContract == address(0)) {\n154 revert ZeroAddressCannotBeRegistered();\n155 }\n156 if (localAddress[dstContract] != address(0) ||\naddress(connectors[srcContract]) != address(0)) {\n157 revert ConnectorAlreadyRegistered({connector: address(connector),\ntoken: srcContract});\n```\n\n\n```\n158 }\n159\n160 address owner = OwnableUpgradeable(address(connector)).owner();\n161 if (owner != address(this)) {\n162 revert IncorrectOwner(owner, address(this));\n163 }\n164\n165 connectors[srcContract] = connector;\n166 localAddress[dstContract] = srcContract;\n167 tokenAddresses.push(srcContract);\n168 emit ConnectorRegistered(address(connector), srcContract, dstContract);\n169 }\n```\n\n*Figure 5.1: The registerContract function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\n#### Recommendations\n\nShort term, remove lines 150, 151, and 152, as this same check is already performed on line 156.\n\nLong term, add more inline documentation to the implementation. In particular, add comments that explain what if-statements are checking. This would have likely uncovered this incorrect mapping usage.\n", "sections": {"description_md": "#### Description\n\nA check inside the registerContract function uses the wrong value for the key into the connectors mapping, which will likely result in this check always passing. In terms of the check itself, this does not currently pose a problem due to the other validations, one of which uses the right value for this same mapping to perform the same check a couple lines further down.\n\nThe connectors mapping is used to look up which connector should be used for a specific source contract. As such, the mapping's key is a source contract address, and the value is a connector address. At the end of figure 5.1 a line is highlighted in orange, which shows the correct setting of a value in this mapping where the key is the srcContract address and the value is a connector address.\n\nFigure 5.1 shows that the wrong value is used for the key in the connectors mapping (highlighted in yellow). However, a couple of lines down, the same check is performed with the right value for the key (highlighted in blue), so this important validation is performed.\n\n```\n142 function registerContract(IBridgeConnector connector) public payable {\n143 if (msg.value < registrationFee) {\n144 revert InsufficientFunds(registrationFee, msg.value);\n145 }\n146\n147 address srcContract = connector.getSourceContract();\n148 address dstContract = connector.getDestinationContract();\n149\n150 if (connectors[address(connector)] != IBridgeConnector(address(0))) {\n151 return;\n152 }\n153 if (srcContract == address(0)) {\n154 revert ZeroAddressCannotBeRegistered();\n155 }\n156 if (localAddress[dstContract] != address(0) ||\naddress(connectors[srcContract]) != address(0)) {\n157 revert ConnectorAlreadyRegistered({connector: address(connector),\ntoken: srcContract});\n```\n\n\n```\n158 }\n159\n160 address owner = OwnableUpgradeable(address(connector)).owner();\n161 if (owner != address(this)) {\n162 revert IncorrectOwner(owner, address(this));\n163 }\n164\n165 connectors[srcContract] = connector;\n166 localAddress[dstContract] = srcContract;\n167 tokenAddresses.push(srcContract);\n168 emit ConnectorRegistered(address(connector), srcContract, dstContract);\n169 }\n```\n\n*Figure 5.1: The registerContract function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n", "impact_md": null, "recommendation_md": "#### Recommendations\n\nShort term, remove lines 150, 151, and 152, as this same check is already performed on line 156.\n\nLong term, add more inline documentation to the implementation. In particular, add comments that explain what if-statements are checking. This would have likely uncovered this incorrect mapping usage.\n", "poc_md": null, "fix_status_md": null, "other_md": null, "full_markdown_body": "#### Description\n\nA check inside the registerContract function uses the wrong value for the key into the connectors mapping, which will likely result in this check always passing. In terms of the check itself, this does not currently pose a problem due to the other validations, one of which uses the right value for this same mapping to perform the same check a couple lines further down.\n\nThe connectors mapping is used to look up which connector should be used for a specific source contract. As such, the mapping's key is a source contract address, and the value is a connector address. At the end of figure 5.1 a line is highlighted in orange, which shows the correct setting of a value in this mapping where the key is the srcContract address and the value is a connector address.\n\nFigure 5.1 shows that the wrong value is used for the key in the connectors mapping (highlighted in yellow). However, a couple of lines down, the same check is performed with the right value for the key (highlighted in blue), so this important validation is performed.\n\n```\n142 function registerContract(IBridgeConnector connector) public payable {\n143 if (msg.value < registrationFee) {\n144 revert InsufficientFunds(registrationFee, msg.value);\n145 }\n146\n147 address srcContract = connector.getSourceContract();\n148 address dstContract = connector.getDestinationContract();\n149\n150 if (connectors[address(connector)] != IBridgeConnector(address(0))) {\n151 return;\n152 }\n153 if (srcContract == address(0)) {\n154 revert ZeroAddressCannotBeRegistered();\n155 }\n156 if (localAddress[dstContract] != address(0) ||\naddress(connectors[srcContract]) != address(0)) {\n157 revert ConnectorAlreadyRegistered({connector: address(connector),\ntoken: srcContract});\n```\n\n\n```\n158 }\n159\n160 address owner = OwnableUpgradeable(address(connector)).owner();\n161 if (owner != address(this)) {\n162 revert IncorrectOwner(owner, address(this));\n163 }\n164\n165 connectors[srcContract] = connector;\n166 localAddress[dstContract] = srcContract;\n167 tokenAddresses.push(srcContract);\n168 emit ConnectorRegistered(address(connector), srcContract, dstContract);\n169 }\n```\n\n*Figure 5.1: The registerContract function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\n#### Recommendations\n\nShort term, remove lines 150, 151, and 152, as this same check is already performed on line 156.\n\nLong term, add more inline documentation to the implementation. In particular, add comments that explain what if-statements are checking. This would have likely uncovered this incorrect mapping usage.\n", "markdown_raw": "# <span id=\"page-14-0\"></span>5. Incorrect mapping key used in validation inside registerContract Severity: **Informational** Difficulty: **Low** Type: Undefined Behavior Finding ID: TOB-TARA-5 Target: bridge/src/lib/BridgeBase.sol\n\n#### Description\n\nA check inside the registerContract function uses the wrong value for the key into the connectors mapping, which will likely result in this check always passing. In terms of the check itself, this does not currently pose a problem due to the other validations, one of which uses the right value for this same mapping to perform the same check a couple lines further down.\n\nThe connectors mapping is used to look up which connector should be used for a specific source contract. As such, the mapping's key is a source contract address, and the value is a connector address. At the end of figure 5.1 a line is highlighted in orange, which shows the correct setting of a value in this mapping where the key is the srcContract address and the value is a connector address.\n\nFigure 5.1 shows that the wrong value is used for the key in the connectors mapping (highlighted in yellow). However, a couple of lines down, the same check is performed with the right value for the key (highlighted in blue), so this important validation is performed.\n\n```\n142 function registerContract(IBridgeConnector connector) public payable {\n143 if (msg.value < registrationFee) {\n144 revert InsufficientFunds(registrationFee, msg.value);\n145 }\n146\n147 address srcContract = connector.getSourceContract();\n148 address dstContract = connector.getDestinationContract();\n149\n150 if (connectors[address(connector)] != IBridgeConnector(address(0))) {\n151 return;\n152 }\n153 if (srcContract == address(0)) {\n154 revert ZeroAddressCannotBeRegistered();\n155 }\n156 if (localAddress[dstContract] != address(0) ||\naddress(connectors[srcContract]) != address(0)) {\n157 revert ConnectorAlreadyRegistered({connector: address(connector),\ntoken: srcContract});\n```\n\n{15}------------------------------------------------\n\n```\n158 }\n159\n160 address owner = OwnableUpgradeable(address(connector)).owner();\n161 if (owner != address(this)) {\n162 revert IncorrectOwner(owner, address(this));\n163 }\n164\n165 connectors[srcContract] = connector;\n166 localAddress[dstContract] = srcContract;\n167 tokenAddresses.push(srcContract);\n168 emit ConnectorRegistered(address(connector), srcContract, dstContract);\n169 }\n```\n\n*Figure 5.1: The registerContract function in [TaraClient.sol#L81-L118](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/eth/TaraClient.sol#L81-L118)*\n\n#### Recommendations\n\nShort term, remove lines 150, 151, and 152, as this same check is already performed on line 156.\n\nLong term, add more inline documentation to the implementation. In particular, add comments that explain what if-statements are checking. This would have likely uncovered this incorrect mapping usage.\n\n{16}------------------------------------------------\n"}, "severity": "Informational", "difficulty": "Low", "type": "Undefined Behavior", "finding_id": "TOB-TARA-5", "target": {"path": "bridge/src/lib/BridgeBase.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/crytic/slither-action", "org": "crytic", "name": "slither-action", "commit": null, "branch": null, "relative_file": "bridge/src/lib/BridgeBase.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "2024-07-taraxa-bridge-smart-contracts-v2-securityreview.pdf", "source_mtime": "2025-11-01T20:47:29.319395+00:00", "report_extracted_at": "2025-11-19T09:04:32.938539+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T09:04:32.941583+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Informational", "Difficulty": "Low", "Type": "Undefined Behavior", "Finding ID": "TOB-TARA-5", "Target": "bridge/src/lib/BridgeBase.sol", "Severity_normalized": "Informational"}}
{"schema_version": "0.1", "scvd_id": "SCVD-trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview-006", "doc_id": "trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview", "finding_index": 6, "page_start": 16, "title": "Reentrancy in applyState can lead to breaking the contract and stealing hook-enabled tokens", "short_summary": null, "description_md": "#### Description\n\nThe lack of reentrancy guards on the applyState function allows the stealing of hook-supporting tokens by calling applyState recursively. Since no popular tokens support this standard or hooks in general, this limits the impact of this issue. However, because the epoch incorrectly increments whenever applyState is called through reentrancy, this will likely prevent the broken bridge contract's applyState function from accepting valid bridge messages, since the epoch does not match what is expected.\n\nThe applyState function can be called by anyone and will apply bridged messages (either from Ethereum to Taraxa, or vice versa). Inside this function, the epoch in the input arguments is validated to be one above the current epoch (called appliedEpoch, as highlighted in yellow in figure 6.1). At the very end of the function, the appliedEpoch is incremented (as highlighted in blue in figure 6.1). In the middle of the function, a loop over all of the bridged messages is performed; this will call the applyState function of the configured connector (as highlighted in green in figure 6.1). These will then transfer the tokens to the recipient (this could involve transferring an ERC20 token amount, minting an ERC20 token amount, or transferring an amount of the chain's native token).\n\nIn the case of an ERC20 transfer in which the token to be transferred is an ERC777 (or an otherwise hook-supporting token) contract, the recipient can use reentrancy to call back into the BridgeBase.applyState function with the same arguments. This works since appliedEpoch is incremented only at the end of the function.\n\n```\n175 function applyState(SharedStructs.StateWithProof calldata state_with_proof)\npublic {\n176 uint256 gasleftbefore = gasleft();\n177 // get bridge root from light client and compare it (it should be proved\nthere)\n178 if (\n179 SharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes)\n180 !=\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n```\n\n\n```\n181 ) {\n182 revert StateNotMatchingBridgeRoot({\n183 stateRoot:\nSharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes),\n184 bridgeRoot:\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n185 });\n186 }\n187 if (state_with_proof.state.epoch != appliedEpoch + 1) {\n188 revert NotSuccessiveEpochs({epoch: appliedEpoch, nextEpoch:\nstate_with_proof.state.epoch});\n189 }\n190 uint256 statesLength = state_with_proof.state.states.length;\n191 uint256 idx = 0;\n192 while (idx < statesLength) {\n193 SharedStructs.ContractStateHash calldata proofStateHash =\nstate_with_proof.state_hashes[idx];\n194 SharedStructs.StateWithAddress calldata state =\nstate_with_proof.state.states[idx];\n195 if (localAddress[proofStateHash.contractAddress] == address(0)) {\n196 unchecked {\n197 ++idx;\n198 }\n199 continue;\n200 }\n201 bytes32 stateHash = keccak256(state.state);\n202 if (stateHash != proofStateHash.stateHash) {\n203 unchecked {\n204 ++idx;\n205 }\n206 revert InvalidStateHash(stateHash, proofStateHash.stateHash);\n207 }\n208 if\n(isContract(address(connectors[localAddress[proofStateHash.contractAddress]]))) {\n209 try\nconnectors[localAddress[proofStateHash.contractAddress]].applyState(state.state) {}\ncatch {}\n210 }\n211 unchecked {\n212 ++idx;\n213 }\n214 }\n215 uint256 used = (gasleftbefore - gasleft()) * tx.gasprice;\n216 uint256 payout = used * feeMultiplier / 100;\n217 if (address(this).balance >= payout) {\n218 (bool success,) = payable(msg.sender).call{value: payout}(\"\");\n219 if (!success) {\n220 revert TransferFailed(msg.sender, payout);\n221 }\n222 }\n223 ++appliedEpoch;\n224 }\n```\n\n\n*Figure 6.1: The applyState function in [BridgeBase.sol#L175-L224](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/BridgeBase.sol#L175-L224)*\n", "full_markdown": "### 6. Reentrancy in applyState can lead to breaking the contract and stealing hook-enabled tokens\n\n| Severity: High                        | Diffi culty: Medium    |  |\n|------------------------------------------|------------------------------|--|\n| Type: Undefined Behavior           | Finding ID: TOB-TARA-6 |  |\n| bridge/src/lib/BridgeBase.sol Target: |                              |  |\n\n#### Description\n\nThe lack of reentrancy guards on the applyState function allows the stealing of hook-supporting tokens by calling applyState recursively. Since no popular tokens support this standard or hooks in general, this limits the impact of this issue. However, because the epoch incorrectly increments whenever applyState is called through reentrancy, this will likely prevent the broken bridge contract's applyState function from accepting valid bridge messages, since the epoch does not match what is expected.\n\nThe applyState function can be called by anyone and will apply bridged messages (either from Ethereum to Taraxa, or vice versa). Inside this function, the epoch in the input arguments is validated to be one above the current epoch (called appliedEpoch, as highlighted in yellow in figure 6.1). At the very end of the function, the appliedEpoch is incremented (as highlighted in blue in figure 6.1). In the middle of the function, a loop over all of the bridged messages is performed; this will call the applyState function of the configured connector (as highlighted in green in figure 6.1). These will then transfer the tokens to the recipient (this could involve transferring an ERC20 token amount, minting an ERC20 token amount, or transferring an amount of the chain's native token).\n\nIn the case of an ERC20 transfer in which the token to be transferred is an ERC777 (or an otherwise hook-supporting token) contract, the recipient can use reentrancy to call back into the BridgeBase.applyState function with the same arguments. This works since appliedEpoch is incremented only at the end of the function.\n\n```\n175 function applyState(SharedStructs.StateWithProof calldata state_with_proof)\npublic {\n176 uint256 gasleftbefore = gasleft();\n177 // get bridge root from light client and compare it (it should be proved\nthere)\n178 if (\n179 SharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes)\n180 !=\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n```\n\n\n```\n181 ) {\n182 revert StateNotMatchingBridgeRoot({\n183 stateRoot:\nSharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes),\n184 bridgeRoot:\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n185 });\n186 }\n187 if (state_with_proof.state.epoch != appliedEpoch + 1) {\n188 revert NotSuccessiveEpochs({epoch: appliedEpoch, nextEpoch:\nstate_with_proof.state.epoch});\n189 }\n190 uint256 statesLength = state_with_proof.state.states.length;\n191 uint256 idx = 0;\n192 while (idx < statesLength) {\n193 SharedStructs.ContractStateHash calldata proofStateHash =\nstate_with_proof.state_hashes[idx];\n194 SharedStructs.StateWithAddress calldata state =\nstate_with_proof.state.states[idx];\n195 if (localAddress[proofStateHash.contractAddress] == address(0)) {\n196 unchecked {\n197 ++idx;\n198 }\n199 continue;\n200 }\n201 bytes32 stateHash = keccak256(state.state);\n202 if (stateHash != proofStateHash.stateHash) {\n203 unchecked {\n204 ++idx;\n205 }\n206 revert InvalidStateHash(stateHash, proofStateHash.stateHash);\n207 }\n208 if\n(isContract(address(connectors[localAddress[proofStateHash.contractAddress]]))) {\n209 try\nconnectors[localAddress[proofStateHash.contractAddress]].applyState(state.state) {}\ncatch {}\n210 }\n211 unchecked {\n212 ++idx;\n213 }\n214 }\n215 uint256 used = (gasleftbefore - gasleft()) * tx.gasprice;\n216 uint256 payout = used * feeMultiplier / 100;\n217 if (address(this).balance >= payout) {\n218 (bool success,) = payable(msg.sender).call{value: payout}(\"\");\n219 if (!success) {\n220 revert TransferFailed(msg.sender, payout);\n221 }\n222 }\n223 ++appliedEpoch;\n224 }\n```\n\n\n*Figure 6.1: The applyState function in [BridgeBase.sol#L175-L224](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/BridgeBase.sol#L175-L224)*\n\n#### Exploit Scenario\n\nEve holds 1,000 of an ERC777 token called TokenX in a contract she has deployed (called AttackerContract). Eve bridges these 1,000 TokenX from Ethereum to Taraxa. Eve's 1,000 tokens are now locked inside the configured ERC20LockingConnector on Ethereum. After bridging to Taraxa, she immediately initiates a bridge of 1,000 TokenX from Taraxa back to Ethereum.\n\nShe now monitors the Ethereum chain to spot the first time anyone tries to call the EthBridge.applyState function to bridge messages, which includes her bridging message. Once she spots it, she front-runs the transaction and calls EthBridge.applyState with the same arguments.\n\nThe message handling loop will now call the TokenX.transfer function to transfer the 1,000 tokens to AttackerContract, after which the ERC777 \\_callTokensToReceived hook will call AttackerContract. Inside the called AttackerContract function, a call is made back to EthBridge.applyState with the same arguments as the original call. This will lead to a loop where each time EthBridge.applyState is called, the AttackerContract will receive 1,000 TokenX tokens.\n\nThe only limitations of this attack are gas, the amount of TokenX inside the ERC20LockingConnector, and the failure of other bridging messages due to lack of tokens or multiple executions.\n\n#### Recommendations\n\nShort term, add reentrancy guards to the BridgeBase.applyState function. This will prevent the aforementioned issue.\n\n#### Long term:\n\n- Use [Slither](https://github.com/crytic/slither) to detect this issue, and integrate it into the CI using [slither-action.](https://github.com/crytic/slither-action)\n- Review all non-view functions and consider adding reentrancy guards to each of these functions.\n- Update the implementation to follow the [Checks-Effects-Interactions](https://docs.soliditylang.org/en/latest/security-considerations.html#reentrancy) pattern. This pattern is considered a best practice and structures the code in a manner that helps prevent reentrancy vulnerabilities.\n", "sections": {"description_md": "#### Description\n\nThe lack of reentrancy guards on the applyState function allows the stealing of hook-supporting tokens by calling applyState recursively. Since no popular tokens support this standard or hooks in general, this limits the impact of this issue. However, because the epoch incorrectly increments whenever applyState is called through reentrancy, this will likely prevent the broken bridge contract's applyState function from accepting valid bridge messages, since the epoch does not match what is expected.\n\nThe applyState function can be called by anyone and will apply bridged messages (either from Ethereum to Taraxa, or vice versa). Inside this function, the epoch in the input arguments is validated to be one above the current epoch (called appliedEpoch, as highlighted in yellow in figure 6.1). At the very end of the function, the appliedEpoch is incremented (as highlighted in blue in figure 6.1). In the middle of the function, a loop over all of the bridged messages is performed; this will call the applyState function of the configured connector (as highlighted in green in figure 6.1). These will then transfer the tokens to the recipient (this could involve transferring an ERC20 token amount, minting an ERC20 token amount, or transferring an amount of the chain's native token).\n\nIn the case of an ERC20 transfer in which the token to be transferred is an ERC777 (or an otherwise hook-supporting token) contract, the recipient can use reentrancy to call back into the BridgeBase.applyState function with the same arguments. This works since appliedEpoch is incremented only at the end of the function.\n\n```\n175 function applyState(SharedStructs.StateWithProof calldata state_with_proof)\npublic {\n176 uint256 gasleftbefore = gasleft();\n177 // get bridge root from light client and compare it (it should be proved\nthere)\n178 if (\n179 SharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes)\n180 !=\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n```\n\n\n```\n181 ) {\n182 revert StateNotMatchingBridgeRoot({\n183 stateRoot:\nSharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes),\n184 bridgeRoot:\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n185 });\n186 }\n187 if (state_with_proof.state.epoch != appliedEpoch + 1) {\n188 revert NotSuccessiveEpochs({epoch: appliedEpoch, nextEpoch:\nstate_with_proof.state.epoch});\n189 }\n190 uint256 statesLength = state_with_proof.state.states.length;\n191 uint256 idx = 0;\n192 while (idx < statesLength) {\n193 SharedStructs.ContractStateHash calldata proofStateHash =\nstate_with_proof.state_hashes[idx];\n194 SharedStructs.StateWithAddress calldata state =\nstate_with_proof.state.states[idx];\n195 if (localAddress[proofStateHash.contractAddress] == address(0)) {\n196 unchecked {\n197 ++idx;\n198 }\n199 continue;\n200 }\n201 bytes32 stateHash = keccak256(state.state);\n202 if (stateHash != proofStateHash.stateHash) {\n203 unchecked {\n204 ++idx;\n205 }\n206 revert InvalidStateHash(stateHash, proofStateHash.stateHash);\n207 }\n208 if\n(isContract(address(connectors[localAddress[proofStateHash.contractAddress]]))) {\n209 try\nconnectors[localAddress[proofStateHash.contractAddress]].applyState(state.state) {}\ncatch {}\n210 }\n211 unchecked {\n212 ++idx;\n213 }\n214 }\n215 uint256 used = (gasleftbefore - gasleft()) * tx.gasprice;\n216 uint256 payout = used * feeMultiplier / 100;\n217 if (address(this).balance >= payout) {\n218 (bool success,) = payable(msg.sender).call{value: payout}(\"\");\n219 if (!success) {\n220 revert TransferFailed(msg.sender, payout);\n221 }\n222 }\n223 ++appliedEpoch;\n224 }\n```\n\n\n*Figure 6.1: The applyState function in [BridgeBase.sol#L175-L224](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/BridgeBase.sol#L175-L224)*\n", "impact_md": null, "recommendation_md": "#### Recommendations\n\nShort term, add reentrancy guards to the BridgeBase.applyState function. This will prevent the aforementioned issue.\n\n#### Long term:\n\n- Use [Slither](https://github.com/crytic/slither) to detect this issue, and integrate it into the CI using [slither-action.](https://github.com/crytic/slither-action)\n- Review all non-view functions and consider adding reentrancy guards to each of these functions.\n- Update the implementation to follow the [Checks-Effects-Interactions](https://docs.soliditylang.org/en/latest/security-considerations.html#reentrancy) pattern. This pattern is considered a best practice and structures the code in a manner that helps prevent reentrancy vulnerabilities.\n", "poc_md": "#### Exploit Scenario\n\nEve holds 1,000 of an ERC777 token called TokenX in a contract she has deployed (called AttackerContract). Eve bridges these 1,000 TokenX from Ethereum to Taraxa. Eve's 1,000 tokens are now locked inside the configured ERC20LockingConnector on Ethereum. After bridging to Taraxa, she immediately initiates a bridge of 1,000 TokenX from Taraxa back to Ethereum.\n\nShe now monitors the Ethereum chain to spot the first time anyone tries to call the EthBridge.applyState function to bridge messages, which includes her bridging message. Once she spots it, she front-runs the transaction and calls EthBridge.applyState with the same arguments.\n\nThe message handling loop will now call the TokenX.transfer function to transfer the 1,000 tokens to AttackerContract, after which the ERC777 \\_callTokensToReceived hook will call AttackerContract. Inside the called AttackerContract function, a call is made back to EthBridge.applyState with the same arguments as the original call. This will lead to a loop where each time EthBridge.applyState is called, the AttackerContract will receive 1,000 TokenX tokens.\n\nThe only limitations of this attack are gas, the amount of TokenX inside the ERC20LockingConnector, and the failure of other bridging messages due to lack of tokens or multiple executions.\n", "fix_status_md": null, "other_md": null, "full_markdown_body": "| Severity: High                        | Diffi culty: Medium    |  |\n|------------------------------------------|------------------------------|--|\n| Type: Undefined Behavior           | Finding ID: TOB-TARA-6 |  |\n| bridge/src/lib/BridgeBase.sol Target: |                              |  |\n\n#### Description\n\nThe lack of reentrancy guards on the applyState function allows the stealing of hook-supporting tokens by calling applyState recursively. Since no popular tokens support this standard or hooks in general, this limits the impact of this issue. However, because the epoch incorrectly increments whenever applyState is called through reentrancy, this will likely prevent the broken bridge contract's applyState function from accepting valid bridge messages, since the epoch does not match what is expected.\n\nThe applyState function can be called by anyone and will apply bridged messages (either from Ethereum to Taraxa, or vice versa). Inside this function, the epoch in the input arguments is validated to be one above the current epoch (called appliedEpoch, as highlighted in yellow in figure 6.1). At the very end of the function, the appliedEpoch is incremented (as highlighted in blue in figure 6.1). In the middle of the function, a loop over all of the bridged messages is performed; this will call the applyState function of the configured connector (as highlighted in green in figure 6.1). These will then transfer the tokens to the recipient (this could involve transferring an ERC20 token amount, minting an ERC20 token amount, or transferring an amount of the chain's native token).\n\nIn the case of an ERC20 transfer in which the token to be transferred is an ERC777 (or an otherwise hook-supporting token) contract, the recipient can use reentrancy to call back into the BridgeBase.applyState function with the same arguments. This works since appliedEpoch is incremented only at the end of the function.\n\n```\n175 function applyState(SharedStructs.StateWithProof calldata state_with_proof)\npublic {\n176 uint256 gasleftbefore = gasleft();\n177 // get bridge root from light client and compare it (it should be proved\nthere)\n178 if (\n179 SharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes)\n180 !=\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n```\n\n\n```\n181 ) {\n182 revert StateNotMatchingBridgeRoot({\n183 stateRoot:\nSharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes),\n184 bridgeRoot:\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n185 });\n186 }\n187 if (state_with_proof.state.epoch != appliedEpoch + 1) {\n188 revert NotSuccessiveEpochs({epoch: appliedEpoch, nextEpoch:\nstate_with_proof.state.epoch});\n189 }\n190 uint256 statesLength = state_with_proof.state.states.length;\n191 uint256 idx = 0;\n192 while (idx < statesLength) {\n193 SharedStructs.ContractStateHash calldata proofStateHash =\nstate_with_proof.state_hashes[idx];\n194 SharedStructs.StateWithAddress calldata state =\nstate_with_proof.state.states[idx];\n195 if (localAddress[proofStateHash.contractAddress] == address(0)) {\n196 unchecked {\n197 ++idx;\n198 }\n199 continue;\n200 }\n201 bytes32 stateHash = keccak256(state.state);\n202 if (stateHash != proofStateHash.stateHash) {\n203 unchecked {\n204 ++idx;\n205 }\n206 revert InvalidStateHash(stateHash, proofStateHash.stateHash);\n207 }\n208 if\n(isContract(address(connectors[localAddress[proofStateHash.contractAddress]]))) {\n209 try\nconnectors[localAddress[proofStateHash.contractAddress]].applyState(state.state) {}\ncatch {}\n210 }\n211 unchecked {\n212 ++idx;\n213 }\n214 }\n215 uint256 used = (gasleftbefore - gasleft()) * tx.gasprice;\n216 uint256 payout = used * feeMultiplier / 100;\n217 if (address(this).balance >= payout) {\n218 (bool success,) = payable(msg.sender).call{value: payout}(\"\");\n219 if (!success) {\n220 revert TransferFailed(msg.sender, payout);\n221 }\n222 }\n223 ++appliedEpoch;\n224 }\n```\n\n\n*Figure 6.1: The applyState function in [BridgeBase.sol#L175-L224](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/BridgeBase.sol#L175-L224)*\n\n#### Exploit Scenario\n\nEve holds 1,000 of an ERC777 token called TokenX in a contract she has deployed (called AttackerContract). Eve bridges these 1,000 TokenX from Ethereum to Taraxa. Eve's 1,000 tokens are now locked inside the configured ERC20LockingConnector on Ethereum. After bridging to Taraxa, she immediately initiates a bridge of 1,000 TokenX from Taraxa back to Ethereum.\n\nShe now monitors the Ethereum chain to spot the first time anyone tries to call the EthBridge.applyState function to bridge messages, which includes her bridging message. Once she spots it, she front-runs the transaction and calls EthBridge.applyState with the same arguments.\n\nThe message handling loop will now call the TokenX.transfer function to transfer the 1,000 tokens to AttackerContract, after which the ERC777 \\_callTokensToReceived hook will call AttackerContract. Inside the called AttackerContract function, a call is made back to EthBridge.applyState with the same arguments as the original call. This will lead to a loop where each time EthBridge.applyState is called, the AttackerContract will receive 1,000 TokenX tokens.\n\nThe only limitations of this attack are gas, the amount of TokenX inside the ERC20LockingConnector, and the failure of other bridging messages due to lack of tokens or multiple executions.\n\n#### Recommendations\n\nShort term, add reentrancy guards to the BridgeBase.applyState function. This will prevent the aforementioned issue.\n\n#### Long term:\n\n- Use [Slither](https://github.com/crytic/slither) to detect this issue, and integrate it into the CI using [slither-action.](https://github.com/crytic/slither-action)\n- Review all non-view functions and consider adding reentrancy guards to each of these functions.\n- Update the implementation to follow the [Checks-Effects-Interactions](https://docs.soliditylang.org/en/latest/security-considerations.html#reentrancy) pattern. This pattern is considered a best practice and structures the code in a manner that helps prevent reentrancy vulnerabilities.\n", "markdown_raw": "### <span id=\"page-16-0\"></span>6. Reentrancy in applyState can lead to breaking the contract and stealing hook-enabled tokens\n\n| Severity:<br>High                        | Diffi<br>culty:<br>Medium    |  |\n|------------------------------------------|------------------------------|--|\n| Type:<br>Undefined<br>Behavior           | Finding<br>ID:<br>TOB-TARA-6 |  |\n| bridge/src/lib/BridgeBase.sol<br>Target: |                              |  |\n\n#### Description\n\nThe lack of reentrancy guards on the applyState function allows the stealing of hook-supporting tokens by calling applyState recursively. Since no popular tokens support this standard or hooks in general, this limits the impact of this issue. However, because the epoch incorrectly increments whenever applyState is called through reentrancy, this will likely prevent the broken bridge contract's applyState function from accepting valid bridge messages, since the epoch does not match what is expected.\n\nThe applyState function can be called by anyone and will apply bridged messages (either from Ethereum to Taraxa, or vice versa). Inside this function, the epoch in the input arguments is validated to be one above the current epoch (called appliedEpoch, as highlighted in yellow in figure 6.1). At the very end of the function, the appliedEpoch is incremented (as highlighted in blue in figure 6.1). In the middle of the function, a loop over all of the bridged messages is performed; this will call the applyState function of the configured connector (as highlighted in green in figure 6.1). These will then transfer the tokens to the recipient (this could involve transferring an ERC20 token amount, minting an ERC20 token amount, or transferring an amount of the chain's native token).\n\nIn the case of an ERC20 transfer in which the token to be transferred is an ERC777 (or an otherwise hook-supporting token) contract, the recipient can use reentrancy to call back into the BridgeBase.applyState function with the same arguments. This works since appliedEpoch is incremented only at the end of the function.\n\n```\n175 function applyState(SharedStructs.StateWithProof calldata state_with_proof)\npublic {\n176 uint256 gasleftbefore = gasleft();\n177 // get bridge root from light client and compare it (it should be proved\nthere)\n178 if (\n179 SharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes)\n180 !=\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n```\n\n{17}------------------------------------------------\n\n```\n181 ) {\n182 revert StateNotMatchingBridgeRoot({\n183 stateRoot:\nSharedStructs.getBridgeRoot(state_with_proof.state.epoch,\nstate_with_proof.state_hashes),\n184 bridgeRoot:\nlightClient.getFinalizedBridgeRoot(state_with_proof.state.epoch)\n185 });\n186 }\n187 if (state_with_proof.state.epoch != appliedEpoch + 1) {\n188 revert NotSuccessiveEpochs({epoch: appliedEpoch, nextEpoch:\nstate_with_proof.state.epoch});\n189 }\n190 uint256 statesLength = state_with_proof.state.states.length;\n191 uint256 idx = 0;\n192 while (idx < statesLength) {\n193 SharedStructs.ContractStateHash calldata proofStateHash =\nstate_with_proof.state_hashes[idx];\n194 SharedStructs.StateWithAddress calldata state =\nstate_with_proof.state.states[idx];\n195 if (localAddress[proofStateHash.contractAddress] == address(0)) {\n196 unchecked {\n197 ++idx;\n198 }\n199 continue;\n200 }\n201 bytes32 stateHash = keccak256(state.state);\n202 if (stateHash != proofStateHash.stateHash) {\n203 unchecked {\n204 ++idx;\n205 }\n206 revert InvalidStateHash(stateHash, proofStateHash.stateHash);\n207 }\n208 if\n(isContract(address(connectors[localAddress[proofStateHash.contractAddress]]))) {\n209 try\nconnectors[localAddress[proofStateHash.contractAddress]].applyState(state.state) {}\ncatch {}\n210 }\n211 unchecked {\n212 ++idx;\n213 }\n214 }\n215 uint256 used = (gasleftbefore - gasleft()) * tx.gasprice;\n216 uint256 payout = used * feeMultiplier / 100;\n217 if (address(this).balance >= payout) {\n218 (bool success,) = payable(msg.sender).call{value: payout}(\"\");\n219 if (!success) {\n220 revert TransferFailed(msg.sender, payout);\n221 }\n222 }\n223 ++appliedEpoch;\n224 }\n```\n\n{18}------------------------------------------------\n\n*Figure 6.1: The applyState function in [BridgeBase.sol#L175-L224](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/lib/BridgeBase.sol#L175-L224)*\n\n#### Exploit Scenario\n\nEve holds 1,000 of an ERC777 token called TokenX in a contract she has deployed (called AttackerContract). Eve bridges these 1,000 TokenX from Ethereum to Taraxa. Eve's 1,000 tokens are now locked inside the configured ERC20LockingConnector on Ethereum. After bridging to Taraxa, she immediately initiates a bridge of 1,000 TokenX from Taraxa back to Ethereum.\n\nShe now monitors the Ethereum chain to spot the first time anyone tries to call the EthBridge.applyState function to bridge messages, which includes her bridging message. Once she spots it, she front-runs the transaction and calls EthBridge.applyState with the same arguments.\n\nThe message handling loop will now call the TokenX.transfer function to transfer the 1,000 tokens to AttackerContract, after which the ERC777 \\_callTokensToReceived hook will call AttackerContract. Inside the called AttackerContract function, a call is made back to EthBridge.applyState with the same arguments as the original call. This will lead to a loop where each time EthBridge.applyState is called, the AttackerContract will receive 1,000 TokenX tokens.\n\nThe only limitations of this attack are gas, the amount of TokenX inside the ERC20LockingConnector, and the failure of other bridging messages due to lack of tokens or multiple executions.\n\n#### Recommendations\n\nShort term, add reentrancy guards to the BridgeBase.applyState function. This will prevent the aforementioned issue.\n\n#### Long term:\n\n- Use [Slither](https://github.com/crytic/slither) to detect this issue, and integrate it into the CI using [slither-action.](https://github.com/crytic/slither-action)\n- Review all non-view functions and consider adding reentrancy guards to each of these functions.\n- Update the implementation to follow the [Checks-Effects-Interactions](https://docs.soliditylang.org/en/latest/security-considerations.html#reentrancy) pattern. This pattern is considered a best practice and structures the code in a manner that helps prevent reentrancy vulnerabilities.\n\n![](_page_18_Picture_12.jpeg)\n\n{19}------------------------------------------------\n"}, "severity": "High", "difficulty": "Medium", "type": "Undefined Behavior", "finding_id": "TOB-TARA-6", "target": {"path": "bridge/src/lib/BridgeBase.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/crytic/slither-action", "org": "crytic", "name": "slither-action", "commit": null, "branch": null, "relative_file": "bridge/src/lib/BridgeBase.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "2024-07-taraxa-bridge-smart-contracts-v2-securityreview.pdf", "source_mtime": "2025-11-01T20:47:29.319395+00:00", "report_extracted_at": "2025-11-19T09:04:32.938539+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T09:04:32.941583+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": "Medium", "Type": "Undefined Behavior", "Finding ID": "TOB-TARA-6", "Target": "bridge/src/lib/BridgeBase.sol", "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview-007", "doc_id": "trailofbits_2024-07-taraxa-bridge-smart-contracts-v2-securityreview", "finding_index": 7, "page_start": 19, "title": "Confusing application of settlementFee to locking native assets", "short_summary": null, "description_md": "#### Description\n\nThe process of deducting the fee from the passed in msg.value is confusing and makes it difficult for callers to transfer a specific amount of native assets.\n\nFigure 7.1 shows the lock function, which deducts the settlementFee from the amount to be bridged. A more user-friendly way of doing this would be to add an argument to the lock function called amount that indicates the exact amount to bridge. In the body of the function, a check is then performed that ensures that the difference between msg.value and amount is exactly the settlementFee.\n\n```\n37 function lock() public payable {\n38 uint256 fee = bridge.settlementFee();\n39 uint256 lockingValue = msg.value;\n40\n41 // Charge the fee only if the user has no balance in current state\n42 if (!state.hasBalance(msg.sender)) {\n43 if (msg.value < fee) {\n44 revert InsufficientFunds(fee, lockingValue);\n45 }\n46 lockingValue -= fee;\n47 }\n48\n49 if (lockingValue == 0) {\n50 revert ZeroValueCall();\n51 }\n52 state.addAmount(msg.sender, lockingValue);\n53 emit Locked(msg.sender, lockingValue);\n54 }\n```\n\n*Figure 7.1: The lock function in [NativeConnectorLogic.sol#L37-L54](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/NativeConnectorLogic.sol#L37-L54)*\n", "full_markdown": "# 7. Confusing application of settlementFee to locking native assets Severity: **Informational** Difficulty: **Low** Type: Arithmetic Finding ID: TOB-TARA-7 Target: bridge/src/lib/BridgeBase.sol\n\n#### Description\n\nThe process of deducting the fee from the passed in msg.value is confusing and makes it difficult for callers to transfer a specific amount of native assets.\n\nFigure 7.1 shows the lock function, which deducts the settlementFee from the amount to be bridged. A more user-friendly way of doing this would be to add an argument to the lock function called amount that indicates the exact amount to bridge. In the body of the function, a check is then performed that ensures that the difference between msg.value and amount is exactly the settlementFee.\n\n```\n37 function lock() public payable {\n38 uint256 fee = bridge.settlementFee();\n39 uint256 lockingValue = msg.value;\n40\n41 // Charge the fee only if the user has no balance in current state\n42 if (!state.hasBalance(msg.sender)) {\n43 if (msg.value < fee) {\n44 revert InsufficientFunds(fee, lockingValue);\n45 }\n46 lockingValue -= fee;\n47 }\n48\n49 if (lockingValue == 0) {\n50 revert ZeroValueCall();\n51 }\n52 state.addAmount(msg.sender, lockingValue);\n53 emit Locked(msg.sender, lockingValue);\n54 }\n```\n\n*Figure 7.1: The lock function in [NativeConnectorLogic.sol#L37-L54](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/NativeConnectorLogic.sol#L37-L54)*\n\n## Recommendations\n\nShort term, replace the existing deduct-fee-from-msg.value with an amount argument in the lock function and a check: require(msg.value - amount == settlementFee).\n\n\nLong term, design functions so that they are simple and easy to use for external parties. This improves the usability and prevents confusion for integrators.\n", "sections": {"description_md": "#### Description\n\nThe process of deducting the fee from the passed in msg.value is confusing and makes it difficult for callers to transfer a specific amount of native assets.\n\nFigure 7.1 shows the lock function, which deducts the settlementFee from the amount to be bridged. A more user-friendly way of doing this would be to add an argument to the lock function called amount that indicates the exact amount to bridge. In the body of the function, a check is then performed that ensures that the difference between msg.value and amount is exactly the settlementFee.\n\n```\n37 function lock() public payable {\n38 uint256 fee = bridge.settlementFee();\n39 uint256 lockingValue = msg.value;\n40\n41 // Charge the fee only if the user has no balance in current state\n42 if (!state.hasBalance(msg.sender)) {\n43 if (msg.value < fee) {\n44 revert InsufficientFunds(fee, lockingValue);\n45 }\n46 lockingValue -= fee;\n47 }\n48\n49 if (lockingValue == 0) {\n50 revert ZeroValueCall();\n51 }\n52 state.addAmount(msg.sender, lockingValue);\n53 emit Locked(msg.sender, lockingValue);\n54 }\n```\n\n*Figure 7.1: The lock function in [NativeConnectorLogic.sol#L37-L54](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/NativeConnectorLogic.sol#L37-L54)*\n", "impact_md": null, "recommendation_md": "## Recommendations\n\nShort term, replace the existing deduct-fee-from-msg.value with an amount argument in the lock function and a check: require(msg.value - amount == settlementFee).\n\n\nLong term, design functions so that they are simple and easy to use for external parties. This improves the usability and prevents confusion for integrators.\n", "poc_md": null, "fix_status_md": null, "other_md": null, "full_markdown_body": "#### Description\n\nThe process of deducting the fee from the passed in msg.value is confusing and makes it difficult for callers to transfer a specific amount of native assets.\n\nFigure 7.1 shows the lock function, which deducts the settlementFee from the amount to be bridged. A more user-friendly way of doing this would be to add an argument to the lock function called amount that indicates the exact amount to bridge. In the body of the function, a check is then performed that ensures that the difference between msg.value and amount is exactly the settlementFee.\n\n```\n37 function lock() public payable {\n38 uint256 fee = bridge.settlementFee();\n39 uint256 lockingValue = msg.value;\n40\n41 // Charge the fee only if the user has no balance in current state\n42 if (!state.hasBalance(msg.sender)) {\n43 if (msg.value < fee) {\n44 revert InsufficientFunds(fee, lockingValue);\n45 }\n46 lockingValue -= fee;\n47 }\n48\n49 if (lockingValue == 0) {\n50 revert ZeroValueCall();\n51 }\n52 state.addAmount(msg.sender, lockingValue);\n53 emit Locked(msg.sender, lockingValue);\n54 }\n```\n\n*Figure 7.1: The lock function in [NativeConnectorLogic.sol#L37-L54](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/NativeConnectorLogic.sol#L37-L54)*\n\n## Recommendations\n\nShort term, replace the existing deduct-fee-from-msg.value with an amount argument in the lock function and a check: require(msg.value - amount == settlementFee).\n\n\nLong term, design functions so that they are simple and easy to use for external parties. This improves the usability and prevents confusion for integrators.\n", "markdown_raw": "# <span id=\"page-19-0\"></span>7. Confusing application of settlementFee to locking native assets Severity: **Informational** Difficulty: **Low** Type: Arithmetic Finding ID: TOB-TARA-7 Target: bridge/src/lib/BridgeBase.sol\n\n#### Description\n\nThe process of deducting the fee from the passed in msg.value is confusing and makes it difficult for callers to transfer a specific amount of native assets.\n\nFigure 7.1 shows the lock function, which deducts the settlementFee from the amount to be bridged. A more user-friendly way of doing this would be to add an argument to the lock function called amount that indicates the exact amount to bridge. In the body of the function, a check is then performed that ensures that the difference between msg.value and amount is exactly the settlementFee.\n\n```\n37 function lock() public payable {\n38 uint256 fee = bridge.settlementFee();\n39 uint256 lockingValue = msg.value;\n40\n41 // Charge the fee only if the user has no balance in current state\n42 if (!state.hasBalance(msg.sender)) {\n43 if (msg.value < fee) {\n44 revert InsufficientFunds(fee, lockingValue);\n45 }\n46 lockingValue -= fee;\n47 }\n48\n49 if (lockingValue == 0) {\n50 revert ZeroValueCall();\n51 }\n52 state.addAmount(msg.sender, lockingValue);\n53 emit Locked(msg.sender, lockingValue);\n54 }\n```\n\n*Figure 7.1: The lock function in [NativeConnectorLogic.sol#L37-L54](https://github.com/Taraxa-project/bridge/blob/f82dd87c7e23358c74f7dc37451ca61110b60942/src/connectors/NativeConnectorLogic.sol#L37-L54)*\n\n## Recommendations\n\nShort term, replace the existing deduct-fee-from-msg.value with an amount argument in the lock function and a check: require(msg.value - amount == settlementFee).\n\n{20}------------------------------------------------\n\nLong term, design functions so that they are simple and easy to use for external parties. This improves the usability and prevents confusion for integrators.\n\n{21}------------------------------------------------\n"}, "severity": "Informational", "difficulty": "Low", "type": "Arithmetic", "finding_id": "TOB-TARA-7", "target": {"path": "bridge/src/lib/BridgeBase.sol", "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/crytic/slither-action", "org": "crytic", "name": "slither-action", "commit": null, "branch": null, "relative_file": "bridge/src/lib/BridgeBase.sol", "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "2024-07-taraxa-bridge-smart-contracts-v2-securityreview.pdf", "source_mtime": "2025-11-01T20:47:29.319395+00:00", "report_extracted_at": "2025-11-19T09:04:32.938539+00:00", "report_extractor_version": "poc-0.4", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T09:04:32.941583+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Informational", "Difficulty": "Low", "Type": "Arithmetic", "Finding ID": "TOB-TARA-7", "Target": "bridge/src/lib/BridgeBase.sol", "Severity_normalized": "Informational"}}
