{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-002", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 2, "page_start": null, "title": "`CDPVault.sol#liquidatePositionBadDebt()` does correctly handle profit and loss", "short_summary": null, "description_md": "## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/57 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThere are two issues that needs to be fixed in the new codebase:\n\n1. The `profit` that is passed in `pool.repayCreditAccount(debtData.debt, profit, loss);` should actually use `debtData.accruedInterest`. This is because we should first \"assume\" full debt and interest is paid off, and calculate the loss part independently.\n\n2. The `loss` is correctly calculated in PoolV3#repayCreditAccount, the if-else branch is incorrectly implemented. Currently it can't handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.\n\nNote that the second fix was also suggested in the original issue, but it isn't applied.\n\nCDPVault.sol\n```solidity\n        takeCollateral = position.collateral;\n        repayAmount = wmul(takeCollateral, discountedPrice);\n        uint256 loss = calcTotalDebt(debtData) - repayAmount;\n        uint256 profit;\n        if (repayAmount > debtData.debt) {\n@>          profit = repayAmount - debtData.debt;\n        }\n        ...\n@>      pool.repayCreditAccount(debtData.debt, profit, loss); // U:[CM-11]\n        // transfer the collateral amount from the vault to the liquidator\n        token.safeTransfer(msg.sender, takeCollateral);\n```\n\nPoolV3.sol\n```solidity\n    function repayCreditAccount(\n        uint256 repaidAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        creditManagerOnly // U:[LP-2C]\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n    {\n        ...\n        if (profit > 0) {\n            _mint(treasury, _convertToShares(profit)); // U:[LP-14B]\n@>      } else if (loss > 0) {\n            address treasury_ = treasury;\n            uint256 sharesInTreasury = balanceOf(treasury_);\n            uint256 sharesToBurn = _convertToShares(loss);\n            if (sharesToBurn > sharesInTreasury) {\n                unchecked {\n                    emit IncurUncoveredLoss({\n                        creditManager: msg.sender,\n                        loss: _convertToAssets(sharesToBurn - sharesInTreasury)\n                    }); // U:[LP-14D]\n                }\n                sharesToBurn = sharesInTreasury;\n            }\n            _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n        }\n        ...\n    }\n```\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/PoolV3.sol#L593\n\n\n# Vulnerability details\n\n\n## Impact\n\nWhen liquidating bad debt, the profit and loss is not correctly handled. This will cause incorrect accounting to lpETH stakers.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/57 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThere are two issues that needs to be fixed in the new codebase:\n\n1. The `profit` that is passed in `pool.repayCreditAccount(debtData.debt, profit, loss);` should actually use `debtData.accruedInterest`. This is because we should first \"assume\" full debt and interest is paid off, and calculate the loss part independently.\n\n2. The `loss` is correctly calculated in PoolV3#repayCreditAccount, the if-else branch is incorrectly implemented. Currently it can't handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.\n\nNote that the second fix was also suggested in the original issue, but it isn't applied.\n\nCDPVault.sol\n```solidity\n        takeCollateral = position.collateral;\n        repayAmount = wmul(takeCollateral, discountedPrice);\n        uint256 loss = calcTotalDebt(debtData) - repayAmount;\n        uint256 profit;\n        if (repayAmount > debtData.debt) {\n@>          profit = repayAmount - debtData.debt;\n        }\n        ...\n@>      pool.repayCreditAccount(debtData.debt, profit, loss); // U:[CM-11]\n        // transfer the collateral amount from the vault to the liquidator\n        token.safeTransfer(msg.sender, takeCollateral);\n```\n\nPoolV3.sol\n```solidity\n    function repayCreditAccount(\n        uint256 repaidAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        creditManagerOnly // U:[LP-2C]\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n    {\n        ...\n        if (profit > 0) {\n            _mint(treasury, _convertToShares(profit)); // U:[LP-14B]\n@>      } else if (loss > 0) {\n            address treasury_ = treasury;\n            uint256 sharesInTreasury = balanceOf(treasury_);\n            uint256 sharesToBurn = _convertToShares(loss);\n            if (sharesToBurn > sharesInTreasury) {\n                unchecked {\n                    emit IncurUncoveredLoss({\n                        creditManager: msg.sender,\n                        loss: _convertToAssets(sharesToBurn - sharesInTreasury)\n                    }); // U:[LP-14D]\n                }\n                sharesToBurn = sharesInTreasury;\n            }\n            _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n        }\n        ...\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nIn CDPVault: Change to `pool.repayCreditAccount(debtData.debt, debtData.accruedInterest, loss)`.\n\nIn PoolV3:\n\n```solidity\n        if (profit > 0) {\n            _mint(treasury, convertToShares(profit)); // U:[LP-14B]\n+       }\n+       if (loss > 0)\n-       } else if (loss > 0) {\n            ...\n        }\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": "## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/57 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThere are two issues that needs to be fixed in the new codebase:\n\n1. The `profit` that is passed in `pool.repayCreditAccount(debtData.debt, profit, loss);` should actually use `debtData.accruedInterest`. This is because we should first \"assume\" full debt and interest is paid off, and calculate the loss part independently.\n\n2. The `loss` is correctly calculated in PoolV3#repayCreditAccount, the if-else branch is incorrectly implemented. Currently it can't handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.\n\nNote that the second fix was also suggested in the original issue, but it isn't applied.\n\nCDPVault.sol\n```solidity\n        takeCollateral = position.collateral;\n        repayAmount = wmul(takeCollateral, discountedPrice);\n        uint256 loss = calcTotalDebt(debtData) - repayAmount;\n        uint256 profit;\n        if (repayAmount > debtData.debt) {\n@>          profit = repayAmount - debtData.debt;\n        }\n        ...\n@>      pool.repayCreditAccount(debtData.debt, profit, loss); // U:[CM-11]\n        // transfer the collateral amount from the vault to the liquidator\n        token.safeTransfer(msg.sender, takeCollateral);\n```\n\nPoolV3.sol\n```solidity\n    function repayCreditAccount(\n        uint256 repaidAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        creditManagerOnly // U:[LP-2C]\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n    {\n        ...\n        if (profit > 0) {\n            _mint(treasury, _convertToShares(profit)); // U:[LP-14B]\n@>      } else if (loss > 0) {\n            address treasury_ = treasury;\n            uint256 sharesInTreasury = balanceOf(treasury_);\n            uint256 sharesToBurn = _convertToShares(loss);\n            if (sharesToBurn > sharesInTreasury) {\n                unchecked {\n                    emit IncurUncoveredLoss({\n                        creditManager: msg.sender,\n                        loss: _convertToAssets(sharesToBurn - sharesInTreasury)\n                    }); // U:[LP-14D]\n                }\n                sharesToBurn = sharesInTreasury;\n            }\n            _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n        }\n        ...\n    }\n```\n", "impact_md": "## Impact\n\nWhen liquidating bad debt, the profit and loss is not correctly handled. This will cause incorrect accounting to lpETH stakers.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nIn CDPVault: Change to `pool.repayCreditAccount(debtData.debt, debtData.accruedInterest, loss)`.\n\nIn PoolV3:\n\n```solidity\n        if (profit > 0) {\n            _mint(treasury, convertToShares(profit)); // U:[LP-14B]\n+       }\n+       if (loss > 0)\n-       } else if (loss > 0) {\n            ...\n        }\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\nN/A\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/PoolV3.sol#L593\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/PoolV3.sol#L593\n\n\n# Vulnerability details\n\n\n## Impact\n\nWhen liquidating bad debt, the profit and loss is not correctly handled. This will cause incorrect accounting to lpETH stakers.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/57 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThere are two issues that needs to be fixed in the new codebase:\n\n1. The `profit` that is passed in `pool.repayCreditAccount(debtData.debt, profit, loss);` should actually use `debtData.accruedInterest`. This is because we should first \"assume\" full debt and interest is paid off, and calculate the loss part independently.\n\n2. The `loss` is correctly calculated in PoolV3#repayCreditAccount, the if-else branch is incorrectly implemented. Currently it can't handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.\n\nNote that the second fix was also suggested in the original issue, but it isn't applied.\n\nCDPVault.sol\n```solidity\n        takeCollateral = position.collateral;\n        repayAmount = wmul(takeCollateral, discountedPrice);\n        uint256 loss = calcTotalDebt(debtData) - repayAmount;\n        uint256 profit;\n        if (repayAmount > debtData.debt) {\n@>          profit = repayAmount - debtData.debt;\n        }\n        ...\n@>      pool.repayCreditAccount(debtData.debt, profit, loss); // U:[CM-11]\n        // transfer the collateral amount from the vault to the liquidator\n        token.safeTransfer(msg.sender, takeCollateral);\n```\n\nPoolV3.sol\n```solidity\n    function repayCreditAccount(\n        uint256 repaidAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        creditManagerOnly // U:[LP-2C]\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n    {\n        ...\n        if (profit > 0) {\n            _mint(treasury, _convertToShares(profit)); // U:[LP-14B]\n@>      } else if (loss > 0) {\n            address treasury_ = treasury;\n            uint256 sharesInTreasury = balanceOf(treasury_);\n            uint256 sharesToBurn = _convertToShares(loss);\n            if (sharesToBurn > sharesInTreasury) {\n                unchecked {\n                    emit IncurUncoveredLoss({\n                        creditManager: msg.sender,\n                        loss: _convertToAssets(sharesToBurn - sharesInTreasury)\n                    }); // U:[LP-14D]\n                }\n                sharesToBurn = sharesInTreasury;\n            }\n            _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n        }\n        ...\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nIn CDPVault: Change to `pool.repayCreditAccount(debtData.debt, debtData.accruedInterest, loss)`.\n\nIn PoolV3:\n\n```solidity\n        if (profit > 0) {\n            _mint(treasury, convertToShares(profit)); // U:[LP-14B]\n+       }\n+       if (loss > 0)\n-       } else if (loss > 0) {\n            ...\n        }\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/PoolV3.sol#L593\n\n\n# Vulnerability details\n\n\n## Impact\n\nWhen liquidating bad debt, the profit and loss is not correctly handled. This will cause incorrect accounting to lpETH stakers.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/57 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThere are two issues that needs to be fixed in the new codebase:\n\n1. The `profit` that is passed in `pool.repayCreditAccount(debtData.debt, profit, loss);` should actually use `debtData.accruedInterest`. This is because we should first \"assume\" full debt and interest is paid off, and calculate the loss part independently.\n\n2. The `loss` is correctly calculated in PoolV3#repayCreditAccount, the if-else branch is incorrectly implemented. Currently it can't handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.\n\nNote that the second fix was also suggested in the original issue, but it isn't applied.\n\nCDPVault.sol\n```solidity\n        takeCollateral = position.collateral;\n        repayAmount = wmul(takeCollateral, discountedPrice);\n        uint256 loss = calcTotalDebt(debtData) - repayAmount;\n        uint256 profit;\n        if (repayAmount > debtData.debt) {\n@>          profit = repayAmount - debtData.debt;\n        }\n        ...\n@>      pool.repayCreditAccount(debtData.debt, profit, loss); // U:[CM-11]\n        // transfer the collateral amount from the vault to the liquidator\n        token.safeTransfer(msg.sender, takeCollateral);\n```\n\nPoolV3.sol\n```solidity\n    function repayCreditAccount(\n        uint256 repaidAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        creditManagerOnly // U:[LP-2C]\n        whenNotPaused // U:[LP-2A]\n        nonReentrant // U:[LP-2B]\n    {\n        ...\n        if (profit > 0) {\n            _mint(treasury, _convertToShares(profit)); // U:[LP-14B]\n@>      } else if (loss > 0) {\n            address treasury_ = treasury;\n            uint256 sharesInTreasury = balanceOf(treasury_);\n            uint256 sharesToBurn = _convertToShares(loss);\n            if (sharesToBurn > sharesInTreasury) {\n                unchecked {\n                    emit IncurUncoveredLoss({\n                        creditManager: msg.sender,\n                        loss: _convertToAssets(sharesToBurn - sharesInTreasury)\n                    }); // U:[LP-14D]\n                }\n                sharesToBurn = sharesInTreasury;\n            }\n            _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]\n        }\n        ...\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nIn CDPVault: Change to `pool.repayCreditAccount(debtData.debt, debtData.accruedInterest, loss)`.\n\nIn PoolV3:\n\n```solidity\n        if (profit > 0) {\n            _mint(treasury, convertToShares(profit)); // U:[LP-14B]\n+       }\n+       if (loss > 0)\n-       } else if (loss > 0) {\n            ...\n        }\n```\n\n\n## Assessed type\n\nOther"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-003", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 3, "page_start": null, "title": "`PositionAction.sol#onCreditFlashLoan` may end up with stuck funds for EXACT_IN primary swaps.", "short_summary": null, "description_md": "## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nWhen conducting a decreaseLever action, the final swap inside `onCreditFlashLoan()` is from collateral token to debt token. If the swap is EXACT_IN type, this means all collateral token is used for the swap. The output tokens are then split to two parts:\n\n1. Repay the flashloan (and fees)\n2. Send back to CDPVault to repay debt\n\nHowever, the second part have some issues. Mainly because if the repaid amount is larger than debt amount, the repayed amount will be capped to the debt amount (See CDPVault.sol code below). This means there may be some debt tokens ending up dangling in the PositionAction.sol contract, which the user does not have access to.\n\nTo explain a bit more, this is a reasonable scenario, because the amount of collateral tokens used for swap comes from `uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);`, and for PositionAction4626, `_onDecreaseLever()` supports gathering collateral tokens by exiting from pools (e.g. Balancer). This means it is totally possible that the amount of collateral tokens used for swap values more than the user's debt in CDPVault.\n\nPositionAction.sol\n```solidity\n    function onCreditFlashLoan(\n        address /*initiator*/,\n        uint256 /*amount*/,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        if (msg.sender != address(flashlender)) revert PositionAction__onCreditFlashLoan__invalidSender();\n        (LeverParams memory leverParams, uint256 subCollateral, address residualRecipient) = abi.decode(\n            data,\n            (LeverParams, uint256, address)\n        );\n\n        uint256 subDebt = leverParams.primarySwap.amount;\n        underlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\n        // sub collateral and debt\n        ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n            leverParams.position,\n            address(this),\n            address(this),\n            0,\n            -toInt256(subDebt)\n        );\n\n        // withdraw collateral and handle any CDP specific actions\n@>      uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);\n\n        if (leverParams.primarySwap.swapType == SwapType.EXACT_IN) {\n            leverParams.primarySwap.amount = withdrawnCollateral;\n\n            bytes memory swapData = _delegateCall(\n                address(swapAction),\n                abi.encodeWithSelector(swapAction.swap.selector, leverParams.primarySwap)\n            );\n\n            uint256 swapAmountOut = abi.decode(swapData, (uint256));\n            uint256 residualAmount = swapAmountOut - subDebt;\n\n            // sub collateral and debt\n@>          if (residualAmount > 0) {\n                underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n                ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n                    leverParams.position,\n                    address(this),\n                    address(this),\n                    0,\n                    -toInt256(residualAmount)\n                );\n            }\n        }\n        ...\n    }\n```\n\nPositionAction4626.sol\n```solidity\n    function _onDecreaseLever(\n        LeverParams memory leverParams,\n        uint256 subCollateral\n    ) internal override returns (uint256 tokenOut) {\n        // withdraw collateral from vault\n        uint256 withdrawnCollateral = ICDPVault(leverParams.vault).withdraw(leverParams.position, subCollateral);\n\n        // withdraw collateral from the ERC4626 vault and return underlying assets\n        tokenOut = IERC4626(leverParams.collateralToken).redeem(withdrawnCollateral, address(this), address(this));\n\n        if (leverParams.auxAction.args.length != 0) {\n            _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, leverParams.auxAction)\n            );\n\n            tokenOut = IERC20(IERC4626(leverParams.collateralToken).asset()).balanceOf(address(this));\n        }\n    }\n```\n\nCDPVault.sol\n```solidity\n    function modifyCollateralAndDebt(\n        address owner,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaDebt\n    ) public {\n        ...\n        if (deltaDebt > 0) {\n            ...\n        } else if (deltaDebt < 0) {\n            uint256 debtToDecrease = abs(deltaDebt);\n\n            uint256 maxRepayment = calcTotalDebt(debtData);\n@>          if (debtToDecrease >= maxRepayment) {\n                debtToDecrease = maxRepayment;\n                deltaDebt = -toInt256(debtToDecrease);\n            }\n\n            uint256 scaledDebtDecrease = wmul(debtToDecrease, poolUnderlyingScale);\n            poolUnderlying.safeTransferFrom(creditor, address(pool), scaledDebtDecrease);\n        }\n    }\n```\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L491-L500\n\n\n# Vulnerability details\n\n\n## Impact\n\n`PositionAction.sol#onCreditFlashLoan` may end up with stuck funds for EXACT_IN primary swaps. User may lose these funds.\n\n## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nWhen conducting a decreaseLever action, the final swap inside `onCreditFlashLoan()` is from collateral token to debt token. If the swap is EXACT_IN type, this means all collateral token is used for the swap. The output tokens are then split to two parts:\n\n1. Repay the flashloan (and fees)\n2. Send back to CDPVault to repay debt\n\nHowever, the second part have some issues. Mainly because if the repaid amount is larger than debt amount, the repayed amount will be capped to the debt amount (See CDPVault.sol code below). This means there may be some debt tokens ending up dangling in the PositionAction.sol contract, which the user does not have access to.\n\nTo explain a bit more, this is a reasonable scenario, because the amount of collateral tokens used for swap comes from `uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);`, and for PositionAction4626, `_onDecreaseLever()` supports gathering collateral tokens by exiting from pools (e.g. Balancer). This means it is totally possible that the amount of collateral tokens used for swap values more than the user's debt in CDPVault.\n\nPositionAction.sol\n```solidity\n    function onCreditFlashLoan(\n        address /*initiator*/,\n        uint256 /*amount*/,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        if (msg.sender != address(flashlender)) revert PositionAction__onCreditFlashLoan__invalidSender();\n        (LeverParams memory leverParams, uint256 subCollateral, address residualRecipient) = abi.decode(\n            data,\n            (LeverParams, uint256, address)\n        );\n\n        uint256 subDebt = leverParams.primarySwap.amount;\n        underlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\n        // sub collateral and debt\n        ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n            leverParams.position,\n            address(this),\n            address(this),\n            0,\n            -toInt256(subDebt)\n        );\n\n        // withdraw collateral and handle any CDP specific actions\n@>      uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);\n\n        if (leverParams.primarySwap.swapType == SwapType.EXACT_IN) {\n            leverParams.primarySwap.amount = withdrawnCollateral;\n\n            bytes memory swapData = _delegateCall(\n                address(swapAction),\n                abi.encodeWithSelector(swapAction.swap.selector, leverParams.primarySwap)\n            );\n\n            uint256 swapAmountOut = abi.decode(swapData, (uint256));\n            uint256 residualAmount = swapAmountOut - subDebt;\n\n            // sub collateral and debt\n@>          if (residualAmount > 0) {\n                underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n                ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n                    leverParams.position,\n                    address(this),\n                    address(this),\n                    0,\n                    -toInt256(residualAmount)\n                );\n            }\n        }\n        ...\n    }\n```\n\nPositionAction4626.sol\n```solidity\n    function _onDecreaseLever(\n        LeverParams memory leverParams,\n        uint256 subCollateral\n    ) internal override returns (uint256 tokenOut) {\n        // withdraw collateral from vault\n        uint256 withdrawnCollateral = ICDPVault(leverParams.vault).withdraw(leverParams.position, subCollateral);\n\n        // withdraw collateral from the ERC4626 vault and return underlying assets\n        tokenOut = IERC4626(leverParams.collateralToken).redeem(withdrawnCollateral, address(this), address(this));\n\n        if (leverParams.auxAction.args.length != 0) {\n            _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, leverParams.auxAction)\n            );\n\n            tokenOut = IERC20(IERC4626(leverParams.collateralToken).asset()).balanceOf(address(this));\n        }\n    }\n```\n\nCDPVault.sol\n```solidity\n    function modifyCollateralAndDebt(\n        address owner,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaDebt\n    ) public {\n        ...\n        if (deltaDebt > 0) {\n            ...\n        } else if (deltaDebt < 0) {\n            uint256 debtToDecrease = abs(deltaDebt);\n\n            uint256 maxRepayment = calcTotalDebt(debtData);\n@>          if (debtToDecrease >= maxRepayment) {\n                debtToDecrease = maxRepayment;\n                deltaDebt = -toInt256(debtToDecrease);\n            }\n\n            uint256 scaledDebtDecrease = wmul(debtToDecrease, poolUnderlyingScale);\n            poolUnderlying.safeTransferFrom(creditor, address(pool), scaledDebtDecrease);\n        }\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nSend the residual tokens back to `residualRecipient` instead of trying to repay debt.\n\n\n## Assessed type\n\nToken-Transfer\n", "sections": {"description_md": "## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nWhen conducting a decreaseLever action, the final swap inside `onCreditFlashLoan()` is from collateral token to debt token. If the swap is EXACT_IN type, this means all collateral token is used for the swap. The output tokens are then split to two parts:\n\n1. Repay the flashloan (and fees)\n2. Send back to CDPVault to repay debt\n\nHowever, the second part have some issues. Mainly because if the repaid amount is larger than debt amount, the repayed amount will be capped to the debt amount (See CDPVault.sol code below). This means there may be some debt tokens ending up dangling in the PositionAction.sol contract, which the user does not have access to.\n\nTo explain a bit more, this is a reasonable scenario, because the amount of collateral tokens used for swap comes from `uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);`, and for PositionAction4626, `_onDecreaseLever()` supports gathering collateral tokens by exiting from pools (e.g. Balancer). This means it is totally possible that the amount of collateral tokens used for swap values more than the user's debt in CDPVault.\n\nPositionAction.sol\n```solidity\n    function onCreditFlashLoan(\n        address /*initiator*/,\n        uint256 /*amount*/,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        if (msg.sender != address(flashlender)) revert PositionAction__onCreditFlashLoan__invalidSender();\n        (LeverParams memory leverParams, uint256 subCollateral, address residualRecipient) = abi.decode(\n            data,\n            (LeverParams, uint256, address)\n        );\n\n        uint256 subDebt = leverParams.primarySwap.amount;\n        underlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\n        // sub collateral and debt\n        ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n            leverParams.position,\n            address(this),\n            address(this),\n            0,\n            -toInt256(subDebt)\n        );\n\n        // withdraw collateral and handle any CDP specific actions\n@>      uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);\n\n        if (leverParams.primarySwap.swapType == SwapType.EXACT_IN) {\n            leverParams.primarySwap.amount = withdrawnCollateral;\n\n            bytes memory swapData = _delegateCall(\n                address(swapAction),\n                abi.encodeWithSelector(swapAction.swap.selector, leverParams.primarySwap)\n            );\n\n            uint256 swapAmountOut = abi.decode(swapData, (uint256));\n            uint256 residualAmount = swapAmountOut - subDebt;\n\n            // sub collateral and debt\n@>          if (residualAmount > 0) {\n                underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n                ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n                    leverParams.position,\n                    address(this),\n                    address(this),\n                    0,\n                    -toInt256(residualAmount)\n                );\n            }\n        }\n        ...\n    }\n```\n\nPositionAction4626.sol\n```solidity\n    function _onDecreaseLever(\n        LeverParams memory leverParams,\n        uint256 subCollateral\n    ) internal override returns (uint256 tokenOut) {\n        // withdraw collateral from vault\n        uint256 withdrawnCollateral = ICDPVault(leverParams.vault).withdraw(leverParams.position, subCollateral);\n\n        // withdraw collateral from the ERC4626 vault and return underlying assets\n        tokenOut = IERC4626(leverParams.collateralToken).redeem(withdrawnCollateral, address(this), address(this));\n\n        if (leverParams.auxAction.args.length != 0) {\n            _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, leverParams.auxAction)\n            );\n\n            tokenOut = IERC20(IERC4626(leverParams.collateralToken).asset()).balanceOf(address(this));\n        }\n    }\n```\n\nCDPVault.sol\n```solidity\n    function modifyCollateralAndDebt(\n        address owner,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaDebt\n    ) public {\n        ...\n        if (deltaDebt > 0) {\n            ...\n        } else if (deltaDebt < 0) {\n            uint256 debtToDecrease = abs(deltaDebt);\n\n            uint256 maxRepayment = calcTotalDebt(debtData);\n@>          if (debtToDecrease >= maxRepayment) {\n                debtToDecrease = maxRepayment;\n                deltaDebt = -toInt256(debtToDecrease);\n            }\n\n            uint256 scaledDebtDecrease = wmul(debtToDecrease, poolUnderlyingScale);\n            poolUnderlying.safeTransferFrom(creditor, address(pool), scaledDebtDecrease);\n        }\n    }\n```\n", "impact_md": "## Impact\n\n`PositionAction.sol#onCreditFlashLoan` may end up with stuck funds for EXACT_IN primary swaps. User may lose these funds.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nSend the residual tokens back to `residualRecipient` instead of trying to repay debt.\n\n\n## Assessed type\n\nToken-Transfer\n", "poc_md": "## Proof of Concept\n\nN/A\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L491-L500\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L491-L500\n\n\n# Vulnerability details\n\n\n## Impact\n\n`PositionAction.sol#onCreditFlashLoan` may end up with stuck funds for EXACT_IN primary swaps. User may lose these funds.\n\n## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nWhen conducting a decreaseLever action, the final swap inside `onCreditFlashLoan()` is from collateral token to debt token. If the swap is EXACT_IN type, this means all collateral token is used for the swap. The output tokens are then split to two parts:\n\n1. Repay the flashloan (and fees)\n2. Send back to CDPVault to repay debt\n\nHowever, the second part have some issues. Mainly because if the repaid amount is larger than debt amount, the repayed amount will be capped to the debt amount (See CDPVault.sol code below). This means there may be some debt tokens ending up dangling in the PositionAction.sol contract, which the user does not have access to.\n\nTo explain a bit more, this is a reasonable scenario, because the amount of collateral tokens used for swap comes from `uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);`, and for PositionAction4626, `_onDecreaseLever()` supports gathering collateral tokens by exiting from pools (e.g. Balancer). This means it is totally possible that the amount of collateral tokens used for swap values more than the user's debt in CDPVault.\n\nPositionAction.sol\n```solidity\n    function onCreditFlashLoan(\n        address /*initiator*/,\n        uint256 /*amount*/,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        if (msg.sender != address(flashlender)) revert PositionAction__onCreditFlashLoan__invalidSender();\n        (LeverParams memory leverParams, uint256 subCollateral, address residualRecipient) = abi.decode(\n            data,\n            (LeverParams, uint256, address)\n        );\n\n        uint256 subDebt = leverParams.primarySwap.amount;\n        underlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\n        // sub collateral and debt\n        ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n            leverParams.position,\n            address(this),\n            address(this),\n            0,\n            -toInt256(subDebt)\n        );\n\n        // withdraw collateral and handle any CDP specific actions\n@>      uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);\n\n        if (leverParams.primarySwap.swapType == SwapType.EXACT_IN) {\n            leverParams.primarySwap.amount = withdrawnCollateral;\n\n            bytes memory swapData = _delegateCall(\n                address(swapAction),\n                abi.encodeWithSelector(swapAction.swap.selector, leverParams.primarySwap)\n            );\n\n            uint256 swapAmountOut = abi.decode(swapData, (uint256));\n            uint256 residualAmount = swapAmountOut - subDebt;\n\n            // sub collateral and debt\n@>          if (residualAmount > 0) {\n                underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n                ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n                    leverParams.position,\n                    address(this),\n                    address(this),\n                    0,\n                    -toInt256(residualAmount)\n                );\n            }\n        }\n        ...\n    }\n```\n\nPositionAction4626.sol\n```solidity\n    function _onDecreaseLever(\n        LeverParams memory leverParams,\n        uint256 subCollateral\n    ) internal override returns (uint256 tokenOut) {\n        // withdraw collateral from vault\n        uint256 withdrawnCollateral = ICDPVault(leverParams.vault).withdraw(leverParams.position, subCollateral);\n\n        // withdraw collateral from the ERC4626 vault and return underlying assets\n        tokenOut = IERC4626(leverParams.collateralToken).redeem(withdrawnCollateral, address(this), address(this));\n\n        if (leverParams.auxAction.args.length != 0) {\n            _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, leverParams.auxAction)\n            );\n\n            tokenOut = IERC20(IERC4626(leverParams.collateralToken).asset()).balanceOf(address(this));\n        }\n    }\n```\n\nCDPVault.sol\n```solidity\n    function modifyCollateralAndDebt(\n        address owner,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaDebt\n    ) public {\n        ...\n        if (deltaDebt > 0) {\n            ...\n        } else if (deltaDebt < 0) {\n            uint256 debtToDecrease = abs(deltaDebt);\n\n            uint256 maxRepayment = calcTotalDebt(debtData);\n@>          if (debtToDecrease >= maxRepayment) {\n                debtToDecrease = maxRepayment;\n                deltaDebt = -toInt256(debtToDecrease);\n            }\n\n            uint256 scaledDebtDecrease = wmul(debtToDecrease, poolUnderlyingScale);\n            poolUnderlying.safeTransferFrom(creditor, address(pool), scaledDebtDecrease);\n        }\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nSend the residual tokens back to `residualRecipient` instead of trying to repay debt.\n\n\n## Assessed type\n\nToken-Transfer\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L491-L500\n\n\n# Vulnerability details\n\n\n## Impact\n\n`PositionAction.sol#onCreditFlashLoan` may end up with stuck funds for EXACT_IN primary swaps. User may lose these funds.\n\n## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nWhen conducting a decreaseLever action, the final swap inside `onCreditFlashLoan()` is from collateral token to debt token. If the swap is EXACT_IN type, this means all collateral token is used for the swap. The output tokens are then split to two parts:\n\n1. Repay the flashloan (and fees)\n2. Send back to CDPVault to repay debt\n\nHowever, the second part have some issues. Mainly because if the repaid amount is larger than debt amount, the repayed amount will be capped to the debt amount (See CDPVault.sol code below). This means there may be some debt tokens ending up dangling in the PositionAction.sol contract, which the user does not have access to.\n\nTo explain a bit more, this is a reasonable scenario, because the amount of collateral tokens used for swap comes from `uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);`, and for PositionAction4626, `_onDecreaseLever()` supports gathering collateral tokens by exiting from pools (e.g. Balancer). This means it is totally possible that the amount of collateral tokens used for swap values more than the user's debt in CDPVault.\n\nPositionAction.sol\n```solidity\n    function onCreditFlashLoan(\n        address /*initiator*/,\n        uint256 /*amount*/,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32) {\n        if (msg.sender != address(flashlender)) revert PositionAction__onCreditFlashLoan__invalidSender();\n        (LeverParams memory leverParams, uint256 subCollateral, address residualRecipient) = abi.decode(\n            data,\n            (LeverParams, uint256, address)\n        );\n\n        uint256 subDebt = leverParams.primarySwap.amount;\n        underlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\n        // sub collateral and debt\n        ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n            leverParams.position,\n            address(this),\n            address(this),\n            0,\n            -toInt256(subDebt)\n        );\n        \n        // withdraw collateral and handle any CDP specific actions\n@>      uint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);\n\n        if (leverParams.primarySwap.swapType == SwapType.EXACT_IN) {\n            leverParams.primarySwap.amount = withdrawnCollateral;\n\n            bytes memory swapData = _delegateCall(\n                address(swapAction),\n                abi.encodeWithSelector(swapAction.swap.selector, leverParams.primarySwap)\n            );\n\n            uint256 swapAmountOut = abi.decode(swapData, (uint256));\n            uint256 residualAmount = swapAmountOut - subDebt;\n\n            // sub collateral and debt\n@>          if (residualAmount > 0) {\n                underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n                ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n                    leverParams.position,\n                    address(this),\n                    address(this),\n                    0,\n                    -toInt256(residualAmount)\n                );\n            }\n        }\n        ...\n    }\n```\n\nPositionAction4626.sol\n```solidity\n    function _onDecreaseLever(\n        LeverParams memory leverParams,\n        uint256 subCollateral\n    ) internal override returns (uint256 tokenOut) {\n        // withdraw collateral from vault\n        uint256 withdrawnCollateral = ICDPVault(leverParams.vault).withdraw(leverParams.position, subCollateral);\n\n        // withdraw collateral from the ERC4626 vault and return underlying assets\n        tokenOut = IERC4626(leverParams.collateralToken).redeem(withdrawnCollateral, address(this), address(this));\n\n        if (leverParams.auxAction.args.length != 0) {\n            _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, leverParams.auxAction)\n            );\n\n            tokenOut = IERC20(IERC4626(leverParams.collateralToken).asset()).balanceOf(address(this));\n        }\n    }\n```\n\nCDPVault.sol\n```solidity\n    function modifyCollateralAndDebt(\n        address owner,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaDebt\n    ) public {\n        ...\n        if (deltaDebt > 0) {\n            ...\n        } else if (deltaDebt < 0) {\n            uint256 debtToDecrease = abs(deltaDebt);\n\n            uint256 maxRepayment = calcTotalDebt(debtData);\n@>          if (debtToDecrease >= maxRepayment) {\n                debtToDecrease = maxRepayment;\n                deltaDebt = -toInt256(debtToDecrease);\n            }\n\n            uint256 scaledDebtDecrease = wmul(debtToDecrease, poolUnderlyingScale);\n            poolUnderlying.safeTransferFrom(creditor, address(pool), scaledDebtDecrease);\n        }\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nSend the residual tokens back to `residualRecipient` instead of trying to repay debt.\n\n\n## Assessed type\n\nToken-Transfer"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-010", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 10, "page_start": null, "title": "`PositionActionPendle.sol#_onWithdraw` does not have slippage parameter minOut set.", "short_summary": null, "description_md": "## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nThe dataflow for withdrawing on `PositionActionPendle` is: 1) User withdraws collateral (which is a Pendle token) from CDPVault, 2) User performs pendle pool exit.\n\nThe issue is in step 2, since `minOut` is set to 0, users may receive less output tokens than expected.\n\n```solidity\n    function _onWithdraw(\n        address vault,\n        address position,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(position), amount);\n        address collateralToken = address(ICDPVault(vault).token());\n\n        if (dst != collateralToken && dst != address(0)) {\n            PoolActionParams memory poolActionParams = PoolActionParams({\n                protocol: Protocol.PENDLE,\n@>              minOut: 0, // @audit-bug: No slippage.\n                recipient: address(this),\n                args: abi.encode(\n                    collateralToken,\n                    collateralWithdrawn,\n                    dst\n                )\n            });\n\n            bytes memory exitData = _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, poolActionParams)\n            );\n\n            collateralWithdrawn = abi.decode(exitData, (uint256));\n        }\n        return collateralWithdrawn;\n    }\n```\n\nAlso note that this is similar to the 2024-07 Loopfi contest finding https://github.com/code-423n4/2024-07-loopfi-findings/issues/38, which also talks about slippage in ERC4626. However, this Pendle withdraw exit pool code is new, and not existant in the last contest. Thus this should be considered a new bug.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionActionPendle.sol#L67\n\n\n# Vulnerability details\n\n\n## Impact\n\nWhen performing withdraws on `PositionActionPendle` and exiting Pendle pools, users may lose funds due to not setting slippage.\n\n## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nThe dataflow for withdrawing on `PositionActionPendle` is: 1) User withdraws collateral (which is a Pendle token) from CDPVault, 2) User performs pendle pool exit.\n\nThe issue is in step 2, since `minOut` is set to 0, users may receive less output tokens than expected.\n\n```solidity\n    function _onWithdraw(\n        address vault,\n        address position,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(position), amount);\n        address collateralToken = address(ICDPVault(vault).token());\n\n        if (dst != collateralToken && dst != address(0)) {\n            PoolActionParams memory poolActionParams = PoolActionParams({\n                protocol: Protocol.PENDLE,\n@>              minOut: 0, // @audit-bug: No slippage.\n                recipient: address(this),\n                args: abi.encode(\n                    collateralToken,\n                    collateralWithdrawn,\n                    dst\n                )\n            });\n\n            bytes memory exitData = _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, poolActionParams)\n            );\n\n            collateralWithdrawn = abi.decode(exitData, (uint256));\n        }\n        return collateralWithdrawn;\n    }\n```\n\nAlso note that this is similar to the 2024-07 Loopfi contest finding https://github.com/code-423n4/2024-07-loopfi-findings/issues/38, which also talks about slippage in ERC4626. However, this Pendle withdraw exit pool code is new, and not existant in the last contest. Thus this should be considered a new bug.\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nAllow user to set a minOut parameter for withdraw functions, especially for Pendle position and ERC4626 position.\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": "## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nThe dataflow for withdrawing on `PositionActionPendle` is: 1) User withdraws collateral (which is a Pendle token) from CDPVault, 2) User performs pendle pool exit.\n\nThe issue is in step 2, since `minOut` is set to 0, users may receive less output tokens than expected.\n\n```solidity\n    function _onWithdraw(\n        address vault,\n        address position,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(position), amount);\n        address collateralToken = address(ICDPVault(vault).token());\n\n        if (dst != collateralToken && dst != address(0)) {\n            PoolActionParams memory poolActionParams = PoolActionParams({\n                protocol: Protocol.PENDLE,\n@>              minOut: 0, // @audit-bug: No slippage.\n                recipient: address(this),\n                args: abi.encode(\n                    collateralToken,\n                    collateralWithdrawn,\n                    dst\n                )\n            });\n\n            bytes memory exitData = _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, poolActionParams)\n            );\n\n            collateralWithdrawn = abi.decode(exitData, (uint256));\n        }\n        return collateralWithdrawn;\n    }\n```\n\nAlso note that this is similar to the 2024-07 Loopfi contest finding https://github.com/code-423n4/2024-07-loopfi-findings/issues/38, which also talks about slippage in ERC4626. However, this Pendle withdraw exit pool code is new, and not existant in the last contest. Thus this should be considered a new bug.\n", "impact_md": "## Impact\n\nWhen performing withdraws on `PositionActionPendle` and exiting Pendle pools, users may lose funds due to not setting slippage.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nAllow user to set a minOut parameter for withdraw functions, especially for Pendle position and ERC4626 position.\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\nN/A\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionActionPendle.sol#L67\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionActionPendle.sol#L67\n\n\n# Vulnerability details\n\n\n## Impact\n\nWhen performing withdraws on `PositionActionPendle` and exiting Pendle pools, users may lose funds due to not setting slippage.\n\n## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nThe dataflow for withdrawing on `PositionActionPendle` is: 1) User withdraws collateral (which is a Pendle token) from CDPVault, 2) User performs pendle pool exit.\n\nThe issue is in step 2, since `minOut` is set to 0, users may receive less output tokens than expected.\n\n```solidity\n    function _onWithdraw(\n        address vault,\n        address position,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(position), amount);\n        address collateralToken = address(ICDPVault(vault).token());\n\n        if (dst != collateralToken && dst != address(0)) {\n            PoolActionParams memory poolActionParams = PoolActionParams({\n                protocol: Protocol.PENDLE,\n@>              minOut: 0, // @audit-bug: No slippage.\n                recipient: address(this),\n                args: abi.encode(\n                    collateralToken,\n                    collateralWithdrawn,\n                    dst\n                )\n            });\n\n            bytes memory exitData = _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, poolActionParams)\n            );\n\n            collateralWithdrawn = abi.decode(exitData, (uint256));\n        }\n        return collateralWithdrawn;\n    }\n```\n\nAlso note that this is similar to the 2024-07 Loopfi contest finding https://github.com/code-423n4/2024-07-loopfi-findings/issues/38, which also talks about slippage in ERC4626. However, this Pendle withdraw exit pool code is new, and not existant in the last contest. Thus this should be considered a new bug.\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nAllow user to set a minOut parameter for withdraw functions, especially for Pendle position and ERC4626 position.\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionActionPendle.sol#L67\n\n\n# Vulnerability details\n\n\n## Impact\n\nWhen performing withdraws on `PositionActionPendle` and exiting Pendle pools, users may lose funds due to not setting slippage.\n\n## Bug Description\n\n*Note: This is a new issue that was introduced by the latest code diff (Doesn't exist in the 2024-07 Loopfi contest).*\n\nThe dataflow for withdrawing on `PositionActionPendle` is: 1) User withdraws collateral (which is a Pendle token) from CDPVault, 2) User performs pendle pool exit.\n\nThe issue is in step 2, since `minOut` is set to 0, users may receive less output tokens than expected.\n\n```solidity\n    function _onWithdraw(\n        address vault,\n        address position,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(position), amount);\n        address collateralToken = address(ICDPVault(vault).token());\n\n        if (dst != collateralToken && dst != address(0)) {\n            PoolActionParams memory poolActionParams = PoolActionParams({\n                protocol: Protocol.PENDLE,        \n@>              minOut: 0, // @audit-bug: No slippage.\n                recipient: address(this),     \n                args: abi.encode(\n                    collateralToken,          \n                    collateralWithdrawn,       \n                    dst                        \n                )\n            });\n\n            bytes memory exitData = _delegateCall(\n                address(poolAction),\n                abi.encodeWithSelector(poolAction.exit.selector, poolActionParams)\n            );\n\n            collateralWithdrawn = abi.decode(exitData, (uint256));\n        }\n        return collateralWithdrawn;\n    }\n```\n\nAlso note that this is similar to the 2024-07 Loopfi contest finding https://github.com/code-423n4/2024-07-loopfi-findings/issues/38, which also talks about slippage in ERC4626. However, this Pendle withdraw exit pool code is new, and not existant in the last contest. Thus this should be considered a new bug.\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nAllow user to set a minOut parameter for withdraw functions, especially for Pendle position and ERC4626 position.\n\n\n## Assessed type\n\nOther"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-012", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 12, "page_start": null, "title": "`SwapAction.sol#transferAndSwap` is still payable though direct ETH is not supported anymore.", "short_summary": null, "description_md": "## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/70 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThe original fix was applied that all native ETH support is removed, and all payable modifiers for external functions are removed. However, `SwapAction.sol#transferAndSwap` was left out, and it is still marked payable.\n\n```solidity\n    function transferAndSwap(\n        address from,\n        PermitParams calldata permitParams,\n        SwapParams calldata swapParams\n@>  ) external payable returns (uint256) {\n        if (from != address(this)) {\n            uint256 amount = swapParams.swapType == SwapType.EXACT_IN ? swapParams.amount : swapParams.limit;\n            _transferFrom(swapParams.assetIn, from, address(this), amount, permitParams);\n        }\n        return swap(swapParams);\n    }\n```\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/SwapAction.sol#L102\n\n\n# Vulnerability details\n\n\n## Impact\n\n`SwapAction.sol#transferAndSwap` supports native ETH transfer, but all native ETH swaps (balancer, pendle) are removed.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/70 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThe original fix was applied that all native ETH support is removed, and all payable modifiers for external functions are removed. However, `SwapAction.sol#transferAndSwap` was left out, and it is still marked payable.\n\n```solidity\n    function transferAndSwap(\n        address from,\n        PermitParams calldata permitParams,\n        SwapParams calldata swapParams\n@>  ) external payable returns (uint256) {\n        if (from != address(this)) {\n            uint256 amount = swapParams.swapType == SwapType.EXACT_IN ? swapParams.amount : swapParams.limit;\n            _transferFrom(swapParams.assetIn, from, address(this), amount, permitParams);\n        }\n        return swap(swapParams);\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nRemove the payable modifier.\n\n\n## Assessed type\n\nPayable\n", "sections": {"description_md": "## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/70 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThe original fix was applied that all native ETH support is removed, and all payable modifiers for external functions are removed. However, `SwapAction.sol#transferAndSwap` was left out, and it is still marked payable.\n\n```solidity\n    function transferAndSwap(\n        address from,\n        PermitParams calldata permitParams,\n        SwapParams calldata swapParams\n@>  ) external payable returns (uint256) {\n        if (from != address(this)) {\n            uint256 amount = swapParams.swapType == SwapType.EXACT_IN ? swapParams.amount : swapParams.limit;\n            _transferFrom(swapParams.assetIn, from, address(this), amount, permitParams);\n        }\n        return swap(swapParams);\n    }\n```\n", "impact_md": "## Impact\n\n`SwapAction.sol#transferAndSwap` supports native ETH transfer, but all native ETH swaps (balancer, pendle) are removed.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nRemove the payable modifier.\n\n\n## Assessed type\n\nPayable\n", "poc_md": "## Proof of Concept\n\nN/A\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/SwapAction.sol#L102\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/SwapAction.sol#L102\n\n\n# Vulnerability details\n\n\n## Impact\n\n`SwapAction.sol#transferAndSwap` supports native ETH transfer, but all native ETH swaps (balancer, pendle) are removed.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/70 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThe original fix was applied that all native ETH support is removed, and all payable modifiers for external functions are removed. However, `SwapAction.sol#transferAndSwap` was left out, and it is still marked payable.\n\n```solidity\n    function transferAndSwap(\n        address from,\n        PermitParams calldata permitParams,\n        SwapParams calldata swapParams\n@>  ) external payable returns (uint256) {\n        if (from != address(this)) {\n            uint256 amount = swapParams.swapType == SwapType.EXACT_IN ? swapParams.amount : swapParams.limit;\n            _transferFrom(swapParams.assetIn, from, address(this), amount, permitParams);\n        }\n        return swap(swapParams);\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nRemove the payable modifier.\n\n\n## Assessed type\n\nPayable\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/SwapAction.sol#L102\n\n\n# Vulnerability details\n\n\n## Impact\n\n`SwapAction.sol#transferAndSwap` supports native ETH transfer, but all native ETH swaps (balancer, pendle) are removed.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/70 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nThe original fix was applied that all native ETH support is removed, and all payable modifiers for external functions are removed. However, `SwapAction.sol#transferAndSwap` was left out, and it is still marked payable.\n\n```solidity\n    function transferAndSwap(\n        address from,\n        PermitParams calldata permitParams,\n        SwapParams calldata swapParams\n@>  ) external payable returns (uint256) {\n        if (from != address(this)) {\n            uint256 amount = swapParams.swapType == SwapType.EXACT_IN ? swapParams.amount : swapParams.limit;\n            _transferFrom(swapParams.assetIn, from, address(this), amount, permitParams);\n        }\n        return swap(swapParams);\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nRemove the payable modifier.\n\n\n## Assessed type\n\nPayable"}, "severity": "Medium", "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-013", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 13, "page_start": null, "title": "`PositionAction4626.sol#_onWithdraw` should withdraw from position CDPVault position instead of `address(this)`.", "short_summary": null, "description_md": "## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/81, https://github.com/code-423n4/2024-07-loopfi-findings/issues/80 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nOnly the bug in the `_onDeposit()` was fixed, but not the one in `_onWithdraw()`.\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n\n```solidity\n    function _onDeposit(address vault, address position, address src, uint256 amount) internal override returns (uint256) {\n        address collateral = address(ICDPVault(vault).token());\n\n        // if the src is not the collateralToken, we need to deposit the underlying into the ERC4626 vault\n        if (src != collateral) {\n            address underlying = IERC4626(collateral).asset();\n            IERC20(underlying).forceApprove(collateral, amount);\n            amount = IERC4626(collateral).deposit(amount, address(this));\n        }\n\n        IERC20(collateral).forceApprove(vault, amount);\n\n        // @audit-note: This was fixed.\n        return ICDPVault(vault).deposit(position, amount);\n    }\n\n\n    function _onWithdraw(\n        address vault,\n        address /*position*/,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        // @audit-note: This is still a bug.\n@>      uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n\n        // if collateral is not the dst token, we need to withdraw the underlying from the ERC4626 vault\n        address collateral = address(ICDPVault(vault).token());\n        if (dst != collateral) {\n            collateralWithdrawn = IERC4626(collateral).redeem(collateralWithdrawn, address(this), address(this));\n        }\n\n        return collateralWithdrawn;\n    }\n```\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction4626.sol#L67\n\n\n# Vulnerability details\n\n\n## Impact\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/81, https://github.com/code-423n4/2024-07-loopfi-findings/issues/80 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nOnly the bug in the `_onDeposit()` was fixed, but not the one in `_onWithdraw()`.\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n\n```solidity\n    function _onDeposit(address vault, address position, address src, uint256 amount) internal override returns (uint256) {\n        address collateral = address(ICDPVault(vault).token());\n\n        // if the src is not the collateralToken, we need to deposit the underlying into the ERC4626 vault\n        if (src != collateral) {\n            address underlying = IERC4626(collateral).asset();\n            IERC20(underlying).forceApprove(collateral, amount);\n            amount = IERC4626(collateral).deposit(amount, address(this));\n        }\n\n        IERC20(collateral).forceApprove(vault, amount);\n\n        // @audit-note: This was fixed.\n        return ICDPVault(vault).deposit(position, amount);\n    }\n\n\n    function _onWithdraw(\n        address vault,\n        address /*position*/,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        // @audit-note: This is still a bug.\n@>      uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n\n        // if collateral is not the dst token, we need to withdraw the underlying from the ERC4626 vault\n        address collateral = address(ICDPVault(vault).token());\n        if (dst != collateral) {\n            collateralWithdrawn = IERC4626(collateral).redeem(collateralWithdrawn, address(this), address(this));\n        }\n\n        return collateralWithdrawn;\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\n```diff\n-       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n+       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(position, amount);\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": "## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/81, https://github.com/code-423n4/2024-07-loopfi-findings/issues/80 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nOnly the bug in the `_onDeposit()` was fixed, but not the one in `_onWithdraw()`.\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n\n```solidity\n    function _onDeposit(address vault, address position, address src, uint256 amount) internal override returns (uint256) {\n        address collateral = address(ICDPVault(vault).token());\n\n        // if the src is not the collateralToken, we need to deposit the underlying into the ERC4626 vault\n        if (src != collateral) {\n            address underlying = IERC4626(collateral).asset();\n            IERC20(underlying).forceApprove(collateral, amount);\n            amount = IERC4626(collateral).deposit(amount, address(this));\n        }\n\n        IERC20(collateral).forceApprove(vault, amount);\n\n        // @audit-note: This was fixed.\n        return ICDPVault(vault).deposit(position, amount);\n    }\n\n\n    function _onWithdraw(\n        address vault,\n        address /*position*/,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        // @audit-note: This is still a bug.\n@>      uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n\n        // if collateral is not the dst token, we need to withdraw the underlying from the ERC4626 vault\n        address collateral = address(ICDPVault(vault).token());\n        if (dst != collateral) {\n            collateralWithdrawn = IERC4626(collateral).redeem(collateralWithdrawn, address(this), address(this));\n        }\n\n        return collateralWithdrawn;\n    }\n```\n", "impact_md": "## Impact\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n", "recommendation_md": "## Recommended Mitigation Steps\n\n```diff\n-       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n+       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(position, amount);\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\nN/A\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction4626.sol#L67\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction4626.sol#L67\n\n\n# Vulnerability details\n\n\n## Impact\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/81, https://github.com/code-423n4/2024-07-loopfi-findings/issues/80 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nOnly the bug in the `_onDeposit()` was fixed, but not the one in `_onWithdraw()`.\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n\n```solidity\n    function _onDeposit(address vault, address position, address src, uint256 amount) internal override returns (uint256) {\n        address collateral = address(ICDPVault(vault).token());\n\n        // if the src is not the collateralToken, we need to deposit the underlying into the ERC4626 vault\n        if (src != collateral) {\n            address underlying = IERC4626(collateral).asset();\n            IERC20(underlying).forceApprove(collateral, amount);\n            amount = IERC4626(collateral).deposit(amount, address(this));\n        }\n\n        IERC20(collateral).forceApprove(vault, amount);\n\n        // @audit-note: This was fixed.\n        return ICDPVault(vault).deposit(position, amount);\n    }\n\n\n    function _onWithdraw(\n        address vault,\n        address /*position*/,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        // @audit-note: This is still a bug.\n@>      uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n\n        // if collateral is not the dst token, we need to withdraw the underlying from the ERC4626 vault\n        address collateral = address(ICDPVault(vault).token());\n        if (dst != collateral) {\n            collateralWithdrawn = IERC4626(collateral).redeem(collateralWithdrawn, address(this), address(this));\n        }\n\n        return collateralWithdrawn;\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\n```diff\n-       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n+       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(position, amount);\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction4626.sol#L67\n\n\n# Vulnerability details\n\n\n## Impact\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`. \n\n## Bug Description\n\n*Note: This is based on the 2024-07 Loopfi contest https://github.com/code-423n4/2024-07-loopfi-findings/issues/81, https://github.com/code-423n4/2024-07-loopfi-findings/issues/80 issue. This protocol team applied a fix, but the fix is incomplete.*\n\nOnly the bug in the `_onDeposit()` was fixed, but not the one in `_onWithdraw()`.\n\n`PositionAction4626.sol#_onWithdraw` does not withdraw from the correct position - it should withdraw from `position` instead of `address(this)`.\n\n```solidity\n    function _onDeposit(address vault, address position, address src, uint256 amount) internal override returns (uint256) {\n        address collateral = address(ICDPVault(vault).token());\n\n        // if the src is not the collateralToken, we need to deposit the underlying into the ERC4626 vault\n        if (src != collateral) {\n            address underlying = IERC4626(collateral).asset();\n            IERC20(underlying).forceApprove(collateral, amount);\n            amount = IERC4626(collateral).deposit(amount, address(this));\n        }\n\n        IERC20(collateral).forceApprove(vault, amount);\n\n        // @audit-note: This was fixed.\n        return ICDPVault(vault).deposit(position, amount);\n    }\n\n\n    function _onWithdraw(\n        address vault,\n        address /*position*/,\n        address dst,\n        uint256 amount\n    ) internal override returns (uint256) {\n        // @audit-note: This is still a bug.\n@>      uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n\n        // if collateral is not the dst token, we need to withdraw the underlying from the ERC4626 vault\n        address collateral = address(ICDPVault(vault).token());\n        if (dst != collateral) {\n            collateralWithdrawn = IERC4626(collateral).redeem(collateralWithdrawn, address(this), address(this));\n        }\n\n        return collateralWithdrawn;\n    }\n```\n\n## Proof of Concept\n\nN/A\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\n```diff\n-       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n+       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(position, amount);\n```\n\n\n## Assessed type\n\nOther"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-018", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 18, "page_start": null, "title": "Some residual recipients would now have their residues stuck in `SwapAction` after swap", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n\n# Vulnerability details\n\n\n## Proof of Concept\n\nIn the current scope a new addition has been made to the swapParams: https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\n\n```diff\nstruct SwapParams {\n    SwapProtocol swapProtocol;\n    SwapType swapType;\n    address assetIn;\n    uint256 amount; // Exact amount in or exact amount out depending on swapType\n    uint256 limit; // Min amount out or max amount in depending on swapType\n    address recipient;\n+    address residualRecipient; // Address to send any residual tokens to\n    uint256 deadline;\n    /// @dev `args` can be used for protocol specific parameters\n    /// For Balancer, it is the `poolIds` and `assetPath`\n    /// For Uniswap v3, it is the `path` for the swap\n    bytes args;\n}\n\n```\n\nAs hinted the `residualRecipient` is the address to send any residual tokens to after a swap, also from the above we can see that the logic allows for `recipient` to not be the same as `residualRecipient`, which is why regardless of what happens in as much as `residualRecipient` is set we should transfer the residues post swap to it.\n\nIn the previous scope when we didn't have any param as residual recipient this is how transfers of residual tokens are executed https://github.com/code-423n4/2024-07-loopfi/blob/57871f64bdea450c1f04c9a53dc1a78223719164/src/proxy/SwapAction.sol#L107C1-L144C1:\n\n```solidity\n    /// @return retAmount Amount of tokens taken or received from the swap\n    function swap(SwapParams memory swapParams) public payable returns (uint256 retAmount) {\n..snip\n        // Transfer any remaining tokens to the recipient\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n        }\n    }\n```\n\nThat is a check is made that if the `SwapAction.sol` is not the recipient and the swapType is `EXACT_OUT` then we should transfer the remaining tokens to the real recipient, however if `address(this)` is the real recipient then there is no need for us to make a transfer from `address(this)` -> `address(this)` for a token.\n\nNow in the current scope here is how it's implemented https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n```solidity\n    function swap(SwapParams memory swapParams) public returns (uint256 retAmount) {\n        if (block.timestamp > swapParams.deadline) {\n            _revertBytes(\"SwapAction: swap deadline passed\");\n        }\n..snip\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n            } else {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n    }\n\n```\n\nThe check above is wrong however, considering there is a valid case where even if the `residualRecipient` is set the remaining tokens from the swap are stuck in the contract.\n\nPOC:\n\n- User is a contract who is attempting to swap\n- Swap params includes `residualRecipient`, which a user has set to themselves\n- swapType is `SwapType.EXACT_OUT`\n- And we have `swapParams.recipient` as `address(this)`\n- Per the [docs and one of the current upgrade](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L43) any residual token should in this case be sent to `msg.sender` since they've set themselves as the `residualRecipient`, however this doesn't happen, and instead the tokens would be stuck in the contract due to this [check](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L150).\n\n\n## Impact\n\nUser tokens would be stuck since its not being sent to the `residualRecipient`, and in this case since it's stuck in the contract the user can't query to withdraw the tokens.\n\nAlso this new approach seem to have been deployed to sort out [this issue](https://github.com/code-423n4/2024-07-loopfi-findings/issues/87) from the previous scope, where after conducting `leverParams.auxSwap` some tokens may be leftover, so they should be sent to the residual recipient, however this is not being correctly done as shown above.\n\n## Recommended Mitigation Steps\n\nApply these changes:\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L149-L157\n\n```diff\n        // Transfer any remaining tokens to the residualRecipient or recipient\n-        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n+        if (swapParams.swapType == SwapType.EXACT_OUT &&swapParams.residualRecipient != address(0)) {\n-            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n        } else {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n\n```\n\nThe above ensures regardless of who the recipient is the, the remaining tokens are always transferred to the `residualRecipient`.\n\nAlso note that [per the documentation and readMe](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88), the _action contracts_ are meant to be contracts via which users can bundle transactions, see https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88\n\n> ### Action Contracts\n\n> Action contracts facilitate the bundling of multiple transactions into a single contract interaction, allowing users to efficiently manage their positions and leverage within the protocol.\n\n> - **PoolAction:** Facilitates interactions with the pool, such as deposits and withdrawals.\n> - **PositionAction:** Bundles transactions related to the `CDPVault`, allowing users to leverage positions by performing multiple actions in a single transaction.\n> - **Swap and Transfer Actions:** Provide wrappers over swapping and transferring functionalities, enabling users to perform these actions seamlessly within the protocol.\n\nWhich in our case would then mean that with the normal flow users should be allowed to bundle one tx with another, in regards to swapAction, if a user was attempting to transfer out their received residual amount post swap, this would fail in the case shown in this report.\n\n\n\n\n## Assessed type\n\nToken-Transfer\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nUser tokens would be stuck since its not being sent to the `residualRecipient`, and in this case since it's stuck in the contract the user can't query to withdraw the tokens.\n\nAlso this new approach seem to have been deployed to sort out [this issue](https://github.com/code-423n4/2024-07-loopfi-findings/issues/87) from the previous scope, where after conducting `leverParams.auxSwap` some tokens may be leftover, so they should be sent to the residual recipient, however this is not being correctly done as shown above.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nApply these changes:\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L149-L157\n\n```diff\n        // Transfer any remaining tokens to the residualRecipient or recipient\n-        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n+        if (swapParams.swapType == SwapType.EXACT_OUT &&swapParams.residualRecipient != address(0)) {\n-            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n        } else {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n\n```\n\nThe above ensures regardless of who the recipient is the, the remaining tokens are always transferred to the `residualRecipient`.\n\nAlso note that [per the documentation and readMe](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88), the _action contracts_ are meant to be contracts via which users can bundle transactions, see https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88\n\n> ### Action Contracts\n\n> Action contracts facilitate the bundling of multiple transactions into a single contract interaction, allowing users to efficiently manage their positions and leverage within the protocol.\n\n> - **PoolAction:** Facilitates interactions with the pool, such as deposits and withdrawals.\n> - **PositionAction:** Bundles transactions related to the `CDPVault`, allowing users to leverage positions by performing multiple actions in a single transaction.\n> - **Swap and Transfer Actions:** Provide wrappers over swapping and transferring functionalities, enabling users to perform these actions seamlessly within the protocol.\n\nWhich in our case would then mean that with the normal flow users should be allowed to bundle one tx with another, in regards to swapAction, if a user was attempting to transfer out their received residual amount post swap, this would fail in the case shown in this report.\n\n\n\n\n## Assessed type\n\nToken-Transfer\n", "poc_md": "## Proof of Concept\n\nIn the current scope a new addition has been made to the swapParams: https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\n\n```diff\nstruct SwapParams {\n    SwapProtocol swapProtocol;\n    SwapType swapType;\n    address assetIn;\n    uint256 amount; // Exact amount in or exact amount out depending on swapType\n    uint256 limit; // Min amount out or max amount in depending on swapType\n    address recipient;\n+    address residualRecipient; // Address to send any residual tokens to\n    uint256 deadline;\n    /// @dev `args` can be used for protocol specific parameters\n    /// For Balancer, it is the `poolIds` and `assetPath`\n    /// For Uniswap v3, it is the `path` for the swap\n    bytes args;\n}\n\n```\n\nAs hinted the `residualRecipient` is the address to send any residual tokens to after a swap, also from the above we can see that the logic allows for `recipient` to not be the same as `residualRecipient`, which is why regardless of what happens in as much as `residualRecipient` is set we should transfer the residues post swap to it.\n\nIn the previous scope when we didn't have any param as residual recipient this is how transfers of residual tokens are executed https://github.com/code-423n4/2024-07-loopfi/blob/57871f64bdea450c1f04c9a53dc1a78223719164/src/proxy/SwapAction.sol#L107C1-L144C1:\n\n```solidity\n    /// @return retAmount Amount of tokens taken or received from the swap\n    function swap(SwapParams memory swapParams) public payable returns (uint256 retAmount) {\n..snip\n        // Transfer any remaining tokens to the recipient\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n        }\n    }\n```\n\nThat is a check is made that if the `SwapAction.sol` is not the recipient and the swapType is `EXACT_OUT` then we should transfer the remaining tokens to the real recipient, however if `address(this)` is the real recipient then there is no need for us to make a transfer from `address(this)` -> `address(this)` for a token.\n\nNow in the current scope here is how it's implemented https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n```solidity\n    function swap(SwapParams memory swapParams) public returns (uint256 retAmount) {\n        if (block.timestamp > swapParams.deadline) {\n            _revertBytes(\"SwapAction: swap deadline passed\");\n        }\n..snip\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n            } else {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n    }\n\n```\n\nThe check above is wrong however, considering there is a valid case where even if the `residualRecipient` is set the remaining tokens from the swap are stuck in the contract.\n\nPOC:\n\n- User is a contract who is attempting to swap\n- Swap params includes `residualRecipient`, which a user has set to themselves\n- swapType is `SwapType.EXACT_OUT`\n- And we have `swapParams.recipient` as `address(this)`\n- Per the [docs and one of the current upgrade](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L43) any residual token should in this case be sent to `msg.sender` since they've set themselves as the `residualRecipient`, however this doesn't happen, and instead the tokens would be stuck in the contract due to this [check](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L150).\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n\n# Vulnerability details\n\n\n## Proof of Concept\n\nIn the current scope a new addition has been made to the swapParams: https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\n\n```diff\nstruct SwapParams {\n    SwapProtocol swapProtocol;\n    SwapType swapType;\n    address assetIn;\n    uint256 amount; // Exact amount in or exact amount out depending on swapType\n    uint256 limit; // Min amount out or max amount in depending on swapType\n    address recipient;\n+    address residualRecipient; // Address to send any residual tokens to\n    uint256 deadline;\n    /// @dev `args` can be used for protocol specific parameters\n    /// For Balancer, it is the `poolIds` and `assetPath`\n    /// For Uniswap v3, it is the `path` for the swap\n    bytes args;\n}\n\n```\n\nAs hinted the `residualRecipient` is the address to send any residual tokens to after a swap, also from the above we can see that the logic allows for `recipient` to not be the same as `residualRecipient`, which is why regardless of what happens in as much as `residualRecipient` is set we should transfer the residues post swap to it.\n\nIn the previous scope when we didn't have any param as residual recipient this is how transfers of residual tokens are executed https://github.com/code-423n4/2024-07-loopfi/blob/57871f64bdea450c1f04c9a53dc1a78223719164/src/proxy/SwapAction.sol#L107C1-L144C1:\n\n```solidity\n    /// @return retAmount Amount of tokens taken or received from the swap\n    function swap(SwapParams memory swapParams) public payable returns (uint256 retAmount) {\n..snip\n        // Transfer any remaining tokens to the recipient\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n        }\n    }\n```\n\nThat is a check is made that if the `SwapAction.sol` is not the recipient and the swapType is `EXACT_OUT` then we should transfer the remaining tokens to the real recipient, however if `address(this)` is the real recipient then there is no need for us to make a transfer from `address(this)` -> `address(this)` for a token.\n\nNow in the current scope here is how it's implemented https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n```solidity\n    function swap(SwapParams memory swapParams) public returns (uint256 retAmount) {\n        if (block.timestamp > swapParams.deadline) {\n            _revertBytes(\"SwapAction: swap deadline passed\");\n        }\n..snip\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n            } else {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n    }\n\n```\n\nThe check above is wrong however, considering there is a valid case where even if the `residualRecipient` is set the remaining tokens from the swap are stuck in the contract.\n\nPOC:\n\n- User is a contract who is attempting to swap\n- Swap params includes `residualRecipient`, which a user has set to themselves\n- swapType is `SwapType.EXACT_OUT`\n- And we have `swapParams.recipient` as `address(this)`\n- Per the [docs and one of the current upgrade](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L43) any residual token should in this case be sent to `msg.sender` since they've set themselves as the `residualRecipient`, however this doesn't happen, and instead the tokens would be stuck in the contract due to this [check](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L150).\n\n\n## Impact\n\nUser tokens would be stuck since its not being sent to the `residualRecipient`, and in this case since it's stuck in the contract the user can't query to withdraw the tokens.\n\nAlso this new approach seem to have been deployed to sort out [this issue](https://github.com/code-423n4/2024-07-loopfi-findings/issues/87) from the previous scope, where after conducting `leverParams.auxSwap` some tokens may be leftover, so they should be sent to the residual recipient, however this is not being correctly done as shown above.\n\n## Recommended Mitigation Steps\n\nApply these changes:\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L149-L157\n\n```diff\n        // Transfer any remaining tokens to the residualRecipient or recipient\n-        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n+        if (swapParams.swapType == SwapType.EXACT_OUT &&swapParams.residualRecipient != address(0)) {\n-            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n        } else {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n\n```\n\nThe above ensures regardless of who the recipient is the, the remaining tokens are always transferred to the `residualRecipient`.\n\nAlso note that [per the documentation and readMe](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88), the _action contracts_ are meant to be contracts via which users can bundle transactions, see https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88\n\n> ### Action Contracts\n\n> Action contracts facilitate the bundling of multiple transactions into a single contract interaction, allowing users to efficiently manage their positions and leverage within the protocol.\n\n> - **PoolAction:** Facilitates interactions with the pool, such as deposits and withdrawals.\n> - **PositionAction:** Bundles transactions related to the `CDPVault`, allowing users to leverage positions by performing multiple actions in a single transaction.\n> - **Swap and Transfer Actions:** Provide wrappers over swapping and transferring functionalities, enabling users to perform these actions seamlessly within the protocol.\n\nWhich in our case would then mean that with the normal flow users should be allowed to bundle one tx with another, in regards to swapAction, if a user was attempting to transfer out their received residual amount post swap, this would fail in the case shown in this report.\n\n\n\n\n## Assessed type\n\nToken-Transfer\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n\n# Vulnerability details\n\n\n## Proof of Concept\n\nIn the current scope a new addition has been made to the swapParams: https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L36-L50\n\n```diff\nstruct SwapParams {\n    SwapProtocol swapProtocol;\n    SwapType swapType;\n    address assetIn;\n    uint256 amount; // Exact amount in or exact amount out depending on swapType\n    uint256 limit; // Min amount out or max amount in depending on swapType\n    address recipient;\n+    address residualRecipient; // Address to send any residual tokens to\n    uint256 deadline;\n    /// @dev `args` can be used for protocol specific parameters\n    /// For Balancer, it is the `poolIds` and `assetPath`\n    /// For Uniswap v3, it is the `path` for the swap\n    bytes args;\n}\n\n```\n\nAs hinted the `residualRecipient` is the address to send any residual tokens to after a swap, also from the above we can see that the logic allows for `recipient` to not be the same as `residualRecipient`, which is why regardless of what happens in as much as `residualRecipient` is set we should transfer the residues post swap to it.\n\nIn the previous scope when we didn't have any param as residual recipient this is how transfers of residual tokens are executed https://github.com/code-423n4/2024-07-loopfi/blob/57871f64bdea450c1f04c9a53dc1a78223719164/src/proxy/SwapAction.sol#L107C1-L144C1:\n\n```solidity\n    /// @return retAmount Amount of tokens taken or received from the swap\n    function swap(SwapParams memory swapParams) public payable returns (uint256 retAmount) {\n..snip\n        // Transfer any remaining tokens to the recipient\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n        }\n    }\n```\n\nThat is a check is made that if the `SwapAction.sol` is not the recipient and the swapType is `EXACT_OUT` then we should transfer the remaining tokens to the real recipient, however if `address(this)` is the real recipient then there is no need for us to make a transfer from `address(this)` -> `address(this)` for a token.\n\nNow in the current scope here is how it's implemented https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L113-L158\n\n```solidity\n    function swap(SwapParams memory swapParams) public returns (uint256 retAmount) {\n        if (block.timestamp > swapParams.deadline) {\n            _revertBytes(\"SwapAction: swap deadline passed\");\n        }\n..snip\n        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n            } else {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n    }\n\n```\n\nThe check above is wrong however, considering there is a valid case where even if the `residualRecipient` is set the remaining tokens from the swap are stuck in the contract.\n\nPOC:\n\n- User is a contract who is attempting to swap\n- Swap params includes `residualRecipient`, which a user has set to themselves\n- swapType is `SwapType.EXACT_OUT`\n- And we have `swapParams.recipient` as `address(this)`\n- Per the [docs and one of the current upgrade](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L43) any residual token should in this case be sent to `msg.sender` since they've set themselves as the `residualRecipient`, however this doesn't happen, and instead the tokens would be stuck in the contract due to this [check](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L150).\n\n\n## Impact\n\nUser tokens would be stuck since its not being sent to the `residualRecipient`, and in this case since it's stuck in the contract the user can't query to withdraw the tokens.\n\nAlso this new approach seem to have been deployed to sort out [this issue](https://github.com/code-423n4/2024-07-loopfi-findings/issues/87) from the previous scope, where after conducting `leverParams.auxSwap` some tokens may be leftover, so they should be sent to the residual recipient, however this is not being correctly done as shown above.\n\n## Recommended Mitigation Steps\n\nApply these changes:\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/proxy/SwapAction.sol#L149-L157\n\n```diff\n        // Transfer any remaining tokens to the residualRecipient or recipient\n-        if (swapParams.swapType == SwapType.EXACT_OUT && swapParams.recipient != address(this)) {\n+        if (swapParams.swapType == SwapType.EXACT_OUT &&swapParams.residualRecipient != address(0)) {\n-            if (swapParams.residualRecipient != address(0)) {\n                IERC20(swapParams.assetIn).safeTransfer(swapParams.residualRecipient, swapParams.limit - retAmount);\n        } else {\n            IERC20(swapParams.assetIn).safeTransfer(swapParams.recipient, swapParams.limit - retAmount);\n            }\n        }\n\n```\n\nThe above ensures regardless of who the recipient is the, the remaining tokens are always transferred to the `residualRecipient`.\n\nAlso note that [per the documentation and readMe](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88), the _action contracts_ are meant to be contracts via which users can bundle transactions, see https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/README.md#L80-L88\n\n> ### Action Contracts\n\n> Action contracts facilitate the bundling of multiple transactions into a single contract interaction, allowing users to efficiently manage their positions and leverage within the protocol.\n\n> - **PoolAction:** Facilitates interactions with the pool, such as deposits and withdrawals.\n> - **PositionAction:** Bundles transactions related to the `CDPVault`, allowing users to leverage positions by performing multiple actions in a single transaction.\n> - **Swap and Transfer Actions:** Provide wrappers over swapping and transferring functionalities, enabling users to perform these actions seamlessly within the protocol.\n\nWhich in our case would then mean that with the normal flow users should be allowed to bundle one tx with another, in regards to swapAction, if a user was attempting to transfer out their received residual amount post swap, this would fail in the case shown in this report.\n\n\n\n\n## Assessed type\n\nToken-Transfer"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-024", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 24, "page_start": null, "title": "Incompatibility Between Solidity Version Pragma and Custom Error Syntax in Locking.sol", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16\n\n\n# Vulnerability details\n\nDue to incompatibility between the Solidity version pragma and the syntax used for custom error declarations in the `Locking.sol` contract. The contract specifies `pragma solidity ^0.8.0;`, indicating that it is compatible with Solidity versions greater than or equal to 0.8.0. However, the custom error declarations in the contract use a syntax that was introduced in Solidity `0.8.4`.\n\nIn the Locking.sol contract, the custom errors are declared as follows: [Locking.sol#L13-L16](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16)\n```solidity\nerror AmountIsZero();\nerror InsufficientBalanceForCooldown();\nerror NoTokensInCooldown();\nerror CooldownPeriodNotPassed();\n```\nThe parentheses `()` used in these custom error declarations are only valid in Solidity versions `0.8.4` and above. In Solidity versions prior to `0.8.4`, custom errors are declared without parentheses.\n\nThis mismatch between the Solidity version pragma and the custom error syntax can lead to compilation errors when using a Solidity compiler version lower than 0.8.4. As a result, the contract may fail to deploy or exhibit unexpected behavior when interacting with it.\n\n## Impact\n* The contract will fail to compile when using a Solidity compiler version lower than 0.8.4, preventing successful deployment.\n* If the contract is deployed using a Solidity compiler version that is incompatible with the custom error syntax, it may exhibit unexpected behavior or fail to function as intended.\n* Users may encounter errors or be unable to interact with the contract if it is not deployed correctly due to the incompatibility issue.\n\n## Proof of Concept\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Locking contract\n/// @notice A contract that allows users to deposit tokens and withdraw them after a cooldown period\ncontract Locking is Ownable {\n    using SafeERC20 for IERC20;\n\n//  @audit The custom error declarations are incompatible with the Solidity version pragma. They should not have parentheses.\n    error AmountIsZero();\n    error InsufficientBalanceForCooldown();\n    error NoTokensInCooldown();\n    error CooldownPeriodNotPassed();\n\n    uint256 public cooldownPeriod;\n    IERC20 public token;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 cooldownStart;\n        uint256 cooldownAmount;\n    }\n```\nTo demonstrate the vulnerability, we can attempt to compile the Locking.sol contract using a Solidity compiler version lower than 0.8.4. For example, using Solidity 0.8.0:\n\n```solidity\nsolc --version\n# Output: solc, the solidity compiler commandline interface\n# Version: 0.8.0+commit.c7dfd78e\n\nsolc Locking.sol\n# Output:\n# ParserError: Expected ';' but got '('\n#   --> Locking.sol:13:23:\n#    |\n# 13 |     error AmountIsZero();\n#    |                       ^\n```\nAs shown above, the Solidity compiler (`version 0.8.0`) throws a `ParserError` due to the incompatible syntax used for the custom error declarations. This demonstrates that the contract will fail to compile when using a Solidity version lower than 0.8.4.\n\n## Tools Used\nVsCode\n\n## Recommended Mitigation Steps\n1. Update the Solidity version pragma to ^0.8.4 or higher to ensure compatibility with the custom error syntax used in the contract.\n```solidity\npragma solidity ^0.8.4;\n```\n2. Alternatively, modify the custom error declarations to remove the parentheses, making them compatible with Solidity versions prior to 0.8.4\n```solidity\nerror AmountIsZero;\nerror InsufficientBalanceForCooldown;\nerror NoTokensInCooldown;\nerror CooldownPeriodNotPassed;\n```\n\n\n## Assessed type\n\nError\n", "sections": {"description_md": null, "impact_md": "## Impact\n* The contract will fail to compile when using a Solidity compiler version lower than 0.8.4, preventing successful deployment.\n* If the contract is deployed using a Solidity compiler version that is incompatible with the custom error syntax, it may exhibit unexpected behavior or fail to function as intended.\n* Users may encounter errors or be unable to interact with the contract if it is not deployed correctly due to the incompatibility issue.\n", "recommendation_md": "## Recommended Mitigation Steps\n1. Update the Solidity version pragma to ^0.8.4 or higher to ensure compatibility with the custom error syntax used in the contract.\n```solidity\npragma solidity ^0.8.4;\n```\n2. Alternatively, modify the custom error declarations to remove the parentheses, making them compatible with Solidity versions prior to 0.8.4\n```solidity\nerror AmountIsZero;\nerror InsufficientBalanceForCooldown;\nerror NoTokensInCooldown;\nerror CooldownPeriodNotPassed;\n```\n\n\n## Assessed type\n\nError\n", "poc_md": "## Proof of Concept\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Locking contract\n/// @notice A contract that allows users to deposit tokens and withdraw them after a cooldown period\ncontract Locking is Ownable {\n    using SafeERC20 for IERC20;\n\n//  @audit The custom error declarations are incompatible with the Solidity version pragma. They should not have parentheses.\n    error AmountIsZero();\n    error InsufficientBalanceForCooldown();\n    error NoTokensInCooldown();\n    error CooldownPeriodNotPassed();\n\n    uint256 public cooldownPeriod;\n    IERC20 public token;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 cooldownStart;\n        uint256 cooldownAmount;\n    }\n```\nTo demonstrate the vulnerability, we can attempt to compile the Locking.sol contract using a Solidity compiler version lower than 0.8.4. For example, using Solidity 0.8.0:\n\n```solidity\nsolc --version\n# Output: solc, the solidity compiler commandline interface\n# Version: 0.8.0+commit.c7dfd78e\n\nsolc Locking.sol\n# Output:\n# ParserError: Expected ';' but got '('\n#   --> Locking.sol:13:23:\n#    |\n# 13 |     error AmountIsZero();\n#    |                       ^\n```\nAs shown above, the Solidity compiler (`version 0.8.0`) throws a `ParserError` due to the incompatible syntax used for the custom error declarations. This demonstrates that the contract will fail to compile when using a Solidity version lower than 0.8.4.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16\n\n**container:**\n# Vulnerability details\n\nDue to incompatibility between the Solidity version pragma and the syntax used for custom error declarations in the `Locking.sol` contract. The contract specifies `pragma solidity ^0.8.0;`, indicating that it is compatible with Solidity versions greater than or equal to 0.8.0. However, the custom error declarations in the contract use a syntax that was introduced in Solidity `0.8.4`.\n\nIn the Locking.sol contract, the custom errors are declared as follows: [Locking.sol#L13-L16](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16)\n```solidity\nerror AmountIsZero();\nerror InsufficientBalanceForCooldown();\nerror NoTokensInCooldown();\nerror CooldownPeriodNotPassed();\n```\nThe parentheses `()` used in these custom error declarations are only valid in Solidity versions `0.8.4` and above. In Solidity versions prior to `0.8.4`, custom errors are declared without parentheses.\n\nThis mismatch between the Solidity version pragma and the custom error syntax can lead to compilation errors when using a Solidity compiler version lower than 0.8.4. As a result, the contract may fail to deploy or exhibit unexpected behavior when interacting with it.\n\n**tools_used:**\n## Tools Used\nVsCode\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16\n\n\n# Vulnerability details\n\nDue to incompatibility between the Solidity version pragma and the syntax used for custom error declarations in the `Locking.sol` contract. The contract specifies `pragma solidity ^0.8.0;`, indicating that it is compatible with Solidity versions greater than or equal to 0.8.0. However, the custom error declarations in the contract use a syntax that was introduced in Solidity `0.8.4`.\n\nIn the Locking.sol contract, the custom errors are declared as follows: [Locking.sol#L13-L16](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16)\n```solidity\nerror AmountIsZero();\nerror InsufficientBalanceForCooldown();\nerror NoTokensInCooldown();\nerror CooldownPeriodNotPassed();\n```\nThe parentheses `()` used in these custom error declarations are only valid in Solidity versions `0.8.4` and above. In Solidity versions prior to `0.8.4`, custom errors are declared without parentheses.\n\nThis mismatch between the Solidity version pragma and the custom error syntax can lead to compilation errors when using a Solidity compiler version lower than 0.8.4. As a result, the contract may fail to deploy or exhibit unexpected behavior when interacting with it.\n\n## Impact\n* The contract will fail to compile when using a Solidity compiler version lower than 0.8.4, preventing successful deployment.\n* If the contract is deployed using a Solidity compiler version that is incompatible with the custom error syntax, it may exhibit unexpected behavior or fail to function as intended.\n* Users may encounter errors or be unable to interact with the contract if it is not deployed correctly due to the incompatibility issue.\n\n## Proof of Concept\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Locking contract\n/// @notice A contract that allows users to deposit tokens and withdraw them after a cooldown period\ncontract Locking is Ownable {\n    using SafeERC20 for IERC20;\n\n//  @audit The custom error declarations are incompatible with the Solidity version pragma. They should not have parentheses.\n    error AmountIsZero();\n    error InsufficientBalanceForCooldown();\n    error NoTokensInCooldown();\n    error CooldownPeriodNotPassed();\n\n    uint256 public cooldownPeriod;\n    IERC20 public token;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 cooldownStart;\n        uint256 cooldownAmount;\n    }\n```\nTo demonstrate the vulnerability, we can attempt to compile the Locking.sol contract using a Solidity compiler version lower than 0.8.4. For example, using Solidity 0.8.0:\n\n```solidity\nsolc --version\n# Output: solc, the solidity compiler commandline interface\n# Version: 0.8.0+commit.c7dfd78e\n\nsolc Locking.sol\n# Output:\n# ParserError: Expected ';' but got '('\n#   --> Locking.sol:13:23:\n#    |\n# 13 |     error AmountIsZero();\n#    |                       ^\n```\nAs shown above, the Solidity compiler (`version 0.8.0`) throws a `ParserError` due to the incompatible syntax used for the custom error declarations. This demonstrates that the contract will fail to compile when using a Solidity version lower than 0.8.4.\n\n## Tools Used\nVsCode\n\n## Recommended Mitigation Steps\n1. Update the Solidity version pragma to ^0.8.4 or higher to ensure compatibility with the custom error syntax used in the contract.\n```solidity\npragma solidity ^0.8.4;\n```\n2. Alternatively, modify the custom error declarations to remove the parentheses, making them compatible with Solidity versions prior to 0.8.4\n```solidity\nerror AmountIsZero;\nerror InsufficientBalanceForCooldown;\nerror NoTokensInCooldown;\nerror CooldownPeriodNotPassed;\n```\n\n\n## Assessed type\n\nError\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16\n\n\n# Vulnerability details\n\nDue to incompatibility between the Solidity version pragma and the syntax used for custom error declarations in the `Locking.sol` contract. The contract specifies `pragma solidity ^0.8.0;`, indicating that it is compatible with Solidity versions greater than or equal to 0.8.0. However, the custom error declarations in the contract use a syntax that was introduced in Solidity `0.8.4`.\n\nIn the Locking.sol contract, the custom errors are declared as follows: [Locking.sol#L13-L16](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L13-L16)\n```solidity\nerror AmountIsZero();\nerror InsufficientBalanceForCooldown();\nerror NoTokensInCooldown();\nerror CooldownPeriodNotPassed();\n```\nThe parentheses `()` used in these custom error declarations are only valid in Solidity versions `0.8.4` and above. In Solidity versions prior to `0.8.4`, custom errors are declared without parentheses.\n\nThis mismatch between the Solidity version pragma and the custom error syntax can lead to compilation errors when using a Solidity compiler version lower than 0.8.4. As a result, the contract may fail to deploy or exhibit unexpected behavior when interacting with it.\n\n## Impact\n* The contract will fail to compile when using a Solidity compiler version lower than 0.8.4, preventing successful deployment.\n* If the contract is deployed using a Solidity compiler version that is incompatible with the custom error syntax, it may exhibit unexpected behavior or fail to function as intended.\n* Users may encounter errors or be unable to interact with the contract if it is not deployed correctly due to the incompatibility issue.\n\n## Proof of Concept\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Locking contract\n/// @notice A contract that allows users to deposit tokens and withdraw them after a cooldown period\ncontract Locking is Ownable {\n    using SafeERC20 for IERC20;\n\n//  @audit The custom error declarations are incompatible with the Solidity version pragma. They should not have parentheses.\n    error AmountIsZero();\n    error InsufficientBalanceForCooldown();\n    error NoTokensInCooldown();\n    error CooldownPeriodNotPassed();\n\n    uint256 public cooldownPeriod;\n    IERC20 public token;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 cooldownStart;\n        uint256 cooldownAmount;\n    }\n```\nTo demonstrate the vulnerability, we can attempt to compile the Locking.sol contract using a Solidity compiler version lower than 0.8.4. For example, using Solidity 0.8.0:\n\n```solidity\nsolc --version\n# Output: solc, the solidity compiler commandline interface\n# Version: 0.8.0+commit.c7dfd78e\n\nsolc Locking.sol\n# Output:\n# ParserError: Expected ';' but got '('\n#   --> Locking.sol:13:23:\n#    |\n# 13 |     error AmountIsZero();\n#    |                       ^\n```\nAs shown above, the Solidity compiler (`version 0.8.0`) throws a `ParserError` due to the incompatible syntax used for the custom error declarations. This demonstrates that the contract will fail to compile when using a Solidity version lower than 0.8.4.\n\n## Tools Used\nVsCode\n\n## Recommended Mitigation Steps\n1. Update the Solidity version pragma to ^0.8.4 or higher to ensure compatibility with the custom error syntax used in the contract.\n```solidity\npragma solidity ^0.8.4;\n```\n2. Alternatively, modify the custom error declarations to remove the parentheses, making them compatible with Solidity versions prior to 0.8.4\n```solidity\nerror AmountIsZero;\nerror InsufficientBalanceForCooldown;\nerror NoTokensInCooldown;\nerror CooldownPeriodNotPassed;\n```\n\n\n## Assessed type\n\nError"}, "severity": "Medium", "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-025", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 25, "page_start": null, "title": "Rewards might be lost due to the error that _updateRewardIndex() might advance lastBalance without advancing index for a token.", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78\n\n\n# Vulnerability details\n\n## Proof of Concept\nRewards might be lost due to the error that _updateRewardIndex() might advance ```lastBalance``` without advancing index for a reward token.\n\nAnalysis:\nThe function ```_updateRewardIndex()``` is used to update the ```lastBalance``` and ```index``` of each reward  token. This function will be called when a user deposit, withdraw collateral or claim rewards.\n\nHowever, the function might not advance ```index``` when ```accrued.divDown(totalShares) = 0```, this might happen when ```totalShares``` is too big, and ```accrued``` is too small. One case is that the number of decimals for the reward token is too small.\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74)\n\nFor example, the USDC token only has 6 decimals.\n\nSuppose ```accrued``` = $100 = 100*10**6, and ```totalShares``` = 200M = 200 * 10** 6 * 10**18,\nthen we have ```accrued.divDown(totalShares) = 0```.\n\nFurthermore, if function ```_updateRewardIndex()``` is called more frequently, either because a malicious user keeps calling ```getRewards()```  (the gas fee is low on Arbitrum) or simply because the community is large so there is a high chance that for each block (per 12 seconds on Ethereum), there is someone who calls a withdraw/deposit/getRewards function. As a result, ```accrued``` could be small, leading to ```accrued.divDown(totalShares) = 0```.\n\nMeanwhile, ```_updateRewardIndex()``` always advance ```lastBalance``` when ```accrued !=0 ```:\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78)\n\nThis means the accrued rewards are lost! Nobody will receive the rewards since index has not changed.\n\nMore importantly, due to the rounding down error for ```accrued.divDown(totalShares)```, there is always a slight loss for the rewards, which is accumulative over time.\n\n\nThe following mitigation will fix this problem.\n\n\n## Recommended Mitigation Steps\nThe fix is simple:\ncalculate ```deltaIndex = accrued.divDown(totalShares)```, and advance ```lastBalance``` by ```deltaIndex.mulDown(totalShares)```. In this way, ```index``` and ```lastBalance``` will always advance in the same pace, in particular if index does not advance, then ```lastBalance``` will not advance either. The rounding down error is eliminated too since the ```lastBalance``` will not by ```accrued``` but by ```deltaIndex.mulDown(totalShares)```~~~\n\n\n\n\n\n## Assessed type\n\nMath\n", "sections": {"description_md": null, "impact_md": null, "recommendation_md": "## Recommended Mitigation Steps\nThe fix is simple:\ncalculate ```deltaIndex = accrued.divDown(totalShares)```, and advance ```lastBalance``` by ```deltaIndex.mulDown(totalShares)```. In this way, ```index``` and ```lastBalance``` will always advance in the same pace, in particular if index does not advance, then ```lastBalance``` will not advance either. The rounding down error is eliminated too since the ```lastBalance``` will not by ```accrued``` but by ```deltaIndex.mulDown(totalShares)```~~~\n\n\n\n\n\n## Assessed type\n\nMath\n", "poc_md": "## Proof of Concept\nRewards might be lost due to the error that _updateRewardIndex() might advance ```lastBalance``` without advancing index for a reward token.\n\nAnalysis:\nThe function ```_updateRewardIndex()``` is used to update the ```lastBalance``` and ```index``` of each reward  token. This function will be called when a user deposit, withdraw collateral or claim rewards.\n\nHowever, the function might not advance ```index``` when ```accrued.divDown(totalShares) = 0```, this might happen when ```totalShares``` is too big, and ```accrued``` is too small. One case is that the number of decimals for the reward token is too small.\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74)\n\nFor example, the USDC token only has 6 decimals.\n\nSuppose ```accrued``` = $100 = 100*10**6, and ```totalShares``` = 200M = 200 * 10** 6 * 10**18,\nthen we have ```accrued.divDown(totalShares) = 0```.\n\nFurthermore, if function ```_updateRewardIndex()``` is called more frequently, either because a malicious user keeps calling ```getRewards()```  (the gas fee is low on Arbitrum) or simply because the community is large so there is a high chance that for each block (per 12 seconds on Ethereum), there is someone who calls a withdraw/deposit/getRewards function. As a result, ```accrued``` could be small, leading to ```accrued.divDown(totalShares) = 0```.\n\nMeanwhile, ```_updateRewardIndex()``` always advance ```lastBalance``` when ```accrued !=0 ```:\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78)\n\nThis means the accrued rewards are lost! Nobody will receive the rewards since index has not changed.\n\nMore importantly, due to the rounding down error for ```accrued.divDown(totalShares)```, there is always a slight loss for the rewards, which is accumulative over time.\n\n\nThe following mitigation will fix this problem.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78\n\n\n# Vulnerability details\n\n## Proof of Concept\nRewards might be lost due to the error that _updateRewardIndex() might advance ```lastBalance``` without advancing index for a reward token.\n\nAnalysis:\nThe function ```_updateRewardIndex()``` is used to update the ```lastBalance``` and ```index``` of each reward  token. This function will be called when a user deposit, withdraw collateral or claim rewards.\n\nHowever, the function might not advance ```index``` when ```accrued.divDown(totalShares) = 0```, this might happen when ```totalShares``` is too big, and ```accrued``` is too small. One case is that the number of decimals for the reward token is too small.\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74)\n\nFor example, the USDC token only has 6 decimals.\n\nSuppose ```accrued``` = $100 = 100*10**6, and ```totalShares``` = 200M = 200 * 10** 6 * 10**18,\nthen we have ```accrued.divDown(totalShares) = 0```.\n\nFurthermore, if function ```_updateRewardIndex()``` is called more frequently, either because a malicious user keeps calling ```getRewards()```  (the gas fee is low on Arbitrum) or simply because the community is large so there is a high chance that for each block (per 12 seconds on Ethereum), there is someone who calls a withdraw/deposit/getRewards function. As a result, ```accrued``` could be small, leading to ```accrued.divDown(totalShares) = 0```.\n\nMeanwhile, ```_updateRewardIndex()``` always advance ```lastBalance``` when ```accrued !=0 ```:\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78)\n\nThis means the accrued rewards are lost! Nobody will receive the rewards since index has not changed.\n\nMore importantly, due to the rounding down error for ```accrued.divDown(totalShares)```, there is always a slight loss for the rewards, which is accumulative over time.\n\n\nThe following mitigation will fix this problem.\n\n\n## Recommended Mitigation Steps\nThe fix is simple:\ncalculate ```deltaIndex = accrued.divDown(totalShares)```, and advance ```lastBalance``` by ```deltaIndex.mulDown(totalShares)```. In this way, ```index``` and ```lastBalance``` will always advance in the same pace, in particular if index does not advance, then ```lastBalance``` will not advance either. The rounding down error is eliminated too since the ```lastBalance``` will not by ```accrued``` but by ```deltaIndex.mulDown(totalShares)```~~~\n\n\n\n\n\n## Assessed type\n\nMath\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78\n\n\n# Vulnerability details\n\n## Proof of Concept\nRewards might be lost due to the error that _updateRewardIndex() might advance ```lastBalance``` without advancing index for a reward token. \n\nAnalysis: \nThe function ```_updateRewardIndex()``` is used to update the ```lastBalance``` and ```index``` of each reward  token. This function will be called when a user deposit, withdraw collateral or claim rewards. \n\nHowever, the function might not advance ```index``` when ```accrued.divDown(totalShares) = 0```, this might happen when ```totalShares``` is too big, and ```accrued``` is too small. One case is that the number of decimals for the reward token is too small.\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74)\n\nFor example, the USDC token only has 6 decimals. \n\nSuppose ```accrued``` = $100 = 100*10**6, and ```totalShares``` = 200M = 200 * 10** 6 * 10**18, \nthen we have ```accrued.divDown(totalShares) = 0```. \n\nFurthermore, if function ```_updateRewardIndex()``` is called more frequently, either because a malicious user keeps calling ```getRewards()```  (the gas fee is low on Arbitrum) or simply because the community is large so there is a high chance that for each block (per 12 seconds on Ethereum), there is someone who calls a withdraw/deposit/getRewards function. As a result, ```accrued``` could be small, leading to ```accrued.divDown(totalShares) = 0```.\n\nMeanwhile, ```_updateRewardIndex()``` always advance ```lastBalance``` when ```accrued !=0 ```:\n\n[https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78](https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78)\n\nThis means the accrued rewards are lost! Nobody will receive the rewards since index has not changed. \n\nMore importantly, due to the rounding down error for ```accrued.divDown(totalShares)```, there is always a slight loss for the rewards, which is accumulative over time.  \n\n\nThe following mitigation will fix this problem. \n\n\n## Recommended Mitigation Steps\nThe fix is simple: \ncalculate ```deltaIndex = accrued.divDown(totalShares)```, and advance ```lastBalance``` by ```deltaIndex.mulDown(totalShares)```. In this way, ```index``` and ```lastBalance``` will always advance in the same pace, in particular if index does not advance, then ```lastBalance``` will not advance either. The rounding down error is eliminated too since the ```lastBalance``` will not by ```accrued``` but by ```deltaIndex.mulDown(totalShares)```~~~\n\n\n\n\n\n## Assessed type\n\nMath"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-026", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 26, "page_start": null, "title": "Invalid handling of risdual amount in `PositionAction::onCreditFlashLoan`, forcing it to revert", "short_summary": null, "description_md": "## Description\n\nUsers can call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic. When doing so, users are supposed to swap their collateral withdrawn into debt tokens so that the flash loan can be repaid.\n\nThe protocol tries to handle the residual amount from the swap (swapped - paid debt), by trying to repay extra debt for the designated position, using:\n```solidity\nif (residualAmount > 0) {\n    underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n        -toInt256(residualAmount)\n    );\n}\n```\n\nHowever, this is invalid for 2 main reasons:\n1. This is trying to repay extra debt than what the user is trying to, which is passed in the `primarySwap.amount`.\n2. If the user tries to repay his whole debt using `decreaseLever` the TX will revert, as it'll try to repay some nonexistent debt.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L492-L499\n\n\n# Vulnerability details\n\n## Description\n\nUsers can call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic. When doing so, users are supposed to swap their collateral withdrawn into debt tokens so that the flash loan can be repaid.\n\nThe protocol tries to handle the residual amount from the swap (swapped - paid debt), by trying to repay extra debt for the designated position, using:\n```solidity\nif (residualAmount > 0) {\n    underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n        -toInt256(residualAmount)\n    );\n}\n```\n\nHowever, this is invalid for 2 main reasons:\n1. This is trying to repay extra debt than what the user is trying to, which is passed in the `primarySwap.amount`.\n2. If the user tries to repay his whole debt using `decreaseLever` the TX will revert, as it'll try to repay some nonexistent debt.\n\n## Proof of Concept\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n```solidity\nfunction test_leverageDownWrongResidualHandling() public {\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(token);\n    assets[1] = address(underlyingToken);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_IN,\n                    assetIn: address(token),\n                    amount: vault.virtualDebt(address(userProxy)),\n                    limit: 0,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            201 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\nLogs:\n```\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 2.65s (4.18ms CPU time)\n\nRan 1 test suite in 2.66s (2.65s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in src/test/integration/PositionAction20.lever.t.sol:PositionAction20_Lever_Test\n[FAIL. Reason: CallerNotCreditManagerException()] test_leverageDownWrongResidualHandling() (gas: 1088990)\n```\n\n## Recommended Mitigation Steps\n\nRather than using the residual amount to repay excess debt (that might not even exist), transfer it to the designated residual recipient. Alternatively, check if the user still has any remaining debt. If they do, use the residual to repay it; otherwise, transfer the residual amount to the recipient.\n\n\n\n## Assessed type\n\nDoS\n", "sections": {"description_md": "## Description\n\nUsers can call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic. When doing so, users are supposed to swap their collateral withdrawn into debt tokens so that the flash loan can be repaid.\n\nThe protocol tries to handle the residual amount from the swap (swapped - paid debt), by trying to repay extra debt for the designated position, using:\n```solidity\nif (residualAmount > 0) {\n    underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n        -toInt256(residualAmount)\n    );\n}\n```\n\nHowever, this is invalid for 2 main reasons:\n1. This is trying to repay extra debt than what the user is trying to, which is passed in the `primarySwap.amount`.\n2. If the user tries to repay his whole debt using `decreaseLever` the TX will revert, as it'll try to repay some nonexistent debt.\n", "impact_md": null, "recommendation_md": "## Recommended Mitigation Steps\n\nRather than using the residual amount to repay excess debt (that might not even exist), transfer it to the designated residual recipient. Alternatively, check if the user still has any remaining debt. If they do, use the residual to repay it; otherwise, transfer the residual amount to the recipient.\n\n\n\n## Assessed type\n\nDoS\n", "poc_md": "## Proof of Concept\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n```solidity\nfunction test_leverageDownWrongResidualHandling() public {\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(token);\n    assets[1] = address(underlyingToken);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_IN,\n                    assetIn: address(token),\n                    amount: vault.virtualDebt(address(userProxy)),\n                    limit: 0,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            201 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\nLogs:\n```\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 2.65s (4.18ms CPU time)\n\nRan 1 test suite in 2.66s (2.65s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in src/test/integration/PositionAction20.lever.t.sol:PositionAction20_Lever_Test\n[FAIL. Reason: CallerNotCreditManagerException()] test_leverageDownWrongResidualHandling() (gas: 1088990)\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L492-L499\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L492-L499\n\n\n# Vulnerability details\n\n## Description\n\nUsers can call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic. When doing so, users are supposed to swap their collateral withdrawn into debt tokens so that the flash loan can be repaid.\n\nThe protocol tries to handle the residual amount from the swap (swapped - paid debt), by trying to repay extra debt for the designated position, using:\n```solidity\nif (residualAmount > 0) {\n    underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n        -toInt256(residualAmount)\n    );\n}\n```\n\nHowever, this is invalid for 2 main reasons:\n1. This is trying to repay extra debt than what the user is trying to, which is passed in the `primarySwap.amount`.\n2. If the user tries to repay his whole debt using `decreaseLever` the TX will revert, as it'll try to repay some nonexistent debt.\n\n## Proof of Concept\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n```solidity\nfunction test_leverageDownWrongResidualHandling() public {\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(token);\n    assets[1] = address(underlyingToken);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_IN,\n                    assetIn: address(token),\n                    amount: vault.virtualDebt(address(userProxy)),\n                    limit: 0,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            201 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\nLogs:\n```\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 2.65s (4.18ms CPU time)\n\nRan 1 test suite in 2.66s (2.65s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in src/test/integration/PositionAction20.lever.t.sol:PositionAction20_Lever_Test\n[FAIL. Reason: CallerNotCreditManagerException()] test_leverageDownWrongResidualHandling() (gas: 1088990)\n```\n\n## Recommended Mitigation Steps\n\nRather than using the residual amount to repay excess debt (that might not even exist), transfer it to the designated residual recipient. Alternatively, check if the user still has any remaining debt. If they do, use the residual to repay it; otherwise, transfer the residual amount to the recipient.\n\n\n\n## Assessed type\n\nDoS\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L492-L499\n\n\n# Vulnerability details\n\n## Description\n\nUsers can call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic. When doing so, users are supposed to swap their collateral withdrawn into debt tokens so that the flash loan can be repaid.\n\nThe protocol tries to handle the residual amount from the swap (swapped - paid debt), by trying to repay extra debt for the designated position, using:\n```solidity\nif (residualAmount > 0) {\n    underlyingToken.forceApprove(address(leverParams.vault), residualAmount);\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n        -toInt256(residualAmount)\n    );\n}\n```\n\nHowever, this is invalid for 2 main reasons:\n1. This is trying to repay extra debt than what the user is trying to, which is passed in the `primarySwap.amount`.\n2. If the user tries to repay his whole debt using `decreaseLever` the TX will revert, as it'll try to repay some nonexistent debt.\n\n## Proof of Concept\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n```solidity\nfunction test_leverageDownWrongResidualHandling() public {\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(token);\n    assets[1] = address(underlyingToken);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_IN,\n                    assetIn: address(token),\n                    amount: vault.virtualDebt(address(userProxy)),\n                    limit: 0,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            201 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\nLogs:\n```\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 2.65s (4.18ms CPU time)\n\nRan 1 test suite in 2.66s (2.65s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in src/test/integration/PositionAction20.lever.t.sol:PositionAction20_Lever_Test\n[FAIL. Reason: CallerNotCreditManagerException()] test_leverageDownWrongResidualHandling() (gas: 1088990)\n```\n\n## Recommended Mitigation Steps\n\nRather than using the residual amount to repay excess debt (that might not even exist), transfer it to the designated residual recipient. Alternatively, check if the user still has any remaining debt. If they do, use the residual to repay it; otherwise, transfer the residual amount to the recipient.\n\n\n\n## Assessed type\n\nDoS"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-027", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 27, "page_start": null, "title": "Invalid handling of flash loan fees in `PositionAction::onCreditFlashLoan`, forcing it to always revert", "short_summary": null, "description_md": "## Description\n\nWhen users take a flash loan, an amount is sent to the receiver, and then some action takes place, after that action that sent amount is expected to be paid + some fee. Users can also call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic.\n\nThis was reported in https://github.com/code-423n4/2024-07-loopfi-findings/issues/524, and a fix has been implemented. However, the fix is incomplete, and the `onCreditFlashLoan` will always revert when the fees are >0.\n\nThe fix added includes adding fees to the approval amounts:\n```solidity\nunderlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\nunderlyingToken.forceApprove(address(flashlender), subDebt + fee);\n```\n\nThat fix still misses a point: the amount coming from the flash lender is constant, and that amount will be used to repay a position's debt. The issue here is that all the amount is being used to repay without accounting for the extra fees that the flash lender will be requesting.\n\nThis causes `PositionAction::onCreditFlashLoan` to always revert.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L473\n\n\n# Vulnerability details\n\n## Description\n\nWhen users take a flash loan, an amount is sent to the receiver, and then some action takes place, after that action that sent amount is expected to be paid + some fee. Users can also call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic.\n\nThis was reported in https://github.com/code-423n4/2024-07-loopfi-findings/issues/524, and a fix has been implemented. However, the fix is incomplete, and the `onCreditFlashLoan` will always revert when the fees are >0.\n\nThe fix added includes adding fees to the approval amounts:\n```solidity\nunderlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\nunderlyingToken.forceApprove(address(flashlender), subDebt + fee);\n```\n\nThat fix still misses a point: the amount coming from the flash lender is constant, and that amount will be used to repay a position's debt. The issue here is that all the amount is being used to repay without accounting for the extra fees that the flash lender will be requesting.\n\nThis causes `PositionAction::onCreditFlashLoan` to always revert.\n\n## Proof of Concept\n\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n\n```solidity\nfunction test_leverageDownNotAccountingFees() public {\n    // Re-initialize the system to have fees > 0\n    flashlender = new Flashlender(IPoolV3(address(liquidityPool)), 0.01 ether);\n    liquidityPool.setCreditManagerDebtLimit(address(flashlender), type(uint256).max);\n    positionAction = new PositionAction20(\n        address(flashlender),\n        address(swapAction),\n        address(poolAction),\n        address(vaultRegistry)\n    );\n\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(underlyingToken);\n    assets[1] = address(token);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    vm.expectRevert(bytes(\"ERC20: transfer amount exceeds balance\"));\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_OUT,\n                    assetIn: address(token),\n                    amount: 1 ether,\n                    limit: 2 ether,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            2 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\n\n\n## Recommended Mitigation Steps\n```diff\nfunction onCreditFlashLoan(\n    address /*initiator*/,\n    uint256 /*amount*/,\n   uint256 fee,\n    bytes calldata data\n) external returns (bytes32) {\n    ...\n\n    // sub collateral and debt\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n-       -toInt256(subDebt)\n+       -toInt256(subDebt - fee)\n    );\n\n    ...\n\n    return CALLBACK_SUCCESS_CREDIT;\n}\n```\n\n\n\n\n\n## Assessed type\n\nDoS\n", "sections": {"description_md": "## Description\n\nWhen users take a flash loan, an amount is sent to the receiver, and then some action takes place, after that action that sent amount is expected to be paid + some fee. Users can also call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic.\n\nThis was reported in https://github.com/code-423n4/2024-07-loopfi-findings/issues/524, and a fix has been implemented. However, the fix is incomplete, and the `onCreditFlashLoan` will always revert when the fees are >0.\n\nThe fix added includes adding fees to the approval amounts:\n```solidity\nunderlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\nunderlyingToken.forceApprove(address(flashlender), subDebt + fee);\n```\n\nThat fix still misses a point: the amount coming from the flash lender is constant, and that amount will be used to repay a position's debt. The issue here is that all the amount is being used to repay without accounting for the extra fees that the flash lender will be requesting.\n\nThis causes `PositionAction::onCreditFlashLoan` to always revert.\n", "impact_md": null, "recommendation_md": "## Recommended Mitigation Steps\n```diff\nfunction onCreditFlashLoan(\n    address /*initiator*/,\n    uint256 /*amount*/,\n   uint256 fee,\n    bytes calldata data\n) external returns (bytes32) {\n    ...\n\n    // sub collateral and debt\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n-       -toInt256(subDebt)\n+       -toInt256(subDebt - fee)\n    );\n\n    ...\n\n    return CALLBACK_SUCCESS_CREDIT;\n}\n```\n\n\n\n\n\n## Assessed type\n\nDoS\n", "poc_md": "## Proof of Concept\n\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n\n```solidity\nfunction test_leverageDownNotAccountingFees() public {\n    // Re-initialize the system to have fees > 0\n    flashlender = new Flashlender(IPoolV3(address(liquidityPool)), 0.01 ether);\n    liquidityPool.setCreditManagerDebtLimit(address(flashlender), type(uint256).max);\n    positionAction = new PositionAction20(\n        address(flashlender),\n        address(swapAction),\n        address(poolAction),\n        address(vaultRegistry)\n    );\n\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(underlyingToken);\n    assets[1] = address(token);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    vm.expectRevert(bytes(\"ERC20: transfer amount exceeds balance\"));\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_OUT,\n                    assetIn: address(token),\n                    amount: 1 ether,\n                    limit: 2 ether,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            2 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L473\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L473\n\n\n# Vulnerability details\n\n## Description\n\nWhen users take a flash loan, an amount is sent to the receiver, and then some action takes place, after that action that sent amount is expected to be paid + some fee. Users can also call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic.\n\nThis was reported in https://github.com/code-423n4/2024-07-loopfi-findings/issues/524, and a fix has been implemented. However, the fix is incomplete, and the `onCreditFlashLoan` will always revert when the fees are >0.\n\nThe fix added includes adding fees to the approval amounts:\n```solidity\nunderlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\nunderlyingToken.forceApprove(address(flashlender), subDebt + fee);\n```\n\nThat fix still misses a point: the amount coming from the flash lender is constant, and that amount will be used to repay a position's debt. The issue here is that all the amount is being used to repay without accounting for the extra fees that the flash lender will be requesting.\n\nThis causes `PositionAction::onCreditFlashLoan` to always revert.\n\n## Proof of Concept\n\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n\n```solidity\nfunction test_leverageDownNotAccountingFees() public {\n    // Re-initialize the system to have fees > 0\n    flashlender = new Flashlender(IPoolV3(address(liquidityPool)), 0.01 ether);\n    liquidityPool.setCreditManagerDebtLimit(address(flashlender), type(uint256).max);\n    positionAction = new PositionAction20(\n        address(flashlender),\n        address(swapAction),\n        address(poolAction),\n        address(vaultRegistry)\n    );\n\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(underlyingToken);\n    assets[1] = address(token);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    vm.expectRevert(bytes(\"ERC20: transfer amount exceeds balance\"));\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_OUT,\n                    assetIn: address(token),\n                    amount: 1 ether,\n                    limit: 2 ether,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            2 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\n\n\n## Recommended Mitigation Steps\n```diff\nfunction onCreditFlashLoan(\n    address /*initiator*/,\n    uint256 /*amount*/,\n   uint256 fee,\n    bytes calldata data\n) external returns (bytes32) {\n    ...\n\n    // sub collateral and debt\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n-       -toInt256(subDebt)\n+       -toInt256(subDebt - fee)\n    );\n\n    ...\n\n    return CALLBACK_SUCCESS_CREDIT;\n}\n```\n\n\n\n\n\n## Assessed type\n\nDoS\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PositionAction.sol#L473\n\n\n# Vulnerability details\n\n## Description\n\nWhen users take a flash loan, an amount is sent to the receiver, and then some action takes place, after that action that sent amount is expected to be paid + some fee. Users can also call `PositionAction::decreaseLever` through a proxy, to \"Decrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\", after it is called, the flash loan lender sends the credit and calls `onCreditFlashLoan`, which handles all that logic.\n\nThis was reported in https://github.com/code-423n4/2024-07-loopfi-findings/issues/524, and a fix has been implemented. However, the fix is incomplete, and the `onCreditFlashLoan` will always revert when the fees are >0.\n\nThe fix added includes adding fees to the approval amounts:\n```solidity\nunderlyingToken.forceApprove(address(leverParams.vault), subDebt + fee);\nunderlyingToken.forceApprove(address(flashlender), subDebt + fee);\n```\n\nThat fix still misses a point: the amount coming from the flash lender is constant, and that amount will be used to repay a position's debt. The issue here is that all the amount is being used to repay without accounting for the extra fees that the flash lender will be requesting.\n\nThis causes `PositionAction::onCreditFlashLoan` to always revert.\n\n## Proof of Concept\n\nAdd the following test in `src/test/integration/PositionAction20.lever.t.sol`:\n\n```solidity\nfunction test_leverageDownNotAccountingFees() public {\n    // Re-initialize the system to have fees > 0\n    flashlender = new Flashlender(IPoolV3(address(liquidityPool)), 0.01 ether);\n    liquidityPool.setCreditManagerDebtLimit(address(flashlender), type(uint256).max);\n    positionAction = new PositionAction20(\n        address(flashlender),\n        address(swapAction),\n        address(poolAction),\n        address(vaultRegistry)\n    );\n\n    uint256 depositAmount = 1_000 ether;\n    uint256 borrowAmount = 200 ether;\n\n    deal(address(token), user, depositAmount);\n\n    address[] memory assets = new address[](2);\n    assets[0] = address(underlyingToken);\n    assets[1] = address(token);\n\n    vm.startPrank(user);\n\n    // User deposits 1k ETH collateral\n    token.approve(address(vault), type(uint256).max);\n    vault.deposit(address(userProxy), depositAmount);\n\n    // User borrows 200 ETH\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.borrow.selector,\n            address(userProxy),\n            address(vault),\n            CreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n        )\n    );\n\n    vm.expectRevert(bytes(\"ERC20: transfer amount exceeds balance\"));\n    userProxy.execute(\n        address(positionAction),\n        abi.encodeWithSelector(\n            positionAction.decreaseLever.selector,\n            LeverParams({\n                position: address(userProxy),\n                vault: address(vault),\n                collateralToken: address(token),\n                primarySwap: SwapParams({\n                    swapProtocol: SwapProtocol.BALANCER,\n                    swapType: SwapType.EXACT_OUT,\n                    assetIn: address(token),\n                    amount: 1 ether,\n                    limit: 2 ether,\n                    recipient: address(positionAction),\n                    residualRecipient: address(positionAction),\n                    deadline: block.timestamp,\n                    args: abi.encode(weightedPoolIdArray, assets)\n                }),\n                auxSwap: emptySwap,\n                auxAction: emptyPoolActionParams\n            }),\n            2 ether,\n            address(userProxy)\n        )\n    );\n\n    vm.stopPrank();\n}\n```\n\n\n## Recommended Mitigation Steps\n```diff\nfunction onCreditFlashLoan(\n    address /*initiator*/,\n    uint256 /*amount*/,\n   uint256 fee,\n    bytes calldata data\n) external returns (bytes32) {\n    ...\n\n    // sub collateral and debt\n    ICDPVault(leverParams.vault).modifyCollateralAndDebt(\n        leverParams.position,\n        address(this),\n        address(this),\n        0,\n-       -toInt256(subDebt)\n+       -toInt256(subDebt - fee)\n    );\n\n    ...\n\n    return CALLBACK_SUCCESS_CREDIT;\n}\n```\n\n\n\n\n\n## Assessed type\n\nDoS"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-033", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 33, "page_start": null, "title": "Eth may be transferred from treasury contract", "short_summary": null, "description_md": "# Vulnerability Description\nIn the PaymentSplitter contract, the release function allows you to release funds to beneficiaries based on their participation (shares). If anyone can call this function, even if funds are correctly released to beneficiaries, it could allow unauthorized users to manipulate contract behavior, or that may not be aligned with the purpose of a trustee-controlled treasury contract.\n\nIn your case, the administrator is expected to have sole control over when and to whom the funds are released. If anyone can request release, even without being able to divert funds, they could trigger releases without administrator authorization, or that compromise the desired centralized control.\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Treasury.sol#L12\n\n\n# Vulnerability details\n\n# Vulnerability Description\nIn the PaymentSplitter contract, the release function allows you to release funds to beneficiaries based on their participation (shares). If anyone can call this function, even if funds are correctly released to beneficiaries, it could allow unauthorized users to manipulate contract behavior, or that may not be aligned with the purpose of a trustee-controlled treasury contract.\n\nIn your case, the administrator is expected to have sole control over when and to whom the funds are released. If anyone can request release, even without being able to divert funds, they could trigger releases without administrator authorization, or that compromise the desired centralized control.\n\n## Proof Of Concept (Treasury.t.sol)\n```sol\n    function test_GriefPoC_eth() public {\n        uint256 amount = 1337 ether;\n        address public attacker  = makeAddr(\"Attacker\");\n\n        deal(address(treasury), amount);\n\n        address payable newTreasury = payable(vm.addr(4));\n        console.log(address(payees[0]).balance);\n        vm.prank(attacker);\n        treasury.release(payable(payees[0]));\n        console.log(address(payees[0]).balance);\n    }\n```\n\n# Impact\nAny User/Attacker may grief/transfer eths to payee valid!\n\n# Recommend Mitigation\nOverride the function and add the modifier  onlyRole(FUNDS_ADMINISTRATOR_ROLE)\n```sol\n    function release(address payable account) public override  onlyRole(FUNDS_ADMINISTRATOR_ROLE) {\n        super.release(account);\n    }\n```\n\n\n## Assessed type\n\nAccess Control\n", "sections": {"description_md": "# Vulnerability Description\nIn the PaymentSplitter contract, the release function allows you to release funds to beneficiaries based on their participation (shares). If anyone can call this function, even if funds are correctly released to beneficiaries, it could allow unauthorized users to manipulate contract behavior, or that may not be aligned with the purpose of a trustee-controlled treasury contract.\n\nIn your case, the administrator is expected to have sole control over when and to whom the funds are released. If anyone can request release, even without being able to divert funds, they could trigger releases without administrator authorization, or that compromise the desired centralized control.\n", "impact_md": "# Impact\nAny User/Attacker may grief/transfer eths to payee valid!\n", "recommendation_md": "# Recommend Mitigation\nOverride the function and add the modifier  onlyRole(FUNDS_ADMINISTRATOR_ROLE)\n```sol\n    function release(address payable account) public override  onlyRole(FUNDS_ADMINISTRATOR_ROLE) {\n        super.release(account);\n    }\n```\n\n\n## Assessed type\n\nAccess Control\n", "poc_md": "## Proof Of Concept (Treasury.t.sol)\n```sol\n    function test_GriefPoC_eth() public {\n        uint256 amount = 1337 ether;\n        address public attacker  = makeAddr(\"Attacker\");\n\n        deal(address(treasury), amount);\n\n        address payable newTreasury = payable(vm.addr(4));\n        console.log(address(payees[0]).balance);\n        vm.prank(attacker);\n        treasury.release(payable(payees[0]));\n        console.log(address(payees[0]).balance);\n    }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Treasury.sol#L12\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Treasury.sol#L12\n\n\n# Vulnerability details\n\n# Vulnerability Description\nIn the PaymentSplitter contract, the release function allows you to release funds to beneficiaries based on their participation (shares). If anyone can call this function, even if funds are correctly released to beneficiaries, it could allow unauthorized users to manipulate contract behavior, or that may not be aligned with the purpose of a trustee-controlled treasury contract.\n\nIn your case, the administrator is expected to have sole control over when and to whom the funds are released. If anyone can request release, even without being able to divert funds, they could trigger releases without administrator authorization, or that compromise the desired centralized control.\n\n## Proof Of Concept (Treasury.t.sol)\n```sol\n    function test_GriefPoC_eth() public {\n        uint256 amount = 1337 ether;\n        address public attacker  = makeAddr(\"Attacker\");\n\n        deal(address(treasury), amount);\n\n        address payable newTreasury = payable(vm.addr(4));\n        console.log(address(payees[0]).balance);\n        vm.prank(attacker);\n        treasury.release(payable(payees[0]));\n        console.log(address(payees[0]).balance);\n    }\n```\n\n# Impact\nAny User/Attacker may grief/transfer eths to payee valid!\n\n# Recommend Mitigation\nOverride the function and add the modifier  onlyRole(FUNDS_ADMINISTRATOR_ROLE)\n```sol\n    function release(address payable account) public override  onlyRole(FUNDS_ADMINISTRATOR_ROLE) {\n        super.release(account);\n    }\n```\n\n\n## Assessed type\n\nAccess Control\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Treasury.sol#L12\n\n\n# Vulnerability details\n\n# Vulnerability Description\nIn the PaymentSplitter contract, the release function allows you to release funds to beneficiaries based on their participation (shares). If anyone can call this function, even if funds are correctly released to beneficiaries, it could allow unauthorized users to manipulate contract behavior, or that may not be aligned with the purpose of a trustee-controlled treasury contract.\n\nIn your case, the administrator is expected to have sole control over when and to whom the funds are released. If anyone can request release, even without being able to divert funds, they could trigger releases without administrator authorization, or that compromise the desired centralized control.\n\n## Proof Of Concept (Treasury.t.sol)\n```sol\n    function test_GriefPoC_eth() public {\n        uint256 amount = 1337 ether;\n        address public attacker  = makeAddr(\"Attacker\");\n\n        deal(address(treasury), amount);\n\n        address payable newTreasury = payable(vm.addr(4));\n        console.log(address(payees[0]).balance);\n        vm.prank(attacker);\n        treasury.release(payable(payees[0]));\n        console.log(address(payees[0]).balance);\n    }\n```\n\n# Impact\nAny User/Attacker may grief/transfer eths to payee valid!\n\n# Recommend Mitigation\nOverride the function and add the modifier  onlyRole(FUNDS_ADMINISTRATOR_ROLE)\n```sol\n    function release(address payable account) public override  onlyRole(FUNDS_ADMINISTRATOR_ROLE) {\n        super.release(account);\n    }\n```\n\n\n## Assessed type\n\nAccess Control"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-037", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 37, "page_start": null, "title": "Issue is not fixed: Token array not sorted in PoolAction.transferAndJoin", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75\n\n\n# Vulnerability details\n\n\n## Impact\nThe transferAndJoin function in PoolAction.sol still does not sort the input token array, which can lead to inconsistent behavior and potential exploitation when interacting with protocols like Balancer that expect sorted token arrays.\n\n## Proof of Concept\nIt seems this issue https://github.com/code-423n4/2024-07-loopfi-findings/issues/238 is not fixed.\nIn the [transferAndJoin function](https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75) of PoolAction.sol, the `assets` array is used directly without sorting:\n\n```Solidity\nfunction transferAndJoin(\n    address from,\n    PermitParams[] calldata permitParams,\n    PoolActionParams calldata poolActionParams\n) external {\n    if (from != address(this)) {\n        if (poolActionParams.protocol == Protocol.BALANCER) {\n            (, address[] memory assets, , uint256[] memory maxAmountsIn) = abi.decode(\n                poolActionParams.args,\n                (bytes32, address[], uint256[], uint256[])\n            );\n\n            // ... (rest of the function)\n        }\n    }\n    join(poolActionParams);\n}\n```\n\nThe function uses the unsorted `assets` array in subsequent operations, including the call to `join(poolActionParams)`. This can cause issues when interacting with Balancer, which expects sorted token arrays for certain operations.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nUse the mitigation that suggested in the issue link\n\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe transferAndJoin function in PoolAction.sol still does not sort the input token array, which can lead to inconsistent behavior and potential exploitation when interacting with protocols like Balancer that expect sorted token arrays.\n", "recommendation_md": "## Recommended Mitigation Steps\nUse the mitigation that suggested in the issue link\n\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\nIt seems this issue https://github.com/code-423n4/2024-07-loopfi-findings/issues/238 is not fixed.\nIn the [transferAndJoin function](https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75) of PoolAction.sol, the `assets` array is used directly without sorting:\n\n```Solidity\nfunction transferAndJoin(\n    address from,\n    PermitParams[] calldata permitParams,\n    PoolActionParams calldata poolActionParams\n) external {\n    if (from != address(this)) {\n        if (poolActionParams.protocol == Protocol.BALANCER) {\n            (, address[] memory assets, , uint256[] memory maxAmountsIn) = abi.decode(\n                poolActionParams.args,\n                (bytes32, address[], uint256[], uint256[])\n            );\n\n            // ... (rest of the function)\n        }\n    }\n    join(poolActionParams);\n}\n```\n\nThe function uses the unsorted `assets` array in subsequent operations, including the call to `join(poolActionParams)`. This can cause issues when interacting with Balancer, which expects sorted token arrays for certain operations.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75\n\n\n# Vulnerability details\n\n\n## Impact\nThe transferAndJoin function in PoolAction.sol still does not sort the input token array, which can lead to inconsistent behavior and potential exploitation when interacting with protocols like Balancer that expect sorted token arrays.\n\n## Proof of Concept\nIt seems this issue https://github.com/code-423n4/2024-07-loopfi-findings/issues/238 is not fixed.\nIn the [transferAndJoin function](https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75) of PoolAction.sol, the `assets` array is used directly without sorting:\n\n```Solidity\nfunction transferAndJoin(\n    address from,\n    PermitParams[] calldata permitParams,\n    PoolActionParams calldata poolActionParams\n) external {\n    if (from != address(this)) {\n        if (poolActionParams.protocol == Protocol.BALANCER) {\n            (, address[] memory assets, , uint256[] memory maxAmountsIn) = abi.decode(\n                poolActionParams.args,\n                (bytes32, address[], uint256[], uint256[])\n            );\n\n            // ... (rest of the function)\n        }\n    }\n    join(poolActionParams);\n}\n```\n\nThe function uses the unsorted `assets` array in subsequent operations, including the call to `join(poolActionParams)`. This can cause issues when interacting with Balancer, which expects sorted token arrays for certain operations.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nUse the mitigation that suggested in the issue link\n\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75\n\n\n# Vulnerability details\n\n\n## Impact\nThe transferAndJoin function in PoolAction.sol still does not sort the input token array, which can lead to inconsistent behavior and potential exploitation when interacting with protocols like Balancer that expect sorted token arrays.\n\n## Proof of Concept\nIt seems this issue https://github.com/code-423n4/2024-07-loopfi-findings/issues/238 is not fixed.\nIn the [transferAndJoin function](https://github.com/code-423n4/2024-10-loopfi/blob/main/src/proxy/PoolAction.sol#L75) of PoolAction.sol, the `assets` array is used directly without sorting:\n\n```Solidity\nfunction transferAndJoin(\n    address from,\n    PermitParams[] calldata permitParams,\n    PoolActionParams calldata poolActionParams\n) external {\n    if (from != address(this)) {\n        if (poolActionParams.protocol == Protocol.BALANCER) {\n            (, address[] memory assets, , uint256[] memory maxAmountsIn) = abi.decode(\n                poolActionParams.args,\n                (bytes32, address[], uint256[], uint256[])\n            );\n\n            // ... (rest of the function)\n        }\n    }\n    join(poolActionParams);\n}\n```\n\nThe function uses the unsorted `assets` array in subsequent operations, including the call to `join(poolActionParams)`. This can cause issues when interacting with Balancer, which expects sorted token arrays for certain operations.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nUse the mitigation that suggested in the issue link\n\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-10-loopfi-findings-038", "doc_id": "github:code-423n4/2024-10-loopfi-findings", "finding_index": 38, "page_start": null, "title": "Change in cooldown should not affect users' withdrawal wait time.", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L40-L43\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L72-L75\n\n\n# Vulnerability details\n\n### Proof of Concept\n\nOwner can set cooldown period.\n\n```solidity\n    function setCooldownPeriod(uint256 _cooldownPeriod) external onlyOwner {\n        cooldownPeriod = _cooldownPeriod;\n        emit CooldownPeriodSet(_cooldownPeriod);\n    }\n```\n\nHowever when a user initiates a cooldown, the cooldown period at the time of initiation is not taken into consideration.\n\n```solidity\n    function initiateCooldown(uint256 _amount) external {\n        if (_amount == 0) revert AmountIsZero();\n        if (deposits[msg.sender].amount < _amount) revert InsufficientBalanceForCooldown();\n        deposits[msg.sender].cooldownStart = block.timestamp;\n        deposits[msg.sender].cooldownAmount = _amount;\n\n        emit CooldownInitiated(msg.sender, block.timestamp, _amount);\n    }\n```\nSo when a user attempts to withdraw, the cooldown period set by the owner, regardless of when it was set is what is used queried by the function, and as such might positively or negatively affect the user depending on the period set. This is very inconvinent for users since the `cooldownPeriod` is public and can be used as a basis to initiate cooldowns but being arbitrarily changeable can lead to users waiting for much longer than intended. This issue is further excarcebated because the user has no choice and can't reinitiate cooldown, so will be forced to wait for longer periods.\n\n```solidity\n    function withdraw() external {\n        uint256 _amount;\n        if (cooldownPeriod > 0) {\n            if (deposits[msg.sender].cooldownAmount == 0) revert NoTokensInCooldown();\n            if (block.timestamp < deposits[msg.sender].cooldownStart + cooldownPeriod) revert CooldownPeriodNotPassed();\n            _amount = deposits[msg.sender].cooldownAmount;\n        } else {\n```\nAlso, if the cooldown period is set to 0, the function automatically withdraws all of the user's balance  which might become inconvienient if the contract's integration strictly requires the amount that cooldown was initiated for, causing unexpected issues.\n\nTo prove the above described issue, add the test below to Locking.t.sol and run it.\n\n```solidity\n        function test_change_cooldown() public {\n\n        // User deposits and initiates cooldown\n        vm.startPrank(user);\n        token.approve(address(depositContract), 500 ether);\n        depositContract.deposit(500 ether);\n\n        // He asserts that cooldown period is one day and initiates cooldow\n        assertEq(depositContract.cooldownPeriod(), 1 days);\n        depositContract.initiateCooldown(500 ether);\n        vm.stopPrank();\n\n        // 12 hours later, Owner sets cooldown to two days\n        vm.warp(block.timestamp + 12 hours);\n        vm.startPrank(owner);\n        depositContract.setCooldownPeriod(2 days);\n        vm.stopPrank();\n\n        // One day later i.e 12 hours later, user attempts to withdraw, he can't\n        vm.warp(block.timestamp + 12 hours);\n        vm.expectRevert();\n        vm.startPrank(user);\n        depositContract.withdraw();\n        vm.stopPrank();\n    }\n```\n\n### Recommended Mitigation Steps\n\nImplement a system like that of StakingLPEth.sol in which the the current `cooldownPeriod` is added to `cooldownStart` to get the `cooldownEnd` that the users have to wait for.\n\n\n\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": null, "recommendation_md": "### Recommended Mitigation Steps\n\nImplement a system like that of StakingLPEth.sol in which the the current `cooldownPeriod` is added to `cooldownStart` to get the `cooldownEnd` that the users have to wait for.\n\n\n\n\n\n## Assessed type\n\nContext\n", "poc_md": "### Proof of Concept\n\nOwner can set cooldown period.\n\n```solidity\n    function setCooldownPeriod(uint256 _cooldownPeriod) external onlyOwner {\n        cooldownPeriod = _cooldownPeriod;\n        emit CooldownPeriodSet(_cooldownPeriod);\n    }\n```\n\nHowever when a user initiates a cooldown, the cooldown period at the time of initiation is not taken into consideration.\n\n```solidity\n    function initiateCooldown(uint256 _amount) external {\n        if (_amount == 0) revert AmountIsZero();\n        if (deposits[msg.sender].amount < _amount) revert InsufficientBalanceForCooldown();\n        deposits[msg.sender].cooldownStart = block.timestamp;\n        deposits[msg.sender].cooldownAmount = _amount;\n\n        emit CooldownInitiated(msg.sender, block.timestamp, _amount);\n    }\n```\nSo when a user attempts to withdraw, the cooldown period set by the owner, regardless of when it was set is what is used queried by the function, and as such might positively or negatively affect the user depending on the period set. This is very inconvinent for users since the `cooldownPeriod` is public and can be used as a basis to initiate cooldowns but being arbitrarily changeable can lead to users waiting for much longer than intended. This issue is further excarcebated because the user has no choice and can't reinitiate cooldown, so will be forced to wait for longer periods.\n\n```solidity\n    function withdraw() external {\n        uint256 _amount;\n        if (cooldownPeriod > 0) {\n            if (deposits[msg.sender].cooldownAmount == 0) revert NoTokensInCooldown();\n            if (block.timestamp < deposits[msg.sender].cooldownStart + cooldownPeriod) revert CooldownPeriodNotPassed();\n            _amount = deposits[msg.sender].cooldownAmount;\n        } else {\n```\nAlso, if the cooldown period is set to 0, the function automatically withdraws all of the user's balance  which might become inconvienient if the contract's integration strictly requires the amount that cooldown was initiated for, causing unexpected issues.\n\nTo prove the above described issue, add the test below to Locking.t.sol and run it.\n\n```solidity\n        function test_change_cooldown() public {\n\n        // User deposits and initiates cooldown\n        vm.startPrank(user);\n        token.approve(address(depositContract), 500 ether);\n        depositContract.deposit(500 ether);\n\n        // He asserts that cooldown period is one day and initiates cooldow\n        assertEq(depositContract.cooldownPeriod(), 1 days);\n        depositContract.initiateCooldown(500 ether);\n        vm.stopPrank();\n\n        // 12 hours later, Owner sets cooldown to two days\n        vm.warp(block.timestamp + 12 hours);\n        vm.startPrank(owner);\n        depositContract.setCooldownPeriod(2 days);\n        vm.stopPrank();\n\n        // One day later i.e 12 hours later, user attempts to withdraw, he can't\n        vm.warp(block.timestamp + 12 hours);\n        vm.expectRevert();\n        vm.startPrank(user);\n        depositContract.withdraw();\n        vm.stopPrank();\n    }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L40-L43\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L72-L75\n\n**container:**\n# Vulnerability details\n", "full_markdown_body": "https://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L40-L43\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L72-L75\n\n\n# Vulnerability details\n\n### Proof of Concept\n\nOwner can set cooldown period.\n\n```solidity\n    function setCooldownPeriod(uint256 _cooldownPeriod) external onlyOwner {\n        cooldownPeriod = _cooldownPeriod;\n        emit CooldownPeriodSet(_cooldownPeriod);\n    }\n```\n\nHowever when a user initiates a cooldown, the cooldown period at the time of initiation is not taken into consideration.\n\n```solidity\n    function initiateCooldown(uint256 _amount) external {\n        if (_amount == 0) revert AmountIsZero();\n        if (deposits[msg.sender].amount < _amount) revert InsufficientBalanceForCooldown();\n        deposits[msg.sender].cooldownStart = block.timestamp;\n        deposits[msg.sender].cooldownAmount = _amount;\n\n        emit CooldownInitiated(msg.sender, block.timestamp, _amount);\n    }\n```\nSo when a user attempts to withdraw, the cooldown period set by the owner, regardless of when it was set is what is used queried by the function, and as such might positively or negatively affect the user depending on the period set. This is very inconvinent for users since the `cooldownPeriod` is public and can be used as a basis to initiate cooldowns but being arbitrarily changeable can lead to users waiting for much longer than intended. This issue is further excarcebated because the user has no choice and can't reinitiate cooldown, so will be forced to wait for longer periods.\n\n```solidity\n    function withdraw() external {\n        uint256 _amount;\n        if (cooldownPeriod > 0) {\n            if (deposits[msg.sender].cooldownAmount == 0) revert NoTokensInCooldown();\n            if (block.timestamp < deposits[msg.sender].cooldownStart + cooldownPeriod) revert CooldownPeriodNotPassed();\n            _amount = deposits[msg.sender].cooldownAmount;\n        } else {\n```\nAlso, if the cooldown period is set to 0, the function automatically withdraws all of the user's balance  which might become inconvienient if the contract's integration strictly requires the amount that cooldown was initiated for, causing unexpected issues.\n\nTo prove the above described issue, add the test below to Locking.t.sol and run it.\n\n```solidity\n        function test_change_cooldown() public {\n\n        // User deposits and initiates cooldown\n        vm.startPrank(user);\n        token.approve(address(depositContract), 500 ether);\n        depositContract.deposit(500 ether);\n\n        // He asserts that cooldown period is one day and initiates cooldow\n        assertEq(depositContract.cooldownPeriod(), 1 days);\n        depositContract.initiateCooldown(500 ether);\n        vm.stopPrank();\n\n        // 12 hours later, Owner sets cooldown to two days\n        vm.warp(block.timestamp + 12 hours);\n        vm.startPrank(owner);\n        depositContract.setCooldownPeriod(2 days);\n        vm.stopPrank();\n\n        // One day later i.e 12 hours later, user attempts to withdraw, he can't\n        vm.warp(block.timestamp + 12 hours);\n        vm.expectRevert();\n        vm.startPrank(user);\n        depositContract.withdraw();\n        vm.stopPrank();\n    }\n```\n\n### Recommended Mitigation Steps\n\nImplement a system like that of StakingLPEth.sol in which the the current `cooldownPeriod` is added to `cooldownStart` to get the `cooldownEnd` that the users have to wait for.\n\n\n\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L40-L43\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/Locking.sol#L72-L75\n\n\n# Vulnerability details\n\n### Proof of Concept\n\nOwner can set cooldown period.\n\n```solidity\n    function setCooldownPeriod(uint256 _cooldownPeriod) external onlyOwner {\n        cooldownPeriod = _cooldownPeriod;\n        emit CooldownPeriodSet(_cooldownPeriod);\n    }\n```\n\nHowever when a user initiates a cooldown, the cooldown period at the time of initiation is not taken into consideration. \n\n```solidity\n    function initiateCooldown(uint256 _amount) external {\n        if (_amount == 0) revert AmountIsZero();\n        if (deposits[msg.sender].amount < _amount) revert InsufficientBalanceForCooldown();\n        deposits[msg.sender].cooldownStart = block.timestamp;\n        deposits[msg.sender].cooldownAmount = _amount;\n\n        emit CooldownInitiated(msg.sender, block.timestamp, _amount);\n    }\n```\nSo when a user attempts to withdraw, the cooldown period set by the owner, regardless of when it was set is what is used queried by the function, and as such might positively or negatively affect the user depending on the period set. This is very inconvinent for users since the `cooldownPeriod` is public and can be used as a basis to initiate cooldowns but being arbitrarily changeable can lead to users waiting for much longer than intended. This issue is further excarcebated because the user has no choice and can't reinitiate cooldown, so will be forced to wait for longer periods.\n\n```solidity\n    function withdraw() external {\n        uint256 _amount;\n        if (cooldownPeriod > 0) {\n            if (deposits[msg.sender].cooldownAmount == 0) revert NoTokensInCooldown();\n            if (block.timestamp < deposits[msg.sender].cooldownStart + cooldownPeriod) revert CooldownPeriodNotPassed();\n            _amount = deposits[msg.sender].cooldownAmount;\n        } else {\n```\nAlso, if the cooldown period is set to 0, the function automatically withdraws all of the user's balance  which might become inconvienient if the contract's integration strictly requires the amount that cooldown was initiated for, causing unexpected issues.\n\nTo prove the above described issue, add the test below to Locking.t.sol and run it.\n\n```solidity\n        function test_change_cooldown() public {\n\n        // User deposits and initiates cooldown\n        vm.startPrank(user);\n        token.approve(address(depositContract), 500 ether);\n        depositContract.deposit(500 ether);\n\n        // He asserts that cooldown period is one day and initiates cooldow\n        assertEq(depositContract.cooldownPeriod(), 1 days);\n        depositContract.initiateCooldown(500 ether);\n        vm.stopPrank();\n\n        // 12 hours later, Owner sets cooldown to two days\n        vm.warp(block.timestamp + 12 hours);\n        vm.startPrank(owner);\n        depositContract.setCooldownPeriod(2 days);\n        vm.stopPrank();\n\n        // One day later i.e 12 hours later, user attempts to withdraw, he can't\n        vm.warp(block.timestamp + 12 hours);\n        vm.expectRevert();\n        vm.startPrank(user);\n        depositContract.withdraw();\n        vm.stopPrank();\n    }\n```\n\n### Recommended Mitigation Steps\n\nImplement a system like that of StakingLPEth.sol in which the the current `cooldownPeriod` is added to `cooldownStart` to get the `cooldownEnd` that the users have to wait for. \n\n\n\n\n\n## Assessed type\n\nContext"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-10-loopfi", "org": "code-423n4", "name": "2024-10-loopfi", "commit": "d219f0132005b00a68f505edc22b34f9a8b49766", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-10-loopfi-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:18.844309+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:18.848115+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
